#
msgid ""
msgstr "Content-Type: text/plain; charset=UTF-8\n"

#: docs/index.md:block 1 (paragraph)
msgid "hide:"
msgstr ""

#: docs/index.md:block 2 (unordered list)
msgid "toc title: Welcome"
msgstr ""

#: docs/index.md:block 3 (paragraph)
msgid "![](img/klipper-logo.png){ .center-image }"
msgstr ""

#: docs/index.md:block 4 (paragraph)
msgid ""
"Klipper is a 3d-Printer firmware. It combines the power of a general purpose"
" computer with one or more micro-controllers. See the "
"[features](Features.md) document for more information on why you should use "
"Klipper."
msgstr ""

#: docs/index.md:block 5 (paragraph)
msgid "To begin using Klipper start by [installing](Installation.md) it."
msgstr ""

#: docs/index.md:block 6 (paragraph)
msgid ""
"Klipper is Free Software. Read the [documentation](Overview.md) or view [the"
" Klipper code on github](https://github.com/Klipper3d/klipper). We depend on"
" the generous support from our [sponsors](Sponsors.md)."
msgstr ""

#~ msgid "How does it work?"
#~ msgstr ""

#~ msgid "Using PWM tools"
#~ msgstr ""

#~ msgid ""
#~ "This document describes how to setup a PWM-controlled laser or spindle using"
#~ " `output_pin` and some macros."
#~ msgstr ""

#~ msgid ""
#~ "With re-purposing the printhead's fan pwm output, you can control lasers or "
#~ "spindles. This is useful if you use switchable print heads, for example the "
#~ "E3D toolchanger or a DIY solution. Usually, cam-tools such as LaserWeb can "
#~ "be configured to use `M3-M5` commands, which stand for *spindle speed CW* "
#~ "(`M3 S[0-255]`), *spindle speed CCW* (`M4 S[0-255]`) and *spindle stop* "
#~ "(`M5`)."
#~ msgstr ""

#~ msgid ""
#~ "**Warning:** When driving a laser, keep all security precautions that you "
#~ "can think of! Diode lasers are usually inverted. This means, that when the "
#~ "MCU restarts, the laser will be *fully on* for the time it takes the MCU to "
#~ "start up again. For good measure, it is recommended to *always* wear "
#~ "appropriate laser-goggles of the right wavelength if the laser is powered; "
#~ "and to disconnect the laser when it is not needed. Also, you should "
#~ "configure a safety timeout, so that when your host or MCU encounters an "
#~ "error, the tool will stop."
#~ msgstr ""

#~ msgid ""
#~ "For an example configuration, see [config/sample-pwm-"
#~ "tool.cfg](/config/sample-pwm-tool.cfg)."
#~ msgstr ""

#~ msgid "Current Limitations"
#~ msgstr ""

#~ msgid ""
#~ "There is a limitation of how frequent PWM updates may occur. While being "
#~ "very precise, a PWM update may only occur every 0.1 seconds, rendering it "
#~ "almost useless for raster engraving. However, there exists an [experimental "
#~ "branch](https://github.com/Cirromulus/klipper/tree/laser_tool) with its own "
#~ "tradeoffs. In long term, it is planned to add this functionality to main-"
#~ "line klipper."
#~ msgstr ""

#~ msgid "Commands"
#~ msgstr ""

#~ msgid ""
#~ "`M3/M4 S<value>` : Set PWM duty-cycle. Values between 0 and 255. `M5` : Stop"
#~ " PWM output to shutdown value."
#~ msgstr ""

#~ msgid "Laserweb Configuration"
#~ msgstr ""

#~ msgid "If you use Laserweb, a working configuration would be:"
#~ msgstr ""

#~ msgid ""
#~ "GCODE START:\n"
#~ "    M5            ; Disable Laser\n"
#~ "    G21           ; Set units to mm\n"
#~ "    G90           ; Absolute positioning\n"
#~ "    G0 Z0 F7000   ; Set Non-Cutting speed\n"
#~ "\n"
#~ "GCODE END:\n"
#~ "    M5            ; Disable Laser\n"
#~ "    G91           ; relative\n"
#~ "    G0 Z+20 F4000 ;\n"
#~ "    G90           ; absolute\n"
#~ "\n"
#~ "GCODE HOMING:\n"
#~ "    M5            ; Disable Laser\n"
#~ "    G28           ; Home all axis\n"
#~ "\n"
#~ "TOOL ON:\n"
#~ "    M3 $INTENSITY\n"
#~ "\n"
#~ "TOOL OFF:\n"
#~ "    M5            ; Disable Laser\n"
#~ "\n"
#~ "LASER INTENSITY:\n"
#~ "    S\n"
#~ msgstr ""

#~ msgid "TSL1401CL filament width sensor"
#~ msgstr ""

#~ msgid ""
#~ "This document describes Filament Width Sensor host module. Hardware used for"
#~ " developing this host module is based on TSL1401CL linear sensor array but "
#~ "it can work with any sensor array that has analog output. You can find "
#~ "designs at "
#~ "[Thingiverse](https://www.thingiverse.com/search?q=filament%20width%20sensor)."
#~ msgstr ""

#~ msgid ""
#~ "To use a sensor array as a filament width sensor, read [Config "
#~ "Reference](Config_Reference.md#tsl1401cl_filament_width_sensor) and [G-Code "
#~ "documentation](G-Codes.md#hall_filament_width_sensor)."
#~ msgstr ""

#~ msgid ""
#~ "Sensor generates analog output based on calculated filament width. Output "
#~ "voltage always equals to detected filament width (Ex. 1.65v, 1.70v, 3.0v). "
#~ "Host module monitors voltage changes and adjusts extrusion multiplier."
#~ msgstr ""

#~ msgid "Note:"
#~ msgstr ""

#~ msgid ""
#~ "Sensor readings done with 10 mm intervals by default. If necessary you are "
#~ "free to change this setting by editing ***MEASUREMENT_INTERVAL_MM*** "
#~ "parameter in **filament_width_sensor.py** file."
#~ msgstr ""

#~ msgid "TMC drivers"
#~ msgstr ""

#~ msgid ""
#~ "This document provides information on using Trinamic stepper motor drivers "
#~ "in SPI/UART mode on Klipper."
#~ msgstr ""

#~ msgid ""
#~ "Klipper can also use Trinamic drivers in their \"standalone mode\". However,"
#~ " when the drivers are in this mode, no special Klipper configuration is "
#~ "needed and the advanced Klipper features discussed in this document are not "
#~ "available."
#~ msgstr ""

#~ msgid ""
#~ "In addition to this document, be sure to review the [TMC driver config "
#~ "reference](Config_Reference.md#tmc-stepper-driver-configuration)."
#~ msgstr ""

#~ msgid "Tuning motor current"
#~ msgstr ""

#~ msgid ""
#~ "A higher driver current increases positional accuracy and torque. However, a"
#~ " higher current also increases the heat produced by the stepper motor and "
#~ "the stepper motor driver. If the stepper motor driver gets too hot it will "
#~ "disable itself and Klipper will report an error. If the stepper motor gets "
#~ "too hot, it loses torque and positional accuracy. (If it gets very hot it "
#~ "may also melt plastic parts attached to it or near it.)"
#~ msgstr ""

#~ msgid ""
#~ "As a general tuning tip, prefer higher current values as long as the stepper"
#~ " motor does not get too hot and the stepper motor driver does not report "
#~ "warnings or errors. In general, it is okay for the stepper motor to feel "
#~ "warm, but it should not become so hot that it is painful to touch."
#~ msgstr ""

#~ msgid "Prefer to not specify a hold_current"
#~ msgstr ""

#~ msgid ""
#~ "If one configures a `hold_current` then the TMC driver can reduce current to"
#~ " the stepper motor when it detects that the stepper is not moving. However, "
#~ "changing motor current may itself introduce motor movement. This may occur "
#~ "due to \"detent forces\" within the stepper motor (the permanent magnet in "
#~ "the rotor pulls towards the iron teeth in the stator) or due to external "
#~ "forces on the axis carriage."
#~ msgstr ""

#~ msgid ""
#~ "Most stepper motors will not obtain a significant benefit to reducing "
#~ "current during normal prints, because few printing moves will leave a "
#~ "stepper motor idle for sufficiently long to activate the `hold_current` "
#~ "feature. And, it is unlikely that one would want to introduce subtle print "
#~ "artifacts to the few printing moves that do leave a stepper idle "
#~ "sufficiently long."
#~ msgstr ""

#~ msgid ""
#~ "If one wishes to reduce current to motors during print start routines, then "
#~ "consider issuing [SET_TMC_CURRENT](G-Codes.md#set_tmc_current) commands in a"
#~ " [START_PRINT macro](Slicers.md#klipper-gcode_macro) to adjust the current "
#~ "before and after normal printing moves."
#~ msgstr ""

#~ msgid ""
#~ "Some printers with dedicated Z motors that are idle during normal printing "
#~ "moves (no bed_mesh, no bed_tilt, no Z skew_correction, no \"vase mode\" "
#~ "prints, etc.) may find that Z motors do run cooler with a `hold_current`. If"
#~ " implementing this then be sure to take into account this type of "
#~ "uncommanded Z axis movement during bed leveling, bed probing, probe "
#~ "calibration, and similar. The `driver_TPOWERDOWN` and `driver_IHOLDDELAY` "
#~ "should also be calibrated accordingly. If unsure, prefer to not specify a "
#~ "`hold_current`."
#~ msgstr ""

#~ msgid "Setting \"spreadCycle\" vs \"stealthChop\" Mode"
#~ msgstr ""

#~ msgid ""
#~ "By default, Klipper places the TMC drivers in \"spreadCycle\" mode. If the "
#~ "driver supports \"stealthChop\" then it can be enabled by adding "
#~ "`stealthchop_threshold: 999999` to the TMC config section."
#~ msgstr ""

#~ msgid ""
#~ "In general, spreadCycle mode provides greater torque and greater positional "
#~ "accuracy than stealthChop mode. However, stealthChop mode may produce "
#~ "significantly lower audible noise on some printers."
#~ msgstr ""

#~ msgid ""
#~ "Tests comparing modes have shown an increased \"positional lag\" of around "
#~ "75% of a full-step during constant velocity moves when using stealthChop "
#~ "mode (for example, on a printer with 40mm rotation_distance and 200 "
#~ "steps_per_rotation, position deviation of constant speed moves increased by "
#~ "~0.150mm). However, this \"delay in obtaining the requested position\" may "
#~ "not manifest as a significant print defect and one may prefer the quieter "
#~ "behavior of stealthChop mode."
#~ msgstr ""

#~ msgid ""
#~ "It is recommended to always use \"spreadCycle\" mode (by not specifying "
#~ "`stealthchop_threshold`) or to always use \"stealthChop\" mode (by setting "
#~ "`stealthchop_threshold` to 999999). Unfortunately, the drivers often produce"
#~ " poor and confusing results if the mode changes while the motor is at a non-"
#~ "zero velocity."
#~ msgstr ""

#~ msgid "TMC interpolate setting introduces small position deviation"
#~ msgstr ""

#~ msgid ""
#~ "The TMC driver `interpolate` setting may reduce the audible noise of printer"
#~ " movement at the cost of introducing a small systemic positional error. This"
#~ " systemic positional error results from the driver's delay in executing "
#~ "\"steps\" that Klipper sends it. During constant velocity moves, this delay "
#~ "results in a positional error of nearly half a configured microstep (more "
#~ "precisely, the error is half a microstep distance minus a 512th of a full "
#~ "step distance). For example, on an axis with a 40mm rotation_distance, 200 "
#~ "steps_per_rotation, and 16 microsteps, the systemic error introduced during "
#~ "constant velocity moves is ~0.006mm."
#~ msgstr ""

#~ msgid ""
#~ "For best positional accuracy consider using spreadCycle mode and disable "
#~ "interpolation (set `interpolate: False` in the TMC driver config). When "
#~ "configured this way, one may increase the `microstep` setting to reduce "
#~ "audible noise during stepper movement. Typically, a microstep setting of "
#~ "`64` or `128` will have similar audible noise as interpolation, and do so "
#~ "without introducing a systemic positional error."
#~ msgstr ""

#~ msgid ""
#~ "If using stealthChop mode then the positional inaccuracy from interpolation "
#~ "is small relative to the positional inaccuracy introduced from stealthChop "
#~ "mode. Therefore tuning interpolation is not considered useful when in "
#~ "stealthChop mode, and one can leave interpolation in its default state."
#~ msgstr ""

#~ msgid "Sensorless Homing"
#~ msgstr ""

#~ msgid ""
#~ "Sensorless homing allows to home an axis without the need for a physical "
#~ "limit switch. Instead, the carriage on the axis is moved into the mechanical"
#~ " limit making the stepper motor lose steps. The stepper driver senses the "
#~ "lost steps and indicates this to the controlling MCU (Klipper) by toggling a"
#~ " pin. This information can be used by Klipper as end stop for the axis."
#~ msgstr ""

#~ msgid ""
#~ "This guide covers the setup of sensorless homing for the X axis of your "
#~ "(cartesian) printer. However, it works the same with all other axes (that "
#~ "require an end stop). You should configure and tune it for one axis at a "
#~ "time."
#~ msgstr ""

#~ msgid "Limitations"
#~ msgstr ""

#~ msgid ""
#~ "Be sure that your mechanical components are able to handle the load of the "
#~ "carriage bumping into the limit of the axis repeatedly. Especially "
#~ "leadscrews might generate a lot of force. Homing a Z axis by bumping the "
#~ "nozzle into the printing surface might not be a good idea. For best results,"
#~ " verify that the axis carriage will make a firm contact with the axis limit."
#~ msgstr ""

#~ msgid ""
#~ "Further, sensorless homing might not be accurate enough for your printer. "
#~ "While homing X and Y axes on a cartesian machine can work well, homing the Z"
#~ " axis is generally not accurate enough and may result in an inconsistent "
#~ "first layer height. Homing a delta printer sensorless is not advisable due "
#~ "to missing accuracy."
#~ msgstr ""

#~ msgid ""
#~ "Further, the stall detection of the stepper driver is dependent on the "
#~ "mechanical load on the motor, the motor current and the motor temperature "
#~ "(coil resistance)."
#~ msgstr ""

#~ msgid ""
#~ "Sensorless homing works best at medium motor speeds. For very slow speeds "
#~ "(less than 10 RPM) the motor does not generate significant back EMF and the "
#~ "TMC cannot reliably detect motor stalls. Further, at very high speeds, the "
#~ "back EMF of the motor approaches the supply voltage of the motor, so the TMC"
#~ " cannot detect stalls anymore. It is advised to have a look in the datasheet"
#~ " of your specific TMCs. There you can also find more details on limitations "
#~ "of this setup."
#~ msgstr ""

#~ msgid "Prerequisites"
#~ msgstr ""

#~ msgid "A few prerequisites are needed to use sensorless homing:"
#~ msgstr ""

#~ msgid ""
#~ "A stallGuard capable TMC stepper driver (tmc2130, tmc2209, tmc2660, or "
#~ "tmc5160)."
#~ msgstr ""

#~ msgid ""
#~ "SPI / UART interface of the TMC driver wired to micro-controller (stand-"
#~ "alone mode does not work)."
#~ msgstr ""

#~ msgid ""
#~ "The appropriate \"DIAG\" or \"SG_TST\" pin of TMC driver connected to the "
#~ "micro-controller."
#~ msgstr ""

#~ msgid ""
#~ "The steps in the [config checks](Config_checks.md) document must be run to "
#~ "confirm the stepper motors are configured and working properly."
#~ msgstr ""

#~ msgid "Tuning"
#~ msgstr ""

#~ msgid "The procedure described here has six major steps:"
#~ msgstr ""

#~ msgid "Choose a homing speed."
#~ msgstr ""

#~ msgid "Configure the `printer.cfg` file to enable sensorless homing."
#~ msgstr ""

#~ msgid ""
#~ "Find the stallguard setting with highest sensitivity that successfully "
#~ "homes."
#~ msgstr ""

#~ msgid ""
#~ "Find the stallguard setting with lowest sensitivity that successfully homes "
#~ "with a single touch."
#~ msgstr ""

#~ msgid "Update the `printer.cfg` with the desired stallguard setting."
#~ msgstr ""

#~ msgid "Create or update `printer.cfg` macros to home consistently."
#~ msgstr ""

#~ msgid "Choose homing speed"
#~ msgstr ""

#~ msgid ""
#~ "The homing speed is an important choice when performing sensorless homing. "
#~ "It's desirable to use a slow homing speed so that the carriage does not "
#~ "exert excessive force on the frame when making contact with the end of the "
#~ "rail. However, the TMC drivers can't reliably detect a stall at very slow "
#~ "speeds."
#~ msgstr ""

#~ msgid ""
#~ "A good starting point for the homing speed is for the stepper motor to make "
#~ "a full rotation every two seconds. For many axes this will be the "
#~ "`rotation_distance` divided by two. For example:"
#~ msgstr ""

#~ msgid ""
#~ "[stepper_x]\n"
#~ "rotation_distance: 40\n"
#~ "homing_speed: 20\n"
#~ "...\n"
#~ msgstr ""

#~ msgid "Configure printer.cfg for sensorless homing"
#~ msgstr ""

#~ msgid ""
#~ "The `homing_retract_dist` setting must be set to zero in the `stepper_x` "
#~ "config section to disable the second homing move. The second homing attempt "
#~ "does not add value when using sensorless homing, it will not work reliably, "
#~ "and it will confuse the tuning process."
#~ msgstr ""

#~ msgid ""
#~ "Be sure that a `hold_current` setting is not specified in the TMC driver "
#~ "section of the config. (If a hold_current is set then after contact is made,"
#~ " the motor stops while the carriage is pressed against the end of the rail, "
#~ "and reducing the current while in that position may cause the carriage to "
#~ "move - that results in poor performance and will confuse the tuning "
#~ "process.)"
#~ msgstr ""

#~ msgid ""
#~ "It is necessary to configure the sensorless homing pins and to configure "
#~ "initial \"stallguard\" settings. A tmc2209 example configuration for an X "
#~ "axis might look like:"
#~ msgstr ""

#~ msgid ""
#~ "[tmc2209 stepper_x]\n"
#~ "diag_pin: ^PA1      # Set to MCU pin connected to TMC DIAG pin\n"
#~ "driver_SGTHRS: 255  # 255 is most sensitive value, 0 is least sensitive\n"
#~ "...\n"
#~ "\n"
#~ "[stepper_x]\n"
#~ "endstop_pin: tmc2209_stepper_x:virtual_endstop\n"
#~ "homing_retract_dist: 0\n"
#~ "...\n"
#~ msgstr ""

#~ msgid "An example tmc2130 or tmc5160 config might look like:"
#~ msgstr ""

#~ msgid ""
#~ "[tmc2130 stepper_x]\n"
#~ "diag1_pin: ^!PA1 # Pin connected to TMC DIAG1 pin (or use diag0_pin / DIAG0 pin)\n"
#~ "driver_SGT: -64  # -64 is most sensitive value, 63 is least sensitive\n"
#~ "...\n"
#~ "\n"
#~ "[stepper_x]\n"
#~ "endstop_pin: tmc2130_stepper_x:virtual_endstop\n"
#~ "homing_retract_dist: 0\n"
#~ "...\n"
#~ msgstr ""

#~ msgid "An example tmc2660 config might look like:"
#~ msgstr ""

#~ msgid ""
#~ "[tmc2660 stepper_x]\n"
#~ "driver_SGT: -64     # -64 is most sensitive value, 63 is least sensitive\n"
#~ "...\n"
#~ "\n"
#~ "[stepper_x]\n"
#~ "endstop_pin: ^PA1   # Pin connected to TMC SG_TST pin\n"
#~ "homing_retract_dist: 0\n"
#~ "...\n"
#~ msgstr ""

#~ msgid ""
#~ "The examples above only show settings specific to sensorless homing. See the"
#~ " [config reference](Config_Reference.md#tmc-stepper-driver-configuration) "
#~ "for all the available options."
#~ msgstr ""

#~ msgid "Find highest sensitivity that successfully homes"
#~ msgstr ""

#~ msgid ""
#~ "Place the carriage near the center of the rail. Use the SET_TMC_FIELD "
#~ "command to set the highest sensitivity. For tmc2209:"
#~ msgstr ""

#~ msgid "SET_TMC_FIELD STEPPER=stepper_x FIELD=SGTHRS VALUE=255\n"
#~ msgstr ""

#~ msgid "For tmc2130, tmc5160, and tmc2660:"
#~ msgstr ""

#~ msgid "SET_TMC_FIELD STEPPER=stepper_x FIELD=sgt VALUE=-64\n"
#~ msgstr ""

#~ msgid ""
#~ "Then issue a `G28 X0` command and verify the axis does not move at all or "
#~ "quickly stops moving. If the axis does not stop, then issue an `M112` to "
#~ "halt the printer - something is not correct with the diag/sg_tst pin wiring "
#~ "or configuration and it must be corrected before continuing."
#~ msgstr ""

#~ msgid ""
#~ "Next, continually decrease the sensitivity of the `VALUE` setting and run "
#~ "the `SET_TMC_FIELD` `G28 X0` commands again to find the highest sensitivity "
#~ "that results in the carriage successfully moving all the way to the endstop "
#~ "and halting. (For tmc2209 drivers this will be decreasing SGTHRS, for other "
#~ "drivers it will be increasing sgt.) Be sure to start each attempt with the "
#~ "carriage near the center of the rail (if needed issue `M84` and then "
#~ "manually move the carriage to the center). It should be possible to find the"
#~ " highest sensitivity that homes reliably (settings with higher sensitivity "
#~ "result in small or no movement). Note the found value as "
#~ "*maximum_sensitivity*. (If the minimum possible sensitivity (SGTHRS=0 or "
#~ "sgt=63) is obtained without any carriage movement then something is not "
#~ "correct with the diag/sg_tst pin wiring or configuration and it must be "
#~ "corrected before continuing.)"
#~ msgstr ""

#~ msgid ""
#~ "When searching for maximum_sensitivity, it may be convenient to jump to "
#~ "different VALUE settings (so as to bisect the VALUE parameter). If doing "
#~ "this then be prepared to issue an `M112` command to halt the printer, as a "
#~ "setting with a very low sensitivity may cause the axis to repeatedly "
#~ "\"bang\" into the end of the rail."
#~ msgstr ""

#~ msgid ""
#~ "Be sure to wait a couple of seconds between each homing attempt. After the "
#~ "TMC driver detects a stall it may take a little time for it to clear its "
#~ "internal indicator and be capable of detecting another stall."
#~ msgstr ""

#~ msgid ""
#~ "During these tuning tests, if a `G28 X0` command does not move all the way "
#~ "to the axis limit, then be careful with issuing any regular movement "
#~ "commands (eg, `G1`). Klipper will not have a correct understanding of the "
#~ "carriage position and a move command may cause undesirable and confusing "
#~ "results."
#~ msgstr ""

#~ msgid "Find lowest sensitivity that homes with one touch"
#~ msgstr ""

#~ msgid ""
#~ "When homing with the found *maximum_sensitivity* value, the axis should move"
#~ " to the end of the rail and stop with a \"single touch\" - that is, there "
#~ "should not be a \"clicking\" or \"banging\" sound. (If there is a banging or"
#~ " clicking sound at maximum_sensitivity then the homing_speed may be too low,"
#~ " the driver current may be too low, or sensorless homing may not be a good "
#~ "choice for the axis.)"
#~ msgstr ""

#~ msgid ""
#~ "The next step is to again continually move the carriage to a position near "
#~ "the center of the rail, decrease the sensitivity, and run the "
#~ "`SET_TMC_FIELD` `G28 X0` commands - the goal is now to find the lowest "
#~ "sensitivity that still results in the carriage successfully homing with a "
#~ "\"single touch\". That is, it does not \"bang\" or \"click\" when contacting"
#~ " the end of the rail. Note the found value as *minimum_sensitivity*."
#~ msgstr ""

#~ msgid "Update printer.cfg with sensitivity value"
#~ msgstr ""

#~ msgid ""
#~ "After finding *maximum_sensitivity* and *minimum_sensitivity*, use a "
#~ "calculator to obtain the recommend sensitivity as *minimum_sensitivity + "
#~ "(maximum_sensitivity - minimum_sensitivity)/3*. The recommended sensitivity "
#~ "should be in the range between the minimum and maximum, but slightly closer "
#~ "to the minimum. Round the final value to the nearest integer value."
#~ msgstr ""

#~ msgid ""
#~ "For tmc2209 set this in the config as `driver_SGTHRS`, for other TMC drivers"
#~ " set this in the config as `driver_SGT`."
#~ msgstr ""

#~ msgid ""
#~ "If the range between *maximum_sensitivity* and *minimum_sensitivity* is "
#~ "small (eg, less than 5) then it may result in unstable homing. A faster "
#~ "homing speed may increase the range and make the operation more stable."
#~ msgstr ""

#~ msgid ""
#~ "Note that if any change is made to driver current, homing speed, or a "
#~ "notable change is made to the printer hardware, then it will be necessary to"
#~ " run the tuning process again."
#~ msgstr ""

#~ msgid "Using Macros when Homing"
#~ msgstr ""

#~ msgid ""
#~ "After sensorless homing completes the carriage will be pressed against the "
#~ "end of the rail and the stepper will exert a force on the frame until the "
#~ "carriage is moved away. It is a good idea to create a macro to home the axis"
#~ " and immediately move the carriage away from the end of the rail."
#~ msgstr ""

#~ msgid ""
#~ "It is a good idea for the macro to pause at least 2 seconds prior to "
#~ "starting sensorless homing (or otherwise ensure that there has been no "
#~ "movement on the stepper for 2 seconds). Without a delay it is possible for "
#~ "the driver's internal stall flag to still be set from a previous move."
#~ msgstr ""

#~ msgid ""
#~ "It can also be useful to have that macro set the driver current before "
#~ "homing and set a new current after the carriage has moved away."
#~ msgstr ""

#~ msgid "An example macro might look something like:"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro SENSORLESS_HOME_X]\n"
#~ "gcode:\n"
#~ "    {% set HOME_CUR = 0.700 %}\n"
#~ "    {% set driver_config = printer.configfile.settings['tmc2209 stepper_x'] %}\n"
#~ "    {% set RUN_CUR = driver_config.run_current %}\n"
#~ "    # Set current for sensorless homing\n"
#~ "    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={HOME_CUR}\n"
#~ "    # Pause to ensure driver stall flag is clear\n"
#~ "    G4 P2000\n"
#~ "    # Home\n"
#~ "    G28 X0\n"
#~ "    # Move away\n"
#~ "    G90\n"
#~ "    G1 X5 F1200\n"
#~ "    # Set current during print\n"
#~ "    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={RUN_CUR}\n"
#~ msgstr ""

#~ msgid ""
#~ "The resulting macro can be called from a [homing_override config "
#~ "section](Config_Reference.md#homing_override) or from a [START_PRINT "
#~ "macro](Slicers.md#klipper-gcode_macro)."
#~ msgstr ""

#~ msgid ""
#~ "Note that if the driver current during homing is changed, then the tuning "
#~ "process should be run again."
#~ msgstr ""

#~ msgid "Tips for sensorless homing on CoreXY"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to use sensorless homing on the X and Y carriages of a CoreXY"
#~ " printer. Klipper uses the `[stepper_x]` stepper to detect stalls when "
#~ "homing the X carriage and uses the `[stepper_y]` stepper to detect stalls "
#~ "when homing the Y carriage."
#~ msgstr ""

#~ msgid ""
#~ "Use the tuning guide described above to find the appropriate \"stall "
#~ "sensitivity\" for each carriage, but be aware of the following restrictions:"
#~ msgstr ""

#~ msgid ""
#~ "When using sensorless homing on CoreXY, make sure there is no `hold_current`"
#~ " configured for either stepper."
#~ msgstr ""

#~ msgid ""
#~ "While tuning, make sure both the X and Y carriages are near the center of "
#~ "their rails before each home attempt."
#~ msgstr ""

#~ msgid ""
#~ "After tuning is complete, when homing both X and Y, use macros to ensure "
#~ "that one axis is homed first, then move that carriage away from the axis "
#~ "limit, pause for at least 2 seconds, and then start the homing of the other "
#~ "carriage. The move away from the axis avoids homing one axis while the other"
#~ " is pressed against the axis limit (which may skew the stall detection). The"
#~ " pause is necessary to ensure the driver's stall flag is cleared prior to "
#~ "homing again."
#~ msgstr ""

#~ msgid "An example CoreXY homing macro might look like:"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro HOME]\n"
#~ "gcode:\n"
#~ "    G90\n"
#~ "    # Home Z\n"
#~ "    G28 Z0\n"
#~ "    G1 Z10 F1200\n"
#~ "    # Home Y\n"
#~ "    G28 Y0\n"
#~ "    G1 Y5 F1200\n"
#~ "    # Home X\n"
#~ "    G4 P2000\n"
#~ "    G28 X0\n"
#~ "    G1 X5 F1200\n"
#~ msgstr ""

#~ msgid "Querying and diagnosing driver settings"
#~ msgstr ""

#~ msgid ""
#~ "The `[DUMP_TMC command](G-Codes.md#dump_tmc) is a useful tool when "
#~ "configuring and diagnosing the drivers. It will report all fields configured"
#~ " by Klipper as well as all fields that can be queried from the driver."
#~ msgstr ""

#~ msgid ""
#~ "All of the reported fields are defined in the Trinamic datasheet for each "
#~ "driver. These datasheets can be found on the [Trinamic "
#~ "website](https://www.trinamic.com/). Obtain and review the Trinamic "
#~ "datasheet for the driver to interpret the results of DUMP_TMC."
#~ msgstr ""

#~ msgid "Configuring driver_XXX settings"
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports configuring many low-level driver fields using `driver_XXX`"
#~ " settings. The [TMC driver config reference](Config_Reference.md#tmc-"
#~ "stepper-driver-configuration) has the full list of fields available for each"
#~ " type of driver."
#~ msgstr ""

#~ msgid ""
#~ "In addition, almost all fields can be modified at run-time using the "
#~ "[SET_TMC_FIELD command](G-Codes.md#set_tmc_field)."
#~ msgstr ""

#~ msgid ""
#~ "Each of these fields is defined in the Trinamic datasheet for each driver. "
#~ "These datasheets can be found on the [Trinamic "
#~ "website](https://www.trinamic.com/)."
#~ msgstr ""

#~ msgid ""
#~ "Note that the Trinamic datasheets sometime use wording that can confuse a "
#~ "high-level setting (such as \"hysteresis end\") with a low-level field value"
#~ " (eg, \"HEND\"). In Klipper, `driver_XXX` and SET_TMC_FIELD always set the "
#~ "low-level field value that is actually written to the driver. So, for "
#~ "example, if the Trinamic datasheet states that a value of 3 must be written "
#~ "to the HEND field to obtain a \"hysteresis end\" of 0, then set "
#~ "`driver_HEND=3` to obtain the high-level value of 0."
#~ msgstr ""

#~ msgid "Common Questions"
#~ msgstr ""

#~ msgid "Can I use stealthChop mode on an extruder with pressure advance?"
#~ msgstr ""

#~ msgid ""
#~ "Many people successfully use \"stealthChop\" mode with Klipper's pressure "
#~ "advance. Klipper implements [smooth pressure "
#~ "advance](Kinematics.md#pressure-advance) which does not introduce any "
#~ "instantaneous velocity changes."
#~ msgstr ""

#~ msgid ""
#~ "However, \"stealthChop\" mode may produce lower motor torque and/or produce "
#~ "higher motor heat. It may or may not be an adequate mode for your particular"
#~ " printer."
#~ msgstr ""

#~ msgid ""
#~ "I keep getting \"Unable to read tmc uart 'stepper_x' register IFCNT\" "
#~ "errors?"
#~ msgstr ""

#~ msgid ""
#~ "This occurs when Klipper is unable to communicate with a tmc2208 or tmc2209 "
#~ "driver."
#~ msgstr ""

#~ msgid ""
#~ "Make sure that the motor power is enabled, as the stepper motor driver "
#~ "generally needs motor power before it can communicate with the micro-"
#~ "controller."
#~ msgstr ""

#~ msgid ""
#~ "If this error occurs after flashing Klipper for the first time, then the "
#~ "stepper driver may have been previously programmed in a state that is not "
#~ "compatible with Klipper. To reset the state, remove all power from the "
#~ "printer for several seconds (physically unplug both USB and power plugs)."
#~ msgstr ""

#~ msgid ""
#~ "Otherwise, this error is typically the result of incorrect UART pin wiring "
#~ "or an incorrect Klipper configuration of the UART pin settings."
#~ msgstr ""

#~ msgid ""
#~ "I keep getting \"Unable to write tmc spi 'stepper_x' register ...\" errors?"
#~ msgstr ""

#~ msgid ""
#~ "This occurs when Klipper is unable to communicate with a tmc2130 or tmc5160 "
#~ "driver."
#~ msgstr ""

#~ msgid ""
#~ "Otherwise, this error is typically the result of incorrect SPI wiring, an "
#~ "incorrect Klipper configuration of the SPI settings, or an incomplete "
#~ "configuration of devices on an SPI bus."
#~ msgstr ""

#~ msgid ""
#~ "Note that if the driver is on a shared SPI bus with multiple devices then be"
#~ " sure to fully configure every device on that shared SPI bus in Klipper. If "
#~ "a device on a shared SPI bus is not configured, then it may incorrectly "
#~ "respond to commands not intended for it and corrupt the communication to the"
#~ " intended device. If there is a device on a shared SPI bus that can not be "
#~ "configured in Klipper, then use a [static_digital_output config "
#~ "section](Config_Reference.md#static_digital_output) to set the CS pin of the"
#~ " unused device high (so that it will not attempt to use the SPI bus). The "
#~ "board's schematic is often a useful reference for finding which devices are "
#~ "on an SPI bus and their associated pins."
#~ msgstr ""

#~ msgid "Why did I get a \"TMC reports error: ...\" error?"
#~ msgstr ""

#~ msgid ""
#~ "This type of error indicates the TMC driver detected a problem and has "
#~ "disabled itself. That is, the driver stopped holding its position and "
#~ "ignored movement commands. If Klipper detects that an active driver has "
#~ "disabled itself, it will transition the printer into a \"shutdown\" state."
#~ msgstr ""

#~ msgid ""
#~ "It's also possible that a **TMC reports error** shutdown occurs due to SPI "
#~ "errors that prevent communication with the driver (on tmc2130, tmc5160, or "
#~ "tmc2660). If this occurs, it's common for the reported driver status to show"
#~ " `00000000` or `ffffffff` - for example: `TMC reports error: DRV_STATUS: "
#~ "ffffffff ...` OR `TMC reports error: READRSP@RDSEL2: 00000000 ...`. Such a "
#~ "failure may be due to an SPI wiring problem or may be due to a self-reset or"
#~ " failure of the TMC driver."
#~ msgstr ""

#~ msgid "Some common errors and tips for diagnosing them:"
#~ msgstr ""

#~ msgid "TMC reports error: `... ot=1(OvertempError!)`"
#~ msgstr ""

#~ msgid ""
#~ "This indicates the motor driver disabled itself because it became too hot. "
#~ "Typical solutions are to decrease the stepper motor current, increase "
#~ "cooling on the stepper motor driver, and/or increase cooling on the stepper "
#~ "motor."
#~ msgstr ""

#~ msgid "TMC reports error: `... ShortToGND` OR `LowSideShort`"
#~ msgstr ""

#~ msgid ""
#~ "This indicates the driver has disabled itself because it detected very high "
#~ "current passing through the driver. This may indicate a loose or shorted "
#~ "wire to the stepper motor or within the stepper motor itself."
#~ msgstr ""

#~ msgid ""
#~ "This error may also occur if using stealthChop mode and the TMC driver is "
#~ "not able to accurately predict the mechanical load of the motor. (If the "
#~ "driver makes a poor prediction then it may send too much current through the"
#~ " motor and trigger its own over-current detection.) To test this, disable "
#~ "stealthChop mode and check if the errors continue to occur."
#~ msgstr ""

#~ msgid ""
#~ "TMC reports error: `... reset=1(Reset)` OR `CS_ACTUAL=0(Reset?)` OR "
#~ "`SE=0(Reset?)`"
#~ msgstr ""

#~ msgid ""
#~ "This indicates that the driver has reset itself mid-print. This may be due "
#~ "to voltage or wiring issues."
#~ msgstr ""

#~ msgid "TMC reports error: `... uv_cp=1(Undervoltage!)`"
#~ msgstr ""

#~ msgid ""
#~ "This indicates the driver has detected a low-voltage event and has disabled "
#~ "itself. This may be due to wiring or power supply issues."
#~ msgstr ""

#~ msgid "How do I tune spreadCycle/coolStep/etc. mode on my drivers?"
#~ msgstr ""

#~ msgid ""
#~ "The [Trinamic website](https://www.trinamic.com/) has guides on configuring "
#~ "the drivers. These guides are often technical, low-level, and may require "
#~ "specialized hardware. Regardless, they are the best source of information."
#~ msgstr ""

#~ msgid "Status reference"
#~ msgstr ""

#~ msgid ""
#~ "This document is a reference of printer status information available in "
#~ "Klipper [macros](Command_Templates.md), [display "
#~ "fields](Config_Reference.md#display), and via the [API "
#~ "Server](API_Server.md)."
#~ msgstr ""

#~ msgid ""
#~ "The fields in this document are subject to change - if using an attribute be"
#~ " sure to review the [Config Changes document](Config_Changes.md) when "
#~ "upgrading the Klipper software."
#~ msgstr ""

#~ msgid "angle"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in [angle "
#~ "some_name](Config_Reference.md#angle) objects:"
#~ msgstr ""

#~ msgid ""
#~ "`temperature`: The last temperature reading (in Celsius) from a tle5012b "
#~ "magnetic hall sensor. This value is only available if the angle sensor is a "
#~ "tle5012b chip and if measurements are in progress (otherwise it reports "
#~ "`None`)."
#~ msgstr ""

#~ msgid "bed_mesh"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[bed_mesh](Config_Reference.md#bed_mesh) object:"
#~ msgstr ""

#~ msgid ""
#~ "`profile_name`, `mesh_min`, `mesh_max`, `probed_matrix`, `mesh_matrix`: "
#~ "Information on the currently active bed_mesh."
#~ msgstr ""

#~ msgid ""
#~ "`profiles`: The set of currently defined profiles as setup using "
#~ "BED_MESH_PROFILE."
#~ msgstr ""

#~ msgid "bed_screws"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "`Config_Reference.md#bed_screws` object:"
#~ msgstr ""

#~ msgid ""
#~ "`is_active`: Returns True if the bed screws adjustment tool is currently "
#~ "active."
#~ msgstr ""

#~ msgid ""
#~ "`state`: The bed screws adjustment tool state. It is one of the following "
#~ "strings: \"adjust\", \"fine\"."
#~ msgstr ""

#~ msgid "`current_screw`: The index for the current screw being adjusted."
#~ msgstr ""

#~ msgid "`accepted_screws`: The number of accepted screws."
#~ msgstr ""

#~ msgid "configfile"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `configfile` object (this "
#~ "object is always available):"
#~ msgstr ""

#~ msgid ""
#~ "`settings.<section>.<option>`: Returns the given config file setting (or "
#~ "default value) during the last software start or restart. (Any settings "
#~ "changed at run-time will not be reflected here.)"
#~ msgstr ""

#~ msgid ""
#~ "`config.<section>.<option>`: Returns the given raw config file setting as "
#~ "read by Klipper during the last software start or restart. (Any settings "
#~ "changed at run-time will not be reflected here.) All values are returned as "
#~ "strings."
#~ msgstr ""

#~ msgid ""
#~ "`save_config_pending`: Returns true if there are updates that a "
#~ "`SAVE_CONFIG` command may persist to disk."
#~ msgstr ""

#~ msgid ""
#~ "`save_config_pending_items`: Contains the sections and options that were "
#~ "changed and would be persisted by a `SAVE_CONFIG`."
#~ msgstr ""

#~ msgid ""
#~ "`warnings`: A list of warnings about config options. Each entry in the list "
#~ "will be a dictionary containing a `type` and `message` field (both strings)."
#~ " Additional fields may be available depending on the type of warning."
#~ msgstr ""

#~ msgid "display_status"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `display_status` object (this "
#~ "object is automatically available if a "
#~ "[display](Config_Reference.md#display) config section is defined):"
#~ msgstr ""

#~ msgid ""
#~ "`progress`: The progress value of the last `M73` G-Code command (or "
#~ "`virtual_sdcard.progress` if no recent `M73` received)."
#~ msgstr ""

#~ msgid "`message`: The message contained in the last `M117` G-Code command."
#~ msgstr ""

#~ msgid "endstop_phase"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[endstop_phase](Config_Reference.md#endstop_phase) object:"
#~ msgstr ""

#~ msgid ""
#~ "`last_home.<stepper name>.phase`: The phase of the stepper motor at the end "
#~ "of the last home attempt."
#~ msgstr ""

#~ msgid ""
#~ "`last_home.<stepper name>.phases`: The total number of phases available on "
#~ "the stepper motor."
#~ msgstr ""

#~ msgid ""
#~ "`last_home.<stepper name>.mcu_position`: The position (as tracked by the "
#~ "micro-controller) of the stepper motor at the end of the last home attempt. "
#~ "The position is the total number of steps taken in a forward direction minus"
#~ " the total number of steps taken in the reverse direction since the micro-"
#~ "controller was last restarted."
#~ msgstr ""

#~ msgid "exclude_object"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[exclude_object](Exclude_Object.md) object:"
#~ msgstr ""

#~ msgid ""
#~ "`objects`: An array of the known objects as provided by the "
#~ "`EXCLUDE_OBJECT_DEFINE` command. This is the same information provided by "
#~ "the `EXCLUDE_OBJECT VERBOSE=1` command. The `center` and `polygon` fields "
#~ "will only be present if provided in the original `EXCLUDE_OBJECT_DEFINE`"
#~ msgstr ""

#~ msgid "Here is a JSON sample:"
#~ msgstr ""

#~ msgid ""
#~ "[\n"
#~ "  {\n"
#~ "    \"polygon\": [\n"
#~ "      [ 156.25, 146.2511675 ],\n"
#~ "      [ 156.25, 153.7488325 ],\n"
#~ "      [ 163.75, 153.7488325 ],\n"
#~ "      [ 163.75, 146.2511675 ]\n"
#~ "    ],\n"
#~ "    \"name\": \"CYLINDER_2_STL_ID_2_COPY_0\",\n"
#~ "    \"center\": [ 160, 150 ]\n"
#~ "  },\n"
#~ "  {\n"
#~ "    \"polygon\": [\n"
#~ "      [ 146.25, 146.2511675 ],\n"
#~ "      [ 146.25, 153.7488325 ],\n"
#~ "      [ 153.75, 153.7488325 ],\n"
#~ "      [ 153.75, 146.2511675 ]\n"
#~ "    ],\n"
#~ "    \"name\": \"CYLINDER_2_STL_ID_1_COPY_0\",\n"
#~ "    \"center\": [ 150, 150 ]\n"
#~ "  }\n"
#~ "]\n"
#~ msgstr ""

#~ msgid ""
#~ "`excluded_objects`: An array of strings listing the names of excluded "
#~ "objects."
#~ msgstr ""

#~ msgid "`current_object`: The name of the object currently being printed."
#~ msgstr ""

#~ msgid "extruder_stepper"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available for extruder_stepper objects (as well"
#~ " as [extruder](Config_Reference.md#extruder) objects):"
#~ msgstr ""

#~ msgid ""
#~ "`pressure_advance`: The current [pressure advance](Pressure_Advance.md) "
#~ "value."
#~ msgstr ""

#~ msgid "`smooth_time`: The current pressure advance smooth time."
#~ msgstr ""

#~ msgid "fan"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in [fan](Config_Reference.md#fan), "
#~ "[heater_fan some_name](Config_Reference.md#heater_fan) and [controller_fan "
#~ "some_name](Config_Reference.md#controller_fan) objects:"
#~ msgstr ""

#~ msgid "`speed`: The fan speed as a float between 0.0 and 1.0."
#~ msgstr ""

#~ msgid ""
#~ "`rpm`: The measured fan speed in rotations per minute if the fan has a "
#~ "tachometer_pin defined."
#~ msgstr ""

#~ msgid "filament_switch_sensor"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in [filament_switch_sensor "
#~ "some_name](Config_Reference.md#filament_switch_sensor) objects:"
#~ msgstr ""

#~ msgid "`enabled`: Returns True if the switch sensor is currently enabled."
#~ msgstr ""

#~ msgid ""
#~ "`filament_detected`: Returns True if the sensor is in a triggered state."
#~ msgstr ""

#~ msgid "filament_motion_sensor"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in [filament_motion_sensor "
#~ "some_name](Config_Reference.md#filament_motion_sensor) objects:"
#~ msgstr ""

#~ msgid "`enabled`: Returns True if the motion sensor is currently enabled."
#~ msgstr ""

#~ msgid "firmware_retraction"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[firmware_retraction](Config_Reference.md#firmware_retraction) object:"
#~ msgstr ""

#~ msgid ""
#~ "`retract_length`, `retract_speed`, `unretract_extra_length`, "
#~ "`unretract_speed`: The current settings for the firmware_retraction module. "
#~ "These settings may differ from the config file if a `SET_RETRACTION` command"
#~ " alters them."
#~ msgstr ""

#~ msgid "gcode_macro"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in [gcode_macro "
#~ "some_name](Config_Reference.md#gcode_macro) objects:"
#~ msgstr ""

#~ msgid ""
#~ "`<variable>`: The current value of a [gcode_macro "
#~ "variable](Command_Templates.md#variables)."
#~ msgstr ""

#~ msgid "gcode_move"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `gcode_move` object (this "
#~ "object is always available):"
#~ msgstr ""

#~ msgid ""
#~ "`gcode_position`: The current position of the toolhead relative to the "
#~ "current G-Code origin. That is, positions that one might directly send to a "
#~ "`G1` command. It is possible to access the x, y, z, and e components of this"
#~ " position (eg, `gcode_position.x`)."
#~ msgstr ""

#~ msgid ""
#~ "`position`: The last commanded position of the toolhead using the coordinate"
#~ " system specified in the config file. It is possible to access the x, y, z, "
#~ "and e components of this position (eg, `position.x`)."
#~ msgstr ""

#~ msgid ""
#~ "`homing_origin`: The origin of the gcode coordinate system (relative to the "
#~ "coordinate system specified in the config file) to use after a `G28` "
#~ "command. The `SET_GCODE_OFFSET` command can alter this position. It is "
#~ "possible to access the x, y, and z components of this position (eg, "
#~ "`homing_origin.x`)."
#~ msgstr ""

#~ msgid "`speed`: The last speed set in a `G1` command (in mm/s)."
#~ msgstr ""

#~ msgid ""
#~ "`speed_factor`: The \"speed factor override\" as set by an `M220` command. "
#~ "This is a floating point value such that 1.0 means no override and, for "
#~ "example, 2.0 would double requested speed."
#~ msgstr ""

#~ msgid ""
#~ "`extrude_factor`: The \"extrude factor override\" as set by an `M221` "
#~ "command. This is a floating point value such that 1.0 means no override and,"
#~ " for example, 2.0 would double requested extrusions."
#~ msgstr ""

#~ msgid ""
#~ "`absolute_coordinates`: This returns True if in `G90` absolute coordinate "
#~ "mode or False if in `G91` relative mode."
#~ msgstr ""

#~ msgid ""
#~ "`absolute_extrude`: This returns True if in `M82` absolute extrude mode or "
#~ "False if in `M83` relative mode."
#~ msgstr ""

#~ msgid "hall_filament_width_sensor"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[hall_filament_width_sensor](Config_Reference.md#hall_filament_width_sensor)"
#~ " object:"
#~ msgstr ""

#~ msgid "`is_active`: Returns True if the sensor is currently active."
#~ msgstr ""

#~ msgid "`Diameter`: The last reading from the sensor in mm."
#~ msgstr ""

#~ msgid "`Raw`: The last raw ADC reading from the sensor."
#~ msgstr ""

#~ msgid "heater"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available for heater objects such as "
#~ "[extruder](Config_Reference.md#extruder), "
#~ "[heater_bed](Config_Reference.md#heater_bed), and "
#~ "[heater_generic](Config_Reference.md#heater_generic):"
#~ msgstr ""

#~ msgid ""
#~ "`temperature`: The last reported temperature (in Celsius as a float) for the"
#~ " given heater."
#~ msgstr ""

#~ msgid ""
#~ "`target`: The current target temperature (in Celsius as a float) for the "
#~ "given heater."
#~ msgstr ""

#~ msgid ""
#~ "`power`: The last setting of the PWM pin (a value between 0.0 and 1.0) "
#~ "associated with the heater."
#~ msgstr ""

#~ msgid ""
#~ "`can_extrude`: If extruder can extrude (defined by `min_extrude_temp`), "
#~ "available only for [extruder](Config_Reference.md#extruder)"
#~ msgstr ""

#~ msgid "heaters"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `heaters` object (this object "
#~ "is available if any heater is defined):"
#~ msgstr ""

#~ msgid ""
#~ "`available_heaters`: Returns a list of all currently available heaters by "
#~ "their full config section names, e.g. `[\"extruder\", \"heater_bed\", "
#~ "\"heater_generic my_custom_heater\"]`."
#~ msgstr ""

#~ msgid ""
#~ "`available_sensors`: Returns a list of all currently available temperature "
#~ "sensors by their full config section names, e.g. `[\"extruder\", "
#~ "\"heater_bed\", \"heater_generic my_custom_heater\", \"temperature_sensor "
#~ "electronics_temp\"]`."
#~ msgstr ""

#~ msgid "idle_timeout"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[idle_timeout](Config_Reference.md#idle_timeout) object (this object is "
#~ "always available):"
#~ msgstr ""

#~ msgid ""
#~ "`state`: The current state of the printer as tracked by the idle_timeout "
#~ "module. It is one of the following strings: \"Idle\", \"Printing\", "
#~ "\"Ready\"."
#~ msgstr ""

#~ msgid ""
#~ "`printing_time`: The amount of time (in seconds) the printer has been in the"
#~ " \"Printing\" state (as tracked by the idle_timeout module)."
#~ msgstr ""

#~ msgid "led"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available for each `[led led_name]`, `[neopixel"
#~ " led_name]`, `[dotstar led_name]`, `[pca9533 led_name]`, and `[pca9632 "
#~ "led_name]` config section defined in printer.cfg:"
#~ msgstr ""

#~ msgid ""
#~ "`color_data`: A list of color lists containing the RGBW values for a led in "
#~ "the chain. Each value is represented as a float from 0.0 to 1.0. Each color "
#~ "list contains 4 items (red, green, blue, white) even if the underyling LED "
#~ "supports fewer color channels. For example, the blue value (3rd item in "
#~ "color list) of the second neopixel in a chain could be accessed at "
#~ "`printer[\"neopixel <config_name>\"].color_data[1][2]`."
#~ msgstr ""

#~ msgid "manual_probe"
#~ msgstr ""

#~ msgid "The following information is available in the `manual_probe` object:"
#~ msgstr ""

#~ msgid ""
#~ "`is_active`: Returns True if a manual probing helper script is currently "
#~ "active."
#~ msgstr ""

#~ msgid ""
#~ "`z_position`: The current height of the nozzle (as the printer currently "
#~ "understands it)."
#~ msgstr ""

#~ msgid ""
#~ "`z_position_lower`: Last probe attempt just lower than the current height."
#~ msgstr ""

#~ msgid ""
#~ "`z_position_upper`: Last probe attempt just greater than the current height."
#~ msgstr ""

#~ msgid "mcu"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in [mcu](Config_Reference.md#mcu) and"
#~ " [mcu some_name](Config_Reference.md#mcu-my_extra_mcu) objects:"
#~ msgstr ""

#~ msgid ""
#~ "`mcu_version`: The Klipper code version reported by the micro-controller."
#~ msgstr ""

#~ msgid ""
#~ "`mcu_build_versions`: Information on the build tools used to generate the "
#~ "micro-controller code (as reported by the micro-controller)."
#~ msgstr ""

#~ msgid ""
#~ "`mcu_constants.<constant_name>`: Compile time constants reported by the "
#~ "micro-controller. The available constants may differ between micro-"
#~ "controller architectures and with each code revision."
#~ msgstr ""

#~ msgid ""
#~ "`last_stats.<statistics_name>`: Statistics information on the micro-"
#~ "controller connection."
#~ msgstr ""

#~ msgid "motion_report"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `motion_report` object (this "
#~ "object is automatically available if any stepper config section is defined):"
#~ msgstr ""

#~ msgid ""
#~ "`live_position`: The requested toolhead position interpolated to the current"
#~ " time."
#~ msgstr ""

#~ msgid ""
#~ "`live_velocity`: The requested toolhead velocity (in mm/s) at the current "
#~ "time."
#~ msgstr ""

#~ msgid ""
#~ "`live_extruder_velocity`: The requested extruder velocity (in mm/s) at the "
#~ "current time."
#~ msgstr ""

#~ msgid "output_pin"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in [output_pin "
#~ "some_name](Config_Reference.md#output_pin) objects:"
#~ msgstr ""

#~ msgid "`value`: The \"value\" of the pin, as set by a `SET_PIN` command."
#~ msgstr ""

#~ msgid "palette2"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[palette2](Config_Reference.md#palette2) object:"
#~ msgstr ""

#~ msgid "`ping`: Amount of the last reported Palette 2 ping in percent."
#~ msgstr ""

#~ msgid ""
#~ "`remaining_load_length`: When starting a Palette 2 print, this will be the "
#~ "amount of filament to load into the extruder."
#~ msgstr ""

#~ msgid "`is_splicing`: True when the Palette 2 is splicing filament."
#~ msgstr ""

#~ msgid "pause_resume"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[pause_resume](Config_Reference.md#pause_resume) object:"
#~ msgstr ""

#~ msgid ""
#~ "`is_paused`: Returns true if a PAUSE command has been executed without a "
#~ "corresponding RESUME."
#~ msgstr ""

#~ msgid "print_stats"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `print_stats` object (this "
#~ "object is automatically available if a "
#~ "[virtual_sdcard](Config_Reference.md#virtual_sdcard) config section is "
#~ "defined):"
#~ msgstr ""

#~ msgid ""
#~ "`filename`, `total_duration`, `print_duration`, `filament_used`, `state`, "
#~ "`message`: Estimated information about the current print when a "
#~ "virtual_sdcard print is active."
#~ msgstr ""

#~ msgid ""
#~ "`info.total_layer`: The total layer value of the last `SET_PRINT_STATS_INFO "
#~ "TOTAL_LAYER=<value>` G-Code command."
#~ msgstr ""

#~ msgid ""
#~ "`info.current_layer`: The current layer value of the last "
#~ "`SET_PRINT_STATS_INFO CURRENT_LAYER=<value>` G-Code command."
#~ msgstr ""

#~ msgid "probe"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[probe](Config_Reference.md#probe) object (this object is also available if "
#~ "a [bltouch](Config_Reference.md#bltouch) config section is defined):"
#~ msgstr ""

#~ msgid ""
#~ "`last_query`: Returns True if the probe was reported as \"triggered\" during"
#~ " the last QUERY_PROBE command. Note, if this is used in a macro, due to the "
#~ "order of template expansion, the QUERY_PROBE command must be run prior to "
#~ "the macro containing this reference."
#~ msgstr ""

#~ msgid ""
#~ "`last_z_result`: Returns the Z result value of the last PROBE command. Note,"
#~ " if this is used in a macro, due to the order of template expansion, the "
#~ "PROBE (or similar) command must be run prior to the macro containing this "
#~ "reference."
#~ msgstr ""

#~ msgid "quad_gantry_level"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `quad_gantry_level` object "
#~ "(this object is available if quad_gantry_level is defined):"
#~ msgstr ""

#~ msgid ""
#~ "`applied`: True if the gantry leveling process has been run and completed "
#~ "successfully."
#~ msgstr ""

#~ msgid "query_endstops"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `query_endstops` object (this "
#~ "object is available if any endstop is defined):"
#~ msgstr ""

#~ msgid ""
#~ "`last_query[\"<endstop>\"]`: Returns True if the given endstop was reported "
#~ "as \"triggered\" during the last QUERY_ENDSTOP command. Note, if this is "
#~ "used in a macro, due to the order of template expansion, the QUERY_ENDSTOP "
#~ "command must be run prior to the macro containing this reference."
#~ msgstr ""

#~ msgid "screws_tilt_adjust"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `screws_tilt_adjust` object:"
#~ msgstr ""

#~ msgid ""
#~ "`error`: Returns True if the most recent `SCREWS_TILT_CALCULATE` command "
#~ "included the `MAX_DEVIATION` parameter and any of the probed screw points "
#~ "exceeded the specified `MAX_DEVIATION`."
#~ msgstr ""

#~ msgid ""
#~ "`results`: A list of the probed screw locations. Each entry in the list will"
#~ " be a dictionary containing the following keys:"
#~ msgstr ""

#~ msgid "`name`: The name of the screw as specified in the config file."
#~ msgstr ""

#~ msgid "`x`: The X coordinate of the screw as specified in the config file."
#~ msgstr ""

#~ msgid "`y`: The Y coordinate of the screw as specified in the config file."
#~ msgstr ""

#~ msgid "`z`: The measured Z height of the screw location."
#~ msgstr ""

#~ msgid ""
#~ "`sign`: A string specifying the direction to turn to screw for the necessary"
#~ " adjustment. Either \"CW\" for clockwise or \"CCW\" for counterclockwise. "
#~ "The base screw will not have a `sign` key."
#~ msgstr ""

#~ msgid ""
#~ "`adjust`: The number of screw turns to adjust the screw, given in the format"
#~ " \"HH:MM,\" where \"HH\" is the number of full screw turns and \"MM\" is the"
#~ " number of \"minutes of a clock face\" representing a partial screw turn. "
#~ "(E.g. \"01:15\" would mean to turn the screw one and a quarter revolutions.)"
#~ msgstr ""

#~ msgid "servo"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in [servo "
#~ "some_name](Config_Reference.md#servo) objects:"
#~ msgstr ""

#~ msgid ""
#~ "`printer[\"servo <config_name>\"].value`: The last setting of the PWM pin (a"
#~ " value between 0.0 and 1.0) associated with the servo."
#~ msgstr ""

#~ msgid "system_stats"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `system_stats` object (this "
#~ "object is always available):"
#~ msgstr ""

#~ msgid ""
#~ "`sysload`, `cputime`, `memavail`: Information on the host operating system "
#~ "and process load."
#~ msgstr ""

#~ msgid "temperature sensors"
#~ msgstr ""

#~ msgid "The following information is available in"
#~ msgstr ""

#~ msgid ""
#~ "[bme280 "
#~ "config_section_name](Config_Reference.md#bmp280bme280bme680-temperature-"
#~ "sensor), [htu21d config_section_name](Config_Reference.md#htu21d-sensor), "
#~ "[lm75 config_section_name](Config_Reference.md#lm75-temperature-sensor), and"
#~ " [temperature_host config_section_name](Config_Reference.md#host-"
#~ "temperature-sensor) objects:"
#~ msgstr ""

#~ msgid "`temperature`: The last read temperature from the sensor."
#~ msgstr ""

#~ msgid ""
#~ "`humidity`, `pressure`, `gas`: The last read values from the sensor (only on"
#~ " bme280, htu21d, and lm75 sensors)."
#~ msgstr ""

#~ msgid "temperature_fan"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in [temperature_fan "
#~ "some_name](Config_Reference.md#temperature_fan) objects:"
#~ msgstr ""

#~ msgid "`target`: The target temperature for the fan."
#~ msgstr ""

#~ msgid "temperature_sensor"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in [temperature_sensor "
#~ "some_name](Config_Reference.md#temperature_sensor) objects:"
#~ msgstr ""

#~ msgid ""
#~ "`measured_min_temp`, `measured_max_temp`: The lowest and highest temperature"
#~ " seen by the sensor since the Klipper host software was last restarted."
#~ msgstr ""

#~ msgid "tmc drivers"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in [TMC stepper "
#~ "driver](Config_Reference.md#tmc-stepper-driver-configuration) objects (eg, "
#~ "`[tmc2208 stepper_x]`):"
#~ msgstr ""

#~ msgid ""
#~ "`mcu_phase_offset`: The micro-controller stepper position corresponding with"
#~ " the driver's \"zero\" phase. This field may be null if the phase offset is "
#~ "not known."
#~ msgstr ""

#~ msgid ""
#~ "`phase_offset_position`: The \"commanded position\" corresponding to the "
#~ "driver's \"zero\" phase. This field may be null if the phase offset is not "
#~ "known."
#~ msgstr ""

#~ msgid ""
#~ "`drv_status`: The results of the last driver status query. (Only non-zero "
#~ "fields are reported.) This field will be null if the driver is not enabled "
#~ "(and thus is not periodically queried)."
#~ msgstr ""

#~ msgid "`run_current`: The currently set run current."
#~ msgstr ""

#~ msgid "`hold_current`: The currently set hold current."
#~ msgstr ""

#~ msgid "toolhead"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `toolhead` object (this object"
#~ " is always available):"
#~ msgstr ""

#~ msgid ""
#~ "`position`: The last commanded position of the toolhead relative to the "
#~ "coordinate system specified in the config file. It is possible to access the"
#~ " x, y, z, and e components of this position (eg, `position.x`)."
#~ msgstr ""

#~ msgid ""
#~ "`extruder`: The name of the currently active extruder. For example, in a "
#~ "macro one could use `printer[printer.toolhead.extruder].target` to get the "
#~ "target temperature of the current extruder."
#~ msgstr ""

#~ msgid ""
#~ "`homed_axes`: The current cartesian axes considered to be in a \"homed\" "
#~ "state. This is a string containing one or more of \"x\", \"y\", \"z\"."
#~ msgstr ""

#~ msgid ""
#~ "`axis_minimum`, `axis_maximum`: The axis travel limits (mm) after homing. It"
#~ " is possible to access the x, y, z components of this limit value (eg, "
#~ "`axis_minimum.x`, `axis_maximum.z`)."
#~ msgstr ""

#~ msgid ""
#~ "For Delta printers the `cone_start_z` is the max z height at maximum radius "
#~ "(`printer.toolhead.cone_start_z`)."
#~ msgstr ""

#~ msgid ""
#~ "`max_velocity`, `max_accel`, `max_accel_to_decel`, `square_corner_velocity`:"
#~ " The current printing limits that are in effect. This may differ from the "
#~ "config file settings if a `SET_VELOCITY_LIMIT` (or `M204`) command alters "
#~ "them at run-time."
#~ msgstr ""

#~ msgid ""
#~ "`stalls`: The total number of times (since the last restart) that the "
#~ "printer had to be paused because the toolhead moved faster than moves could "
#~ "be read from the G-Code input."
#~ msgstr ""

#~ msgid "dual_carriage"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in "
#~ "[dual_carriage](Config_Reference.md#dual_carriage) on a hybrid_corexy or "
#~ "hybrid_corexz robot"
#~ msgstr ""

#~ msgid "`mode`: The current mode. Possible values are: \"FULL_CONTROL\""
#~ msgstr ""

#~ msgid ""
#~ "`active_carriage`: The current active carriage. Possible values are: "
#~ "\"CARRIAGE_0\", \"CARRIAGE_1\""
#~ msgstr ""

#~ msgid "virtual_sdcard"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[virtual_sdcard](Config_Reference.md#virtual_sdcard) object:"
#~ msgstr ""

#~ msgid "`is_active`: Returns True if a print from file is currently active."
#~ msgstr ""

#~ msgid ""
#~ "`progress`: An estimate of the current print progress (based of file size "
#~ "and file position)."
#~ msgstr ""

#~ msgid "`file_path`: A full path to the file of currently loaded file."
#~ msgstr ""

#~ msgid "`file_position`: The current position (in bytes) of an active print."
#~ msgstr ""

#~ msgid "`file_size`: The file size (in bytes) of currently loaded file."
#~ msgstr ""

#~ msgid "webhooks"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `webhooks` object (this object"
#~ " is always available):"
#~ msgstr ""

#~ msgid ""
#~ "`state`: Returns a string indicating the current Klipper state. Possible "
#~ "values are: \"ready\", \"startup\", \"shutdown\", \"error\"."
#~ msgstr ""

#~ msgid ""
#~ "`state_message`: A human readable string giving additional context on the "
#~ "current Klipper state."
#~ msgstr ""

#~ msgid "z_thermal_adjust"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `z_thermal_adjust` object "
#~ "(this object is available if "
#~ "[z_thermal_adjust](Config_Reference.md#z_thermal_adjust) is defined)."
#~ msgstr ""

#~ msgid "`enabled`: Returns True if adjustment is enabled."
#~ msgstr ""

#~ msgid ""
#~ "`temperature`: Current (smoothed) temperature of the defined sensor. [degC]"
#~ msgstr ""

#~ msgid "`measured_min_temp`: Minimum measured temperature. [degC]"
#~ msgstr ""

#~ msgid "`measured_max_temp`: Maximum measured temperature. [degC]"
#~ msgstr ""

#~ msgid "`current_z_adjust`: Last computed Z adjustment [mm]."
#~ msgstr ""

#~ msgid ""
#~ "`z_adjust_ref_temperature`: Current reference temperature used for "
#~ "calculation of Z `current_z_adjust` [degC]."
#~ msgstr ""

#~ msgid "z_tilt"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `z_tilt` object (this object "
#~ "is available if z_tilt is defined):"
#~ msgstr ""

#~ msgid ""
#~ "`applied`: True if the z-tilt leveling process has been run and completed "
#~ "successfully."
#~ msgstr ""

#~ msgid "Sponsors"
#~ msgstr ""

#~ msgid ""
#~ "Klipper is Free Software. We depend on the generous support from sponsors. "
#~ "Please consider sponsoring Klipper or supporting our sponsors."
#~ msgstr ""

#~ msgid "BIGTREETECH"
#~ msgstr ""

#~ msgid ""
#~ "[<img src=\"./img/sponsors/BTT_BTT.png\" width=\"200\" />](https://bigtree-"
#~ "tech.com/collections/all-products)"
#~ msgstr ""

#~ msgid ""
#~ "BIGTREETECH is the official mainboard sponsor of Klipper. BIGTREETECH is "
#~ "committed to developing innovative and competitive products to serve the 3D "
#~ "printing community better. Follow them on "
#~ "[Facebook](https://www.facebook.com/BIGTREETECH) or "
#~ "[Twitter](https://twitter.com/BigTreeTech)."
#~ msgstr ""

#~ msgid "Klipper Developers"
#~ msgstr ""

#~ msgid "Kevin O'Connor"
#~ msgstr ""

#~ msgid ""
#~ "Kevin is the original author and current maintainer of Klipper. Donate at: "
#~ "<https://ko-fi.com/koconnor> or <https://www.patreon.com/koconnor>"
#~ msgstr ""

#~ msgid "Eric Callahan"
#~ msgstr ""

#~ msgid ""
#~ "Eric is the author of bed_mesh, spi_flash, and several other Klipper "
#~ "modules. Eric has a donations page at: <https://ko-fi.com/arksine>"
#~ msgstr ""

#~ msgid "Related Klipper Projects"
#~ msgstr ""

#~ msgid ""
#~ "Klipper is frequently used with other Free Software. Consider using or "
#~ "supporting these projects."
#~ msgstr ""

#~ msgid "[Moonraker](https://github.com/Arksine/moonraker)"
#~ msgstr ""

#~ msgid "[Mainsail](https://github.com/mainsail-crew/mainsail)"
#~ msgstr ""

#~ msgid "[Fluidd](https://github.com/fluidd-core/fluidd)"
#~ msgstr ""

#~ msgid "[OctoPrint](https://octoprint.org/)"
#~ msgstr ""

#~ msgid "[KlipperScreen](https://github.com/jordanruthe/KlipperScreen)"
#~ msgstr ""

#~ msgid "Slicers"
#~ msgstr ""

#~ msgid ""
#~ "This document provides some tips for configuring a \"slicer\" application "
#~ "for use with Klipper. Common slicers used with Klipper are Slic3r, Cura, "
#~ "Simplify3D, etc."
#~ msgstr ""

#~ msgid "Set the G-Code flavor to Marlin"
#~ msgstr ""

#~ msgid ""
#~ "Many slicers have an option to configure the \"G-Code flavor\". The default "
#~ "is frequently \"Marlin\" and that works well with Klipper. The "
#~ "\"Smoothieware\" setting also works well with Klipper."
#~ msgstr ""

#~ msgid "Klipper gcode_macro"
#~ msgstr ""

#~ msgid ""
#~ "Slicers will often allow one to configure \"Start G-Code\" and \"End "
#~ "G-Code\" sequences. It is often convenient to define custom macros in the "
#~ "Klipper config file instead - such as: `[gcode_macro START_PRINT]` and "
#~ "`[gcode_macro END_PRINT]`. Then one can just run START_PRINT and END_PRINT "
#~ "in the slicer's configuration. Defining these actions in the Klipper "
#~ "configuration may make it easier to tweak the printer's start and end steps "
#~ "as changes do not require re-slicing."
#~ msgstr ""

#~ msgid ""
#~ "See [sample-macros.cfg](../config/sample-macros.cfg) for example START_PRINT"
#~ " and END_PRINT macros."
#~ msgstr ""

#~ msgid ""
#~ "See the [config reference](Config_Reference.md#gcode_macro) for details on "
#~ "defining a gcode_macro."
#~ msgstr ""

#~ msgid "Large retraction settings may require tuning Klipper"
#~ msgstr ""

#~ msgid ""
#~ "The maximum speed and acceleration of retraction moves are controlled in "
#~ "Klipper by the `max_extrude_only_velocity` and `max_extrude_only_accel` "
#~ "config settings. These settings have a default value that should work well "
#~ "on many printers. However, if one has configured a large retraction in the "
#~ "slicer (eg, 5mm or greater) then one may find they limit the desired speed "
#~ "of retractions."
#~ msgstr ""

#~ msgid ""
#~ "If using a large retraction, consider tuning Klipper's [pressure "
#~ "advance](Pressure_Advance.md) instead. Otherwise, if one finds the toolhead "
#~ "seems to \"pause\" during retraction and priming, then consider explicitly "
#~ "defining `max_extrude_only_velocity` and `max_extrude_only_accel` in the "
#~ "Klipper config file."
#~ msgstr ""

#~ msgid "Do not enable \"coasting\""
#~ msgstr ""

#~ msgid ""
#~ "The \"coasting\" feature is likely to result in poor quality prints with "
#~ "Klipper. Consider using Klipper's [pressure advance](Pressure_Advance.md) "
#~ "instead."
#~ msgstr ""

#~ msgid ""
#~ "Specifically, if the slicer dramatically changes the extrusion rate between "
#~ "moves then Klipper will perform deceleration and acceleration between moves."
#~ " This is likely to make blobbing worse, not better."
#~ msgstr ""

#~ msgid ""
#~ "In contrast, it is okay (and often helpful) to use a slicer's \"retract\" "
#~ "setting, \"wipe\" setting, and/or \"wipe on retract\" setting."
#~ msgstr ""

#~ msgid "Do not use \"extra restart distance\" on Simplify3d"
#~ msgstr ""

#~ msgid ""
#~ "This setting can cause dramatic changes to extrusion rates which can trigger"
#~ " Klipper's maximum extrusion cross-section check. Consider using Klipper's "
#~ "[pressure advance](Pressure_Advance.md) or the regular Simplify3d retract "
#~ "setting instead."
#~ msgstr ""

#~ msgid "Disable \"PreloadVE\" on KISSlicer"
#~ msgstr ""

#~ msgid ""
#~ "If using KISSlicer slicing software then set \"PreloadVE\" to zero. Consider"
#~ " using Klipper's [pressure advance](Pressure_Advance.md) instead."
#~ msgstr ""

#~ msgid "Disable any \"advanced extruder pressure\" settings"
#~ msgstr ""

#~ msgid ""
#~ "Some slicers advertise an \"advanced extruder pressure\" capability. It is "
#~ "recommended to keep these options disabled when using Klipper as they are "
#~ "likely to result in poor quality prints. Consider using Klipper's [pressure "
#~ "advance](Pressure_Advance.md) instead."
#~ msgstr ""

#~ msgid ""
#~ "Specifically, these slicer settings can instruct the firmware to make wild "
#~ "changes to the extrusion rate in the hope that the firmware will approximate"
#~ " those requests and the printer will roughly obtain a desirable extruder "
#~ "pressure. Klipper, however, utilizes precise kinematic calculations and "
#~ "timing. When Klipper is commanded to make significant changes to the "
#~ "extrusion rate it will plan out the corresponding changes to velocity, "
#~ "acceleration, and extruder movement - which is not the slicer's intent. The "
#~ "slicer may even command excessive extrusion rates to the point that it "
#~ "triggers Klipper's maximum extrusion cross-section check."
#~ msgstr ""

#~ msgid "Caveats"
#~ msgstr ""

#~ msgid "Skew correction"
#~ msgstr ""

#~ msgid ""
#~ "Software based skew correction can help resolve dimensional inaccuracies "
#~ "resulting from a printer assembly that is not perfectly square. Note that if"
#~ " your printer is significantly skewed it is strongly recommended to first "
#~ "use mechanical means to get your printer as square as possible prior to "
#~ "applying software based correction."
#~ msgstr ""

#~ msgid "Print a Calibration Object"
#~ msgstr ""

#~ msgid ""
#~ "The first step in correcting skew is to print a [calibration "
#~ "object](https://www.thingiverse.com/thing:2563185/files) along the plane you"
#~ " want to correct. There is also a [calibration "
#~ "object](https://www.thingiverse.com/thing:2972743) that includes all planes "
#~ "in one model. You want the object oriented so that corner A is toward the "
#~ "origin of the plane."
#~ msgstr ""

#~ msgid ""
#~ "Make sure that no skew correction is applied during this print. You may do "
#~ "this by either removing the `[skew_correction]` module from printer.cfg or "
#~ "by issuing a `SET_SKEW CLEAR=1` gcode."
#~ msgstr ""

#~ msgid "Take your measurements"
#~ msgstr ""

#~ msgid ""
#~ "The `[skew_correcton]` module requires 3 measurements for each plane you "
#~ "want to correct; the length from Corner A to Corner C, the length from "
#~ "Corner B to Corner D, and the length from Corner A to Corner D. When "
#~ "measuring length AD do not include the flats on the corners that some test "
#~ "objects provide."
#~ msgstr ""

#~ msgid "![skew_lengths](img/skew_lengths.png)"
#~ msgstr ""

#~ msgid "Configure your skew"
#~ msgstr ""

#~ msgid ""
#~ "Make sure `[skew_correction]` is in printer.cfg. You may now use the "
#~ "`SET_SKEW` gcode to configure skew_correcton. For example, if your measured "
#~ "lengths along XY are as follows:"
#~ msgstr ""

#~ msgid ""
#~ "Length AC = 140.4\n"
#~ "Length BD = 142.8\n"
#~ "Length AD = 99.8\n"
#~ msgstr ""

#~ msgid "`SET_SKEW` can be used to configure skew correction for the XY plane."
#~ msgstr ""

#~ msgid "SET_SKEW XY=140.4,142.8,99.8\n"
#~ msgstr ""

#~ msgid "You may also add measurements for XZ and YZ to the gcode:"
#~ msgstr ""

#~ msgid "SET_SKEW XY=140.4,142.8,99.8 XZ=141.6,141.4,99.8 YZ=142.4,140.5,99.5\n"
#~ msgstr ""

#~ msgid ""
#~ "The `[skew_correction]` module also supports profile management in a manner "
#~ "similar to `[bed_mesh]`. After setting skew using the `SET_SKEW` gcode, you "
#~ "may use the `SKEW_PROFILE` gcode to save it:"
#~ msgstr ""

#~ msgid "SKEW_PROFILE SAVE=my_skew_profile\n"
#~ msgstr ""

#~ msgid ""
#~ "After this command you will be prompted to issue a `SAVE_CONFIG` gcode to "
#~ "save the profile to persistent storage. If no profile is named "
#~ "`my_skew_profile` then a new profile will be created. If the named profile "
#~ "exists it will be overwritten."
#~ msgstr ""

#~ msgid "Once you have a saved profile, you may load it:"
#~ msgstr ""

#~ msgid "SKEW_PROFILE LOAD=my_skew_profile\n"
#~ msgstr ""

#~ msgid "It is also possible to remove an old or out of date profile:"
#~ msgstr ""

#~ msgid "SKEW_PROFILE REMOVE=my_skew_profile\n"
#~ msgstr ""

#~ msgid ""
#~ "After removing a profile you will be prompted to issue a `SAVE_CONFIG` to "
#~ "make this change persist."
#~ msgstr ""

#~ msgid "Verifying your correction"
#~ msgstr ""

#~ msgid ""
#~ "After skew_correction has been configured you may reprint the calibration "
#~ "part with correction enabled. Use the following gcode to check your skew on "
#~ "each plane. The results should be lower than those reported via "
#~ "`GET_CURRENT_SKEW`."
#~ msgstr ""

#~ msgid "CALC_MEASURED_SKEW AC=<ac_length> BD=<bd_length> AD=<ad_length>\n"
#~ msgstr ""

#~ msgid ""
#~ "Due to the nature of skew correction it is recommended to configure skew in "
#~ "your start gcode, after homing and any kind of movement that travels near "
#~ "the edge of the print area such as a purge or nozzle wipe. You may use use "
#~ "the `SET_SKEW` or `SKEW_PROFILE` gcodes to accomplish this. It is also "
#~ "recommended to issue a `SET_SKEW CLEAR=1` in your end gcode."
#~ msgstr ""

#~ msgid ""
#~ "Keep in mind that it is possible for `[skew_correction]` to generate a "
#~ "correction that moves the tool beyond the printer's boundaries on the X "
#~ "and/or Y axes. It is recommended to arrange parts away from the edges when "
#~ "using `[skew_correction]`."
#~ msgstr ""

#~ msgid "SDCard updates"
#~ msgstr ""

#~ msgid ""
#~ "Many of today's popular controller boards ship with a bootloader capable of "
#~ "updating firmware via SD Card. While this is convenient in many "
#~ "circumstances, these bootloaders typically provide no other way to update "
#~ "firmware. This can be a nuisance if your board is mounted in a location that"
#~ " is difficult to access or if you need to update firmware often. After "
#~ "Klipper has been initially flashed to a controller it is possible to "
#~ "transfer new firmware to the SD Card and initiate the flashing procedure via"
#~ " ssh."
#~ msgstr ""

#~ msgid "Typical Upgrade Procedure"
#~ msgstr ""

#~ msgid ""
#~ "The procedure for updating MCU firmware using the SD Card is similar to that"
#~ " of other methods. Instead of using `make flash` it is necessary to run a "
#~ "helper script, `flash-sdcard.sh`. Updating a BigTreeTech SKR 1.3 might look "
#~ "like the following:"
#~ msgstr ""

#~ msgid ""
#~ "sudo service klipper stop\n"
#~ "cd ~/klipper\n"
#~ "git pull\n"
#~ "make clean\n"
#~ "make menuconfig\n"
#~ "make\n"
#~ "./scripts/flash-sdcard.sh /dev/ttyACM0 btt-skr-v1.3\n"
#~ "sudo service klipper start\n"
#~ msgstr ""

#~ msgid ""
#~ "It is up to the user to determine the device location and board name. If a "
#~ "user needs to flash multiple boards, `flash-sdcard.sh` (or `make flash` if "
#~ "appropriate) should be run for each board prior to restarting the Klipper "
#~ "service."
#~ msgstr ""

#~ msgid "Supported boards can be listed with the following command:"
#~ msgstr ""

#~ msgid "./scripts/flash-sdcard.sh -l\n"
#~ msgstr ""

#~ msgid ""
#~ "If you do not see your board listed it may be necessary to add a new board "
#~ "definition as [described below](#board-definitions)."
#~ msgstr ""

#~ msgid "Advanced Usage"
#~ msgstr ""

#~ msgid ""
#~ "The above commands assume that your MCU connects at the default baud rate of"
#~ " 250000 and the firmware is located at `~/klipper/out/klipper.bin`. The "
#~ "`flash-sdcard.sh` script provides options for changing these defaults. All "
#~ "options can be viewed by the help screen:"
#~ msgstr ""

#~ msgid ""
#~ "./scripts/flash-sdcard.sh -h\n"
#~ "SD Card upload utility for Klipper\n"
#~ "\n"
#~ "usage: flash_sdcard.sh [-h] [-l] [-c] [-b <baud>] [-f <firmware>]\n"
#~ "                       <device> <board>\n"
#~ "\n"
#~ "positional arguments:\n"
#~ "  <device>        device serial port\n"
#~ "  <board>         board type\n"
#~ "\n"
#~ "optional arguments:\n"
#~ "  -h              show this message\n"
#~ "  -l              list available boards\n"
#~ "  -c              run flash check/verify only (skip upload)\n"
#~ "  -b <baud>       serial baud rate (default is 250000)\n"
#~ "  -f <firmware>   path to klipper.bin\n"
#~ msgstr ""

#~ msgid ""
#~ "If your board is flashed with firmware that connects at a custom baud rate "
#~ "it is possible to upgrade by specifying the `-b` option:"
#~ msgstr ""

#~ msgid "./scripts/flash-sdcard.sh -b 115200 /dev/ttyAMA0 btt-skr-v1.3\n"
#~ msgstr ""

#~ msgid ""
#~ "If you wish to flash a build of Klipper located somewhere other than the "
#~ "default location it can be done by specifying the `-f` option:"
#~ msgstr ""

#~ msgid ""
#~ "./scripts/flash-sdcard.sh -f ~/downloads/klipper.bin /dev/ttyAMA0 btt-"
#~ "skr-v1.3\n"
#~ msgstr ""

#~ msgid ""
#~ "Note that when upgrading a MKS Robin E3 it is not necessary to manually run "
#~ "`update_mks_robin.py` and supply the resulting binary to `flash-sdcard.sh`. "
#~ "This procedure is automated during the upload process."
#~ msgstr ""

#~ msgid ""
#~ "The `-c` option is used to perform a check or verify-only operation to test "
#~ "if the board is running the specified firmware correctly. This option is "
#~ "primarily intended for cases where a manual power-cycle is necessary to "
#~ "complete the flashing procedure, such as with bootloaders that use SDIO mode"
#~ " instead of SPI to access their SD Cards. (See Caveats below) But, it can "
#~ "also be used anytime to verify if the code flashed into the board matches "
#~ "the version in your build folder on any supported board."
#~ msgstr ""

#~ msgid ""
#~ "As mentioned in the introduction, this method only works for upgrading "
#~ "firmware. The initial flashing procedure must be done manually per the "
#~ "instructions that apply to your controller board."
#~ msgstr ""

#~ msgid ""
#~ "While it is possible to flash a build that changes the Serial Baud or "
#~ "connection interface (ie: from USB to UART), verification will always fail "
#~ "as the script will be unable to reconnect to the MCU to verify the current "
#~ "version."
#~ msgstr ""

#~ msgid ""
#~ "Only boards that use SPI for SD Card communication are supported. Boards "
#~ "that use SDIO, such as the Flymaker Flyboard and MKS Robin Nano V1/V2, will "
#~ "not work in SDIO mode. However, it's usually possible to flash such boards "
#~ "using Software SPI mode instead. But if the board's bootloader only uses "
#~ "SDIO mode to access the SD Card, a power-cycle of the board and SD Card will"
#~ " be necessary so that the mode can switch from SPI back to SDIO to complete "
#~ "reflashing. Such boards should be defined with `skip_verify` enabled to skip"
#~ " the verify step immediately after flashing. Then after the manual power-"
#~ "cycle, you can rerun the exact same `./scripts/flash-sdcard.sh` command, but"
#~ " add the `-c` option to complete the check/verify operation. See [Flashing "
#~ "Boards that use SDIO](#flashing-boards-that-use-sdio) for examples."
#~ msgstr ""

#~ msgid "Board Definitions"
#~ msgstr ""

#~ msgid ""
#~ "Most common boards should be available, however it is possible to add a new "
#~ "board definition if necessary. Board definitions are located in "
#~ "`~/klipper/scripts/spi_flash/board_defs.py`. The definitions are stored in "
#~ "dictionary, for example:"
#~ msgstr ""

#~ msgid ""
#~ "BOARD_DEFS = {\n"
#~ "    'generic-lpc1768': {\n"
#~ "        'mcu': \"lpc1768\",\n"
#~ "        'spi_bus': \"ssp1\",\n"
#~ "        \"cs_pin\": \"P0.6\"\n"
#~ "    },\n"
#~ "    ...<further definitions>\n"
#~ "}\n"
#~ msgstr ""

#~ msgid "The following fields may be specified:"
#~ msgstr ""

#~ msgid ""
#~ "`mcu`: The mcu type. This can be retrevied after configuring the build via "
#~ "`make menuconfig` by running `cat .config | grep CONFIG_MCU`. This field is "
#~ "required."
#~ msgstr ""

#~ msgid ""
#~ "`spi_bus`: The SPI bus connected to the SD Card. This should be retreived "
#~ "from the board's schematic. This field is required."
#~ msgstr ""

#~ msgid ""
#~ "`cs_pin`: The Chip Select Pin connected to the SD Card. This should be "
#~ "retreived from the board schematic. This field is required."
#~ msgstr ""

#~ msgid ""
#~ "`firmware_path`: The path on the SD Card where firmware should be "
#~ "transferred. The default is `firmware.bin`."
#~ msgstr ""

#~ msgid ""
#~ "`current_firmware_path`: The path on the SD Card where the renamed firmware "
#~ "file is located after a successful flash. The default is `firmware.cur`."
#~ msgstr ""

#~ msgid ""
#~ "`skip_verify`: This defines a boolean value which tells the scripts to skip "
#~ "the firmware verification step during the flashing process. The default is "
#~ "`False`. It can be set to `True` for boards that require a manual power-"
#~ "cycle to complete flashing. To verify the firmware afterward, run the script"
#~ " again with the `-c` option to perform the verification step. [See caveats "
#~ "with SDIO cards](#caveats)"
#~ msgstr ""

#~ msgid ""
#~ "If software SPI is required, the `spi_bus` field should be set to `swspi` "
#~ "and the following additional field should be specified:"
#~ msgstr ""

#~ msgid ""
#~ "`spi_pins`: This should be 3 comma separated pins that are connected to the "
#~ "SD Card in the format of `miso,mosi,sclk`."
#~ msgstr ""

#~ msgid ""
#~ "It should be exceedingly rare that Software SPI is necessary, typically only"
#~ " boards with design errors or boards that normally only support SDIO mode "
#~ "for their SD Card will require it. The `btt-skr-pro` board definition "
#~ "provides an example of the former, and the `btt-octopus-f446-v1` board "
#~ "definition provides an example of the latter."
#~ msgstr ""

#~ msgid ""
#~ "Prior to creating a new board definition one should check to see if an "
#~ "existing board definition meets the criteria necessary for the new board. If"
#~ " this is the case, a `BOARD_ALIAS` may be specified. For example, the "
#~ "following alias may be added to specify `my-new-board` as an alias for "
#~ "`generic-lpc1768`:"
#~ msgstr ""

#~ msgid ""
#~ "BOARD_ALIASES = {\n"
#~ "    ...<previous aliases>,\n"
#~ "    'my-new-board': BOARD_DEFS['generic-lpc1768'],\n"
#~ "}\n"
#~ msgstr ""

#~ msgid ""
#~ "If you need a new board definition and you are uncomfortable with the "
#~ "procedure outlined above it is recommended that you request one in the "
#~ "[Klipper Community Discord](Contact.md#discord)."
#~ msgstr ""

#~ msgid "Flashing Boards that use SDIO"
#~ msgstr ""

#~ msgid ""
#~ "[As mentioned in the Caveats](#caveats), boards whose bootloader uses SDIO "
#~ "mode to access their SD Card require a power-cycle of the board, and "
#~ "specifically the SD Card itself, in order to switch from the SPI Mode used "
#~ "while writing the file to the SD Card back to SDIO mode for the bootloader "
#~ "to flash it into the board. These board definitions will use the "
#~ "`skip_verify` flag, which tells the flashing tool to stop after writing the "
#~ "firmware to the SD Card so that the board can be manually power-cycled and "
#~ "the verification step deferred until that's complete."
#~ msgstr ""

#~ msgid ""
#~ "There are two scenarios -- one with the RPi Host running on a separate power"
#~ " supply and the other when the RPi Host is running on the same power supply "
#~ "as the main board being flashed. The difference is whether or not it's "
#~ "necessary to also shutdown the RPi and then `ssh` again after the flashing "
#~ "is complete in order to do the verification step, or if the verification can"
#~ " be done immediately. Here's examples of the two scenarios:"
#~ msgstr ""

#~ msgid "SDIO Programming with RPi on Separate Power Supply"
#~ msgstr ""

#~ msgid ""
#~ "A typical session with the RPi on a Separate Power Supply looks like the "
#~ "following. You will, of course, need to use your proper device path and "
#~ "board name:"
#~ msgstr ""

#~ msgid ""
#~ "sudo service klipper stop\n"
#~ "cd ~/klipper\n"
#~ "git pull\n"
#~ "make clean\n"
#~ "make menuconfig\n"
#~ "make\n"
#~ "./scripts/flash-sdcard.sh /dev/ttyACM0 btt-octopus-f446-v1\n"
#~ "[[[manually power-cycle the printer board here when instructed]]]\n"
#~ "./scripts/flash-sdcard.sh -c /dev/ttyACM0 btt-octopus-f446-v1\n"
#~ "sudo service klipper start\n"
#~ msgstr ""

#~ msgid "SDIO Programming with RPi on the Same Power Supply"
#~ msgstr ""

#~ msgid ""
#~ "A typical session with the RPi on the Same Power Supply looks like the "
#~ "following. You will, of course, need to use your proper device path and "
#~ "board name:"
#~ msgstr ""

#~ msgid ""
#~ "sudo service klipper stop\n"
#~ "cd ~/klipper\n"
#~ "git pull\n"
#~ "make clean\n"
#~ "make menuconfig\n"
#~ "make\n"
#~ "./scripts/flash-sdcard.sh /dev/ttyACM0 btt-octopus-f446-v1\n"
#~ "sudo shutdown -h now\n"
#~ "[[[wait for the RPi to shutdown, then power-cycle and ssh again to the RPi when it restarts]]]\n"
#~ "sudo service klipper stop\n"
#~ "cd ~/klipper\n"
#~ "./scripts/flash-sdcard.sh -c /dev/ttyACM0 btt-octopus-f446-v1\n"
#~ "sudo service klipper start\n"
#~ msgstr ""

#~ msgid ""
#~ "In this case, since the RPi Host is being restarted, which will restart the "
#~ "`klipper` service, it's necessary to stop `klipper` again before doing the "
#~ "verification step and restart it after verification is complete."
#~ msgstr ""

#~ msgid "SDIO to SPI Pin Mapping"
#~ msgstr ""

#~ msgid ""
#~ "If your board's schematic uses SDIO for its SD Card, you can map the pins as"
#~ " described in the chart below to determine the compatible Software SPI pins "
#~ "to assign in the `board_defs.py` file:"
#~ msgstr ""

#~ msgid "SD Card Pin"
#~ msgstr ""

#~ msgid "Micro SD Card Pin"
#~ msgstr ""

#~ msgid "SDIO Pin Name"
#~ msgstr ""

#~ msgid "SPI Pin Name"
#~ msgstr ""

#~ msgid "9"
#~ msgstr ""

#~ msgid "1"
#~ msgstr ""

#~ msgid "DATA2"
#~ msgstr ""

#~ msgid "None (PU)*"
#~ msgstr ""

#~ msgid "2"
#~ msgstr ""

#~ msgid "CD/DATA3"
#~ msgstr ""

#~ msgid "CS"
#~ msgstr ""

#~ msgid "3"
#~ msgstr ""

#~ msgid "CMD"
#~ msgstr ""

#~ msgid "MOSI"
#~ msgstr ""

#~ msgid "4"
#~ msgstr ""

#~ msgid "+3.3V (VDD)"
#~ msgstr ""

#~ msgid "5"
#~ msgstr ""

#~ msgid "CLK"
#~ msgstr ""

#~ msgid "SCLK"
#~ msgstr ""

#~ msgid "6"
#~ msgstr ""

#~ msgid "GND (VSS)"
#~ msgstr ""

#~ msgid "7"
#~ msgstr ""

#~ msgid "DATA0"
#~ msgstr ""

#~ msgid "MISO"
#~ msgstr ""

#~ msgid "8"
#~ msgstr ""

#~ msgid "DATA1"
#~ msgstr ""

#~ msgid "N/A"
#~ msgstr ""

#~ msgid "Card Detect (CD)"
#~ msgstr ""

#~ msgid "10"
#~ msgstr ""

#~ msgid "GND"
#~ msgstr ""

#~ msgid "\\* None (PU) indicates an unused pin with a pull-up resistor"
#~ msgstr ""

#~ msgid "Rotation distance"
#~ msgstr ""

#~ msgid ""
#~ "Stepper motor drivers on Klipper require a `rotation_distance` parameter in "
#~ "each [stepper config section](Config_Reference.md#stepper). The "
#~ "`rotation_distance` is the amount of distance that the axis moves with one "
#~ "full revolution of the stepper motor. This document describes how one can "
#~ "configure this value."
#~ msgstr ""

#~ msgid "Obtaining rotation_distance from steps_per_mm (or step_distance)"
#~ msgstr ""

#~ msgid ""
#~ "The designers of your 3d printer originally calculated `steps_per_mm` from a"
#~ " rotation distance. If you know the steps_per_mm then it is possible to use "
#~ "this general formula to obtain that original rotation distance:"
#~ msgstr ""

#~ msgid ""
#~ "rotation_distance = <full_steps_per_rotation> * <microsteps> / "
#~ "<steps_per_mm>\n"
#~ msgstr ""

#~ msgid ""
#~ "Or, if you have an older Klipper configuration and know the `step_distance` "
#~ "parameter you can use this formula:"
#~ msgstr ""

#~ msgid ""
#~ "rotation_distance = <full_steps_per_rotation> * <microsteps> * "
#~ "<step_distance>\n"
#~ msgstr ""

#~ msgid ""
#~ "The `<full_steps_per_rotation>` setting is determined from the type of "
#~ "stepper motor. Most stepper motors are \"1.8 degree steppers\" and therefore"
#~ " have 200 full steps per rotation (360 divided by 1.8 is 200). Some stepper "
#~ "motors are \"0.9 degree steppers\" and thus have 400 full steps per "
#~ "rotation. Other stepper motors are rare. If unsure, do not set "
#~ "full_steps_per_rotation in the config file and use 200 in the formula above."
#~ msgstr ""

#~ msgid ""
#~ "The `<microsteps>` setting is determined by the stepper motor driver. Most "
#~ "drivers use 16 microsteps. If unsure, set `microsteps: 16` in the config and"
#~ " use 16 in the formula above."
#~ msgstr ""

#~ msgid ""
#~ "Almost all printers should have a whole number for `rotation_distance` on X,"
#~ " Y, and Z type axes. If the above formula results in a rotation_distance "
#~ "that is within .01 of a whole number then round the final value to that "
#~ "whole_number."
#~ msgstr ""

#~ msgid "Calibrating rotation_distance on extruders"
#~ msgstr ""

#~ msgid ""
#~ "On an extruder, the `rotation_distance` is the amount of distance the "
#~ "filament travels for one full rotation of the stepper motor. The best way to"
#~ " get an accurate value for this setting is to use a \"measure and trim\" "
#~ "procedure."
#~ msgstr ""

#~ msgid ""
#~ "First start with an initial guess for the rotation distance. This may be "
#~ "obtained from [steps_per_mm](#obtaining-rotation_distance-from-steps_per_mm-"
#~ "or-step_distance) or by [inspecting the hardware](#extruder)."
#~ msgstr ""

#~ msgid "Then use the following procedure to \"measure and trim\":"
#~ msgstr ""

#~ msgid ""
#~ "Make sure the extruder has filament in it, the hotend is heated to an "
#~ "appropriate temperature, and the printer is ready to extrude."
#~ msgstr ""

#~ msgid ""
#~ "Use a marker to place a mark on the filament around 70mm from the intake of "
#~ "the extruder body. Then use a digital calipers to measure the actual "
#~ "distance of that mark as precisely as one can. Note this as "
#~ "`<initial_mark_distance>`."
#~ msgstr ""

#~ msgid ""
#~ "Extrude 50mm of filament with the following command sequence: `G91` followed"
#~ " by `G1 E50 F60`. Note 50mm as `<requested_extrude_distance>`. Wait for the "
#~ "extruder to finish the move (it will take about 50 seconds). It is important"
#~ " to use the slow extrusion rate for this test as a faster rate can cause "
#~ "high pressure in the extruder which will skew the results. (Do not use the "
#~ "\"extrude button\" on graphical front-ends for this test as they extrude at "
#~ "a fast rate.)"
#~ msgstr ""

#~ msgid ""
#~ "Use the digital calipers to measure the new distance between the extruder "
#~ "body and the mark on the filament. Note this as "
#~ "`<subsequent_mark_distance>`. Then calculate: `actual_extrude_distance = "
#~ "<initial_mark_distance> - <subsequent_mark_distance>`"
#~ msgstr ""

#~ msgid ""
#~ "Calculate rotation_distance as: `rotation_distance = "
#~ "<previous_rotation_distance> * <actual_extrude_distance> / "
#~ "<requested_extrude_distance>` Round the new rotation_distance to three "
#~ "decimal places."
#~ msgstr ""

#~ msgid ""
#~ "If the actual_extrude_distance differs from requested_extrude_distance by "
#~ "more than about 2mm then it is a good idea to perform the steps above a "
#~ "second time."
#~ msgstr ""

#~ msgid ""
#~ "Note: Do *not* use a \"measure and trim\" type of method to calibrate x, y, "
#~ "or z type axes. The \"measure and trim\" method is not accurate enough for "
#~ "those axes and will likely lead to a worse configuration. Instead, if "
#~ "needed, those axes can be determined by [measuring the belts, pulleys, and "
#~ "lead screw hardware](#obtaining-rotation_distance-by-inspecting-the-"
#~ "hardware)."
#~ msgstr ""

#~ msgid "Obtaining rotation_distance by inspecting the hardware"
#~ msgstr ""

#~ msgid ""
#~ "It's possible to calculate rotation_distance with knowledge of the stepper "
#~ "motors and printer kinematics. This may be useful if the steps_per_mm is not"
#~ " known or if designing a new printer."
#~ msgstr ""

#~ msgid "Belt driven axes"
#~ msgstr ""

#~ msgid ""
#~ "It is easy to calculate rotation_distance for a linear axis that uses a belt"
#~ " and pulley."
#~ msgstr ""

#~ msgid ""
#~ "First determine the type of belt. Most printers use a 2mm belt pitch (that "
#~ "is, each tooth on the belt is 2mm apart). Then count the number of teeth on "
#~ "the stepper motor pulley. The rotation_distance is then calculated as:"
#~ msgstr ""

#~ msgid "rotation_distance = <belt_pitch> * <number_of_teeth_on_pulley>\n"
#~ msgstr ""

#~ msgid ""
#~ "For example, if a printer has a 2mm belt and uses a pulley with 20 teeth, "
#~ "then the rotation distance is 40."
#~ msgstr ""

#~ msgid "Axes with a lead screw"
#~ msgstr ""

#~ msgid ""
#~ "It is easy to calculate the rotation_distance for common lead screws using "
#~ "the following formula:"
#~ msgstr ""

#~ msgid "rotation_distance = <screw_pitch> * <number_of_separate_threads>\n"
#~ msgstr ""

#~ msgid ""
#~ "For example, the common \"T8 leadscrew\" has a rotation distance of 8 (it "
#~ "has a pitch of 2mm and has 4 separate threads)."
#~ msgstr ""

#~ msgid ""
#~ "Older printers with \"threaded rods\" have only one \"thread\" on the lead "
#~ "screw and thus the rotation distance is the pitch of the screw. (The screw "
#~ "pitch is the distance between each groove on the screw.) So, for example, an"
#~ " M6 metric rod has a rotation distance of 1 and an M8 rod has a rotation "
#~ "distance of 1.25."
#~ msgstr ""

#~ msgid "Extruder"
#~ msgstr ""

#~ msgid ""
#~ "It's possible to obtain an initial rotation distance for extruders by "
#~ "measuring the diameter of the \"hobbed bolt\" that pushes the filament and "
#~ "using the following formula: `rotation_distance = <diameter> * 3.14`"
#~ msgstr ""

#~ msgid ""
#~ "If the extruder uses gears then it will also be necessary to [determine and "
#~ "set the gear_ratio](#using-a-gear_ratio) for the extruder."
#~ msgstr ""

#~ msgid ""
#~ "The actual rotation distance on an extruder will vary from printer to "
#~ "printer, because the grip of the \"hobbed bolt\" that engages the filament "
#~ "can vary. It can even vary between filament spools. After obtaining an "
#~ "initial rotation_distance, use the [measure and trim "
#~ "procedure](#calibrating-rotation_distance-on-extruders) to obtain a more "
#~ "accurate setting."
#~ msgstr ""

#~ msgid "Using a gear_ratio"
#~ msgstr ""

#~ msgid ""
#~ "Setting a `gear_ratio` can make it easier to configure the "
#~ "`rotation_distance` on steppers that have a gear box (or similar) attached "
#~ "to it. Most steppers do not have a gear box - if unsure then do not set "
#~ "`gear_ratio` in the config."
#~ msgstr ""

#~ msgid ""
#~ "When `gear_ratio` is set, the `rotation_distance` represents the distance "
#~ "the axis moves with one full rotation of the final gear on the gear box. If,"
#~ " for example, one is using a gearbox with a \"5:1\" ratio, then one could "
#~ "calculate the rotation_distance with [knowledge of the hardware](#obtaining-"
#~ "rotation_distance-by-inspecting-the-hardware) and then add `gear_ratio: 5:1`"
#~ " to the config."
#~ msgstr ""

#~ msgid ""
#~ "For gearing implemented with belts and pulleys, it is possible to determine "
#~ "the gear_ratio by counting the teeth on the pulleys. For example, if a "
#~ "stepper with a 16 toothed pulley drives the next pulley with 80 teeth then "
#~ "one would use `gear_ratio: 80:16`. Indeed, one could open a common off the "
#~ "shelf \"gear box\" and count the teeth in it to confirm its gear ratio."
#~ msgstr ""

#~ msgid ""
#~ "Note that sometimes a gearbox will have a slightly different gear ratio than"
#~ " what it is advertised as. The common BMG extruder motor gears are an "
#~ "example of this - they are advertised as \"3:1\" but actually use \"50:17\" "
#~ "gearing. (Using teeth numbers without a common denominator may improve "
#~ "overall gear wear as the teeth don't always mesh the same way with each "
#~ "revolution.) The common \"5.18:1 planetary gearbox\", is more accurately "
#~ "configured with `gear_ratio: 57:11`."
#~ msgstr ""

#~ msgid ""
#~ "If several gears are used on an axis then it is possible to provide a comma "
#~ "separated list to gear_ratio. For example, a \"5:1\" gear box driving a 16 "
#~ "toothed to 80 toothed pulley could use `gear_ratio: 5:1, 80:16`."
#~ msgstr ""

#~ msgid ""
#~ "In most cases, gear_ratio should be defined with whole numbers as common "
#~ "gears and pulleys have a whole number of teeth on them. However, in cases "
#~ "where a belt drives a pulley using friction instead of teeth, it may make "
#~ "sense to use a floating point number in the gear ratio (eg, `gear_ratio: "
#~ "107.237:16`)."
#~ msgstr ""

#~ msgid "Resonance Compensation"
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports Input Shaping - a technique that can be used to reduce "
#~ "ringing (also known as echoing, ghosting or rippling) in prints. Ringing is "
#~ "a surface printing defect when, typically, elements like edges repeat "
#~ "themselves on a printed surface as a subtle 'echo':"
#~ msgstr ""

#~ msgid ""
#~ "|![Ringing test](img/ringing-test.jpg)|![3D "
#~ "Benchy](img/ringing-3dbenchy.jpg)|"
#~ msgstr ""

#~ msgid ""
#~ "Ringing is caused by mechanical vibrations in the printer due to quick "
#~ "changes of the printing direction. Note that ringing usually has mechanical "
#~ "origins: insufficiently rigid printer frame, non-tight or too springy belts,"
#~ " alignment issues of mechanical parts, heavy moving mass, etc. Those should "
#~ "be checked and fixed first, if possible."
#~ msgstr ""

#~ msgid ""
#~ "[Input shaping](https://en.wikipedia.org/wiki/Input_shaping) is an open-loop"
#~ " control technique which creates a commanding signal that cancels its own "
#~ "vibrations. Input shaping requires some tuning and measurements before it "
#~ "can be enabled. Besides ringing, Input Shaping typically reduces the "
#~ "vibrations and shaking of the printer in general, and may also improve the "
#~ "reliability of the stealthChop mode of Trinamic stepper drivers."
#~ msgstr ""

#~ msgid ""
#~ "Basic tuning requires measuring the ringing frequencies of the printer by "
#~ "printing a test model."
#~ msgstr ""

#~ msgid ""
#~ "Slice the ringing test model, which can be found in "
#~ "[docs/prints/ringing_tower.stl](prints/ringing_tower.stl), in the slicer:"
#~ msgstr ""

#~ msgid "Suggested layer height is 0.2 or 0.25 mm."
#~ msgstr ""

#~ msgid "Infill and top layers can be set to 0."
#~ msgstr ""

#~ msgid ""
#~ "Use 1-2 perimeters, or even better the smooth vase mode with 1-2 mm base."
#~ msgstr ""

#~ msgid ""
#~ "Use sufficiently high speed, around 80-100 mm/sec, for **external** "
#~ "perimeters."
#~ msgstr ""

#~ msgid "Make sure that the minimum layer time is **at most** 3 seconds."
#~ msgstr ""

#~ msgid "Make sure any \"dynamic acceleration control\" is disabled in the slicer."
#~ msgstr ""

#~ msgid ""
#~ "Do not turn the model. The model has X and Y marks at the back of the model."
#~ " Note the unusual location of the marks vs. the axes of the printer - it is "
#~ "not a mistake. The marks can be used later in the tuning process as a "
#~ "reference, because they show which axis the measurements correspond to."
#~ msgstr ""

#~ msgid "Ringing frequency"
#~ msgstr ""

#~ msgid "First, measure the **ringing frequency**."
#~ msgstr ""

#~ msgid ""
#~ "If `square_corner_velocity` parameter was changed, revert it back to 5.0. It"
#~ " is not advised to increase it when using input shaper because it can cause "
#~ "more smoothing in parts - it is better to use higher acceleration value "
#~ "instead."
#~ msgstr ""

#~ msgid ""
#~ "Increase `max_accel_to_decel` by issuing the following command: "
#~ "`SET_VELOCITY_LIMIT ACCEL_TO_DECEL=7000`"
#~ msgstr ""

#~ msgid "Disable Pressure Advance: `SET_PRESSURE_ADVANCE ADVANCE=0`"
#~ msgstr ""

#~ msgid ""
#~ "If you have already added `[input_shaper]` section to the printer.cfg, "
#~ "execute `SET_INPUT_SHAPER SHAPER_FREQ_X=0 SHAPER_FREQ_Y=0` command. If you "
#~ "get \"Unknown command\" error, you can safely ignore it at this point and "
#~ "continue with the measurements."
#~ msgstr ""

#~ msgid ""
#~ "Execute the command: `TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT "
#~ "PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5` Basically, we try "
#~ "to make ringing more pronounced by setting different large values for "
#~ "acceleration. This command will increase the acceleration every 5 mm "
#~ "starting from 1500 mm/sec^2: 1500 mm/sec^2, 2000 mm/sec^2, 2500 mm/sec^2 and"
#~ " so forth up until 7000 mm/sec^2 at the last band."
#~ msgstr ""

#~ msgid "Print the test model sliced with the suggested parameters."
#~ msgstr ""

#~ msgid ""
#~ "You can stop the print earlier if the ringing is clearly visible and you see"
#~ " that acceleration gets too high for your printer (e.g. printer shakes too "
#~ "much or starts skipping steps)."
#~ msgstr ""

#~ msgid ""
#~ "Use X and Y marks at the back of the model for reference. The measurements "
#~ "from the side with X mark should be used for X axis *configuration*, and Y "
#~ "mark - for Y axis configuration. Measure the distance *D* (in mm) between "
#~ "several oscillations on the part with X mark, near the notches, preferably "
#~ "skipping the first oscillation or two. To measure the distance between "
#~ "oscillations more easily, mark the oscillations first, then measure the "
#~ "distance between the marks with a ruler or calipers:"
#~ msgstr ""

#~ msgid ""
#~ "|![Mark ringing](img/ringing-mark.jpg)|![Measure ringing](img/ringing-"
#~ "measure.jpg)|"
#~ msgstr ""

#~ msgid ""
#~ "Count how many oscillations *N* the measured distance *D* corresponds to. If"
#~ " you are unsure how to count the oscillations, refer to the picture above, "
#~ "which shows *N* = 6 oscillations."
#~ msgstr ""

#~ msgid ""
#~ "Compute the ringing frequency of X axis as *V* &middot; *N* / *D* (Hz), "
#~ "where *V* is the velocity for outer perimeters (mm/sec). For the example "
#~ "above, we marked 6 oscillations, and the test was printed at 100 mm/sec "
#~ "velocity, so the frequency is 100 * 6 / 12.14  49.4 Hz."
#~ msgstr ""

#~ msgid "Do (8) - (10) for Y mark as well."
#~ msgstr ""

#~ msgid ""
#~ "Note that ringing on the test print should follow the pattern of the curved "
#~ "notches, as in the picture above. If it doesn't, then this defect is not "
#~ "really a ringing and has a different origin - either mechanical, or an "
#~ "extruder issue. It should be fixed first before enabling and tuning input "
#~ "shapers."
#~ msgstr ""

#~ msgid ""
#~ "If the measurements are not reliable because, say, the distance between the "
#~ "oscillations is not stable, it might mean that the printer has several "
#~ "resonance frequencies on the same axis. One may try to follow the tuning "
#~ "process described in [Unreliable measurements of ringing "
#~ "frequencies](#unreliable-measurements-of-ringing-frequencies) section "
#~ "instead and still get something out of the input shaping technique."
#~ msgstr ""

#~ msgid ""
#~ "Ringing frequency can depend on the position of the model within the "
#~ "buildplate and Z height, *especially on delta printers*; you can check if "
#~ "you see the differences in frequencies at different positions along the "
#~ "sides of the test model and at different heights. You can calculate the "
#~ "average ringing frequencies over X and Y axes if that is the case."
#~ msgstr ""

#~ msgid ""
#~ "If the measured ringing frequency is very low (below approx 20-25 Hz), it "
#~ "might be a good idea to invest into stiffening the printer or decreasing the"
#~ " moving mass - depending on what is applicable in your case - before "
#~ "proceeding with further input shaping tuning, and re-measuring the "
#~ "frequencies afterwards. For many popular printer models there are often some"
#~ " solutions available already."
#~ msgstr ""

#~ msgid ""
#~ "Note that the ringing frequencies can change if the changes are made to the "
#~ "printer that affect the moving mass or change the stiffness of the system, "
#~ "for example:"
#~ msgstr ""

#~ msgid ""
#~ "Some tools are installed, removed or replaced on the toolhead that change "
#~ "its mass, e.g. a new (heavier or lighter) stepper motor for direct extruder "
#~ "or a new hotend is installed, heavy fan with a duct is added, etc."
#~ msgstr ""

#~ msgid "Belts are tightened."
#~ msgstr ""

#~ msgid "Some addons to increase frame rigidity are installed."
#~ msgstr ""

#~ msgid ""
#~ "Different bed is installed on a bed-slinger printer, or glass added, etc."
#~ msgstr ""

#~ msgid ""
#~ "If such changes are made, it is a good idea to at least measure the ringing "
#~ "frequencies to see if they have changed."
#~ msgstr ""

#~ msgid "Input shaper configuration"
#~ msgstr ""

#~ msgid ""
#~ "After the ringing frequencies for X and Y axes are measured, you can add the"
#~ " following section to your `printer.cfg`:"
#~ msgstr ""

#~ msgid ""
#~ "[input_shaper]\n"
#~ "shaper_freq_x: ...  # frequency for the X mark of the test model\n"
#~ "shaper_freq_y: ...  # frequency for the Y mark of the test model\n"
#~ msgstr ""

#~ msgid "For the example above, we get shaper_freq_x/y = 49.4."
#~ msgstr ""

#~ msgid "Choosing input shaper"
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports several input shapers. They differ in their sensitivity to "
#~ "errors determining the resonance frequency and how much smoothing they cause"
#~ " in the printed parts. Also, some of the shapers like 2HUMP_EI and 3HUMP_EI "
#~ "should usually not be used with shaper_freq = resonance frequency - they are"
#~ " configured from different considerations to reduce several resonances at "
#~ "once."
#~ msgstr ""

#~ msgid ""
#~ "For most of the printers, either MZV or EI shapers can be recommended. This "
#~ "section describes a testing process to choose between them, and figure out a"
#~ " few other related parameters."
#~ msgstr ""

#~ msgid "Print the ringing test model as follows:"
#~ msgstr ""

#~ msgid "Restart the firmware: `RESTART`"
#~ msgstr ""

#~ msgid "Prepare for test: `SET_VELOCITY_LIMIT ACCEL_TO_DECEL=7000`"
#~ msgstr ""

#~ msgid "Execute: `SET_INPUT_SHAPER SHAPER_TYPE=MZV`"
#~ msgstr ""

#~ msgid ""
#~ "Execute the command: `TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT "
#~ "PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5`"
#~ msgstr ""

#~ msgid ""
#~ "If you see no ringing at this point, then MZV shaper can be recommended for "
#~ "use."
#~ msgstr ""

#~ msgid ""
#~ "If you do see some ringing, re-measure the frequencies using steps (8)-(10) "
#~ "described in [Ringing frequency](#ringing-frequency) section. If the "
#~ "frequencies differ significantly from the values you obtained earlier, a "
#~ "more complex input shaper configuration is needed. You can refer to "
#~ "Technical details of [Input shapers](#input-shapers) section. Otherwise, "
#~ "proceed to the next step."
#~ msgstr ""

#~ msgid ""
#~ "Now try EI input shaper. To try it, repeat steps (1)-(6) from above, but "
#~ "executing at step 4 the following command instead: `SET_INPUT_SHAPER "
#~ "SHAPER_TYPE=EI`."
#~ msgstr ""

#~ msgid ""
#~ "Compare two prints with MZV and EI input shaper. If EI shows noticeably "
#~ "better results than MZV, use EI shaper, otherwise prefer MZV. Note that EI "
#~ "shaper will cause more smoothing in printed parts (see the next section for "
#~ "further details). Add `shaper_type: mzv` (or ei) parameter to [input_shaper]"
#~ " section, e.g.:"
#~ msgstr ""

#~ msgid ""
#~ "[input_shaper]\n"
#~ "shaper_freq_x: ...\n"
#~ "shaper_freq_y: ...\n"
#~ "shaper_type: mzv\n"
#~ msgstr ""

#~ msgid "A few notes on shaper selection:"
#~ msgstr ""

#~ msgid ""
#~ "EI shaper may be more suited for bed slinger printers (if the resonance "
#~ "frequency and resulting smoothing allows): as more filament is deposited on "
#~ "the moving bed, the mass of the bed increases and the resonance frequency "
#~ "will decrease. Since EI shaper is more robust to resonance frequency "
#~ "changes, it may work better when printing large parts."
#~ msgstr ""

#~ msgid ""
#~ "Due to the nature of delta kinematics, resonance frequencies can differ a "
#~ "lot in different parts of the build volume. Therefore, EI shaper can be a "
#~ "better fit for delta printers rather than MZV or ZV, and should be "
#~ "considered for the use. If the resonance frequency is sufficiently large "
#~ "(more than 50-60 Hz), then one can even attempt to test 2HUMP_EI shaper (by "
#~ "running the suggested test above with `SET_INPUT_SHAPER "
#~ "SHAPER_TYPE=2HUMP_EI`), but check the considerations in the [section "
#~ "below](#selecting-max_accel) before enabling it."
#~ msgstr ""

#~ msgid "Selecting max_accel"
#~ msgstr ""

#~ msgid ""
#~ "You should have a printed test for the shaper you chose from the previous "
#~ "step (if you don't, print the test model sliced with the [suggested "
#~ "parameters](#tuning) with the pressure advance disabled "
#~ "`SET_PRESSURE_ADVANCE ADVANCE=0` and with the tuning tower enabled as "
#~ "`TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 "
#~ "STEP_DELTA=500 STEP_HEIGHT=5`). Note that at very high accelerations, "
#~ "depending on the resonance frequency and the input shaper you chose (e.g. EI"
#~ " shaper creates more smoothing than MZV), input shaping may cause too much "
#~ "smoothing and rounding of the parts. So, max_accel should be chosen such as "
#~ "to prevent that. Another parameter that can impact smoothing is "
#~ "`square_corner_velocity`, so it is not advisable to increase it above the "
#~ "default 5 mm/sec to prevent increased smoothing."
#~ msgstr ""

#~ msgid ""
#~ "In order to select a suitable max_accel value, inspect the model for the "
#~ "chosen input shaper. First, take a note at which acceleration ringing is "
#~ "still small - that you are comfortable with it."
#~ msgstr ""

#~ msgid ""
#~ "Next, check the smoothing. To help with that, the test model has a small gap"
#~ " in the wall (0.15 mm):"
#~ msgstr ""

#~ msgid "![Test gap](img/smoothing-test.png)"
#~ msgstr ""

#~ msgid ""
#~ "As the acceleration increases, so does the smoothing, and the actual gap in "
#~ "the print widens:"
#~ msgstr ""

#~ msgid "![Shaper smoothing](img/shaper-smoothing.jpg)"
#~ msgstr ""

#~ msgid ""
#~ "In this picture, the acceleration increases left to right, and the gap "
#~ "starts to grow starting from 3500 mm/sec^2 (5-th band from the left). So the"
#~ " good value for max_accel = 3000 (mm/sec^2) in this case to avoid the "
#~ "excessive smoothing."
#~ msgstr ""

#~ msgid ""
#~ "Note the acceleration when the gap is still very small in your test print. "
#~ "If you see bulges, but no gap in the wall at all, even at high "
#~ "accelerations, it may be due to disabled Pressure Advance, especially on "
#~ "Bowden extruders. If that is the case, you may need to repeat the print with"
#~ " the PA enabled. It may also be a result of a miscalibrated (too high) "
#~ "filament flow, so it is a good idea to check that too."
#~ msgstr ""

#~ msgid ""
#~ "Choose the minimum out of the two acceleration values (from ringing and "
#~ "smoothing), and put it as `max_accel` into printer.cfg."
#~ msgstr ""

#~ msgid ""
#~ "As a note, it may happen - especially at low ringing frequencies - that EI "
#~ "shaper will cause too much smoothing even at lower accelerations. In this "
#~ "case, MZV may be a better choice, because it may allow higher acceleration "
#~ "values."
#~ msgstr ""

#~ msgid ""
#~ "At very low ringing frequencies (~25 Hz and below) even MZV shaper may "
#~ "create too much smoothing. If that is the case, you can also try to repeat "
#~ "the steps in [Choosing input shaper](#choosing-input-shaper) section with ZV"
#~ " shaper, by using `SET_INPUT_SHAPER SHAPER_TYPE=ZV` command instead. ZV "
#~ "shaper should show even less smoothing than MZV, but is more sensitive to "
#~ "errors in measuring the ringing frequencies."
#~ msgstr ""

#~ msgid ""
#~ "Another consideration is that if a resonance frequency is too low (below "
#~ "20-25 Hz), it might be a good idea to increase the printer stiffness or "
#~ "reduce the moving mass. Otherwise, acceleration and printing speed may be "
#~ "limited due too much smoothing now instead of ringing."
#~ msgstr ""

#~ msgid "Fine-tuning resonance frequencies"
#~ msgstr ""

#~ msgid ""
#~ "Note that the precision of the resonance frequencies measurements using the "
#~ "ringing test model is sufficient for most purposes, so further tuning is not"
#~ " advised. If you still want to try to double-check your results (e.g. if you"
#~ " still see some ringing after printing a test model with an input shaper of "
#~ "your choice with the same frequencies as you have measured earlier), you can"
#~ " follow the steps in this section. Note that if you see ringing at different"
#~ " frequencies after enabling [input_shaper], this section will not help with "
#~ "that."
#~ msgstr ""

#~ msgid ""
#~ "Assuming that you have sliced the ringing model with suggested parameters, "
#~ "complete the following steps for each of the axes X and Y:"
#~ msgstr ""

#~ msgid ""
#~ "Make sure Pressure Advance is disabled: `SET_PRESSURE_ADVANCE ADVANCE=0`"
#~ msgstr ""

#~ msgid "Execute: `SET_INPUT_SHAPER SHAPER_TYPE=ZV`"
#~ msgstr ""

#~ msgid ""
#~ "From the existing ringing test model with your chosen input shaper select "
#~ "the acceleration that shows ringing sufficiently well, and set it with: "
#~ "`SET_VELOCITY_LIMIT ACCEL=...`"
#~ msgstr ""

#~ msgid ""
#~ "Calculate the necessary parameters for the `TUNING_TOWER` command to tune "
#~ "`shaper_freq_x` parameter as follows: start = shaper_freq_x * 83 / 132 and "
#~ "factor = shaper_freq_x / 66, where `shaper_freq_x` here is the current value"
#~ " in `printer.cfg`."
#~ msgstr ""

#~ msgid ""
#~ "Execute the command: `TUNING_TOWER COMMAND=SET_INPUT_SHAPER "
#~ "PARAMETER=SHAPER_FREQ_X START=start FACTOR=factor BAND=5` using `start` and "
#~ "`factor` values calculated at step (5)."
#~ msgstr ""

#~ msgid "Print the test model."
#~ msgstr ""

#~ msgid ""
#~ "Reset the original frequency value: `SET_INPUT_SHAPER SHAPER_FREQ_X=...`."
#~ msgstr ""

#~ msgid ""
#~ "Find the band which shows ringing the least and count its number from the "
#~ "bottom starting at 1."
#~ msgstr ""

#~ msgid ""
#~ "Calculate the new shaper_freq_x value via old shaper_freq_x * (39 + 5 * "
#~ "#band-number) / 66."
#~ msgstr ""

#~ msgid ""
#~ "Repeat these steps for the Y axis in the same manner, replacing references "
#~ "to X axis with the axis Y (e.g. replace `shaper_freq_x` with `shaper_freq_y`"
#~ " in the formulae and in the `TUNING_TOWER` command)."
#~ msgstr ""

#~ msgid ""
#~ "As an example, let's assume you have had measured the ringing frequency for "
#~ "one of the axis equal to 45 Hz. This gives start = 45 * 83 / 132 = 28.30 and"
#~ " factor = 45 / 66 = 0.6818 values for `TUNING_TOWER` command. Now let's "
#~ "assume that after printing the test model, the fourth band from the bottom "
#~ "gives the least ringing. This gives the updated shaper_freq_? value equal to"
#~ " 45 * (39 + 5 * 4) / 66  40.23."
#~ msgstr ""

#~ msgid ""
#~ "After both new `shaper_freq_x` and `shaper_freq_y` parameters have been "
#~ "calculated, you can update `[input_shaper]` section in `printer.cfg` with "
#~ "the new `shaper_freq_x` and `shaper_freq_y` values."
#~ msgstr ""

#~ msgid "Pressure Advance"
#~ msgstr ""

#~ msgid ""
#~ "If you use Pressure Advance, it may need to be re-tuned. Follow the "
#~ "[instructions](Pressure_Advance.md#tuning-pressure-advance) to find the new "
#~ "value, if it differs from the previous one. Make sure to restart Klipper "
#~ "before tuning Pressure Advance."
#~ msgstr ""

#~ msgid "Unreliable measurements of ringing frequencies"
#~ msgstr ""

#~ msgid ""
#~ "If you are unable to measure the ringing frequencies, e.g. if the distance "
#~ "between the oscillations is not stable, you may still be able to take "
#~ "advantage of input shaping techniques, but the results may not be as good as"
#~ " with proper measurements of the frequencies, and will require a bit more "
#~ "tuning and printing the test model. Note that another possibility is to "
#~ "purchase and install an accelerometer and measure the resonances with it "
#~ "(refer to the [docs](Measuring_Resonances.md) describing the required "
#~ "hardware and the setup process) - but this option requires some crimping and"
#~ " soldering."
#~ msgstr ""

#~ msgid ""
#~ "For tuning, add empty `[input_shaper]` section to your `printer.cfg`. Then, "
#~ "assuming that you have sliced the ringing model with suggested parameters, "
#~ "print the test model 3 times as follows. First time, prior to printing, run"
#~ msgstr ""

#~ msgid "`RESTART`"
#~ msgstr ""

#~ msgid "`SET_VELOCITY_LIMIT ACCEL_TO_DECEL=7000`"
#~ msgstr ""

#~ msgid "`SET_PRESSURE_ADVANCE ADVANCE=0`"
#~ msgstr ""

#~ msgid ""
#~ "`SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=60 SHAPER_FREQ_Y=60`"
#~ msgstr ""

#~ msgid ""
#~ "`TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 "
#~ "STEP_DELTA=500 STEP_HEIGHT=5`"
#~ msgstr ""

#~ msgid ""
#~ "and print the model. Then print the model again, but before printing run "
#~ "instead"
#~ msgstr ""

#~ msgid ""
#~ "`SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=50 SHAPER_FREQ_Y=50`"
#~ msgstr ""

#~ msgid "Then print the model for the 3rd time, but now run"
#~ msgstr ""

#~ msgid ""
#~ "`SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=40 SHAPER_FREQ_Y=40`"
#~ msgstr ""

#~ msgid ""
#~ "Essentially, we are printing the ringing test model with TUNING_TOWER using "
#~ "2HUMP_EI shaper with shaper_freq = 60 Hz, 50 Hz, and 40 Hz."
#~ msgstr ""

#~ msgid ""
#~ "If none of the models demonstrate improvements in ringing, then, "
#~ "unfortunately, it does not look like the input shaping techniques can help "
#~ "with your case."
#~ msgstr ""

#~ msgid ""
#~ "Otherwise, it may be that all models show no ringing, or some show the "
#~ "ringing and some - not so much. Choose the test model with the highest "
#~ "frequency that still shows good improvements in ringing. For example, if 40 "
#~ "Hz and 50 Hz models show almost no ringing, and 60 Hz model already shows "
#~ "some more ringing, stick with 50 Hz."
#~ msgstr ""

#~ msgid ""
#~ "Now check if EI shaper would be good enough in your case. Choose EI shaper "
#~ "frequency based on the frequency of 2HUMP_EI shaper you chose:"
#~ msgstr ""

#~ msgid "For 2HUMP_EI 60 Hz shaper, use EI shaper with shaper_freq = 50 Hz."
#~ msgstr ""

#~ msgid "For 2HUMP_EI 50 Hz shaper, use EI shaper with shaper_freq = 40 Hz."
#~ msgstr ""

#~ msgid "For 2HUMP_EI 40 Hz shaper, use EI shaper with shaper_freq = 33 Hz."
#~ msgstr ""

#~ msgid "Now print the test model one more time, running"
#~ msgstr ""

#~ msgid "`SET_INPUT_SHAPER SHAPER_TYPE=EI SHAPER_FREQ_X=... SHAPER_FREQ_Y=...`"
#~ msgstr ""

#~ msgid ""
#~ "providing the shaper_freq_x=... and shaper_freq_y=... as determined "
#~ "previously."
#~ msgstr ""

#~ msgid ""
#~ "If EI shaper shows very comparable good results as 2HUMP_EI shaper, stick "
#~ "with EI shaper and the frequency determined earlier, otherwise use 2HUMP_EI "
#~ "shaper with the corresponding frequency. Add the results to `printer.cfg` "
#~ "as, e.g."
#~ msgstr ""

#~ msgid ""
#~ "[input_shaper]\n"
#~ "shaper_freq_x: 50\n"
#~ "shaper_freq_y: 50\n"
#~ "shaper_type: 2hump_ei\n"
#~ msgstr ""

#~ msgid ""
#~ "Continue the tuning with [Selecting max_accel](#selecting-max_accel) "
#~ "section."
#~ msgstr ""

#~ msgid "Troubleshooting and FAQ"
#~ msgstr ""

#~ msgid "I cannot get reliable measurements of resonance frequencies"
#~ msgstr ""

#~ msgid ""
#~ "First, make sure it is not some other problem with the printer instead of "
#~ "ringing. If the measurements are not reliable because, say, the distance "
#~ "between the oscillations is not stable, it might mean that the printer has "
#~ "several resonance frequencies on the same axis. One may try to follow the "
#~ "tuning process described in [Unreliable measurements of ringing "
#~ "frequencies](#unreliable-measurements-of-ringing-frequencies) section and "
#~ "still get something out of the input shaping technique. Another possibility "
#~ "is to install an accelerometer, [measure](Measuring_Resonances.md) the "
#~ "resonances with it, and auto-tune the input shaper using the results of "
#~ "those measurements."
#~ msgstr ""

#~ msgid ""
#~ "After enabling [input_shaper], I get too smoothed printed parts and fine "
#~ "details are lost"
#~ msgstr ""

#~ msgid ""
#~ "Check the considerations in [Selecting max_accel](#selecting-max_accel) "
#~ "section. If the resonance frequency is low, one should not set too high "
#~ "max_accel or increase square_corner_velocity parameters. It might also be "
#~ "better to choose MZV or even ZV input shapers over EI (or 2HUMP_EI and "
#~ "3HUMP_EI shapers)."
#~ msgstr ""

#~ msgid ""
#~ "After successfully printing for some time without ringing, it appears to "
#~ "come back"
#~ msgstr ""

#~ msgid ""
#~ "It is possible that after some time the resonance frequencies have changed. "
#~ "E.g. maybe the belts tension has changed (belts got more loose), etc. It is "
#~ "a good idea to check and re-measure the ringing frequencies as described in "
#~ "[Ringing frequency](#ringing-frequency) section and update your config file "
#~ "if necessary."
#~ msgstr ""

#~ msgid "Is dual carriage setup supported with input shapers?"
#~ msgstr ""

#~ msgid ""
#~ "There is no dedicated support for dual carriages with input shapers, but it "
#~ "does not mean this setup will not work. One should run the tuning twice for "
#~ "each of the carriages, and calculate the ringing frequencies for X and Y "
#~ "axes for each of the carriages independently. Then put the values for "
#~ "carriage 0 into [input_shaper] section, and change the values on the fly "
#~ "when changing carriages, e.g. as a part of some macro:"
#~ msgstr ""

#~ msgid ""
#~ "SET_DUAL_CARRIAGE CARRIAGE=1\n"
#~ "SET_INPUT_SHAPER SHAPER_FREQ_X=... SHAPER_FREQ_Y=...\n"
#~ msgstr ""

#~ msgid "And similarly when switching back to carriage 0."
#~ msgstr ""

#~ msgid "Does input_shaper affect print time?"
#~ msgstr ""

#~ msgid ""
#~ "No, `input_shaper` feature has pretty much no impact on the print times by "
#~ "itself. However, the value of `max_accel` certainly does (tuning of this "
#~ "parameter described in [this section](#selecting-max_accel))."
#~ msgstr ""

#~ msgid "Technical details"
#~ msgstr ""

#~ msgid "Input shapers"
#~ msgstr ""

#~ msgid ""
#~ "Input shapers used in Klipper are rather standard, and one can find more in-"
#~ "depth overview in the articles describing the corresponding shapers. This "
#~ "section contains a brief overview of some technical aspects of the supported"
#~ " input shapers. The table below shows some (usually approximate) parameters "
#~ "of each shaper."
#~ msgstr ""

#~ msgid "Input <br> shaper"
#~ msgstr ""

#~ msgid "Shaper <br> duration"
#~ msgstr ""

#~ msgid "Vibration reduction 20x <br> (5% vibration tolerance)"
#~ msgstr ""

#~ msgid "Vibration reduction 10x <br> (10% vibration tolerance)"
#~ msgstr ""

#~ msgid "ZV"
#~ msgstr ""

#~ msgid "0.5 / shaper_freq"
#~ msgstr ""

#~ msgid " 5% shaper_freq"
#~ msgstr ""

#~ msgid "MZV"
#~ msgstr ""

#~ msgid "0.75 / shaper_freq"
#~ msgstr ""

#~ msgid " 4% shaper_freq"
#~ msgstr ""

#~ msgid "-10%...+15% shaper_freq"
#~ msgstr ""

#~ msgid "ZVD"
#~ msgstr ""

#~ msgid "1 / shaper_freq"
#~ msgstr ""

#~ msgid " 15% shaper_freq"
#~ msgstr ""

#~ msgid " 22% shaper_freq"
#~ msgstr ""

#~ msgid "EI"
#~ msgstr ""

#~ msgid " 20% shaper_freq"
#~ msgstr ""

#~ msgid " 25% shaper_freq"
#~ msgstr ""

#~ msgid "2HUMP_EI"
#~ msgstr ""

#~ msgid "1.5 / shaper_freq"
#~ msgstr ""

#~ msgid " 35% shaper_freq"
#~ msgstr ""

#~ msgid " 40 shaper_freq"
#~ msgstr ""

#~ msgid "3HUMP_EI"
#~ msgstr ""

#~ msgid "2 / shaper_freq"
#~ msgstr ""

#~ msgid "-45...+50% shaper_freq"
#~ msgstr ""

#~ msgid "-50%...+55% shaper_freq"
#~ msgstr ""

#~ msgid ""
#~ "A note on vibration reduction: the values in the table above are "
#~ "approximate. If the damping ratio of the printer is known for each axis, the"
#~ " shaper can be configured more precisely and it will then reduce the "
#~ "resonances in a bit wider range of frequencies. However, the damping ratio "
#~ "is usually unknown and is hard to estimate without a special equipment, so "
#~ "Klipper uses 0.1 value by default, which is a good all-round value. The "
#~ "frequency ranges in the table cover a number of different possible damping "
#~ "ratios around that value (approx. from 0.05 to 0.2)."
#~ msgstr ""

#~ msgid ""
#~ "Also note that EI, 2HUMP_EI, and 3HUMP_EI are tuned to reduce vibrations to "
#~ "5%, so the values for 10% vibration tolerance are provided only for the "
#~ "reference."
#~ msgstr ""

#~ msgid "**How to use this table:**"
#~ msgstr ""

#~ msgid ""
#~ "Shaper duration affects the smoothing in parts - the larger it is, the more "
#~ "smooth the parts are. This dependency is not linear, but can give a sense of"
#~ " which shapers 'smooth' more for the same frequency. The ordering by "
#~ "smoothing is like this: ZV < MZV < ZVD  EI < 2HUMP_EI < 3HUMP_EI. Also, it "
#~ "is rarely practical to set shaper_freq = resonance freq for shapers 2HUMP_EI"
#~ " and 3HUMP_EI (they should be used to reduce vibrations for several "
#~ "frequencies)."
#~ msgstr ""

#~ msgid ""
#~ "One can estimate a range of frequencies in which the shaper reduces "
#~ "vibrations. For example, MZV with shaper_freq = 35 Hz reduces vibrations to "
#~ "5% for frequencies [33.6, 36.4] Hz. 3HUMP_EI with shaper_freq = 50 Hz "
#~ "reduces vibrations to 5% in range [27.5, 75] Hz."
#~ msgstr ""

#~ msgid ""
#~ "One can use this table to check which shaper they should be using if they "
#~ "need to reduce vibrations at several frequencies. For example, if one has "
#~ "resonances at 35 Hz and 60 Hz on the same axis: a) EI shaper needs to have "
#~ "shaper_freq = 35 / (1 - 0.2) = 43.75 Hz, and it will reduce resonances until"
#~ " 43.75 * (1 + 0.2) = 52.5 Hz, so it is not sufficient; b) 2HUMP_EI shaper "
#~ "needs to have shaper_freq = 35 / (1 - 0.35) = 53.85 Hz and will reduce "
#~ "vibrations until 53.85 * (1 + 0.35) = 72.7 Hz - so this is an acceptable "
#~ "configuration. Always try to use as high shaper_freq as possible for a given"
#~ " shaper (perhaps with some safety margin, so in this example shaper_freq  "
#~ "50-52 Hz would work best), and try to use a shaper with as small shaper "
#~ "duration as possible."
#~ msgstr ""

#~ msgid ""
#~ "If one needs to reduce vibrations at several very different frequencies "
#~ "(say, 30 Hz and 100 Hz), they may see that the table above does not provide "
#~ "enough information. In this case one may have more luck with "
#~ "[scripts/graph_shaper.py](../scripts/graph_shaper.py) script, which is more "
#~ "flexible."
#~ msgstr ""

#~ msgid "Releases"
#~ msgstr ""

#~ msgid ""
#~ "History of Klipper releases. Please see [installation](Installation.md) for "
#~ "information on installing Klipper."
#~ msgstr ""

#~ msgid "Klipper 0.11.0"
#~ msgstr ""

#~ msgid "Available on 20221128. Major changes in this release:"
#~ msgstr ""

#~ msgid "Trinamic stepper motor driver \"step on both edges\" optimization."
#~ msgstr ""

#~ msgid ""
#~ "Support for Python3. The Klipper host code will run with either Python2 or "
#~ "Python3."
#~ msgstr ""

#~ msgid ""
#~ "Enhanced CAN bus support. Support for CAN bus on rp2040, stm32g0, stm32h7, "
#~ "same51, and same54 chips. Support for \"USB to CAN bus bridge\" mode."
#~ msgstr ""

#~ msgid "Support for CanBoot bootloader."
#~ msgstr ""

#~ msgid "Support for mpu9250 and mpu6050 accelerometers."
#~ msgstr ""

#~ msgid ""
#~ "Improved error handling for max31856, max31855, max31865, and max6675 "
#~ "temperature sensors."
#~ msgstr ""

#~ msgid ""
#~ "It is now possible to configure LEDs to update during long running G-Code "
#~ "commands using LED \"template\" support."
#~ msgstr ""

#~ msgid ""
#~ "Several micro-controller improvements. New support for stm32h743, stm32h750,"
#~ " stm32l412, stm32g0b1, same70, same51, and same54 chips. Support for i2c "
#~ "reads on atsamd and stm32f0. Hardware pwm support on stm32. Linux mcu signal"
#~ " based event dispatch. New rp2040 support for \"make flash\", i2c, and "
#~ "rp2040-e5 USB errata."
#~ msgstr ""

#~ msgid ""
#~ "New modules added: angle, dac084S085, exclude_object, led, mpu9250, pca9632,"
#~ " smart_effector, z_thermal_adjust. New deltesian kinematics added. New "
#~ "dump_mcu tool added."
#~ msgstr ""

#~ msgid "Several bug fixes and code cleanups."
#~ msgstr ""

#~ msgid "Klipper 0.10.0"
#~ msgstr ""

#~ msgid "Available on 20210929. Major changes in this release:"
#~ msgstr ""

#~ msgid ""
#~ "Support for \"Multi-MCU Homing\". It is now possible for a stepper motor and"
#~ " its endstop to be wired to separate micro-controllers. This simplifies "
#~ "wiring of Z probes on \"toolhead boards\"."
#~ msgstr ""

#~ msgid ""
#~ "Klipper now has a [Community Discord Server](https://discord.klipper3d.org) "
#~ "and a [Community Discourse Server](https://community.klipper3d.org)."
#~ msgstr ""

#~ msgid ""
#~ "The [Klipper website](https://www.klipper3d.org) now uses the \"mkdocs\" "
#~ "infrastructure. There is also a [Klipper "
#~ "Translations](https://github.com/Klipper3d/klipper-translations) project."
#~ msgstr ""

#~ msgid "Automated support for flashing firmware via sdcard on many boards."
#~ msgstr ""

#~ msgid "New kinematic support for \"Hybrid CoreXY\" and \"Hybrid CoreXZ\" printers."
#~ msgstr ""

#~ msgid ""
#~ "Klipper now uses `rotation_distance` to configure stepper motor travel "
#~ "distances."
#~ msgstr ""

#~ msgid ""
#~ "The main Klipper host code can now directly communicate with micro-"
#~ "controllers using CAN bus."
#~ msgstr ""

#~ msgid ""
#~ "New \"motion analysis\" system. Klipper's internal motion updates and sensor"
#~ " results can be tracked and logged for analysis."
#~ msgstr ""

#~ msgid ""
#~ "Trinamic stepper motor drivers are now continuously monitored for error "
#~ "conditions."
#~ msgstr ""

#~ msgid "Support for the rp2040 micro-controller (Raspberry Pi Pico boards)."
#~ msgstr ""

#~ msgid "The \"make menuconfig\" system now utilizes kconfiglib."
#~ msgstr ""

#~ msgid ""
#~ "Many additional modules added: ds18b20, duplicate_pin_override, "
#~ "filament_motion_sensor, palette2, motion_report, pca9533, pulse_counter, "
#~ "save_variables, sdcard_loop, temperature_host, temperature_mcu"
#~ msgstr ""

#~ msgid "Klipper 0.9.0"
#~ msgstr ""

#~ msgid "Available on 20201020. Major changes in this release:"
#~ msgstr ""

#~ msgid ""
#~ "Support for \"Input Shaping\" - a mechanism to counteract printer resonance."
#~ " It can reduce or eliminate \"ringing\" in prints."
#~ msgstr ""

#~ msgid ""
#~ "New \"Smooth Pressure Advance\" system. This implements \"Pressure Advance\""
#~ " without introducing instantaneous velocity changes. It is also now possible"
#~ " to tune pressure advance using a \"Tuning Tower\" method."
#~ msgstr ""

#~ msgid ""
#~ "New \"webhooks\" API server. This provides a programmable JSON interface to "
#~ "Klipper."
#~ msgstr ""

#~ msgid ""
#~ "The LCD display and menu are now configurable using the Jinja2 template "
#~ "language."
#~ msgstr ""

#~ msgid ""
#~ "The TMC2208 stepper motor drivers can now be used in \"standalone\" mode "
#~ "with Klipper."
#~ msgstr ""

#~ msgid "Improved BL-Touch v3 support."
#~ msgstr ""

#~ msgid ""
#~ "Improved USB identification. Klipper now has its own USB identification code"
#~ " and micro-controllers can now report their unique serial numbers during USB"
#~ " identification."
#~ msgstr ""

#~ msgid "New kinematic support for \"Rotary Delta\" and \"CoreXZ\" printers."
#~ msgstr ""

#~ msgid ""
#~ "Micro-controller improvements: support for stm32f070, support for stm32f207,"
#~ " support for GPIO pins on \"Linux MCU\", stm32 \"HID bootloader\" support, "
#~ "Chitu bootloader support, MKS Robin bootloader support."
#~ msgstr ""

#~ msgid "Improved handling of Python \"garbage collection\" events."
#~ msgstr ""

#~ msgid ""
#~ "Many additional modules added: adc_scaled, adxl345, bme280, display_status, "
#~ "extruder_stepper, fan_generic, hall_filament_width_sensor, htu21d, "
#~ "homing_heaters, input_shaper, lm75, print_stats, resonance_tester, "
#~ "shaper_calibrate, query_adc, graph_accelerometer, graph_extruder, "
#~ "graph_motion, graph_shaper, graph_temp_sensor, whconsole"
#~ msgstr ""

#~ msgid "Klipper 0.9.1"
#~ msgstr ""

#~ msgid "Available on 20201028. Release containing only bug fixes."
#~ msgstr ""

#~ msgid "Klipper 0.8.0"
#~ msgstr ""

#~ msgid "Available on 20191021. Major changes in this release:"
#~ msgstr ""

#~ msgid ""
#~ "New G-Code command template support. G-Code in the config file is now "
#~ "evaluated with the Jinja2 template language."
#~ msgstr ""

#~ msgid "Improvements to Trinamic stepper drivers:"
#~ msgstr ""

#~ msgid "New support for TMC2209 and TMC5160 drivers."
#~ msgstr ""

#~ msgid "Improved DUMP_TMC, SET_TMC_CURRENT, and INIT_TMC G-Code commands."
#~ msgstr ""

#~ msgid "Improved support for TMC UART handling with an analog mux."
#~ msgstr ""

#~ msgid "Improved homing, probing, and bed leveling support:"
#~ msgstr ""

#~ msgid ""
#~ "New manual_probe, bed_screws, screws_tilt_adjust, skew_correction, "
#~ "safe_z_home modules added."
#~ msgstr ""

#~ msgid "Enhanced multi-sample probing with median, average, and retry logic."
#~ msgstr ""

#~ msgid ""
#~ "Improved documentation for BL-Touch, probe calibration, endstop calibration,"
#~ " delta calibration, sensorless homing, and endstop phase calibration."
#~ msgstr ""

#~ msgid "Improved homing support on a large Z axis."
#~ msgstr ""

#~ msgid "Many Klipper micro-controller improvements:"
#~ msgstr ""

#~ msgid "Klipper ported to: SAM3X8C, SAM4S8C, SAMD51, STM32F042, STM32F4"
#~ msgstr ""

#~ msgid "New USB CDC driver implementations on SAM3X, SAM4, STM32F4."
#~ msgstr ""

#~ msgid "Enhanced support for flashing Klipper over USB."
#~ msgstr ""

#~ msgid "Software SPI support."
#~ msgstr ""

#~ msgid "Greatly improved temperature filtering on the LPC176x."
#~ msgstr ""

#~ msgid "Early output pin settings can be configured in the micro-controller."
#~ msgstr ""

#~ msgid "New website with the Klipper documentation: http://klipper3d.org/"
#~ msgstr ""

#~ msgid "Klipper now has a logo."
#~ msgstr ""

#~ msgid "Experimental support for polar and \"cable winch\" kinematics."
#~ msgstr ""

#~ msgid "The config file can now include other config files."
#~ msgstr ""

#~ msgid ""
#~ "Many additional modules added: board_pins, controller_fan, delayed_gcode, "
#~ "dotstar, filament_switch_sensor, firmware_retraction, gcode_arcs, "
#~ "gcode_button, heater_generic, manual_stepper, mcp4018, mcp4728, neopixel, "
#~ "pause_resume, respond, temperature_sensor tsl1401cl_filament_width_sensor, "
#~ "tuning_tower"
#~ msgstr ""

#~ msgid ""
#~ "Many additional commands added: RESTORE_GCODE_STATE, SAVE_GCODE_STATE, "
#~ "SET_GCODE_VARIABLE, SET_HEATER_TEMPERATURE, SET_IDLE_TIMEOUT, "
#~ "SET_TEMPERATURE_FAN_TARGET"
#~ msgstr ""

#~ msgid "Klipper 0.7.0"
#~ msgstr ""

#~ msgid "Available on 20181220. Major changes in this release:"
#~ msgstr ""

#~ msgid "Klipper now supports \"mesh\" bed leveling"
#~ msgstr ""

#~ msgid ""
#~ "New support for \"enhanced\" delta calibration (calibrates print x/y "
#~ "dimensions on delta printers)"
#~ msgstr ""

#~ msgid ""
#~ "Support for run-time configuration of Trinamic stepper motor drivers "
#~ "(tmc2130, tmc2208, tmc2660)"
#~ msgstr ""

#~ msgid ""
#~ "Improved temperature sensor support: MAX6675, MAX31855, MAX31856, MAX31865, "
#~ "custom thermistors, common pt100 style sensors"
#~ msgstr ""

#~ msgid ""
#~ "Several new modules: temperature_fan, sx1509, force_move, mcp4451, z_tilt, "
#~ "quad_gantry_level, endstop_phase, bltouch"
#~ msgstr ""

#~ msgid ""
#~ "Several new commands added: SAVE_CONFIG, SET_PRESSURE_ADVANCE, "
#~ "SET_GCODE_OFFSET, SET_VELOCITY_LIMIT, STEPPER_BUZZ, TURN_OFF_HEATERS, M204, "
#~ "custom g-code macros"
#~ msgstr ""

#~ msgid "Expanded LCD display support:"
#~ msgstr ""

#~ msgid "Support for run-time menus"
#~ msgstr ""

#~ msgid "New display icons"
#~ msgstr ""

#~ msgid "Support for \"uc1701\" and \"ssd1306\" displays"
#~ msgstr ""

#~ msgid "Additional micro-controller support:"
#~ msgstr ""

#~ msgid ""
#~ "Klipper ported to: LPC176x (Smoothieboards), SAM4E8E (Duet2), SAMD21 "
#~ "(Arduino Zero), STM32F103 (\"Blue pill\" devices), atmega32u4"
#~ msgstr ""

#~ msgid ""
#~ "New Generic USB CDC driver implemented on AVR, LPC176x, SAMD21, and "
#~ "STM32F103"
#~ msgstr ""

#~ msgid "Performance improvements on ARM processors"
#~ msgstr ""

#~ msgid "The kinematics code was rewritten to use an \"iterative solver\""
#~ msgstr ""

#~ msgid "New automatic test cases for the Klipper host software"
#~ msgstr ""

#~ msgid "Many new example config files for common off-the-shelf printers"
#~ msgstr ""

#~ msgid ""
#~ "Documentation updates for bootloaders, benchmarking, micro-controller "
#~ "porting, config checks, pin mapping, slicer settings, packaging, and more"
#~ msgstr ""

#~ msgid "Several bug fixes and code cleanups"
#~ msgstr ""

#~ msgid "Klipper 0.6.0"
#~ msgstr ""

#~ msgid "Available on 20180331. Major changes in this release:"
#~ msgstr ""

#~ msgid "Enhanced heater and thermistor hardware failure checks"
#~ msgstr ""

#~ msgid "Support for Z probes"
#~ msgstr ""

#~ msgid ""
#~ "Initial support for automatic parameter calibration on deltas (via a new "
#~ "delta_calibrate command)"
#~ msgstr ""

#~ msgid ""
#~ "Initial support for bed tilt compensation (via bed_tilt_calibrate command)"
#~ msgstr ""

#~ msgid "Initial support for \"safe homing\" and homing overrides"
#~ msgstr ""

#~ msgid ""
#~ "Initial support for displaying status on RepRapDiscount style 2004 and 12864"
#~ " displays"
#~ msgstr ""

#~ msgid "New multi-extruder improvements:"
#~ msgstr ""

#~ msgid "Support for shared heaters"
#~ msgstr ""

#~ msgid "Initial support for dual carriages"
#~ msgstr ""

#~ msgid "Support for configuring multiple steppers per axis (eg, dual Z)"
#~ msgstr ""

#~ msgid ""
#~ "Support for custom digital and pwm output pins (with a new SET_PIN command)"
#~ msgstr ""

#~ msgid ""
#~ "Initial support for a \"virtual sdcard\" that allows printing directly from "
#~ "Klipper (helps on machines too slow to run OctoPrint well)"
#~ msgstr ""

#~ msgid "Support for setting different arm lengths on each tower of a delta"
#~ msgstr ""

#~ msgid ""
#~ "Support for G-Code M220/M221 commands (speed factor override / extrude "
#~ "factor override)"
#~ msgstr ""

#~ msgid "Several documentation updates:"
#~ msgstr ""

#~ msgid "New multiple MCU config example"
#~ msgstr ""

#~ msgid "New bltouch sensor config example"
#~ msgstr ""

#~ msgid "New FAQ, config check, and G-Code documents"
#~ msgstr ""

#~ msgid ""
#~ "Initial support for continuous integration testing on all github commits"
#~ msgstr ""

#~ msgid "Klipper 0.5.0"
#~ msgstr ""

#~ msgid "Available on 20171025. Major changes in this release:"
#~ msgstr ""

#~ msgid "Support for printers with multiple extruders."
#~ msgstr ""

#~ msgid ""
#~ "Initial support for running on the Beaglebone PRU. Initial support for the "
#~ "Replicape board."
#~ msgstr ""

#~ msgid ""
#~ "Initial support for running the micro-controller code in a real-time Linux "
#~ "process."
#~ msgstr ""

#~ msgid ""
#~ "Support for multiple micro-controllers. (For example, one could control an "
#~ "extruder with one micro-controller and the rest of the printer with "
#~ "another.) Software clock synchronization is implemented to coordinate "
#~ "actions between micro-controllers."
#~ msgstr ""

#~ msgid ""
#~ "Stepper performance improvements (20Mhz AVRs up to 189K steps per second)."
#~ msgstr ""

#~ msgid ""
#~ "Support for controlling servos and support for defining nozzle cooling fans."
#~ msgstr ""

#~ msgid "Klipper 0.4.0"
#~ msgstr ""

#~ msgid "Available on 20170503. Major changes in this release:"
#~ msgstr ""

#~ msgid ""
#~ "Improved installation on Raspberry Pi machines. Most of the install is now "
#~ "scripted."
#~ msgstr ""

#~ msgid "Support for corexy kinematics"
#~ msgstr ""

#~ msgid ""
#~ "Documentation updates: New Kinematics document, new Pressure Advance tuning "
#~ "guide, new example config files, and more"
#~ msgstr ""

#~ msgid ""
#~ "Stepper performance improvements (20Mhz AVRs over 175K steps per second, "
#~ "Arduino Due over 460K)"
#~ msgstr ""

#~ msgid ""
#~ "Support for automatic micro-controller resets. Support for resets via "
#~ "toggling USB power on Raspberry Pi."
#~ msgstr ""

#~ msgid ""
#~ "The pressure advance algorithm now works with look-ahead to reduce pressure "
#~ "changes during cornering."
#~ msgstr ""

#~ msgid "Support for limiting the top speed of short zigzag moves"
#~ msgstr ""

#~ msgid "Support for AD595 sensors"
#~ msgstr ""

#~ msgid "Klipper 0.3.0"
#~ msgstr ""

#~ msgid "Available on 20161223. Major changes in this release:"
#~ msgstr ""

#~ msgid "Improved documentation"
#~ msgstr ""

#~ msgid "Support for robots with delta kinematics"
#~ msgstr ""

#~ msgid "Support for Arduino Due micro-controller (ARM cortex-M3)"
#~ msgstr ""

#~ msgid "Support for USB based AVR micro-controllers"
#~ msgstr ""

#~ msgid ""
#~ "Support for \"pressure advance\" algorithm - it reduces ooze during prints."
#~ msgstr ""

#~ msgid ""
#~ "New \"stepper phased based endstop\" feature - enables higher precision on "
#~ "endstop homing."
#~ msgstr ""

#~ msgid ""
#~ "Support for \"extended g-code\" commands such as \"help\", \"restart\", and "
#~ "\"status\"."
#~ msgstr ""

#~ msgid ""
#~ "Support for reloading the Klipper config and restarting the host software by"
#~ " issuing a \"restart\" command from the terminal."
#~ msgstr ""

#~ msgid ""
#~ "Stepper performance improvements (20Mhz AVRs up to 158K steps per second)."
#~ msgstr ""

#~ msgid ""
#~ "Improved error reporting. Most errors now shown via the terminal along with "
#~ "help on how to resolve."
#~ msgstr ""

#~ msgid "Klipper 0.2.0"
#~ msgstr ""

#~ msgid ""
#~ "Initial release of Klipper. Available on 20160525. Major features available "
#~ "in the initial release include:"
#~ msgstr ""

#~ msgid ""
#~ "Basic support for cartesian printers (steppers, extruder, heated bed, "
#~ "cooling fan)."
#~ msgstr ""

#~ msgid ""
#~ "Support for common g-code commands. Support for interfacing with OctoPrint."
#~ msgstr ""

#~ msgid "Acceleration and lookahead handling"
#~ msgstr ""

#~ msgid "Support for AVR micro-controllers via standard serial ports"
#~ msgstr ""

#~ msgid "RPi microcontroller"
#~ msgstr ""

#~ msgid ""
#~ "This document describes the process of running Klipper on a RPi and use the "
#~ "same RPi as secondary mcu."
#~ msgstr ""

#~ msgid "Why use RPi as a secondary MCU?"
#~ msgstr ""

#~ msgid ""
#~ "Often the MCUs dedicated to controlling 3D printers have a limited and pre-"
#~ "configured number of exposed pins to manage the main printing functions "
#~ "(thermal resistors, extruders, steppers ...). Using the RPi where Klipper is"
#~ " installed as a secondary MCU gives the possibility to directly use the "
#~ "GPIOs and the buses (i2c, spi) of the RPi inside klipper without using "
#~ "Octoprint plugins (if used) or external programs giving the ability to "
#~ "control everything within the print GCODE."
#~ msgstr ""

#~ msgid ""
#~ "**Warning**: If your platform is a *Beaglebone* and you have correctly "
#~ "followed the installation steps, the linux mcu is already installed and "
#~ "configured for your system."
#~ msgstr ""

#~ msgid "Install the rc script"
#~ msgstr ""

#~ msgid ""
#~ "If you want to use the host as a secondary MCU the klipper_mcu process must "
#~ "run before the klippy process."
#~ msgstr ""

#~ msgid "After installing Klipper, install the script. run:"
#~ msgstr ""

#~ msgid ""
#~ "cd ~/klipper/\n"
#~ "sudo cp \"./scripts/klipper-mcu-start.sh\" /etc/init.d/klipper_mcu\n"
#~ "sudo update-rc.d klipper_mcu defaults\n"
#~ msgstr ""

#~ msgid "Building the micro-controller code"
#~ msgstr ""

#~ msgid ""
#~ "To compile the Klipper micro-controller code, start by configuring it for "
#~ "the \"Linux process\":"
#~ msgstr ""

#~ msgid ""
#~ "cd ~/klipper/\n"
#~ "make menuconfig\n"
#~ msgstr ""

#~ msgid ""
#~ "In the menu, set \"Microcontroller Architecture\" to \"Linux process,\" then"
#~ " save and exit."
#~ msgstr ""

#~ msgid "To build and install the new micro-controller code, run:"
#~ msgstr ""

#~ msgid ""
#~ "sudo service klipper stop\n"
#~ "make flash\n"
#~ "sudo service klipper start\n"
#~ msgstr ""

#~ msgid ""
#~ "If klippy.log reports a \"Permission denied\" error when attempting to "
#~ "connect to `/tmp/klipper_host_mcu` then you need to add your user to the tty"
#~ " group. The following command will add the \"pi\" user to the tty group:"
#~ msgstr ""

#~ msgid "sudo usermod -a -G tty pi\n"
#~ msgstr ""

#~ msgid "Remaining configuration"
#~ msgstr ""

#~ msgid ""
#~ "Complete the installation by configuring Klipper secondary MCU following the"
#~ " instructions in [RaspberryPi sample config](../config/sample-raspberry-"
#~ "pi.cfg) and [Multi MCU sample config](../config/sample-multi-mcu.cfg)."
#~ msgstr ""

#~ msgid "Optional: Enabling SPI"
#~ msgstr ""

#~ msgid ""
#~ "Make sure the Linux SPI driver is enabled by running `sudo raspi-config` and"
#~ " enabling SPI under the \"Interfacing options\" menu."
#~ msgstr ""

#~ msgid "Optional: Enabling I2C"
#~ msgstr ""

#~ msgid ""
#~ "Make sure the Linux I2C driver is enabled by running `sudo raspi-config` and"
#~ " enabling I2C under the \"Interfacing options\" menu. If planning to use I2C"
#~ " for the MPU accelerometer, it is also required to set the baud rate to "
#~ "400000 by: adding/uncommenting `dtparam=i2c_arm=on,i2c_arm_baudrate=400000` "
#~ "in `/boot/config.txt` (or `/boot/firmware/config.txt` in some distros)."
#~ msgstr ""

#~ msgid "Optional: Identify the correct gpiochip"
#~ msgstr ""

#~ msgid ""
#~ "On Raspberry Pi and on many clones the pins exposed on the GPIO belong to "
#~ "the first gpiochip. They can therefore be used on klipper simply by "
#~ "referring them with the name `gpio0..n`. However, there are cases in which "
#~ "the exposed pins belong to gpiochips other than the first. For example in "
#~ "the case of some OrangePi models or if a Port Expander is used. In these "
#~ "cases it is useful to use the commands to access the *Linux GPIO character "
#~ "device* to verify the configuration."
#~ msgstr ""

#~ msgid ""
#~ "To install the *Linux GPIO character device - binary* on a debian based "
#~ "distro like octopi run:"
#~ msgstr ""

#~ msgid "sudo apt-get install gpiod\n"
#~ msgstr ""

#~ msgid "To check available gpiochip run:"
#~ msgstr ""

#~ msgid "gpiodetect\n"
#~ msgstr ""

#~ msgid "To check the pin number and the pin availability tun:"
#~ msgstr ""

#~ msgid "gpioinfo\n"
#~ msgstr ""

#~ msgid ""
#~ "The chosen pin can thus be used within the configuration as "
#~ "`gpiochip<n>/gpio<o>` where **n** is the chip number as seen by the "
#~ "`gpiodetect` command and **o** is the line number seen by the`gpioinfo` "
#~ "command."
#~ msgstr ""

#~ msgid ""
#~ "***Warning:*** only gpio marked as `unused` can be used. It is not possible "
#~ "for a *line* to be used by multiple processes simultaneously."
#~ msgstr ""

#~ msgid "For example on a RPi 3B+ where klipper use the GPIO20 for a switch:"
#~ msgstr ""

#~ msgid ""
#~ "$ gpiodetect\n"
#~ "gpiochip0 [pinctrl-bcm2835] (54 lines)\n"
#~ "gpiochip1 [raspberrypi-exp-gpio] (8 lines)\n"
#~ "\n"
#~ "$ gpioinfo\n"
#~ "gpiochip0 - 54 lines:\n"
#~ "        line   0:      unnamed       unused   input  active-high\n"
#~ "        line   1:      unnamed       unused   input  active-high\n"
#~ "        line   2:      unnamed       unused   input  active-high\n"
#~ "        line   3:      unnamed       unused   input  active-high\n"
#~ "        line   4:      unnamed       unused   input  active-high\n"
#~ "        line   5:      unnamed       unused   input  active-high\n"
#~ "        line   6:      unnamed       unused   input  active-high\n"
#~ "        line   7:      unnamed       unused   input  active-high\n"
#~ "        line   8:      unnamed       unused   input  active-high\n"
#~ "        line   9:      unnamed       unused   input  active-high\n"
#~ "        line  10:      unnamed       unused   input  active-high\n"
#~ "        line  11:      unnamed       unused   input  active-high\n"
#~ "        line  12:      unnamed       unused   input  active-high\n"
#~ "        line  13:      unnamed       unused   input  active-high\n"
#~ "        line  14:      unnamed       unused   input  active-high\n"
#~ "        line  15:      unnamed       unused   input  active-high\n"
#~ "        line  16:      unnamed       unused   input  active-high\n"
#~ "        line  17:      unnamed       unused   input  active-high\n"
#~ "        line  18:      unnamed       unused   input  active-high\n"
#~ "        line  19:      unnamed       unused   input  active-high\n"
#~ "        line  20:      unnamed    \"klipper\"  output  active-high [used]\n"
#~ "        line  21:      unnamed       unused   input  active-high\n"
#~ "        line  22:      unnamed       unused   input  active-high\n"
#~ "        line  23:      unnamed       unused   input  active-high\n"
#~ "        line  24:      unnamed       unused   input  active-high\n"
#~ "        line  25:      unnamed       unused   input  active-high\n"
#~ "        line  26:      unnamed       unused   input  active-high\n"
#~ "        line  27:      unnamed       unused   input  active-high\n"
#~ "        line  28:      unnamed       unused   input  active-high\n"
#~ "        line  29:      unnamed       \"led0\"  output  active-high [used]\n"
#~ "        line  30:      unnamed       unused   input  active-high\n"
#~ "        line  31:      unnamed       unused   input  active-high\n"
#~ "        line  32:      unnamed       unused   input  active-high\n"
#~ "        line  33:      unnamed       unused   input  active-high\n"
#~ "        line  34:      unnamed       unused   input  active-high\n"
#~ "        line  35:      unnamed       unused   input  active-high\n"
#~ "        line  36:      unnamed       unused   input  active-high\n"
#~ "        line  37:      unnamed       unused   input  active-high\n"
#~ "        line  38:      unnamed       unused   input  active-high\n"
#~ "        line  39:      unnamed       unused   input  active-high\n"
#~ "        line  40:      unnamed       unused   input  active-high\n"
#~ "        line  41:      unnamed       unused   input  active-high\n"
#~ "        line  42:      unnamed       unused   input  active-high\n"
#~ "        line  43:      unnamed       unused   input  active-high\n"
#~ "        line  44:      unnamed       unused   input  active-high\n"
#~ "        line  45:      unnamed       unused   input  active-high\n"
#~ "        line  46:      unnamed       unused   input  active-high\n"
#~ "        line  47:      unnamed       unused   input  active-high\n"
#~ "        line  48:      unnamed       unused   input  active-high\n"
#~ "        line  49:      unnamed       unused   input  active-high\n"
#~ "        line  50:      unnamed       unused   input  active-high\n"
#~ "        line  51:      unnamed       unused   input  active-high\n"
#~ "        line  52:      unnamed       unused   input  active-high\n"
#~ "        line  53:      unnamed       unused   input  active-high\n"
#~ "gpiochip1 - 8 lines:\n"
#~ "        line   0:      unnamed       unused   input  active-high\n"
#~ "        line   1:      unnamed       unused   input  active-high\n"
#~ "        line   2:      unnamed       \"led1\"  output   active-low [used]\n"
#~ "        line   3:      unnamed       unused   input  active-high\n"
#~ "        line   4:      unnamed       unused   input  active-high\n"
#~ "        line   5:      unnamed       unused   input  active-high\n"
#~ "        line   6:      unnamed       unused   input  active-high\n"
#~ "        line   7:      unnamed       unused   input  active-high\n"
#~ msgstr ""

#~ msgid "Optional: Hardware PWM"
#~ msgstr ""

#~ msgid ""
#~ "Raspberry Pi's have two PWM channels (PWM0 and PWM1) which are exposed on "
#~ "the header or if not, can be routed to existing gpio pins. The Linux mcu "
#~ "daemon uses the pwmchip sysfs interface to control hardware pwm devices on "
#~ "Linux hosts. The pwm sysfs interface is not exposed by default on a "
#~ "Raspberry and can be activated by adding a line to `/boot/config.txt`:"
#~ msgstr ""

#~ msgid ""
#~ "# Enable pwmchip sysfs interface\n"
#~ "dtoverlay=pwm,pin=12,func=4\n"
#~ msgstr ""

#~ msgid ""
#~ "This example enables only PWM0 and routes it to gpio12. If both PWM channels"
#~ " need to be enabled you can use `pwm-2chan`."
#~ msgstr ""

#~ msgid ""
#~ "The overlay does not expose the pwm line on sysfs on boot and needs to be "
#~ "exported by echo'ing the number of the pwm channel to "
#~ "`/sys/class/pwm/pwmchip0/export`:"
#~ msgstr ""

#~ msgid "echo 0 > /sys/class/pwm/pwmchip0/export\n"
#~ msgstr ""

#~ msgid ""
#~ "This will create device `/sys/class/pwm/pwmchip0/pwm0` in the filesystem. "
#~ "The easiest way to do this is by adding this to `/etc/rc.local` before the "
#~ "`exit 0` line."
#~ msgstr ""

#~ msgid ""
#~ "With the sysfs in place, you can now use either the pwm channel(s) by adding"
#~ " the following piece of configuration to your `printer.cfg`:"
#~ msgstr ""

#~ msgid ""
#~ "[output_pin caselight]\n"
#~ "pin: host:pwmchip0/pwm0\n"
#~ "pwm: True\n"
#~ "hardware_pwm: True\n"
#~ "cycle_time: 0.000001\n"
#~ msgstr ""

#~ msgid ""
#~ "This will add hardware pwm control to gpio12 on the Pi (because the overlay "
#~ "was configured to route pwm0 to pin=12)."
#~ msgstr ""

#~ msgid ""
#~ "PWM0 can be routed to gpio12 and gpio18, PWM1 can be routed to gpio13 and "
#~ "gpio19:"
#~ msgstr ""

#~ msgid "PWM"
#~ msgstr ""

#~ msgid "gpio PIN"
#~ msgstr ""

#~ msgid "Func"
#~ msgstr ""

#~ msgid "0"
#~ msgstr ""

#~ msgid "12"
#~ msgstr ""

#~ msgid "18"
#~ msgstr ""

#~ msgid "1"
#~ msgstr ""

#~ msgid "13"
#~ msgstr ""

#~ msgid "19"
#~ msgstr ""

#~ msgid ""
#~ "Welcome to the Klipper documentation. The [overview document](Overview.md) "
#~ "is a good starting point."
#~ msgstr ""

#~ msgid "Protocol"
#~ msgstr ""

#~ msgid ""
#~ "The Klipper messaging protocol is used for low-level communication between "
#~ "the Klipper host software and the Klipper micro-controller software. At a "
#~ "high level the protocol can be thought of as a series of command and "
#~ "response strings that are compressed, transmitted, and then processed at the"
#~ " receiving side. An example series of commands in uncompressed human-"
#~ "readable format might look like:"
#~ msgstr ""

#~ msgid ""
#~ "set_digital_out pin=PA3 value=1\n"
#~ "set_digital_out pin=PA7 value=1\n"
#~ "schedule_digital_out oid=8 clock=4000000 value=0\n"
#~ "queue_step oid=7 interval=7458 count=10 add=331\n"
#~ "queue_step oid=7 interval=11717 count=4 add=1281\n"
#~ msgstr ""

#~ msgid ""
#~ "See the [mcu commands](MCU_Commands.md) document for information on "
#~ "available commands. See the [debugging](Debugging.md) document for "
#~ "information on how to translate a G-Code file into its corresponding human-"
#~ "readable micro-controller commands."
#~ msgstr ""

#~ msgid ""
#~ "This page provides a high-level description of the Klipper messaging "
#~ "protocol itself. It describes how messages are declared, encoded in binary "
#~ "format (the \"compression\" scheme), and transmitted."
#~ msgstr ""

#~ msgid ""
#~ "The goal of the protocol is to enable an error-free communication channel "
#~ "between the host and micro-controller that is low-latency, low-bandwidth, "
#~ "and low-complexity for the micro-controller."
#~ msgstr ""

#~ msgid "Micro-controller Interface"
#~ msgstr ""

#~ msgid ""
#~ "The Klipper transmission protocol can be thought of as a "
#~ "[RPC](https://en.wikipedia.org/wiki/Remote_procedure_call) mechanism between"
#~ " micro-controller and host. The micro-controller software declares the "
#~ "commands that the host may invoke along with the response messages that it "
#~ "can generate. The host uses that information to command the micro-controller"
#~ " to perform actions and to interpret the results."
#~ msgstr ""

#~ msgid "Declaring commands"
#~ msgstr ""

#~ msgid ""
#~ "The micro-controller software declares a \"command\" by using the "
#~ "DECL_COMMAND() macro in the C code. For example:"
#~ msgstr ""

#~ msgid ""
#~ "DECL_COMMAND(command_update_digital_out, \"update_digital_out oid=%c "
#~ "value=%c\");\n"
#~ msgstr ""

#~ msgid ""
#~ "The above declares a command named \"update_digital_out\". This allows the "
#~ "host to \"invoke\" this command which would cause the "
#~ "command_update_digital_out() C function to be executed in the micro-"
#~ "controller. The above also indicates that the command takes two integer "
#~ "parameters. When the command_update_digital_out() C code is executed, it "
#~ "will be passed an array containing these two integers - the first "
#~ "corresponding to the 'oid' and the second corresponding to the 'value'."
#~ msgstr ""

#~ msgid ""
#~ "In general, the parameters are described with printf() style syntax (eg, "
#~ "\"%u\"). The formatting directly corresponds to the human-readable view of "
#~ "commands (eg, \"update_digital_out oid=7 value=1\"). In the above example, "
#~ "\"value=\" is a parameter name and \"%c\" indicates the parameter is an "
#~ "integer. Internally, the parameter name is only used as documentation. In "
#~ "this example, the \"%c\" is also used as documentation to indicate the "
#~ "expected integer is 1 byte in size (the declared integer size does not "
#~ "impact the parsing or encoding)."
#~ msgstr ""

#~ msgid ""
#~ "The micro-controller build will collect all commands declared with "
#~ "DECL_COMMAND(), determine their parameters, and arrange for them to be "
#~ "callable."
#~ msgstr ""

#~ msgid "Declaring responses"
#~ msgstr ""

#~ msgid ""
#~ "To send information from the micro-controller to the host a \"response\" is "
#~ "generated. These are both declared and transmitted using the sendf() C "
#~ "macro. For example:"
#~ msgstr ""

#~ msgid ""
#~ "sendf(\"status clock=%u status=%c\", sched_read_time(), "
#~ "sched_is_shutdown());\n"
#~ msgstr ""

#~ msgid ""
#~ "The above transmits a \"status\" response message that contains two integer "
#~ "parameters (\"clock\" and \"status\"). The micro-controller build "
#~ "automatically finds all sendf() calls and generates encoders for them. The "
#~ "first parameter of the sendf() function describes the response and it is in "
#~ "the same format as command declarations."
#~ msgstr ""

#~ msgid ""
#~ "The host can arrange to register a callback function for each response. So, "
#~ "in effect, commands allow the host to invoke C functions in the micro-"
#~ "controller and responses allow the micro-controller software to invoke code "
#~ "in the host."
#~ msgstr ""

#~ msgid ""
#~ "The sendf() macro should only be invoked from command or task handlers, and "
#~ "it should not be invoked from interrupts or timers. The code does not need "
#~ "to issue a sendf() in response to a received command, it is not limited in "
#~ "the number of times sendf() may be invoked, and it may invoke sendf() at any"
#~ " time from a task handler."
#~ msgstr ""

#~ msgid "Output responses"
#~ msgstr ""

#~ msgid ""
#~ "To simplify debugging, there is also an output() C function. For example:"
#~ msgstr ""

#~ msgid "output(\"The value of %u is %s with size %u.\", x, buf, buf_len);\n"
#~ msgstr ""

#~ msgid ""
#~ "The output() function is similar in usage to printf() - it is intended to "
#~ "generate and format arbitrary messages for human consumption."
#~ msgstr ""

#~ msgid "Declaring enumerations"
#~ msgstr ""

#~ msgid ""
#~ "Enumerations allow the host code to use string identifiers for parameters "
#~ "that the micro-controller handles as integers. They are declared in the "
#~ "micro-controller code - for example:"
#~ msgstr ""

#~ msgid ""
#~ "DECL_ENUMERATION(\"spi_bus\", \"spi\", 0);\n"
#~ "\n"
#~ "DECL_ENUMERATION_RANGE(\"pin\", \"PC0\", 16, 8);\n"
#~ msgstr ""

#~ msgid ""
#~ "If the first example, the DECL_ENUMERATION() macro defines an enumeration "
#~ "for any command/response message with a parameter name of \"spi_bus\" or "
#~ "parameter name with a suffix of \"_spi_bus\". For those parameters the "
#~ "string \"spi\" is a valid value and it will be transmitted with an integer "
#~ "value of zero."
#~ msgstr ""

#~ msgid ""
#~ "It's also possible to declare an enumeration range. In the second example, a"
#~ " \"pin\" parameter (or any parameter with a suffix of \"_pin\") would accept"
#~ " PC0, PC1, PC2, ..., PC7 as valid values. The strings will be transmitted "
#~ "with integers 16, 17, 18, ..., 23."
#~ msgstr ""

#~ msgid "Declaring constants"
#~ msgstr ""

#~ msgid "Constants can also be exported. For example, the following:"
#~ msgstr ""

#~ msgid "DECL_CONSTANT(\"SERIAL_BAUD\", 250000);\n"
#~ msgstr ""

#~ msgid ""
#~ "would export a constant named \"SERIAL_BAUD\" with a value of 250000 from "
#~ "the micro-controller to the host. It is also possible to declare a constant "
#~ "that is a string - for example:"
#~ msgstr ""

#~ msgid "DECL_CONSTANT_STR(\"MCU\", \"pru\");\n"
#~ msgstr ""

#~ msgid "Low-level message encoding"
#~ msgstr ""

#~ msgid ""
#~ "To accomplish the above RPC mechanism, each command and response is encoded "
#~ "into a binary format for transmission. This section describes the "
#~ "transmission system."
#~ msgstr ""

#~ msgid "Message Blocks"
#~ msgstr ""

#~ msgid ""
#~ "All data sent from host to micro-controller and vice-versa are contained in "
#~ "\"message blocks\". A message block has a two byte header and a three byte "
#~ "trailer. The format of a message block is:"
#~ msgstr ""

#~ msgid ""
#~ "<1 byte length><1 byte sequence><n-byte content><2 byte crc><1 byte sync>\n"
#~ msgstr ""

#~ msgid ""
#~ "The length byte contains the number of bytes in the message block including "
#~ "the header and trailer bytes (thus the minimum message length is 5 bytes). "
#~ "The maximum message block length is currently 64 bytes. The sequence byte "
#~ "contains a 4 bit sequence number in the low-order bits and the high-order "
#~ "bits always contain 0x10 (the high-order bits are reserved for future use). "
#~ "The content bytes contain arbitrary data and its format is described in the "
#~ "following section. The crc bytes contain a 16bit CCITT "
#~ "[CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) of the message "
#~ "block including the header bytes but excluding the trailer bytes. The sync "
#~ "byte is 0x7e."
#~ msgstr ""

#~ msgid ""
#~ "The format of the message block is inspired by "
#~ "[HDLC](https://en.wikipedia.org/wiki/High-Level_Data_Link_Control) message "
#~ "frames. Like in HDLC, the message block may optionally contain an additional"
#~ " sync character at the start of the block. Unlike in HDLC, a sync character "
#~ "is not exclusive to the framing and may be present in the message block "
#~ "content."
#~ msgstr ""

#~ msgid "Message Block Contents"
#~ msgstr ""

#~ msgid ""
#~ "Each message block sent from host to micro-controller contains a series of "
#~ "zero or more message commands in its contents. Each command starts with a "
#~ "[Variable Length Quantity](#variable-length-quantities) (VLQ) encoded "
#~ "integer command-id followed by zero or more VLQ parameters for the given "
#~ "command."
#~ msgstr ""

#~ msgid ""
#~ "As an example, the following four commands might be placed in a single "
#~ "message block:"
#~ msgstr ""

#~ msgid ""
#~ "update_digital_out oid=6 value=1\n"
#~ "update_digital_out oid=5 value=0\n"
#~ "get_config\n"
#~ "get_clock\n"
#~ msgstr ""

#~ msgid "and encoded into the following eight VLQ integers:"
#~ msgstr ""

#~ msgid ""
#~ "<id_update_digital_out><6><1><id_update_digital_out><5><0><id_get_config><id_get_clock>\n"
#~ msgstr ""

#~ msgid ""
#~ "In order to encode and parse the message contents, both the host and micro-"
#~ "controller must agree on the command ids and the number of parameters each "
#~ "command has. So, in the above example, both the host and micro-controller "
#~ "would know that \"id_update_digital_out\" is always followed by two "
#~ "parameters, and \"id_get_config\" and \"id_get_clock\" have zero parameters."
#~ " The host and micro-controller share a \"data dictionary\" that maps the "
#~ "command descriptions (eg, \"update_digital_out oid=%c value=%c\") to their "
#~ "integer command-ids. When processing the data, the parser will know to "
#~ "expect a specific number of VLQ encoded parameters following a given command"
#~ " id."
#~ msgstr ""

#~ msgid ""
#~ "The message contents for blocks sent from micro-controller to host follow "
#~ "the same format. The identifiers in these messages are \"response ids\", but"
#~ " they serve the same purpose and follow the same encoding rules. In "
#~ "practice, message blocks sent from the micro-controller to the host never "
#~ "contain more than one response in the message block contents."
#~ msgstr ""

#~ msgid "Variable Length Quantities"
#~ msgstr ""

#~ msgid ""
#~ "See the [wikipedia article](https://en.wikipedia.org/wiki/Variable-"
#~ "length_quantity) for more information on the general format of VLQ encoded "
#~ "integers. Klipper uses an encoding scheme that supports both positive and "
#~ "negative integers. Integers close to zero use less bytes to encode and "
#~ "positive integers typically encode using less bytes than negative integers. "
#~ "The following table shows the number of bytes each integer takes to encode:"
#~ msgstr ""

#~ msgid "Integer"
#~ msgstr ""

#~ msgid "Encoded size"
#~ msgstr ""

#~ msgid "-32 .. 95"
#~ msgstr ""

#~ msgid "-4096 .. 12287"
#~ msgstr ""

#~ msgid "-524288 .. 1572863"
#~ msgstr ""

#~ msgid "-67108864 .. 201326591"
#~ msgstr ""

#~ msgid "-2147483648 .. 4294967295"
#~ msgstr ""

#~ msgid "Variable length strings"
#~ msgstr ""

#~ msgid ""
#~ "As an exception to the above encoding rules, if a parameter to a command or "
#~ "response is a dynamic string then the parameter is not encoded as a simple "
#~ "VLQ integer. Instead it is encoded by transmitting the length as a VLQ "
#~ "encoded integer followed by the contents itself:"
#~ msgstr ""

#~ msgid "<VLQ encoded length><n-byte contents>\n"
#~ msgstr ""

#~ msgid ""
#~ "The command descriptions found in the data dictionary allow both the host "
#~ "and micro-controller to know which command parameters use simple VLQ "
#~ "encoding and which parameters use string encoding."
#~ msgstr ""

#~ msgid "Data Dictionary"
#~ msgstr ""

#~ msgid ""
#~ "In order for meaningful communications to be established between micro-"
#~ "controller and host, both sides must agree on a \"data dictionary\". This "
#~ "data dictionary contains the integer identifiers for commands and responses "
#~ "along with their descriptions."
#~ msgstr ""

#~ msgid ""
#~ "The micro-controller build uses the contents of DECL_COMMAND() and sendf() "
#~ "macros to generate the data dictionary. The build automatically assigns "
#~ "unique identifiers to each command and response. This system allows both the"
#~ " host and micro-controller code to seamlessly use descriptive human-readable"
#~ " names while still using minimal bandwidth."
#~ msgstr ""

#~ msgid ""
#~ "The host queries the data dictionary when it first connects to the micro-"
#~ "controller. Once the host downloads the data dictionary from the micro-"
#~ "controller, it uses that data dictionary to encode all commands and to parse"
#~ " all responses from the micro-controller. The host must therefore handle a "
#~ "dynamic data dictionary. However, to keep the micro-controller software "
#~ "simple, the micro-controller always uses its static (compiled in) data "
#~ "dictionary."
#~ msgstr ""

#~ msgid ""
#~ "The data dictionary is queried by sending \"identify\" commands to the "
#~ "micro-controller. The micro-controller will respond to each identify command"
#~ " with an \"identify_response\" message. Since these two commands are needed "
#~ "prior to obtaining the data dictionary, their integer ids and parameter "
#~ "types are hard-coded in both the micro-controller and the host. The "
#~ "\"identify_response\" response id is 0, the \"identify\" command id is 1. "
#~ "Other than having hard-coded ids the identify command and its response are "
#~ "declared and transmitted the same way as other commands and responses. No "
#~ "other command or response is hard-coded."
#~ msgstr ""

#~ msgid ""
#~ "The format of the transmitted data dictionary itself is a zlib compressed "
#~ "JSON string. The micro-controller build process generates the string, "
#~ "compresses it, and stores it in the text section of the micro-controller "
#~ "flash. The data dictionary can be much larger than the maximum message block"
#~ " size - the host downloads it by sending multiple identify commands "
#~ "requesting progressive chunks of the data dictionary. Once all chunks are "
#~ "obtained the host will assemble the chunks, uncompress the data, and parse "
#~ "the contents."
#~ msgstr ""

#~ msgid ""
#~ "In addition to information on the communication protocol, the data "
#~ "dictionary also contains the software version, enumerations (as defined by "
#~ "DECL_ENUMERATION), and constants (as defined by DECL_CONSTANT)."
#~ msgstr ""

#~ msgid "Message flow"
#~ msgstr ""

#~ msgid ""
#~ "Message commands sent from host to micro-controller are intended to be "
#~ "error-free. The micro-controller will check the CRC and sequence numbers in "
#~ "each message block to ensure the commands are accurate and in-order. The "
#~ "micro-controller always processes message blocks in-order - should it "
#~ "receive a block out-of-order it will discard it and any other out-of-order "
#~ "blocks until it receives blocks with the correct sequencing."
#~ msgstr ""

#~ msgid ""
#~ "The low-level host code implements an automatic retransmission system for "
#~ "lost and corrupt message blocks sent to the micro-controller. To facilitate "
#~ "this, the micro-controller transmits an \"ack message block\" after each "
#~ "successfully received message block. The host schedules a timeout after "
#~ "sending each block and it will retransmit should the timeout expire without "
#~ "receiving a corresponding \"ack\". In addition, if the micro-controller "
#~ "detects a corrupt or out-of-order block it may transmit a \"nak message "
#~ "block\" to facilitate fast retransmission."
#~ msgstr ""

#~ msgid ""
#~ "An \"ack\" is a message block with empty content (ie, a 5 byte message "
#~ "block) and a sequence number greater than the last received host sequence "
#~ "number. A \"nak\" is a message block with empty content and a sequence "
#~ "number less than the last received host sequence number."
#~ msgstr ""

#~ msgid ""
#~ "The protocol facilitates a \"window\" transmission system so that the host "
#~ "can have many outstanding message blocks in-flight at a time. (This is in "
#~ "addition to the many commands that may be present in a given message block.)"
#~ " This allows maximum bandwidth utilization even in the event of transmission"
#~ " latency. The timeout, retransmit, windowing, and ack mechanism are inspired"
#~ " by similar mechanisms in "
#~ "[TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)."
#~ msgstr ""

#~ msgid ""
#~ "In the other direction, message blocks sent from micro-controller to host "
#~ "are designed to be error-free, but they do not have assured transmission. "
#~ "(Responses should not be corrupt, but they may go missing.) This is done to "
#~ "keep the implementation in the micro-controller simple. There is no "
#~ "automatic retransmission system for responses - the high-level code is "
#~ "expected to be capable of handling an occasional missing response (usually "
#~ "by re-requesting the content or setting up a recurring schedule of response "
#~ "transmission). The sequence number field in message blocks sent to the host "
#~ "is always one greater than the last received sequence number of message "
#~ "blocks received from the host. It is not used to track sequences of response"
#~ " message blocks."
#~ msgstr ""

#~ msgid "Probe calibration"
#~ msgstr ""

#~ msgid ""
#~ "This document describes the method for calibrating the X, Y, and Z offsets "
#~ "of an \"automatic z probe\" in Klipper. This is useful for users that have a"
#~ " `[probe]` or `[bltouch]` section in their config file."
#~ msgstr ""

#~ msgid "Calibrating probe X and Y offsets"
#~ msgstr ""

#~ msgid ""
#~ "To calibrate the X and Y offset, navigate to the OctoPrint \"Control\" tab, "
#~ "home the printer, and then use the OctoPrint jogging buttons to move the "
#~ "head to a position near the center of the bed."
#~ msgstr ""

#~ msgid ""
#~ "Place a piece of blue painters tape (or similar) on the bed underneath the "
#~ "probe. Navigate to the OctoPrint \"Terminal\" tab and issue a PROBE command:"
#~ msgstr ""

#~ msgid "PROBE\n"
#~ msgstr ""

#~ msgid ""
#~ "Place a mark on the tape directly under where the probe is (or use a similar"
#~ " method to note the location on the bed)."
#~ msgstr ""

#~ msgid ""
#~ "Issue a `GET_POSITION` command and record the toolhead XY location reported "
#~ "by that command. For example if one sees:"
#~ msgstr ""

#~ msgid "Recv: // toolhead: X:46.500000 Y:27.000000 Z:15.000000 E:0.000000\n"
#~ msgstr ""

#~ msgid ""
#~ "then one would record a probe X position of 46.5 and probe Y position of 27."
#~ msgstr ""

#~ msgid ""
#~ "After recording the probe position, issue a series of G1 commands until the "
#~ "nozzle is directly above the mark on the bed. For example, one might issue:"
#~ msgstr ""

#~ msgid "G1 F300 X57 Y30 Z15\n"
#~ msgstr ""

#~ msgid ""
#~ "to move the nozzle to an X position of 57 and Y of 30. Once one finds the "
#~ "position directly above the mark, use the `GET_POSITION` command to report "
#~ "that position. This is the nozzle position."
#~ msgstr ""

#~ msgid ""
#~ "The x_offset is then the `nozzle_x_position - probe_x_position` and y_offset"
#~ " is similarly the `nozzle_y_position - probe_y_position`. Update the "
#~ "printer.cfg file with the given values, remove the tape/marks from the bed, "
#~ "and then issue a `RESTART` command so that the new values take effect."
#~ msgstr ""

#~ msgid "Calibrating probe Z offset"
#~ msgstr ""

#~ msgid ""
#~ "Providing an accurate probe z_offset is critical to obtaining high quality "
#~ "prints. The z_offset is the distance between the nozzle and bed when the "
#~ "probe triggers. The Klipper `PROBE_CALIBRATE` tool can be used to obtain "
#~ "this value - it will run an automatic probe to measure the probe's Z trigger"
#~ " position and then start a manual probe to obtain the nozzle Z height. The "
#~ "probe z_offset will then be calculated from these measurements."
#~ msgstr ""

#~ msgid ""
#~ "Start by homing the printer and then move the head to a position near the "
#~ "center of the bed. Navigate to the OctoPrint terminal tab and run the "
#~ "`PROBE_CALIBRATE` command to start the tool."
#~ msgstr ""

#~ msgid ""
#~ "This tool will perform an automatic probe, then lift the head, move the "
#~ "nozzle over the location of the probe point, and start the manual probe "
#~ "tool. If the nozzle does not move to a position above the automatic probe "
#~ "point, then `ABORT` the manual probe tool and perform the XY probe offset "
#~ "calibration described above."
#~ msgstr ""

#~ msgid ""
#~ "Once the manual probe tool starts, follow the steps described at [\"the "
#~ "paper test\"](Bed_Level.md#the-paper-test)) to determine the actual distance"
#~ " between the nozzle and bed at the given location. Once those steps are "
#~ "complete one can `ACCEPT` the position and save the results to the config "
#~ "file with:"
#~ msgstr ""

#~ msgid "SAVE_CONFIG\n"
#~ msgstr ""

#~ msgid ""
#~ "Note that if a change is made to the printer's motion system, hotend "
#~ "position, or probe location then it will invalidate the results of "
#~ "PROBE_CALIBRATE."
#~ msgstr ""

#~ msgid ""
#~ "If the probe has an X or Y offset and the bed tilt is changed (eg, by "
#~ "adjusting bed screws, running DELTA_CALIBRATE, running Z_TILT_ADJUST, "
#~ "running QUAD_GANTRY_LEVEL, or similar) then it will invalidate the results "
#~ "of PROBE_CALIBRATE. After making any of the above adjustments it will be "
#~ "necessary to run PROBE_CALIBRATE again."
#~ msgstr ""

#~ msgid ""
#~ "If the results of PROBE_CALIBRATE are invalidated, then any previous [bed "
#~ "mesh](Bed_Mesh.md) results that were obtained using the probe are also "
#~ "invalidated - it will be necessary to rerun BED_MESH_CALIBRATE after "
#~ "recalibrating the probe."
#~ msgstr ""

#~ msgid "Repeatability check"
#~ msgstr ""

#~ msgid ""
#~ "After calibrating the probe X, Y, and Z offsets it is a good idea to verify "
#~ "that the probe provides repeatable results. Start by homing the printer and "
#~ "then move the head to a position near the center of the bed. Navigate to the"
#~ " OctoPrint terminal tab and run the `PROBE_ACCURACY` command."
#~ msgstr ""

#~ msgid ""
#~ "This command will run the probe ten times and produce output similar to the "
#~ "following:"
#~ msgstr ""

#~ msgid ""
#~ "Recv: // probe accuracy: at X:0.000 Y:0.000 Z:10.000\n"
#~ "Recv: // and read 10 times with speed of 5 mm/s\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.506948\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.519448\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.519448\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.506948\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.519448\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.519448\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.506948\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.506948\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.519448\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.506948\n"
#~ "Recv: // probe accuracy results: maximum 2.519448, minimum 2.506948, range 0.012500, average 2.513198, median 2.513198, standard deviation 0.006250\n"
#~ msgstr ""

#~ msgid ""
#~ "Ideally the tool will report an identical maximum and minimum value. (That "
#~ "is, ideally the probe obtains an identical result on all ten probes.) "
#~ "However, it's normal for the minimum and maximum values to differ by one Z "
#~ "\"step distance\" or up to 5 microns (.005mm). A \"step distance\" is "
#~ "`rotation_distance/(full_steps_per_rotation*microsteps)`. The distance "
#~ "between the minimum and the maximum value is called the range. So, in the "
#~ "above example, since the printer uses a Z step distance of .0125, a range of"
#~ " 0.012500 would be considered normal."
#~ msgstr ""

#~ msgid ""
#~ "If the results of the test show a range value that is greater than 25 "
#~ "microns (.025mm) then the probe does not have sufficient accuracy for "
#~ "typical bed leveling procedures. It may be possible to tune the probe speed "
#~ "and/or probe start height to improve the repeatability of the probe. The "
#~ "`PROBE_ACCURACY` command allows one to run tests with different parameters "
#~ "to see their impact - see the [G-Codes document](G-Codes.md#probe_accuracy) "
#~ "for further details. If the probe generally obtains repeatable results but "
#~ "has an occasional outlier, then it may be possible to account for that by "
#~ "using multiple samples on each probe - read the description of the probe "
#~ "`samples` config parameters in the [config "
#~ "reference](Config_Reference.md#probe) for more details."
#~ msgstr ""

#~ msgid ""
#~ "If new probe speed, samples count, or other settings are needed, then update"
#~ " the printer.cfg file and issue a `RESTART` command. If so, it is a good "
#~ "idea to [calibrate the z_offset](#calibrating-probe-z-offset) again. If "
#~ "repeatable results can not be obtained then don't use the probe for bed "
#~ "leveling. Klipper has several manual probing tools that can be used instead "
#~ "- see the [Bed Level document](Bed_Level.md) for further details."
#~ msgstr ""

#~ msgid "Location Bias Check"
#~ msgstr ""

#~ msgid ""
#~ "Some probes can have a systemic bias that corrupts the results of the probe "
#~ "at certain toolhead locations. For example, if the probe mount tilts "
#~ "slightly when moving along the Y axis then it could result in the probe "
#~ "reporting biased results at different Y positions."
#~ msgstr ""

#~ msgid ""
#~ "This is a common issue with probes on delta printers, however it can occur "
#~ "on all printers."
#~ msgstr ""

#~ msgid ""
#~ "One can check for a location bias by using the `PROBE_CALIBRATE` command to "
#~ "measuring the probe z_offset at various X and Y locations. Ideally, the "
#~ "probe z_offset would be a constant value at every printer location."
#~ msgstr ""

#~ msgid ""
#~ "For delta printers, try measuring the z_offset at a position near the A "
#~ "tower, at a position near the B tower, and at a position near the C tower. "
#~ "For cartesian, corexy, and similar printers, try measuring the z_offset at "
#~ "positions near the four corners of the bed."
#~ msgstr ""

#~ msgid ""
#~ "Before starting this test, first calibrate the probe X, Y, and Z offsets as "
#~ "described at the beginning of this document. Then home the printer and "
#~ "navigate to the first XY position. Follow the steps at [calibrating probe Z "
#~ "offset](#calibrating-probe-z-offset) to run the `PROBE_CALIBRATE` command, "
#~ "`TESTZ` commands, and `ACCEPT` command, but do not run `SAVE_CONFIG`. Note "
#~ "the reported z_offset found. Then navigate to the other XY positions, repeat"
#~ " these `PROBE_CALIBRATE` steps, and note the reported z_offset."
#~ msgstr ""

#~ msgid ""
#~ "If the difference between the minimum reported z_offset and the maximum "
#~ "reported z_offset is greater than 25 microns (.025mm) then the probe is not "
#~ "suitable for typical bed leveling procedures. See the [Bed Level "
#~ "document](Bed_Level.md) for manual probe alternatives."
#~ msgstr ""

#~ msgid "Temperature Bias"
#~ msgstr ""

#~ msgid ""
#~ "Many probes have a systemic bias when probing at different temperatures. For"
#~ " example, the probe may consistently trigger at a lower height when the "
#~ "probe is at a higher temperature."
#~ msgstr ""

#~ msgid ""
#~ "It is recommended to run the bed leveling tools at a consistent temperature "
#~ "to account for this bias. For example, either always run the tools when the "
#~ "printer is at room temperature, or always run the tools after the printer "
#~ "has obtained a consistent print temperature. In either case, it is a good "
#~ "idea to wait several minutes after the desired temperature is reached, so "
#~ "that the printer apparatus is consistently at the desired temperature."
#~ msgstr ""

#~ msgid ""
#~ "To check for a temperature bias, start with the printer at room temperature "
#~ "and then home the printer, move the head to a position near the center of "
#~ "the bed, and run the `PROBE_ACCURACY` command. Note the results. Then, "
#~ "without homing or disabling the stepper motors, heat the printer nozzle and "
#~ "bed to printing temperature, and run the `PROBE_ACCURACY` command again. "
#~ "Ideally, the command will report identical results. As above, if the probe "
#~ "does have a temperature bias then be careful to always use the probe at a "
#~ "consistent temperature."
#~ msgstr ""

#~ msgid "Pressure advance"
#~ msgstr ""

#~ msgid ""
#~ "This document provides information on tuning the \"pressure advance\" "
#~ "configuration variable for a particular nozzle and filament. The pressure "
#~ "advance feature can be helpful in reducing ooze. For more information on how"
#~ " pressure advance is implemented see the [kinematics](Kinematics.md) "
#~ "document."
#~ msgstr ""

#~ msgid "Tuning pressure advance"
#~ msgstr ""

#~ msgid ""
#~ "Pressure advance does two useful things - it reduces ooze during non-extrude"
#~ " moves and it reduces blobbing during cornering. This guide uses the second "
#~ "feature (reducing blobbing during cornering) as a mechanism for tuning."
#~ msgstr ""

#~ msgid ""
#~ "In order to calibrate pressure advance the printer must be configured and "
#~ "operational as the tuning test involves printing and inspecting a test "
#~ "object. It is a good idea to read this document in full prior to running the"
#~ " test."
#~ msgstr ""

#~ msgid ""
#~ "Use a slicer to generate g-code for the large hollow square found in "
#~ "[docs/prints/square_tower.stl](prints/square_tower.stl). Use a high speed "
#~ "(eg, 100mm/s), zero infill, and a coarse layer height (the layer height "
#~ "should be around 75% of the nozzle diameter). Make sure any \"dynamic "
#~ "acceleration control\" is disabled in the slicer."
#~ msgstr ""

#~ msgid "Prepare for the test by issuing the following G-Code command:"
#~ msgstr ""

#~ msgid "SET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY=1 ACCEL=500\n"
#~ msgstr ""

#~ msgid ""
#~ "This command makes the nozzle travel slower through corners to emphasize the"
#~ " effects of extruder pressure. Then for printers with a direct drive "
#~ "extruder run the command:"
#~ msgstr ""

#~ msgid ""
#~ "TUNING_TOWER COMMAND=SET_PRESSURE_ADVANCE PARAMETER=ADVANCE START=0 "
#~ "FACTOR=.005\n"
#~ msgstr ""

#~ msgid "For long bowden extruders use:"
#~ msgstr ""

#~ msgid ""
#~ "TUNING_TOWER COMMAND=SET_PRESSURE_ADVANCE PARAMETER=ADVANCE START=0 "
#~ "FACTOR=.020\n"
#~ msgstr ""

#~ msgid "Then print the object. When fully printed the test print looks like:"
#~ msgstr ""

#~ msgid "![tuning_tower](img/tuning_tower.jpg)"
#~ msgstr ""

#~ msgid ""
#~ "The above TUNING_TOWER command instructs Klipper to alter the "
#~ "pressure_advance setting on each layer of the print. Higher layers in the "
#~ "print will have a larger pressure advance value set. Layers below the ideal "
#~ "pressure_advance setting will have blobbing at the corners, and layers above"
#~ " the ideal setting can lead to rounded corners and poor extrusion leading up"
#~ " to the corner."
#~ msgstr ""

#~ msgid ""
#~ "One can cancel the print early if one observes that the corners are no "
#~ "longer printing well (and thus one can avoid printing layers that are known "
#~ "to be above the ideal pressure_advance value)."
#~ msgstr ""

#~ msgid ""
#~ "Inspect the print and then use a digital calipers to find the height that "
#~ "has the best quality corners. When in doubt, prefer a lower height."
#~ msgstr ""

#~ msgid "![tune_pa](img/tune_pa.jpg)"
#~ msgstr ""

#~ msgid ""
#~ "The pressure_advance value can then be calculated as `pressure_advance = "
#~ "<start> + <measured_height> * <factor>`. (For example, `0 + 12.90 * .020` "
#~ "would be `.258`.)"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to choose custom settings for START and FACTOR if that helps "
#~ "identify the best pressure advance setting. When doing this, be sure to "
#~ "issue the TUNING_TOWER command at the start of each test print."
#~ msgstr ""

#~ msgid ""
#~ "Typical pressure advance values are between 0.050 and 1.000 (the high end "
#~ "usually only with bowden extruders). If there is no significant improvement "
#~ "with a pressure advance up to 1.000, then pressure advance is unlikely to "
#~ "improve the quality of prints. Return to a default configuration with "
#~ "pressure advance disabled."
#~ msgstr ""

#~ msgid ""
#~ "Although this tuning exercise directly improves the quality of corners, it's"
#~ " worth remembering that a good pressure advance configuration also reduces "
#~ "ooze throughout the print."
#~ msgstr ""

#~ msgid ""
#~ "At the completion of this test, set `pressure_advance = <calculated_value>` "
#~ "in the `[extruder]` section of the configuration file and issue a RESTART "
#~ "command. The RESTART command will clear the test state and return the "
#~ "acceleration and cornering speeds to their normal values."
#~ msgstr ""

#~ msgid "Important Notes"
#~ msgstr ""

#~ msgid ""
#~ "The pressure advance value is dependent on the extruder, the nozzle, and the"
#~ " filament. It is common for filament from different manufactures or with "
#~ "different pigments to require significantly different pressure advance "
#~ "values. Therefore, one should calibrate pressure advance on each printer and"
#~ " with each spool of filament."
#~ msgstr ""

#~ msgid ""
#~ "Printing temperature and extrusion rates can impact pressure advance. Be "
#~ "sure to tune the [extruder "
#~ "rotation_distance](Rotation_Distance.md#calibrating-rotation_distance-on-"
#~ "extruders) and [nozzle "
#~ "temperature](http://reprap.org/wiki/Triffid_Hunter%27s_Calibration_Guide#Nozzle_Temperature)"
#~ " prior to tuning pressure advance."
#~ msgstr ""

#~ msgid ""
#~ "The test print is designed to run with a high extruder flow rate, but "
#~ "otherwise \"normal\" slicer settings. A high flow rate is obtained by using "
#~ "a high printing speed (eg, 100mm/s) and a coarse layer height (typically "
#~ "around 75% of the nozzle diameter). Other slicer settings should be similar "
#~ "to their defaults (eg, perimeters of 2 or 3 lines, normal retraction "
#~ "amount). It can be useful to set the external perimeter speed to be the same"
#~ " speed as the rest of the print, but it is not a requirement."
#~ msgstr ""

#~ msgid ""
#~ "It is common for the test print to show different behavior on each corner. "
#~ "Often the slicer will arrange to change layers at one corner which can "
#~ "result in that corner being significantly different from the remaining three"
#~ " corners. If this occurs, then ignore that corner and tune pressure advance "
#~ "using the other three corners. It is also common for the remaining corners "
#~ "to vary slightly. (This can occur due to small differences in how the "
#~ "printer's frame reacts to cornering in certain directions.) Try to choose a "
#~ "value that works well for all the remaining corners. If in doubt, prefer a "
#~ "lower pressure advance value."
#~ msgstr ""

#~ msgid ""
#~ "If a high pressure advance value (eg, over 0.200) is used then one may find "
#~ "that the extruder skips when returning to the printer's normal acceleration."
#~ " The pressure advance system accounts for pressure by pushing in extra "
#~ "filament during acceleration and retracting that filament during "
#~ "deceleration. With a high acceleration and high pressure advance the "
#~ "extruder may not have enough torque to push the required filament. If this "
#~ "occurs, either use a lower acceleration value or disable pressure advance."
#~ msgstr ""

#~ msgid ""
#~ "Once pressure advance is tuned in Klipper, it may still be useful to "
#~ "configure a small retract value in the slicer (eg, 0.75mm) and to utilize "
#~ "the slicer's \"wipe on retract option\" if available. These slicer settings "
#~ "may help counteract ooze caused by filament cohesion (filament pulled out of"
#~ " the nozzle due to the stickiness of the plastic). It is recommended to "
#~ "disable the slicer's \"z-lift on retract\" option."
#~ msgstr ""

#~ msgid ""
#~ "The pressure advance system does not change the timing or path of the "
#~ "toolhead. A print with pressure advance enabled will take the same amount of"
#~ " time as a print without pressure advance. Pressure advance also does not "
#~ "change the total amount of filament extruded during a print. Pressure "
#~ "advance results in extra extruder movement during move acceleration and "
#~ "deceleration. A very high pressure advance setting will result in a very "
#~ "large amount of extruder movement during acceleration and deceleration, and "
#~ "no configuration setting places a limit on the amount of that movement."
#~ msgstr ""

#~ msgid "Packaging Klipper"
#~ msgstr ""

#~ msgid ""
#~ "Klipper is somewhat of a packaging anomaly among python programs, as it "
#~ "doesn't use setuptools to build and install. Some notes regarding how best "
#~ "to package it are as follows:"
#~ msgstr ""

#~ msgid "C modules"
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses a C module to handle some kinematics calculations more quickly."
#~ " This module needs to be compiled at packaging time to avoid introducing a "
#~ "runtime dependency on a compiler. To compile the C module, run `python2 "
#~ "klippy/chelper/__init__.py`."
#~ msgstr ""

#~ msgid "Compiling python code"
#~ msgstr ""

#~ msgid ""
#~ "Many distributions have a policy of compiling all python code before "
#~ "packaging to improve startup time. You can do this by running `python2 -m "
#~ "compileall klippy`."
#~ msgstr ""

#~ msgid "Versioning"
#~ msgstr ""

#~ msgid ""
#~ "If you are building a package of Klipper from git, it is usual practice not "
#~ "to ship a .git directory, so the versioning must be handled without git. To "
#~ "do this, use the script shipped in `scripts/make_version.py` which should be"
#~ " run as follows: `python2 scripts/make_version.py YOURDISTRONAME > "
#~ "klippy/.version`."
#~ msgstr ""

#~ msgid "Sample packaging script"
#~ msgstr ""

#~ msgid ""
#~ "klipper-git is packaged for Arch Linux, and has a PKGBUILD (package build "
#~ "script) available at [Arch User "
#~ "Repositiory](https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=klipper-"
#~ "git)."
#~ msgstr ""

#~ msgid "Installation and Configuration"
#~ msgstr ""

#~ msgid "Developer Documentation"
#~ msgstr ""

#~ msgid "Device Specific Documents"
#~ msgstr ""

#~ msgid "Overview"
#~ msgstr ""

#~ msgid ""
#~ "Welcome to the Klipper documentation. If new to Klipper, start with the "
#~ "[features](Features.md) and [installation](Installation.md) documents."
#~ msgstr ""

#~ msgid "Overview information"
#~ msgstr ""

#~ msgid "[Features](Features.md): A high-level list of features in Klipper."
#~ msgstr ""

#~ msgid "[FAQ](FAQ.md): Frequently asked questions."
#~ msgstr ""

#~ msgid "[Releases](Releases.md): The history of Klipper releases."
#~ msgstr ""

#~ msgid ""
#~ "[Config changes](Config_Changes.md): Recent software changes that may "
#~ "require users to update their printer config file."
#~ msgstr ""

#~ msgid ""
#~ "[Contact](Contact.md): Information on bug reporting and general "
#~ "communication with the Klipper developers."
#~ msgstr ""

#~ msgid "[Installation](Installation.md): Guide to installing Klipper."
#~ msgstr ""

#~ msgid ""
#~ "[Config Reference](Config_Reference.md): Description of config parameters."
#~ msgstr ""

#~ msgid ""
#~ "[Rotation Distance](Rotation_Distance.md): Calculating the rotation_distance"
#~ " stepper parameter."
#~ msgstr ""

#~ msgid ""
#~ "[Config checks](Config_checks.md): Verify basic pin settings in the config "
#~ "file."
#~ msgstr ""

#~ msgid "[Bed level](Bed_Level.md): Information on \"bed leveling\" in Klipper."
#~ msgstr ""

#~ msgid ""
#~ "[Delta calibrate](Delta_Calibrate.md): Calibration of delta kinematics."
#~ msgstr ""

#~ msgid ""
#~ "[Probe calibrate](Probe_Calibrate.md): Calibration of automatic Z probes."
#~ msgstr ""

#~ msgid "[BL-Touch](BLTouch.md): Configure a \"BL-Touch\" Z probe."
#~ msgstr ""

#~ msgid ""
#~ "[Manual level](Manual_Level.md): Calibration of Z endstops (and similar)."
#~ msgstr ""

#~ msgid "[Bed Mesh](Bed_Mesh.md): Bed height correction based on XY locations."
#~ msgstr ""

#~ msgid ""
#~ "[Endstop phase](Endstop_Phase.md): Stepper assisted Z endstop positioning."
#~ msgstr ""

#~ msgid ""
#~ "[Resonance compensation](Resonance_Compensation.md): A tool to reduce "
#~ "ringing in prints."
#~ msgstr ""

#~ msgid ""
#~ "[Measuring resonances](Measuring_Resonances.md): Information on using "
#~ "adxl345 accelerometer hardware to measure resonance."
#~ msgstr ""

#~ msgid "[Pressure advance](Pressure_Advance.md): Calibrate extruder pressure."
#~ msgstr ""

#~ msgid "[G-Codes](G-Codes.md): Information on commands supported by Klipper."
#~ msgstr ""

#~ msgid ""
#~ "[Command Templates](Command_Templates.md): G-Code macros and conditional "
#~ "evaluation."
#~ msgstr ""

#~ msgid ""
#~ "[Status Reference](Status_Reference.md): Information available to macros "
#~ "(and similar)."
#~ msgstr ""

#~ msgid ""
#~ "[TMC Drivers](TMC_Drivers.md): Using Trinamic stepper motor drivers with "
#~ "Klipper."
#~ msgstr ""

#~ msgid ""
#~ "[Multi-MCU Homing](Multi_MCU_Homing.md): Homing and probing using multiple "
#~ "micro-controllers."
#~ msgstr ""

#~ msgid "[Slicers](Slicers.md): Configure \"slicer\" software for Klipper."
#~ msgstr ""

#~ msgid ""
#~ "[Skew correction](Skew_Correction.md): Adjustments for axes not perfectly "
#~ "square."
#~ msgstr ""

#~ msgid ""
#~ "[PWM tools](Using_PWM_Tools.md): Guide on how to use PWM controlled tools "
#~ "such as lasers or spindles."
#~ msgstr ""

#~ msgid ""
#~ "[Exclude Object](Exclude_Object.md): The guide to the Exclude Objecs "
#~ "implementation."
#~ msgstr ""

#~ msgid "[Code overview](Code_Overview.md): Developers should read this first."
#~ msgstr ""

#~ msgid ""
#~ "[Kinematics](Kinematics.md): Technical details on how Klipper implements "
#~ "motion."
#~ msgstr ""

#~ msgid ""
#~ "[Protocol](Protocol.md): Information on the low-level messaging protocol "
#~ "between host and micro-controller."
#~ msgstr ""

#~ msgid ""
#~ "[API Server](API_Server.md): Information on Klipper's command and control "
#~ "API."
#~ msgstr ""

#~ msgid ""
#~ "[MCU commands](MCU_Commands.md): A description of low-level commands "
#~ "implemented in the micro-controller software."
#~ msgstr ""

#~ msgid ""
#~ "[CAN bus protocol](CANBUS_protocol.md): Klipper CAN bus message format."
#~ msgstr ""

#~ msgid ""
#~ "[Debugging](Debugging.md): Information on how to test and debug Klipper."
#~ msgstr ""

#~ msgid ""
#~ "[Benchmarks](Benchmarks.md): Information on the Klipper benchmark method."
#~ msgstr ""

#~ msgid ""
#~ "[Contributing](CONTRIBUTING.md): Information on how to submit improvements "
#~ "to Klipper."
#~ msgstr ""

#~ msgid "[Packaging](Packaging.md): Information on building OS packages."
#~ msgstr ""

#~ msgid ""
#~ "[Example configs](Example_Configs.md): Information on adding an example "
#~ "config file to Klipper."
#~ msgstr ""

#~ msgid ""
#~ "[SDCard Updates](SDCard_Updates.md): Flash a micro-controller by copying a "
#~ "binary to an sdcard in the micro-controller."
#~ msgstr ""

#~ msgid ""
#~ "[Raspberry Pi as Micro-controller](RPi_microcontroller.md): Details for "
#~ "controlling devices wired to the GPIO pins of a Raspberry Pi."
#~ msgstr ""

#~ msgid ""
#~ "[Beaglebone](Beaglebone.md): Details for running Klipper on the Beaglebone "
#~ "PRU."
#~ msgstr ""

#~ msgid ""
#~ "[Bootloaders](Bootloaders.md): Developer information on micro-controller "
#~ "flashing."
#~ msgstr ""

#~ msgid "[CAN bus](CANBUS.md): Information on using CAN bus with Klipper."
#~ msgstr ""

#~ msgid "[TSL1401CL filament width sensor](TSL1401CL_Filament_Width_Sensor.md)"
#~ msgstr ""

#~ msgid "[Hall filament width sensor](Hall_Filament_Width_Sensor.md)"
#~ msgstr ""

#~ msgid "Klipper documentation"
#~ msgstr ""

#~ msgid "Configuration Reference"
#~ msgstr ""

#~ msgid "Bed Level"
#~ msgstr ""

#~ msgid "Command templates"
#~ msgstr ""

#~ msgid "Multiple Micro-controller Homing and Probing"
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports a mechanism for homing with an endstop attached to one "
#~ "micro-controller while its stepper motors are on a different micro-"
#~ "controller. This support is referred to as \"multi-mcu homing\". This "
#~ "feature is also used when a Z probe is on a different micro-controller than "
#~ "the Z stepper motors."
#~ msgstr ""

#~ msgid ""
#~ "This feature can be useful to simplify wiring, as it may be more convenient "
#~ "to attach an endstop or probe to a closer micro-controller. However, using "
#~ "this feature may result in \"overshoot\" of the stepper motors during homing"
#~ " and probing operations."
#~ msgstr ""

#~ msgid ""
#~ "The overshoot occurs due to possible message transmission delays between the"
#~ " micro-controller monitoring the endstop and the micro-controllers moving "
#~ "the stepper motors. The Klipper code is designed to limit this delay to no "
#~ "more than 25ms. (When multi-mcu homing is activated, the micro-controllers "
#~ "send periodic status messages and check that corresponding status messages "
#~ "are received within 25ms.)"
#~ msgstr ""

#~ msgid ""
#~ "So, for example, if homing at 10mm/s then it is possible for an overshoot of"
#~ " up to 0.250mm (10mm/s * .025s == 0.250mm). Care should be taken when "
#~ "configuring multi-mcu homing to account for this type of overshoot. Using "
#~ "slower homing or probing speeds can reduce the overshoot."
#~ msgstr ""

#~ msgid ""
#~ "Stepper motor overshoot should not adversely impact the precision of the "
#~ "homing and probing procedure. The Klipper code will detect the overshoot and"
#~ " account for it in its calculations. However, it is important that the "
#~ "hardware design is capable of handling overshoot without causing damage to "
#~ "the machine."
#~ msgstr ""

#~ msgid ""
#~ "Should Klipper detect a communication issue between micro-controllers during"
#~ " multi-mcu homing then it will raise a \"Communication timeout during "
#~ "homing\" error."
#~ msgstr ""

#~ msgid ""
#~ "Note that an axis with multiple steppers (eg, `stepper_z` and `stepper_z1`) "
#~ "need to be on the same micro-controller in order to use multi-mcu homing. "
#~ "For example, if an endstop is on a separate micro-controller from "
#~ "`stepper_z` then `stepper_z1` must be on the same micro-controller as "
#~ "`stepper_z`."
#~ msgstr ""

#~ msgid "Measuring Resonances"
#~ msgstr ""

#~ msgid ""
#~ "Klipper has built-in support for ADXL345 accelerometer, which can be used to"
#~ " measure resonance frequencies of the printer for different axes, and auto-"
#~ "tune [input shapers](Resonance_Compensation.md) to compensate for "
#~ "resonances. Note that using ADXL345 requires some soldering and crimping. "
#~ "ADXL345 can be connected to a Raspberry Pi directly, or to an SPI interface "
#~ "of an MCU board (it needs to be reasonably fast)."
#~ msgstr ""

#~ msgid ""
#~ "When sourcing ADXL345, be aware that there is a variety of different PCB "
#~ "board designs and different clones of them. Make sure that the board "
#~ "supports SPI mode (small number of boards appear to be hard-configured for "
#~ "I2C by pulling SDO to GND), and, if it is going to be connected to a 5V "
#~ "printer MCU, that it has a voltage regulator and a level shifter."
#~ msgstr ""

#~ msgid "Installation instructions"
#~ msgstr ""

#~ msgid "Wiring"
#~ msgstr ""

#~ msgid ""
#~ "An ethernet cable with shielded twisted pairs (cat5e or better) is "
#~ "recommended for signal integrety over a long distance. If you still "
#~ "experience signal integrity issues (SPI/I2C errors), shorten the cable."
#~ msgstr ""

#~ msgid "Connect ethernet cable shielding to the controller board/RPI ground."
#~ msgstr ""

#~ msgid ""
#~ "***Double-check your wiring before powering up to prevent damaging your "
#~ "MCU/Raspberry Pi or the accelerometer.***"
#~ msgstr ""

#~ msgid "SPI Accelerometers"
#~ msgstr ""

#~ msgid "Suggested twisted pair order:"
#~ msgstr ""

#~ msgid ""
#~ "GND+MISO\n"
#~ "3.3V+MOSI\n"
#~ "SCLK+CS\n"
#~ msgstr ""

#~ msgid "ADXL345"
#~ msgstr ""

#~ msgid ""
#~ "**Note: Many MCUs will work with an ADXL345 in SPI mode(eg Pi Pico), wiring "
#~ "and configuration will vary according to your specific board and avaliable "
#~ "pins.**"
#~ msgstr ""

#~ msgid ""
#~ "You need to connect ADXL345 to your Raspberry Pi via SPI. Note that the I2C "
#~ "connection, which is suggested by ADXL345 documentation, has too low "
#~ "throughput and **will not work**. The recommended connection scheme:"
#~ msgstr ""

#~ msgid "ADXL345 pin"
#~ msgstr ""

#~ msgid "RPi pin"
#~ msgstr ""

#~ msgid "RPi pin name"
#~ msgstr ""

#~ msgid "3V3 (or VCC)"
#~ msgstr ""

#~ msgid "01"
#~ msgstr ""

#~ msgid "3.3v DC power"
#~ msgstr ""

#~ msgid "06"
#~ msgstr ""

#~ msgid "Ground"
#~ msgstr ""

#~ msgid "24"
#~ msgstr ""

#~ msgid "GPIO08 (SPI0_CE0_N)"
#~ msgstr ""

#~ msgid "SDO"
#~ msgstr ""

#~ msgid "21"
#~ msgstr ""

#~ msgid "GPIO09 (SPI0_MISO)"
#~ msgstr ""

#~ msgid "SDA"
#~ msgstr ""

#~ msgid "GPIO10 (SPI0_MOSI)"
#~ msgstr ""

#~ msgid "SCL"
#~ msgstr ""

#~ msgid "23"
#~ msgstr ""

#~ msgid "GPIO11 (SPI0_SCLK)"
#~ msgstr ""

#~ msgid "Fritzing wiring diagrams for some of the ADXL345 boards:"
#~ msgstr ""

#~ msgid "![ADXL345-Rpi](img/adxl345-fritzing.png)"
#~ msgstr ""

#~ msgid "I2C Accelerometers"
#~ msgstr ""

#~ msgid ""
#~ "3.3V+SDA\n"
#~ "GND+SCL\n"
#~ msgstr ""

#~ msgid "MPU-9250/MPU-9255/MPU-6515/MPU-6050/MPU-6500"
#~ msgstr ""

#~ msgid ""
#~ "Alternatives to the ADXL345 are "
#~ "MPU-9250/MPU-9255/MPU-6515/MPU-6050/MPU-6500. These accelerometers have been"
#~ " tested to work over I2C on the RPi or RP2040(pico) at 400kbaud."
#~ msgstr ""

#~ msgid "Recommended connection scheme for I2C on the Raspberry Pi:"
#~ msgstr ""

#~ msgid "MPU-9250 pin"
#~ msgstr ""

#~ msgid "VCC"
#~ msgstr ""

#~ msgid "09"
#~ msgstr ""

#~ msgid "03"
#~ msgstr ""

#~ msgid "GPIO02 (SDA1)"
#~ msgstr ""

#~ msgid "05"
#~ msgstr ""

#~ msgid "GPIO03 (SCL1)"
#~ msgstr ""

#~ msgid "![MPU-9250 connected to RPI](img/mpu9250-PI-fritzing.png)"
#~ msgstr ""

#~ msgid "Recommended connection scheme for I2C(i2c0a) on the RP2040:"
#~ msgstr ""

#~ msgid "RP2040 pin"
#~ msgstr ""

#~ msgid "39"
#~ msgstr ""

#~ msgid "3v3"
#~ msgstr ""

#~ msgid "38"
#~ msgstr ""

#~ msgid "GP0 (I2C0 SDA)"
#~ msgstr ""

#~ msgid "02"
#~ msgstr ""

#~ msgid "GP1 (I2C0 SCL)"
#~ msgstr ""

#~ msgid "![MPU-9250 connected to PICO](img/mpu9250-PICO-fritzing.png)"
#~ msgstr ""

#~ msgid "Mounting the accelerometer"
#~ msgstr ""

#~ msgid ""
#~ "The accelerometer must be attached to the toolhead. One needs to design a "
#~ "proper mount that fits their own 3D printer. It is better to align the axes "
#~ "of the accelerometer with the printer's axes (but if it makes it more "
#~ "convenient, axes can be swapped - i.e. no need to align X axis with X and so"
#~ " forth - it should be fine even if Z axis of accelerometer is X axis of the "
#~ "printer, etc.)."
#~ msgstr ""

#~ msgid "An example of mounting ADXL345 on the SmartEffector:"
#~ msgstr ""

#~ msgid "![ADXL345 on SmartEffector](img/adxl345-mount.jpg)"
#~ msgstr ""

#~ msgid ""
#~ "Note that on a bed slinger printer one must design 2 mounts: one for the "
#~ "toolhead and one for the bed, and run the measurements twice. See the "
#~ "corresponding [section](#bed-slinger-printers) for more details."
#~ msgstr ""

#~ msgid ""
#~ "**Attention:** make sure the accelerometer and any screws that hold it in "
#~ "place do not touch any metal parts of the printer. Basically, the mount must"
#~ " be designed such as to ensure the electrical isolation of the accelerometer"
#~ " from the printer frame. Failing to ensure that can create a ground loop in "
#~ "the system that may damage the electronics."
#~ msgstr ""

#~ msgid "Software installation"
#~ msgstr ""

#~ msgid ""
#~ "Note that resonance measurements and shaper auto-calibration require "
#~ "additional software dependencies not installed by default. First, run on "
#~ "your Raspberry Pi the following commands:"
#~ msgstr ""

#~ msgid ""
#~ "sudo apt update\n"
#~ "sudo apt install python3-numpy python3-matplotlib libatlas-base-dev\n"
#~ msgstr ""

#~ msgid ""
#~ "Next, in order to install NumPy in the Klipper environment, run the command:"
#~ msgstr ""

#~ msgid "~/klippy-env/bin/pip install -v numpy\n"
#~ msgstr ""

#~ msgid ""
#~ "Note that, depending on the performance of the CPU, it may take *a lot* of "
#~ "time, up to 10-20 minutes. Be patient and wait for the completion of the "
#~ "installation. On some occasions, if the board has too little RAM the "
#~ "installation may fail and you will need to enable swap."
#~ msgstr ""

#~ msgid ""
#~ "Afterwards, check and follow the instructions in the [RPi Microcontroller "
#~ "document](RPi_microcontroller.md) to setup the \"linux mcu\" on the "
#~ "Raspberry Pi."
#~ msgstr ""

#~ msgid "Configure ADXL345 With RPi"
#~ msgstr ""

#~ msgid "Add the following to the printer.cfg file:"
#~ msgstr ""

#~ msgid ""
#~ "[mcu rpi]\n"
#~ "serial: /tmp/klipper_host_mcu\n"
#~ "\n"
#~ "[adxl345]\n"
#~ "cs_pin: rpi:None\n"
#~ "\n"
#~ "[resonance_tester]\n"
#~ "accel_chip: adxl345\n"
#~ "probe_points:\n"
#~ "    100, 100, 20  # an example\n"
#~ msgstr ""

#~ msgid ""
#~ "It is advised to start with 1 probe point, in the middle of the print bed, "
#~ "slightly above it."
#~ msgstr ""

#~ msgid "Configure MPU-6000/9000 series With RPi"
#~ msgstr ""

#~ msgid ""
#~ "Make sure the Linux I2C driver is enabled and the baud rate is set to 400000"
#~ " (see [Enabling I2C](RPi_microcontroller.md#optional-enabling-i2c) section "
#~ "for more details). Then, add the following to the printer.cfg:"
#~ msgstr ""

#~ msgid ""
#~ "[mcu rpi]\n"
#~ "serial: /tmp/klipper_host_mcu\n"
#~ "\n"
#~ "[mpu9250]\n"
#~ "i2c_mcu: rpi\n"
#~ "i2c_bus: i2c.1\n"
#~ "\n"
#~ "[resonance_tester]\n"
#~ "accel_chip: mpu9250\n"
#~ "probe_points:\n"
#~ "    100, 100, 20  # an example\n"
#~ msgstr ""

#~ msgid "Configure MPU-6000/9000 series With PICO"
#~ msgstr ""

#~ msgid ""
#~ "PICO I2C is set to 400000 on default. Simply add the following to the "
#~ "printer.cfg:"
#~ msgstr ""

#~ msgid ""
#~ "[mcu pico]\n"
#~ "serial: /dev/serial/by-id/<your PICO's serial ID>\n"
#~ "\n"
#~ "[mpu9250]\n"
#~ "i2c_mcu: pico\n"
#~ "i2c_bus: i2c1a\n"
#~ "\n"
#~ "[resonance_tester]\n"
#~ "accel_chip: mpu9250\n"
#~ "probe_points:\n"
#~ "    100, 100, 20  # an example\n"
#~ "\n"
#~ "[static_digital_output pico_3V3pwm] # Improve power stability\n"
#~ "pin: pico:gpio23\n"
#~ msgstr ""

#~ msgid "Restart Klipper via the `RESTART` command."
#~ msgstr ""

#~ msgid "Measuring the resonances"
#~ msgstr ""

#~ msgid "Checking the setup"
#~ msgstr ""

#~ msgid "Now you can test a connection."
#~ msgstr ""

#~ msgid ""
#~ "For \"non bed-slingers\" (e.g. one accelerometer), in Octoprint, enter "
#~ "`ACCELEROMETER_QUERY`"
#~ msgstr ""

#~ msgid ""
#~ "For \"bed-slingers\" (e.g. more than one accelerometer), enter "
#~ "`ACCELEROMETER_QUERY CHIP=<chip>` where `<chip>` is the name of the chip as-"
#~ "entered, e.g. `CHIP=bed` (see: [bed-slinger](#bed-slinger-printers)) for all"
#~ " installed accelerometer chips."
#~ msgstr ""

#~ msgid ""
#~ "You should see the current measurements from the accelerometer, including "
#~ "the free-fall acceleration, e.g."
#~ msgstr ""

#~ msgid "Recv: // adxl345 values (x, y, z): 470.719200, 941.438400, 9728.196800\n"
#~ msgstr ""

#~ msgid ""
#~ "If you get an error like `Invalid adxl345 id (got xx vs e5)`, where `xx` is "
#~ "some other ID, it is indicative of the connection problem with ADXL345, or "
#~ "the faulty sensor. Double-check the power, the wiring (that it matches the "
#~ "schematics, no wire is broken or loose, etc.), and soldering quality."
#~ msgstr ""

#~ msgid ""
#~ "**If you are using MPU-6000/9000 series accelerometer and it show up as "
#~ "`mpu-unknown`, use with caution! They are probably refurbished chips!**"
#~ msgstr ""

#~ msgid ""
#~ "Next, try running `MEASURE_AXES_NOISE` in Octoprint, you should get some "
#~ "baseline numbers for the noise of accelerometer on the axes (should be "
#~ "somewhere in the range of ~1-100). Too high axes noise (e.g. 1000 and more) "
#~ "can be indicative of the sensor issues, problems with its power, or too "
#~ "noisy imbalanced fans on a 3D printer."
#~ msgstr ""

#~ msgid "Now you can run some real-life tests. Run the following command:"
#~ msgstr ""

#~ msgid "TEST_RESONANCES AXIS=X\n"
#~ msgstr ""

#~ msgid ""
#~ "Note that it will create vibrations on X axis. It will also disable input "
#~ "shaping if it was enabled previously, as it is not valid to run the "
#~ "resonance testing with the input shaper enabled."
#~ msgstr ""

#~ msgid ""
#~ "**Attention!** Be sure to observe the printer for the first time, to make "
#~ "sure the vibrations do not become too violent (`M112` command can be used to"
#~ " abort the test in case of emergency; hopefully it will not come to this "
#~ "though). If the vibrations do get too strong, you can attempt to specify a "
#~ "lower than the default value for `accel_per_hz` parameter in "
#~ "`[resonance_tester]` section, e.g."
#~ msgstr ""

#~ msgid ""
#~ "[resonance_tester]\n"
#~ "accel_chip: adxl345\n"
#~ "accel_per_hz: 50  # default is 75\n"
#~ "probe_points: ...\n"
#~ msgstr ""

#~ msgid "If it works for X axis, run for Y axis as well:"
#~ msgstr ""

#~ msgid "TEST_RESONANCES AXIS=Y\n"
#~ msgstr ""

#~ msgid ""
#~ "This will generate 2 CSV files (`/tmp/resonances_x_*.csv` and "
#~ "`/tmp/resonances_y_*.csv`). These files can be processed with the stand-"
#~ "alone script on a Raspberry Pi. To do that, run the following commands:"
#~ msgstr ""

#~ msgid ""
#~ "~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png\n"
#~ "~/klipper/scripts/calibrate_shaper.py /tmp/resonances_y_*.csv -o /tmp/shaper_calibrate_y.png\n"
#~ msgstr ""

#~ msgid ""
#~ "This script will generate the charts `/tmp/shaper_calibrate_x.png` and "
#~ "`/tmp/shaper_calibrate_y.png` with frequency responses. You will also get "
#~ "the suggested frequencies for each input shaper, as well as which input "
#~ "shaper is recommended for your setup. For example:"
#~ msgstr ""

#~ msgid "![Resonances](img/calibrate-y.png)"
#~ msgstr ""

#~ msgid ""
#~ "Fitted shaper 'zv' frequency = 34.4 Hz (vibrations = 4.0%, smoothing ~= 0.132)\n"
#~ "To avoid too much smoothing with 'zv', suggested max_accel <= 4500 mm/sec^2\n"
#~ "Fitted shaper 'mzv' frequency = 34.6 Hz (vibrations = 0.0%, smoothing ~= 0.170)\n"
#~ "To avoid too much smoothing with 'mzv', suggested max_accel <= 3500 mm/sec^2\n"
#~ "Fitted shaper 'ei' frequency = 41.4 Hz (vibrations = 0.0%, smoothing ~= 0.188)\n"
#~ "To avoid too much smoothing with 'ei', suggested max_accel <= 3200 mm/sec^2\n"
#~ "Fitted shaper '2hump_ei' frequency = 51.8 Hz (vibrations = 0.0%, smoothing ~= 0.201)\n"
#~ "To avoid too much smoothing with '2hump_ei', suggested max_accel <= 3000 mm/sec^2\n"
#~ "Fitted shaper '3hump_ei' frequency = 61.8 Hz (vibrations = 0.0%, smoothing ~= 0.215)\n"
#~ "To avoid too much smoothing with '3hump_ei', suggested max_accel <= 2800 mm/sec^2\n"
#~ "Recommended shaper is mzv @ 34.6 Hz\n"
#~ msgstr ""

#~ msgid ""
#~ "The suggested configuration can be added to `[input_shaper]` section of "
#~ "`printer.cfg`, e.g.:"
#~ msgstr ""

#~ msgid ""
#~ "[input_shaper]\n"
#~ "shaper_freq_x: ...\n"
#~ "shaper_type_x: ...\n"
#~ "shaper_freq_y: 34.6\n"
#~ "shaper_type_y: mzv\n"
#~ "\n"
#~ "[printer]\n"
#~ "max_accel: 3000  # should not exceed the estimated max_accel for X and Y axes\n"
#~ msgstr ""

#~ msgid ""
#~ "or you can choose some other configuration yourself based on the generated "
#~ "charts: peaks in the power spectral density on the charts correspond to the "
#~ "resonance frequencies of the printer."
#~ msgstr ""

#~ msgid ""
#~ "Note that alternatively you can run the input shaper autocalibration from "
#~ "Klipper [directly](#input-shaper-auto-calibration), which can be convenient,"
#~ " for example, for the input shaper [re-calibration](#input-shaper-re-"
#~ "calibration)."
#~ msgstr ""

#~ msgid "Bed-slinger printers"
#~ msgstr ""

#~ msgid ""
#~ "If your printer is a bed slinger printer, you will need to change the "
#~ "location of the accelerometer between the measurements for X and Y axes: "
#~ "measure the resonances of X axis with the accelerometer attached to the "
#~ "toolhead and the resonances of Y axis - to the bed (the usual bed slinger "
#~ "setup)."
#~ msgstr ""

#~ msgid ""
#~ "However, you can also connect two accelerometers simultaneously, though they"
#~ " must be connected to different boards (say, to an RPi and printer MCU "
#~ "board), or to two different physical SPI interfaces on the same board "
#~ "(rarely available). Then they can be configured in the following manner:"
#~ msgstr ""

#~ msgid ""
#~ "[adxl345 hotend]\n"
#~ "# Assuming `hotend` chip is connected to an RPi\n"
#~ "cs_pin: rpi:None\n"
#~ "\n"
#~ "[adxl345 bed]\n"
#~ "# Assuming `bed` chip is connected to a printer MCU board\n"
#~ "cs_pin: ...  # Printer board SPI chip select (CS) pin\n"
#~ "\n"
#~ "[resonance_tester]\n"
#~ "# Assuming the typical setup of the bed slinger printer\n"
#~ "accel_chip_x: adxl345 hotend\n"
#~ "accel_chip_y: adxl345 bed\n"
#~ "probe_points: ...\n"
#~ msgstr ""

#~ msgid ""
#~ "Then the commands `TEST_RESONANCES AXIS=X` and `TEST_RESONANCES AXIS=Y` will"
#~ " use the correct accelerometer for each axis."
#~ msgstr ""

#~ msgid "Max smoothing"
#~ msgstr ""

#~ msgid ""
#~ "Keep in mind that the input shaper can create some smoothing in parts. "
#~ "Automatic tuning of the input shaper performed by `calibrate_shaper.py` "
#~ "script or `SHAPER_CALIBRATE` command tries not to exacerbate the smoothing, "
#~ "but at the same time they try to minimize the resulting vibrations. "
#~ "Sometimes they can make a sub-optimal choice of the shaper frequency, or "
#~ "maybe you simply prefer to have less smoothing in parts at the expense of a "
#~ "larger remaining vibrations. In these cases, you can request to limit the "
#~ "maximum smoothing from the input shaper."
#~ msgstr ""

#~ msgid "Let's consider the following results from the automatic tuning:"
#~ msgstr ""

#~ msgid "![Resonances](img/calibrate-x.png)"
#~ msgstr ""

#~ msgid ""
#~ "Fitted shaper 'zv' frequency = 57.8 Hz (vibrations = 20.3%, smoothing ~= 0.053)\n"
#~ "To avoid too much smoothing with 'zv', suggested max_accel <= 13000 mm/sec^2\n"
#~ "Fitted shaper 'mzv' frequency = 34.8 Hz (vibrations = 3.6%, smoothing ~= 0.168)\n"
#~ "To avoid too much smoothing with 'mzv', suggested max_accel <= 3600 mm/sec^2\n"
#~ "Fitted shaper 'ei' frequency = 48.8 Hz (vibrations = 4.9%, smoothing ~= 0.135)\n"
#~ "To avoid too much smoothing with 'ei', suggested max_accel <= 4400 mm/sec^2\n"
#~ "Fitted shaper '2hump_ei' frequency = 45.2 Hz (vibrations = 0.1%, smoothing ~= 0.264)\n"
#~ "To avoid too much smoothing with '2hump_ei', suggested max_accel <= 2200 mm/sec^2\n"
#~ "Fitted shaper '3hump_ei' frequency = 48.0 Hz (vibrations = 0.0%, smoothing ~= 0.356)\n"
#~ "To avoid too much smoothing with '3hump_ei', suggested max_accel <= 1500 mm/sec^2\n"
#~ "Recommended shaper is 2hump_ei @ 45.2 Hz\n"
#~ msgstr ""

#~ msgid ""
#~ "Note that the reported `smoothing` values are some abstract projected "
#~ "values. These values can be used to compare different configurations: the "
#~ "higher the value, the more smoothing a shaper will create. However, these "
#~ "smoothing scores do not represent any real measure of smoothing, because the"
#~ " actual smoothing depends on [`max_accel`](#selecting-max-accel) and "
#~ "`square_corner_velocity` parameters. Therefore, you should print some test "
#~ "prints to see how much smoothing exactly a chosen configuration creates."
#~ msgstr ""

#~ msgid ""
#~ "In the example above the suggested shaper parameters are not bad, but what "
#~ "if you want to get less smoothing on the X axis? You can try to limit the "
#~ "maximum shaper smoothing using the following command:"
#~ msgstr ""

#~ msgid ""
#~ "~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o "
#~ "/tmp/shaper_calibrate_x.png --max_smoothing=0.2\n"
#~ msgstr ""

#~ msgid ""
#~ "which limits the smoothing to 0.2 score. Now you can get the following "
#~ "result:"
#~ msgstr ""

#~ msgid "![Resonances](img/calibrate-x-max-smoothing.png)"
#~ msgstr ""

#~ msgid ""
#~ "Fitted shaper 'zv' frequency = 55.4 Hz (vibrations = 19.7%, smoothing ~= 0.057)\n"
#~ "To avoid too much smoothing with 'zv', suggested max_accel <= 12000 mm/sec^2\n"
#~ "Fitted shaper 'mzv' frequency = 34.6 Hz (vibrations = 3.6%, smoothing ~= 0.170)\n"
#~ "To avoid too much smoothing with 'mzv', suggested max_accel <= 3500 mm/sec^2\n"
#~ "Fitted shaper 'ei' frequency = 48.2 Hz (vibrations = 4.8%, smoothing ~= 0.139)\n"
#~ "To avoid too much smoothing with 'ei', suggested max_accel <= 4300 mm/sec^2\n"
#~ "Fitted shaper '2hump_ei' frequency = 52.0 Hz (vibrations = 2.7%, smoothing ~= 0.200)\n"
#~ "To avoid too much smoothing with '2hump_ei', suggested max_accel <= 3000 mm/sec^2\n"
#~ "Fitted shaper '3hump_ei' frequency = 72.6 Hz (vibrations = 1.4%, smoothing ~= 0.155)\n"
#~ "To avoid too much smoothing with '3hump_ei', suggested max_accel <= 3900 mm/sec^2\n"
#~ "Recommended shaper is 3hump_ei @ 72.6 Hz\n"
#~ msgstr ""

#~ msgid ""
#~ "If you compare to the previously suggested parameters, the vibrations are a "
#~ "bit larger, but the smoothing is significantly smaller than previously, "
#~ "allowing larger maximum acceleration."
#~ msgstr ""

#~ msgid ""
#~ "When deciding which `max_smoothing` parameter to choose, you can use a "
#~ "trial-and-error approach. Try a few different values and see which results "
#~ "you get. Note that the actual smoothing produced by the input shaper "
#~ "depends, primarily, on the lowest resonance frequency of the printer: the "
#~ "higher the frequency of the lowest resonance - the smaller the smoothing. "
#~ "Therefore, if you request the script to find a configuration of the input "
#~ "shaper with the unrealistically small smoothing, it will be at the expense "
#~ "of increased ringing at the lowest resonance frequencies (which are, "
#~ "typically, also more prominently visible in prints). So, always double-check"
#~ " the projected remaining vibrations reported by the script and make sure "
#~ "they are not too high."
#~ msgstr ""

#~ msgid ""
#~ "Note that if you chose a good `max_smoothing` value for both of your axes, "
#~ "you can store it in the `printer.cfg` as"
#~ msgstr ""

#~ msgid ""
#~ "[resonance_tester]\n"
#~ "accel_chip: ...\n"
#~ "probe_points: ...\n"
#~ "max_smoothing: 0.25  # an example\n"
#~ msgstr ""

#~ msgid ""
#~ "Then, if you [rerun](#input-shaper-re-calibration) the input shaper auto-"
#~ "tuning using `SHAPER_CALIBRATE` Klipper command in the future, it will use "
#~ "the stored `max_smoothing` value as a reference."
#~ msgstr ""

#~ msgid ""
#~ "Since the input shaper can create some smoothing in parts, especially at "
#~ "high accelerations, you will still need to choose the `max_accel` value that"
#~ " does not create too much smoothing in the printed parts. A calibration "
#~ "script provides an estimate for `max_accel` parameter that should not create"
#~ " too much smoothing. Note that the `max_accel` as displayed by the "
#~ "calibration script is only a theoretical maximum at which the respective "
#~ "shaper is still able to work without producing too much smoothing. It is by "
#~ "no means a recommendation to set this acceleration for printing. The maximum"
#~ " acceleration your printer is able to sustain depends on its mechanical "
#~ "properties and the maximum torque of the used stepper motors. Therefore, it "
#~ "is suggested to set `max_accel` in `[printer]` section that does not exceed "
#~ "the estimated values for X and Y axes, likely with some conservative safety "
#~ "margin."
#~ msgstr ""

#~ msgid ""
#~ "Alternatively, follow [this](Resonance_Compensation.md#selecting-max_accel) "
#~ "part of the input shaper tuning guide and print the test model to choose "
#~ "`max_accel` parameter experimentally."
#~ msgstr ""

#~ msgid ""
#~ "The same notice applies to the input shaper [auto-calibration](#input-"
#~ "shaper-auto-calibration) with `SHAPER_CALIBRATE` command: it is still "
#~ "necessary to choose the right `max_accel` value after the auto-calibration, "
#~ "and the suggested acceleration limits will not be applied automatically."
#~ msgstr ""

#~ msgid ""
#~ "If you are doing a shaper re-calibration and the reported smoothing for the "
#~ "suggested shaper configuration is almost the same as what you got during the"
#~ " previous calibration, this step can be skipped."
#~ msgstr ""

#~ msgid "Testing custom axes"
#~ msgstr ""

#~ msgid ""
#~ "`TEST_RESONANCES` command supports custom axes. While this is not really "
#~ "useful for input shaper calibration, it can be used to study printer "
#~ "resonances in-depth and to check, for example, belt tension."
#~ msgstr ""

#~ msgid "To check the belt tension on CoreXY printers, execute"
#~ msgstr ""

#~ msgid ""
#~ "TEST_RESONANCES AXIS=1,1 OUTPUT=raw_data\n"
#~ "TEST_RESONANCES AXIS=1,-1 OUTPUT=raw_data\n"
#~ msgstr ""

#~ msgid "and use `graph_accelerometer.py` to process the generated files, e.g."
#~ msgstr ""

#~ msgid ""
#~ "~/klipper/scripts/graph_accelerometer.py -c /tmp/raw_data_axis*.csv -o "
#~ "/tmp/resonances.png\n"
#~ msgstr ""

#~ msgid "which will generate `/tmp/resonances.png` comparing the resonances."
#~ msgstr ""

#~ msgid ""
#~ "For Delta printers with the default tower placement (tower A ~= 210 degrees,"
#~ " B ~= 330 degrees, and C ~= 90 degrees), execute"
#~ msgstr ""

#~ msgid ""
#~ "TEST_RESONANCES AXIS=0,1 OUTPUT=raw_data\n"
#~ "TEST_RESONANCES AXIS=-0.866025404,-0.5 OUTPUT=raw_data\n"
#~ "TEST_RESONANCES AXIS=0.866025404,-0.5 OUTPUT=raw_data\n"
#~ msgstr ""

#~ msgid "and then use the same command"
#~ msgstr ""

#~ msgid "to generate `/tmp/resonances.png` comparing the resonances."
#~ msgstr ""

#~ msgid "Input Shaper auto-calibration"
#~ msgstr ""

#~ msgid ""
#~ "Besides manually choosing the appropriate parameters for the input shaper "
#~ "feature, it is also possible to run the auto-tuning for the input shaper "
#~ "directly from Klipper. Run the following command via Octoprint terminal:"
#~ msgstr ""

#~ msgid "SHAPER_CALIBRATE\n"
#~ msgstr ""

#~ msgid ""
#~ "This will run the full test for both axes and generate the csv output "
#~ "(`/tmp/calibration_data_*.csv` by default) for the frequency response and "
#~ "the suggested input shapers. You will also get the suggested frequencies for"
#~ " each input shaper, as well as which input shaper is recommended for your "
#~ "setup, on Octoprint console. For example:"
#~ msgstr ""

#~ msgid ""
#~ "Calculating the best input shaper parameters for y axis\n"
#~ "Fitted shaper 'zv' frequency = 39.0 Hz (vibrations = 13.2%, smoothing ~= 0.105)\n"
#~ "To avoid too much smoothing with 'zv', suggested max_accel <= 5900 mm/sec^2\n"
#~ "Fitted shaper 'mzv' frequency = 36.8 Hz (vibrations = 1.7%, smoothing ~= 0.150)\n"
#~ "To avoid too much smoothing with 'mzv', suggested max_accel <= 4000 mm/sec^2\n"
#~ "Fitted shaper 'ei' frequency = 36.6 Hz (vibrations = 2.2%, smoothing ~= 0.240)\n"
#~ "To avoid too much smoothing with 'ei', suggested max_accel <= 2500 mm/sec^2\n"
#~ "Fitted shaper '2hump_ei' frequency = 48.0 Hz (vibrations = 0.0%, smoothing ~= 0.234)\n"
#~ "To avoid too much smoothing with '2hump_ei', suggested max_accel <= 2500 mm/sec^2\n"
#~ "Fitted shaper '3hump_ei' frequency = 59.0 Hz (vibrations = 0.0%, smoothing ~= 0.235)\n"
#~ "To avoid too much smoothing with '3hump_ei', suggested max_accel <= 2500 mm/sec^2\n"
#~ "Recommended shaper_type_y = mzv, shaper_freq_y = 36.8 Hz\n"
#~ msgstr ""

#~ msgid ""
#~ "If you agree with the suggested parameters, you can execute `SAVE_CONFIG` "
#~ "now to save them and restart the Klipper. Note that this will not update "
#~ "`max_accel` value in `[printer]` section. You should update it manually "
#~ "following the considerations in [Selecting max_accel](#selecting-max_accel) "
#~ "section."
#~ msgstr ""

#~ msgid ""
#~ "If your printer is a bed slinger printer, you can specify which axis to "
#~ "test, so that you can change the accelerometer mounting point between the "
#~ "tests (by default the test is performed for both axes):"
#~ msgstr ""

#~ msgid "SHAPER_CALIBRATE AXIS=Y\n"
#~ msgstr ""

#~ msgid "You can execute `SAVE_CONFIG` twice - after calibrating each axis."
#~ msgstr ""

#~ msgid ""
#~ "However, if you connected two accelerometers simultaneously, you simply run "
#~ "`SHAPER_CALIBRATE` without specifying an axis to calibrate the input shaper "
#~ "for both axes in one go."
#~ msgstr ""

#~ msgid "Input Shaper re-calibration"
#~ msgstr ""

#~ msgid ""
#~ "`SHAPER_CALIBRATE` command can be also used to re-calibrate the input shaper"
#~ " in the future, especially if some changes to the printer that can affect "
#~ "its kinematics are made. One can either re-run the full calibration using "
#~ "`SHAPER_CALIBRATE` command, or restrict the auto-calibration to a single "
#~ "axis by supplying `AXIS=` parameter, like"
#~ msgstr ""

#~ msgid "SHAPER_CALIBRATE AXIS=X\n"
#~ msgstr ""

#~ msgid ""
#~ "**Warning!** It is not advisable to run the shaper autocalibration very "
#~ "frequently (e.g. before every print, or every day). In order to determine "
#~ "resonance frequencies, autocalibration creates intensive vibrations on each "
#~ "of the axes. Generally, 3D printers are not designed to withstand a "
#~ "prolonged exposure to vibrations near the resonance frequencies. Doing so "
#~ "may increase wear of the printer components and reduce their lifespan. There"
#~ " is also an increased risk of some parts unscrewing or becoming loose. "
#~ "Always check that all parts of the printer (including the ones that may "
#~ "normally not move) are securely fixed in place after each auto-tuning."
#~ msgstr ""

#~ msgid ""
#~ "Also, due to some noise in measurements, it is possible that the tuning "
#~ "results will be slightly different from one calibration run to another one. "
#~ "Still, it is not expected that the noise will affect the print quality too "
#~ "much. However, it is still advised to double-check the suggested parameters,"
#~ " and print some test prints before using them to confirm they are good."
#~ msgstr ""

#~ msgid "Offline processing of the accelerometer data"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to generate the raw accelerometer data and process it offline"
#~ " (e.g. on a host machine), for example to find resonances. In order to do "
#~ "so, run the following commands via Octoprint terminal:"
#~ msgstr ""

#~ msgid ""
#~ "SET_INPUT_SHAPER SHAPER_FREQ_X=0 SHAPER_FREQ_Y=0\n"
#~ "TEST_RESONANCES AXIS=X OUTPUT=raw_data\n"
#~ msgstr ""

#~ msgid ""
#~ "ignoring any errors for `SET_INPUT_SHAPER` command. For `TEST_RESONANCES` "
#~ "command, specify the desired test axis. The raw data will be written into "
#~ "`/tmp` directory on the RPi."
#~ msgstr ""

#~ msgid ""
#~ "The raw data can also be obtained by running the command "
#~ "`ACCELEROMETER_MEASURE` command twice during some normal printer activity - "
#~ "first to start the measurements, and then to stop them and write the output "
#~ "file. Refer to [G-Codes](G-Codes.md#adxl345) for more details."
#~ msgstr ""

#~ msgid ""
#~ "The data can be processed later by the following scripts: "
#~ "`scripts/graph_accelerometer.py` and `scripts/calibrate_shaper.py`. Both of "
#~ "them accept one or several raw csv files as the input depending on the mode."
#~ " The graph_accelerometer.py script supports several modes of operation:"
#~ msgstr ""

#~ msgid ""
#~ "plotting raw accelerometer data (use `-r` parameter), only 1 input is "
#~ "supported;"
#~ msgstr ""

#~ msgid ""
#~ "plotting a frequency response (no extra parameters required), if multiple "
#~ "inputs are specified, the average frequency response is computed;"
#~ msgstr ""

#~ msgid ""
#~ "comparison of the frequency response between several inputs (use `-c` "
#~ "parameter); you can additionally specify which accelerometer axis to "
#~ "consider via `-a x`, `-a y` or `-a z` parameter (if none specified, the sum "
#~ "of vibrations for all axes is used);"
#~ msgstr ""

#~ msgid ""
#~ "plotting the spectrogram (use `-s` parameter), only 1 input is supported; "
#~ "you can additionally specify which accelerometer axis to consider via `-a "
#~ "x`, `-a y` or `-a z` parameter (if none specified, the sum of vibrations for"
#~ " all axes is used)."
#~ msgstr ""

#~ msgid ""
#~ "Note that graph_accelerometer.py script supports only the raw_data\\*.csv "
#~ "files and not resonances\\*.csv or calibration_data\\*.csv files."
#~ msgstr ""

#~ msgid "For example,"
#~ msgstr ""

#~ msgid ""
#~ "~/klipper/scripts/graph_accelerometer.py /tmp/raw_data_x_*.csv -o "
#~ "/tmp/resonances_x.png -c -a z\n"
#~ msgstr ""

#~ msgid ""
#~ "will plot the comparison of several `/tmp/raw_data_x_*.csv` files for Z axis"
#~ " to `/tmp/resonances_x.png` file."
#~ msgstr ""

#~ msgid ""
#~ "The shaper_calibrate.py script accepts 1 or several inputs and can run "
#~ "automatic tuning of the input shaper and suggest the best parameters that "
#~ "work well for all provided inputs. It prints the suggested parameters to the"
#~ " console, and can additionally generate the chart if `-o output.png` "
#~ "parameter is provided, or the CSV file if `-c output.csv` parameter is "
#~ "specified."
#~ msgstr ""

#~ msgid ""
#~ "Providing several inputs to shaper_calibrate.py script can be useful if "
#~ "running some advanced tuning of the input shapers, for example:"
#~ msgstr ""

#~ msgid ""
#~ "Running `TEST_RESONANCES AXIS=X OUTPUT=raw_data` (and `Y` axis) for a single"
#~ " axis twice on a bed slinger printer with the accelerometer attached to the "
#~ "toolhead the first time, and the accelerometer attached to the bed the "
#~ "second time in order to detect axes cross-resonances and attempt to cancel "
#~ "them with input shapers."
#~ msgstr ""

#~ msgid ""
#~ "Running `TEST_RESONANCES AXIS=Y OUTPUT=raw_data` twice on a bed slinger with"
#~ " a glass bed and a magnetic surfaces (which is lighter) to find the input "
#~ "shaper parameters that work well for any print surface configuration."
#~ msgstr ""

#~ msgid "Combining the resonance data from multiple test points."
#~ msgstr ""

#~ msgid ""
#~ "Combining the resonance data from 2 axis (e.g. on a bed slinger printer to "
#~ "configure X-axis input_shaper from both X and Y axes resonances to cancel "
#~ "vibrations of the *bed* in case the nozzle 'catches' a print when moving in "
#~ "X axis direction)."
#~ msgstr ""

#~ msgid "Manual leveling"
#~ msgstr ""

#~ msgid ""
#~ "This document describes tools for calibrating a Z endstop and for performing"
#~ " adjustments to bed leveling screws."
#~ msgstr ""

#~ msgid "Calibrating a Z endstop"
#~ msgstr ""

#~ msgid ""
#~ "An accurate Z endstop position is critical to obtaining high quality prints."
#~ msgstr ""

#~ msgid ""
#~ "Note, though, the accuracy of the Z endstop switch itself can be a limiting "
#~ "factor. If one is using Trinamic stepper motor drivers then consider "
#~ "enabling [endstop phase](Endstop_Phase.md) detection to improve the accuracy"
#~ " of the switch."
#~ msgstr ""

#~ msgid ""
#~ "To perform a Z endstop calibration, home the printer, command the head to "
#~ "move to a Z position that is at least five millimeters above the bed (if it "
#~ "is not already), command the head to move to an XY position near the center "
#~ "of the bed, then navigate to the OctoPrint terminal tab and run:"
#~ msgstr ""

#~ msgid "Z_ENDSTOP_CALIBRATE\n"
#~ msgstr ""

#~ msgid ""
#~ "Then follow the steps described at [\"the paper test\"](Bed_Level.md#the-"
#~ "paper-test) to determine the actual distance between the nozzle and bed at "
#~ "the given location. Once those steps are complete one can `ACCEPT` the "
#~ "position and save the results to the config file with:"
#~ msgstr ""

#~ msgid ""
#~ "It's preferable to use a Z endstop switch on the opposite end of the Z axis "
#~ "from the bed. (Homing away from the bed is more robust as then it is "
#~ "generally always safe to home the Z.) However, if one must home towards the "
#~ "bed it is recommended to adjust the endstop so that it triggers a small "
#~ "distance (eg, .5mm) above the bed. Almost all endstop switches can safely be"
#~ " depressed a small distance beyond their trigger point. When this is done, "
#~ "one should find that the `Z_ENDSTOP_CALIBRATE` command reports a small "
#~ "positive value (eg, .5mm) for the Z position_endstop. Triggering the endstop"
#~ " while it is still some distance from the bed reduces the risk of "
#~ "inadvertent bed crashes."
#~ msgstr ""

#~ msgid ""
#~ "Some printers have the ability to manually adjust the location of the "
#~ "physical endstop switch. However, it's recommended to perform Z endstop "
#~ "positioning in software with Klipper - once the physical location of the "
#~ "endstop is in a convenient location, one can make any further adjustments by"
#~ " running Z_ENDSTOP_CALIBRATE or by manually updating the Z position_endstop "
#~ "in the configuration file."
#~ msgstr ""

#~ msgid "Adjusting bed leveling screws"
#~ msgstr ""

#~ msgid ""
#~ "The secret to getting good bed leveling with bed leveling screws is to "
#~ "utilize the printer's high precision motion system during the bed leveling "
#~ "process itself. This is done by commanding the nozzle to a position near "
#~ "each bed screw and then adjusting that screw until the bed is a set distance"
#~ " from the nozzle. Klipper has a tool to assist with this. In order to use "
#~ "the tool it is necessary to specify each screw XY location."
#~ msgstr ""

#~ msgid ""
#~ "This is done by creating a `[bed_screws]` config section. For example, it "
#~ "might look something similar to:"
#~ msgstr ""

#~ msgid ""
#~ "[bed_screws]\n"
#~ "screw1: 100, 50\n"
#~ "screw2: 100, 150\n"
#~ "screw3: 150, 100\n"
#~ msgstr ""

#~ msgid ""
#~ "If a bed screw is under the bed, then specify the XY position directly above"
#~ " the screw. If the screw is outside the bed then specify an XY position "
#~ "closest to the screw that is still within the range of the bed."
#~ msgstr ""

#~ msgid ""
#~ "Once the config file is ready, run `RESTART` to load that config, and then "
#~ "one can start the tool by running:"
#~ msgstr ""

#~ msgid "BED_SCREWS_ADJUST\n"
#~ msgstr ""

#~ msgid ""
#~ "This tool will move the printer's nozzle to each screw XY location and then "
#~ "move the nozzle to a Z=0 height. At this point one can use the \"paper "
#~ "test\" to adjust the bed screw directly under the nozzle. See the "
#~ "information described in [\"the paper test\"](Bed_Level.md#the-paper-test), "
#~ "but adjust the bed screw instead of commanding the nozzle to different "
#~ "heights. Adjust the bed screw until there is a small amount of friction when"
#~ " pushing the paper back and forth."
#~ msgstr ""

#~ msgid ""
#~ "Once the screw is adjusted so that a small amount of friction is felt, run "
#~ "either the `ACCEPT` or `ADJUSTED` command. Use the `ADJUSTED` command if the"
#~ " bed screw needed an adjustment (typically anything more than about 1/8th of"
#~ " a turn of the screw). Use the `ACCEPT` command if no significant adjustment"
#~ " is necessary. Both commands will cause the tool to proceed to the next "
#~ "screw. (When an `ADJUSTED` command is used, the tool will schedule an "
#~ "additional cycle of bed screw adjustments; the tool completes successfully "
#~ "when all bed screws are verified to not require any significant "
#~ "adjustments.) One can use the `ABORT` command to exit the tool early."
#~ msgstr ""

#~ msgid ""
#~ "This system works best when the printer has a flat printing surface (such as"
#~ " glass) and has straight rails. Upon successful completion of the bed "
#~ "leveling tool the bed should be ready for printing."
#~ msgstr ""

#~ msgid "Fine grained bed screw adjustments"
#~ msgstr ""

#~ msgid ""
#~ "If the printer uses three bed screws and all three screws are under the bed,"
#~ " then it may be possible to perform a second \"high precision\" bed leveling"
#~ " step. This is done by commanding the nozzle to locations where the bed "
#~ "moves a larger distance with each bed screw adjustment."
#~ msgstr ""

#~ msgid "For example, consider a bed with screws at locations A, B, and C:"
#~ msgstr ""

#~ msgid "![bed_screws](img/bed_screws.svg.png)"
#~ msgstr ""

#~ msgid ""
#~ "For each adjustment made to the bed screw at location C, the bed will swing "
#~ "along a pendulum defined by the remaining two bed screws (shown here as a "
#~ "green line). In this situation, each adjustment to the bed screw at C will "
#~ "move the bed at position D a further amount than directly at C. It is thus "
#~ "possible to make an improved C screw adjustment when the nozzle is at "
#~ "position D."
#~ msgstr ""

#~ msgid ""
#~ "To enable this feature, one would determine the additional nozzle "
#~ "coordinates and add them to the config file. For example, it might look "
#~ "like:"
#~ msgstr ""

#~ msgid ""
#~ "[bed_screws]\n"
#~ "screw1: 100, 50\n"
#~ "screw1_fine_adjust: 0, 0\n"
#~ "screw2: 100, 150\n"
#~ "screw2_fine_adjust: 300, 300\n"
#~ "screw3: 150, 100\n"
#~ "screw3_fine_adjust: 0, 100\n"
#~ msgstr ""

#~ msgid ""
#~ "When this feature is enabled, the `BED_SCREWS_ADJUST` tool will first prompt"
#~ " for coarse adjustments directly above each screw position, and once those "
#~ "are accepted, it will prompt for fine adjustments at the additional "
#~ "locations. Continue to use `ACCEPT` and `ADJUSTED` at each position."
#~ msgstr ""

#~ msgid "Adjusting bed leveling screws using the bed probe"
#~ msgstr ""

#~ msgid ""
#~ "This is another way to calibrate the bed level using the bed probe. To use "
#~ "it you must have a Z probe (BL Touch, Inductive sensor, etc)."
#~ msgstr ""

#~ msgid ""
#~ "To enable this feature, one would determine the nozzle coordinates such that"
#~ " the Z probe is above the screws, and then add them to the config file. For "
#~ "example, it might look like:"
#~ msgstr ""

#~ msgid ""
#~ "[screws_tilt_adjust]\n"
#~ "screw1: -5, 30\n"
#~ "screw1_name: front left screw\n"
#~ "screw2: 155, 30\n"
#~ "screw2_name: front right screw\n"
#~ "screw3: 155, 190\n"
#~ "screw3_name: rear right screw\n"
#~ "screw4: -5, 190\n"
#~ "screw4_name: rear left screw\n"
#~ "horizontal_move_z: 10.\n"
#~ "speed: 50.\n"
#~ "screw_thread: CW-M3\n"
#~ msgstr ""

#~ msgid ""
#~ "The screw1 is always the reference point for the others, so the system "
#~ "assumes that screw1 is at the correct height. Always run `G28` first and "
#~ "then run `SCREWS_TILT_CALCULATE` - it should produce output similar to:"
#~ msgstr ""

#~ msgid ""
#~ "Send: G28\n"
#~ "Recv: ok\n"
#~ "Send: SCREWS_TILT_CALCULATE\n"
#~ "Recv: // 01:20 means 1 full turn and 20 minutes, CW=clockwise, CCW=counter-clockwise\n"
#~ "Recv: // front left screw (base) : x=-5.0, y=30.0, z=2.48750\n"
#~ "Recv: // front right screw : x=155.0, y=30.0, z=2.36000 : adjust CW 01:15\n"
#~ "Recv: // rear right screw : y=155.0, y=190.0, z=2.71500 : adjust CCW 00:50\n"
#~ "Recv: // read left screw : x=-5.0, y=190.0, z=2.47250 : adjust CW 00:02\n"
#~ "Recv: ok\n"
#~ msgstr ""

#~ msgid "This means that:"
#~ msgstr ""

#~ msgid "front left screw is the reference point you must not change it."
#~ msgstr ""

#~ msgid ""
#~ "front right screw must be turned clockwise 1 full turn and a quarter turn"
#~ msgstr ""

#~ msgid "rear right screw must be turned counter-clockwise 50 minutes"
#~ msgstr ""

#~ msgid "rear left screw must be turned clockwise 2 minutes (not need it's ok)"
#~ msgstr ""

#~ msgid ""
#~ "Note that \"minutes\" refers to \"minutes of a clock face\". So, for "
#~ "example, 15 minutes is a quarter of a full turn."
#~ msgstr ""

#~ msgid ""
#~ "Repeat the process several times until you get a good level bed - normally "
#~ "when all adjustments are below 6 minutes."
#~ msgstr ""

#~ msgid ""
#~ "If using a probe that is mounted on the side of the hotend (that is, it has "
#~ "an X or Y offset) then note that adjusting the bed tilt will invalidate any "
#~ "previous probe calibration that was performed with a tilted bed. Be sure to "
#~ "run [probe calibration](Probe_Calibrate.md) after the bed screws have been "
#~ "adjusted."
#~ msgstr ""

#~ msgid ""
#~ "The `MAX_DEVIATION` parameter is useful when a saved bed mesh is used, to "
#~ "ensure that the bed level has not drifted too far from where it was when the"
#~ " mesh was created. For example, `SCREWS_TILT_CALCULATE MAX_DEVIATION=0.01` "
#~ "can be added to the custom start gcode of the slicer before the mesh is "
#~ "loaded. It will abort the print if the configured limit is exceeded (0.01mm "
#~ "in this example), giving the user a chance to adjust the screws and restart "
#~ "the print."
#~ msgstr ""

#~ msgid ""
#~ "The `DIRECTION` parameter is useful if you can turn your bed adjustment "
#~ "screws in one direction only. For example, you might have screws that start "
#~ "tightened in their lowest (or highest) possible position, which can only be "
#~ "turned in a single direction, to raise (or lower) the bed. If you can only "
#~ "turn the screws clockwise, run `SCREWS_TILT_CALCULATE DIRECTION=CW`. If you "
#~ "can only turn them counter-clockwise, run `SCREWS_TILT_CALCULATE "
#~ "DIRECTION=CCW`. A suitable reference point will be chosen such that the bed "
#~ "can be leveled by turning all the screws in the given direction."
#~ msgstr ""

#~ msgid "MCU commands"
#~ msgstr ""

#~ msgid ""
#~ "This document provides information on the low-level micro-controller "
#~ "commands that are sent from the Klipper \"host\" software and processed by "
#~ "the Klipper micro-controller software. This document is not an authoritative"
#~ " reference for these commands, nor is it an exclusive list of all available "
#~ "commands."
#~ msgstr ""

#~ msgid ""
#~ "This document may be useful for developers interested in understanding the "
#~ "low-level micro-controller commands."
#~ msgstr ""

#~ msgid ""
#~ "See the [protocol](Protocol.md) document for more information on the format "
#~ "of commands and their transmission. The commands here are described using "
#~ "their \"printf\" style syntax - for those unfamiliar with that format, just "
#~ "note that where a '%...' sequence is seen it should be replaced with an "
#~ "actual integer. For example, a description with \"count=%c\" could be "
#~ "replaced with the text \"count=10\". Note that parameters that are "
#~ "considered \"enumerations\" (see the above protocol document) take a string "
#~ "value which is automatically converted to an integer value for the micro-"
#~ "controller. This is common with parameters named \"pin\" (or that have a "
#~ "suffix of \"_pin\")."
#~ msgstr ""

#~ msgid "Startup Commands"
#~ msgstr ""

#~ msgid ""
#~ "It may be necessary to take certain one-time actions to configure the micro-"
#~ "controller and its peripherals. This section lists common commands available"
#~ " for that purpose. Unlike most micro-controller commands, these commands run"
#~ " as soon as they are received and they do not require any particular setup."
#~ msgstr ""

#~ msgid "Common startup commands:"
#~ msgstr ""

#~ msgid ""
#~ "`set_digital_out pin=%u value=%c` : This command immediately configures the "
#~ "given pin as a digital out GPIO and it sets it to either a low level "
#~ "(value=0) or a high level (value=1). This command may be useful for "
#~ "configuring the initial value of LEDs and for configuring the initial value "
#~ "of stepper driver micro-stepping pins."
#~ msgstr ""

#~ msgid ""
#~ "`set_pwm_out pin=%u cycle_ticks=%u value=%hu` : This command will "
#~ "immediately configure the given pin to use hardware based pulse-width-"
#~ "modulation (PWM) with the given number of cycle_ticks. The \"cycle_ticks\" "
#~ "is the number of MCU clock ticks each power on and power off cycle should "
#~ "last. A cycle_ticks value of 1 can be used to request the fastest possible "
#~ "cycle time. The \"value\" parameter is between 0 and 255 with 0 indicating a"
#~ " full off state and 255 indicating a full on state. This command may be "
#~ "useful for enabling CPU and nozzle cooling fans."
#~ msgstr ""

#~ msgid "Low-level micro-controller configuration"
#~ msgstr ""

#~ msgid ""
#~ "Most commands in the micro-controller require an initial setup before they "
#~ "can be successfully invoked. This section provides an overview of the "
#~ "configuration process. This section and the following sections are likely "
#~ "only of interest to developers interested in the internal details of "
#~ "Klipper."
#~ msgstr ""

#~ msgid ""
#~ "When the host first connects to the micro-controller it always starts by "
#~ "obtaining a data dictionary (see [protocol](Protocol.md) for more "
#~ "information). After the data dictionary is obtained the host will check if "
#~ "the micro-controller is in a \"configured\" state and configure it if not. "
#~ "Configuration involves the following phases:"
#~ msgstr ""

#~ msgid ""
#~ "`get_config` : The host starts by checking if the micro-controller is "
#~ "already configured. The micro-controller responds to this command with a "
#~ "\"config\" response message. The micro-controller software always starts in "
#~ "an unconfigured state at power-on. It remains in this state until the host "
#~ "completes the configuration processes (by issuing a finalize_config "
#~ "command). If the micro-controller is already configured from a previous "
#~ "session (and is configured with the desired settings) then no further action"
#~ " is needed by the host and the configuration process ends successfully."
#~ msgstr ""

#~ msgid ""
#~ "`allocate_oids count=%c` : This command is issued to inform the micro-"
#~ "controller of the maximum number of object-ids (oid) that the host requires."
#~ " It is only valid to issue this command once. An oid is an integer "
#~ "identifier allocated to each stepper, each endstop, and each schedulable "
#~ "gpio pin. The host determines in advance the number of oids it will require "
#~ "to operate the hardware and passes this to the micro-controller so that it "
#~ "may allocate sufficient memory to store a mapping from oid to internal "
#~ "object."
#~ msgstr ""

#~ msgid ""
#~ "`config_XXX oid=%c ...` : By convention any command starting with the "
#~ "\"config_\" prefix creates a new micro-controller object and assigns the "
#~ "given oid to it. For example, the config_digital_out command will configure "
#~ "the specified pin as a digital output GPIO and create an internal object "
#~ "that the host can use to schedule changes to the given GPIO. The oid "
#~ "parameter passed into the config command is selected by the host and must be"
#~ " between zero and the maximum count supplied in the allocate_oids command. "
#~ "The config commands may only be run when the micro-controller is not in a "
#~ "configured state (ie, prior to the host sending finalize_config) and after "
#~ "the allocate_oids command has been sent."
#~ msgstr ""

#~ msgid ""
#~ "`finalize_config crc=%u` : The finalize_config command transitions the "
#~ "micro-controller from an unconfigured state to a configured state. The crc "
#~ "parameter passed to the micro-controller is stored and provided back to the "
#~ "host in \"config\" response messages. By convention, the host takes a 32bit "
#~ "CRC of the configuration it will request and at the start of subsequent "
#~ "communication sessions it checks that the CRC stored in the micro-controller"
#~ " exactly matches its desired CRC. If the CRC does not match then the host "
#~ "knows the micro-controller has not been configured in the state desired by "
#~ "the host."
#~ msgstr ""

#~ msgid "Common micro-controller objects"
#~ msgstr ""

#~ msgid "This section lists some commonly used config commands."
#~ msgstr ""

#~ msgid ""
#~ "`config_digital_out oid=%c pin=%u value=%c default_value=%c max_duration=%u`"
#~ " : This command creates an internal micro-controller object for the given "
#~ "GPIO 'pin'. The pin will be configured in digital output mode and set to an "
#~ "initial value as specified by 'value' (0 for low, 1 for high). Creating a "
#~ "digital_out object allows the host to schedule GPIO updates for the given "
#~ "pin at specified times (see the queue_digital_out command described below). "
#~ "Should the micro-controller software go into shutdown mode then all "
#~ "configured digital_out objects will be set to 'default_value'. The "
#~ "'max_duration' parameter is used to implement a safety check - if it is non-"
#~ "zero then it is the maximum number of clock ticks that the host may set the "
#~ "given GPIO to a non-default value without further updates. For example, if "
#~ "the default_value is zero and the max_duration is 16000 then if the host "
#~ "sets the gpio to a value of one then it must schedule another update to the "
#~ "gpio pin (to either zero or one) within 16000 clock ticks. This safety "
#~ "feature can be used with heater pins to ensure the host does not enable the "
#~ "heater and then go off-line."
#~ msgstr ""

#~ msgid ""
#~ "`config_pwm_out oid=%c pin=%u cycle_ticks=%u value=%hu default_value=%hu "
#~ "max_duration=%u` : This command creates an internal object for hardware "
#~ "based PWM pins that the host may schedule updates for. Its usage is "
#~ "analogous to config_digital_out - see the description of the 'set_pwm_out' "
#~ "and 'config_digital_out' commands for parameter description."
#~ msgstr ""

#~ msgid ""
#~ "`config_analog_in oid=%c pin=%u` : This command is used to configure a pin "
#~ "in analog input sampling mode. Once configured, the pin can be sampled at "
#~ "regular interval using the query_analog_in command (see below)."
#~ msgstr ""

#~ msgid ""
#~ "`config_stepper oid=%c step_pin=%c dir_pin=%c invert_step=%c "
#~ "step_pulse_ticks=%u` : This command creates an internal stepper object. The "
#~ "'step_pin' and 'dir_pin' parameters specify the step and direction pins "
#~ "respectively; this command will configure them in digital output mode. The "
#~ "'invert_step' parameter specifies whether a step occurs on a rising edge "
#~ "(invert_step=0) or falling edge (invert_step=1). The 'step_pulse_ticks' "
#~ "parameter specifies the minimum duration of the step pulse. If the mcu "
#~ "exports the constant 'STEPPER_BOTH_EDGE=1' then setting step_pulse_ticks=0 "
#~ "and invert_step=-1 will setup for stepping on both the rising and falling "
#~ "edges of the step pin."
#~ msgstr ""

#~ msgid ""
#~ "`config_endstop oid=%c pin=%c pull_up=%c stepper_count=%c` : This command "
#~ "creates an internal \"endstop\" object. It is used to specify the endstop "
#~ "pins and to enable \"homing\" operations (see the endstop_home command "
#~ "below). The command will configure the specified pin in digital input mode. "
#~ "The 'pull_up' parameter determines whether hardware provided pullup "
#~ "resistors for the pin (if available) will be enabled. The 'stepper_count' "
#~ "parameter specifies the maximum number of steppers that this endstop may "
#~ "need to halt during a homing operation (see endstop_home below)."
#~ msgstr ""

#~ msgid ""
#~ "`config_spi oid=%c bus=%u pin=%u mode=%u rate=%u shutdown_msg=%*s` : This "
#~ "command creates an internal SPI object. It is used with spi_transfer and "
#~ "spi_send commands (see below). The \"bus\" identifies the SPI bus to use (if"
#~ " the micro-controller has more than one SPI bus available). The \"pin\" "
#~ "specifies the chip select (CS) pin for the device. The \"mode\" is the SPI "
#~ "mode (should be between 0 and 3). The \"rate\" parameter specifies the SPI "
#~ "bus rate (in cycles per second). Finally, the \"shutdown_msg\" is an SPI "
#~ "command to send to the given device should the micro-controller go into a "
#~ "shutdown state."
#~ msgstr ""

#~ msgid ""
#~ "`config_spi_without_cs oid=%c bus=%u mode=%u rate=%u shutdown_msg=%*s` : "
#~ "This command is similar to config_spi, but without a CS pin definition. It "
#~ "is useful for SPI devices that do not have a chip select line."
#~ msgstr ""

#~ msgid "Common commands"
#~ msgstr ""

#~ msgid ""
#~ "This section lists some commonly used run-time commands. It is likely only "
#~ "of interest to developers looking to gain insight into Klipper."
#~ msgstr ""

#~ msgid ""
#~ "`set_digital_out_pwm_cycle oid=%c cycle_ticks=%u` : This command configures "
#~ "a digital output pin (as created by config_digital_out) to use \"software "
#~ "PWM\". The 'cycle_ticks' is the number of clock ticks for the PWM cycle. "
#~ "Because the output switching is implemented in the micro-controller "
#~ "software, it is recommended that 'cycle_ticks' correspond to a time of 10ms "
#~ "or greater."
#~ msgstr ""

#~ msgid ""
#~ "`queue_digital_out oid=%c clock=%u on_ticks=%u` : This command will schedule"
#~ " a change to a digital output GPIO pin at the given clock time. To use this "
#~ "command a 'config_digital_out' command with the same 'oid' parameter must "
#~ "have been issued during micro-controller configuration. If "
#~ "'set_digital_out_pwm_cycle' has been called then 'on_ticks' is the on "
#~ "duration (in clock ticks) for the pwm cycle. Otherwise, 'on_ticks' should be"
#~ " either 0 (for low voltage) or 1 (for high voltage)."
#~ msgstr ""

#~ msgid ""
#~ "`queue_pwm_out oid=%c clock=%u value=%hu` : Schedules a change to a hardware"
#~ " PWM output pin. See the 'queue_digital_out' and 'config_pwm_out' commands "
#~ "for more info."
#~ msgstr ""

#~ msgid ""
#~ "`query_analog_in oid=%c clock=%u sample_ticks=%u sample_count=%c "
#~ "rest_ticks=%u min_value=%hu max_value=%hu` : This command sets up a "
#~ "recurring schedule of analog input samples. To use this command a "
#~ "'config_analog_in' command with the same 'oid' parameter must have been "
#~ "issued during micro-controller configuration. The samples will start as of "
#~ "'clock' time, it will report on the obtained value every 'rest_ticks' clock "
#~ "ticks, it will over-sample 'sample_count' number of times, and it will pause"
#~ " 'sample_ticks' number of clock ticks between over-sample samples. The "
#~ "'min_value' and 'max_value' parameters implement a safety feature - the "
#~ "micro-controller software will verify the sampled value (after any "
#~ "oversampling) is always between the supplied range. This is intended for use"
#~ " with pins attached to thermistors controlling heaters - it can be used to "
#~ "check that a heater is within a temperature range."
#~ msgstr ""

#~ msgid ""
#~ "`get_clock` : This command causes the micro-controller to generate a "
#~ "\"clock\" response message. The host sends this command once a second to "
#~ "obtain the value of the micro-controller clock and to estimate the drift "
#~ "between host and micro-controller clocks. It enables the host to accurately "
#~ "estimate the micro-controller clock."
#~ msgstr ""

#~ msgid "Stepper commands"
#~ msgstr ""

#~ msgid ""
#~ "`queue_step oid=%c interval=%u count=%hu add=%hi` : This command schedules "
#~ "'count' number of steps for the given stepper, with 'interval' number of "
#~ "clock ticks between each step. The first step will be 'interval' number of "
#~ "clock ticks since the last scheduled step for the given stepper. If 'add' is"
#~ " non-zero then the interval will be adjusted by 'add' amount after each "
#~ "step. This command appends the given interval/count/add sequence to a per-"
#~ "stepper queue. There may be hundreds of these sequences queued during normal"
#~ " operation. New sequence are appended to the end of the queue and as each "
#~ "sequence completes its 'count' number of steps it is popped from the front "
#~ "of the queue. This system allows the micro-controller to queue potentially "
#~ "hundreds of thousands of steps - all with reliable and predictable schedule "
#~ "times."
#~ msgstr ""

#~ msgid ""
#~ "`set_next_step_dir oid=%c dir=%c` : This command specifies the value of the "
#~ "dir_pin that the next queue_step command will use."
#~ msgstr ""

#~ msgid ""
#~ "`reset_step_clock oid=%c clock=%u` : Normally, step timing is relative to "
#~ "the last step for a given stepper. This command resets the clock so that the"
#~ " next step is relative to the supplied 'clock' time. The host usually only "
#~ "sends this command at the start of a print."
#~ msgstr ""

#~ msgid ""
#~ "`stepper_get_position oid=%c` : This command causes the micro-controller to "
#~ "generate a \"stepper_position\" response message with the stepper's current "
#~ "position. The position is the total number of steps generated with dir=1 "
#~ "minus the total number of steps generated with dir=0."
#~ msgstr ""

#~ msgid ""
#~ "`endstop_home oid=%c clock=%u sample_ticks=%u sample_count=%c rest_ticks=%u "
#~ "pin_value=%c` : This command is used during stepper \"homing\" operations. "
#~ "To use this command a 'config_endstop' command with the same 'oid' parameter"
#~ " must have been issued during micro-controller configuration. When this "
#~ "command is invoked, the micro-controller will sample the endstop pin every "
#~ "'rest_ticks' clock ticks and check if it has a value equal to 'pin_value'. "
#~ "If the value matches (and it continues to match for 'sample_count' "
#~ "additional samples spread 'sample_ticks' apart) then the movement queue for "
#~ "the associated stepper will be cleared and the stepper will come to an "
#~ "immediate halt. The host uses this command to implement homing - the host "
#~ "instructs the endstop to sample for the endstop trigger and then it issues a"
#~ " series of queue_step commands to move a stepper towards the endstop. Once "
#~ "the stepper hits the endstop, the trigger will be detected, the movement "
#~ "halted, and the host notified."
#~ msgstr ""

#~ msgid "Move queue"
#~ msgstr ""

#~ msgid ""
#~ "Each queue_step command utilizes an entry in the micro-controller \"move "
#~ "queue\". This queue is allocated when it receives the \"finalize_config\" "
#~ "command, and it reports the number of available queue entries in \"config\" "
#~ "response messages."
#~ msgstr ""

#~ msgid ""
#~ "It is the responsibility of the host to ensure that there is available space"
#~ " in the queue before sending a queue_step command. The host does this by "
#~ "calculating when each queue_step command completes and scheduling new "
#~ "queue_step commands accordingly."
#~ msgstr ""

#~ msgid "SPI Commands"
#~ msgstr ""

#~ msgid ""
#~ "`spi_transfer oid=%c data=%*s` : This command causes the micro-controller to"
#~ " send 'data' to the spi device specified by 'oid' and it generates a "
#~ "\"spi_transfer_response\" response message with the data returned during the"
#~ " transmission."
#~ msgstr ""

#~ msgid ""
#~ "`spi_send oid=%c data=%*s` : This command is similar to \"spi_transfer\", "
#~ "but it does not generate a \"spi_transfer_response\" message."
#~ msgstr ""

#~ msgid "Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "This document provides an overview of how Klipper implements robot motion "
#~ "(its [kinematics](https://en.wikipedia.org/wiki/Kinematics)). The contents "
#~ "may be of interest to both developers interested in working on the Klipper "
#~ "software as well as users interested in better understanding the mechanics "
#~ "of their machines."
#~ msgstr ""

#~ msgid "Acceleration"
#~ msgstr ""

#~ msgid ""
#~ "Klipper implements a constant acceleration scheme whenever the print head "
#~ "changes velocity - the velocity is gradually changed to the new speed "
#~ "instead of suddenly jerking to it. Klipper always enforces acceleration "
#~ "between the tool head and the print. The filament leaving the extruder can "
#~ "be quite fragile - rapid jerks and/or extruder flow changes lead to poor "
#~ "quality and poor bed adhesion. Even when not extruding, if the print head is"
#~ " at the same level as the print then rapid jerking of the head can cause "
#~ "disruption of recently deposited filament. Limiting speed changes of the "
#~ "print head (relative to the print) reduces risks of disrupting the print."
#~ msgstr ""

#~ msgid ""
#~ "It is also important to limit acceleration so that the stepper motors do not"
#~ " skip or put excessive stress on the machine. Klipper limits the torque on "
#~ "each stepper by virtue of limiting the acceleration of the print head. "
#~ "Enforcing acceleration at the print head naturally also limits the torque of"
#~ " the steppers that move the print head (the inverse is not always true)."
#~ msgstr ""

#~ msgid ""
#~ "Klipper implements constant acceleration. The key formula for constant "
#~ "acceleration is:"
#~ msgstr ""

#~ msgid "velocity(time) = start_velocity + accel*time\n"
#~ msgstr ""

#~ msgid "Trapezoid generator"
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses a traditional \"trapezoid generator\" to model the motion of "
#~ "each move - each move has a start speed, it accelerates to a cruising speed "
#~ "at constant acceleration, it cruises at a constant speed, and then "
#~ "decelerates to the end speed using constant acceleration."
#~ msgstr ""

#~ msgid "![trapezoid](img/trapezoid.svg.png)"
#~ msgstr ""

#~ msgid ""
#~ "It's called a \"trapezoid generator\" because a velocity diagram of the move"
#~ " looks like a trapezoid."
#~ msgstr ""

#~ msgid ""
#~ "The cruising speed is always greater than or equal to both the start speed "
#~ "and the end speed. The acceleration phase may be of zero duration (if the "
#~ "start speed is equal to the cruising speed), the cruising phase may be of "
#~ "zero duration (if the move immediately starts decelerating after "
#~ "acceleration), and/or the deceleration phase may be of zero duration (if the"
#~ " end speed is equal to the cruising speed)."
#~ msgstr ""

#~ msgid "![trapezoids](img/trapezoids.svg.png)"
#~ msgstr ""

#~ msgid "Look-ahead"
#~ msgstr ""

#~ msgid ""
#~ "The \"look-ahead\" system is used to determine cornering speeds between "
#~ "moves."
#~ msgstr ""

#~ msgid "Consider the following two moves contained on an XY plane:"
#~ msgstr ""

#~ msgid "![corner](img/corner.svg.png)"
#~ msgstr ""

#~ msgid ""
#~ "In the above situation it is possible to fully decelerate after the first "
#~ "move and then fully accelerate at the start of the next move, but that is "
#~ "not ideal as all that acceleration and deceleration would greatly increase "
#~ "the print time and the frequent changes in extruder flow would result in "
#~ "poor print quality."
#~ msgstr ""

#~ msgid ""
#~ "To solve this, the \"look-ahead\" mechanism queues multiple incoming moves "
#~ "and analyzes the angles between moves to determine a reasonable speed that "
#~ "can be obtained during the \"junction\" between two moves. If the next move "
#~ "is nearly in the same direction then the head need only slow down a little "
#~ "(if at all)."
#~ msgstr ""

#~ msgid "![lookahead](img/lookahead.svg.png)"
#~ msgstr ""

#~ msgid ""
#~ "However, if the next move forms an acute angle (the head is going to travel "
#~ "in nearly a reverse direction on the next move) then only a small junction "
#~ "speed is permitted."
#~ msgstr ""

#~ msgid "![lookahead](img/lookahead-slow.svg.png)"
#~ msgstr ""

#~ msgid ""
#~ "The junction speeds are determined using \"approximated centripetal "
#~ "acceleration\". Best [described by the "
#~ "author](https://onehossshay.wordpress.com/2011/09/24/improving_grbl_cornering_algorithm/)."
#~ " However, in Klipper, junction speeds are configured by specifying the "
#~ "desired speed that a 90 corner should have (the \"square corner "
#~ "velocity\"), and the junction speeds for other angles are derived from that."
#~ msgstr ""

#~ msgid "Key formula for look-ahead:"
#~ msgstr ""

#~ msgid "end_velocity^2 = start_velocity^2 + 2*accel*move_distance\n"
#~ msgstr ""

#~ msgid "Smoothed look-ahead"
#~ msgstr ""

#~ msgid ""
#~ "Klipper also implements a mechanism for smoothing out the motions of short "
#~ "\"zigzag\" moves. Consider the following moves:"
#~ msgstr ""

#~ msgid "![zigzag](img/zigzag.svg.png)"
#~ msgstr ""

#~ msgid ""
#~ "In the above, the frequent changes from acceleration to deceleration can "
#~ "cause the machine to vibrate which causes stress on the machine and "
#~ "increases the noise. To reduce this, Klipper tracks both regular move "
#~ "acceleration as well as a virtual \"acceleration to deceleration\" rate. "
#~ "Using this system, the top speed of these short \"zigzag\" moves are limited"
#~ " to smooth out the printer motion:"
#~ msgstr ""

#~ msgid "![smoothed](img/smoothed.svg.png)"
#~ msgstr ""

#~ msgid ""
#~ "Specifically, the code calculates what the velocity of each move would be if"
#~ " it were limited to this virtual \"acceleration to deceleration\" rate (half"
#~ " the normal acceleration rate by default). In the above picture the dashed "
#~ "gray lines represent this virtual acceleration rate for the first move. If a"
#~ " move can not reach its full cruising speed using this virtual acceleration "
#~ "rate then its top speed is reduced to the maximum speed it could obtain at "
#~ "this virtual acceleration rate. For most moves the limit will be at or above"
#~ " the move's existing limits and no change in behavior is induced. For short "
#~ "zigzag moves, however, this limit reduces the top speed. Note that it does "
#~ "not change the actual acceleration within the move - the move continues to "
#~ "use the normal acceleration scheme up to its adjusted top-speed."
#~ msgstr ""

#~ msgid "Generating steps"
#~ msgstr ""

#~ msgid ""
#~ "Once the look-ahead process completes, the print head movement for the given"
#~ " move is fully known (time, start position, end position, velocity at each "
#~ "point) and it is possible to generate the step times for the move. This "
#~ "process is done within \"kinematic classes\" in the Klipper code. Outside of"
#~ " these kinematic classes, everything is tracked in millimeters, seconds, and"
#~ " in cartesian coordinate space. It's the task of the kinematic classes to "
#~ "convert from this generic coordinate system to the hardware specifics of the"
#~ " particular printer."
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
#~ "finding_algorithm) to generate the step times for each stepper. The code "
#~ "contains the formulas to calculate the ideal cartesian coordinates of the "
#~ "head at each moment in time, and it has the kinematic formulas to calculate "
#~ "the ideal stepper positions based on those cartesian coordinates. With these"
#~ " formulas, Klipper can determine the ideal time that the stepper should be "
#~ "at each step position. The given steps are then scheduled at these "
#~ "calculated times."
#~ msgstr ""

#~ msgid ""
#~ "The key formula to determine how far a move should travel under constant "
#~ "acceleration is:"
#~ msgstr ""

#~ msgid "move_distance = (start_velocity + .5 * accel * move_time) * move_time\n"
#~ msgstr ""

#~ msgid "and the key formula for movement with constant velocity is:"
#~ msgstr ""

#~ msgid "move_distance = cruise_velocity * move_time\n"
#~ msgstr ""

#~ msgid ""
#~ "The key formulas for determining the cartesian coordinate of a move given a "
#~ "move distance is:"
#~ msgstr ""

#~ msgid ""
#~ "cartesian_x_position = start_x + move_distance * total_x_movement / total_movement\n"
#~ "cartesian_y_position = start_y + move_distance * total_y_movement / total_movement\n"
#~ "cartesian_z_position = start_z + move_distance * total_z_movement / total_movement\n"
#~ msgstr ""

#~ msgid "Cartesian Robots"
#~ msgstr ""

#~ msgid ""
#~ "Generating steps for cartesian printers is the simplest case. The movement "
#~ "on each axis is directly related to the movement in cartesian space."
#~ msgstr ""

#~ msgid "Key formulas:"
#~ msgstr ""

#~ msgid ""
#~ "stepper_x_position = cartesian_x_position\n"
#~ "stepper_y_position = cartesian_y_position\n"
#~ "stepper_z_position = cartesian_z_position\n"
#~ msgstr ""

#~ msgid "CoreXY Robots"
#~ msgstr ""

#~ msgid ""
#~ "Generating steps on a CoreXY machine is only a little more complex than "
#~ "basic cartesian robots. The key formulas are:"
#~ msgstr ""

#~ msgid ""
#~ "stepper_a_position = cartesian_x_position + cartesian_y_position\n"
#~ "stepper_b_position = cartesian_x_position - cartesian_y_position\n"
#~ "stepper_z_position = cartesian_z_position\n"
#~ msgstr ""

#~ msgid "Delta Robots"
#~ msgstr ""

#~ msgid "Step generation on a delta robot is based on Pythagoras's theorem:"
#~ msgstr ""

#~ msgid ""
#~ "stepper_position = (sqrt(arm_length^2\n"
#~ "                         - (cartesian_x_position - tower_x_position)^2\n"
#~ "                         - (cartesian_y_position - tower_y_position)^2)\n"
#~ "                    + cartesian_z_position)\n"
#~ msgstr ""

#~ msgid "Stepper motor acceleration limits"
#~ msgstr ""

#~ msgid ""
#~ "With delta kinematics it is possible for a move that is accelerating in "
#~ "cartesian space to require an acceleration on a particular stepper motor "
#~ "greater than the move's acceleration. This can occur when a stepper arm is "
#~ "more horizontal than vertical and the line of movement passes near that "
#~ "stepper's tower. Although these moves could require a stepper motor "
#~ "acceleration greater than the printer's maximum configured move "
#~ "acceleration, the effective mass moved by that stepper would be smaller. "
#~ "Thus the higher stepper acceleration does not result in significantly higher"
#~ " stepper torque and it is therefore considered harmless."
#~ msgstr ""

#~ msgid ""
#~ "However, to avoid extreme cases, Klipper enforces a maximum ceiling on "
#~ "stepper acceleration of three times the printer's configured maximum move "
#~ "acceleration. (Similarly, the maximum velocity of the stepper is limited to "
#~ "three times the maximum move velocity.) In order to enforce this limit, "
#~ "moves at the extreme edge of the build envelope (where a stepper arm may be "
#~ "nearly horizontal) will have a lower maximum acceleration and velocity."
#~ msgstr ""

#~ msgid "Extruder kinematics"
#~ msgstr ""

#~ msgid ""
#~ "Klipper implements extruder motion in its own kinematic class. Since the "
#~ "timing and speed of each print head movement is fully known for each move, "
#~ "it's possible to calculate the step times for the extruder independently "
#~ "from the step time calculations of the print head movement."
#~ msgstr ""

#~ msgid ""
#~ "Basic extruder movement is simple to calculate. The step time generation "
#~ "uses the same formulas that cartesian robots use:"
#~ msgstr ""

#~ msgid "stepper_position = requested_e_position\n"
#~ msgstr ""

#~ msgid ""
#~ "Experimentation has shown that it's possible to improve the modeling of the "
#~ "extruder beyond the basic extruder formula. In the ideal case, as an "
#~ "extrusion move progresses, the same volume of filament should be deposited "
#~ "at each point along the move and there should be no volume extruded after "
#~ "the move. Unfortunately, it's common to find that the basic extrusion "
#~ "formulas cause too little filament to exit the extruder at the start of "
#~ "extrusion moves and for excess filament to extrude after extrusion ends. "
#~ "This is often referred to as \"ooze\"."
#~ msgstr ""

#~ msgid "![ooze](img/ooze.svg.png)"
#~ msgstr ""

#~ msgid ""
#~ "The \"pressure advance\" system attempts to account for this by using a "
#~ "different model for the extruder. Instead of naively believing that each "
#~ "mm^3 of filament fed into the extruder will result in that amount of mm^3 "
#~ "immediately exiting the extruder, it uses a model based on pressure. "
#~ "Pressure increases when filament is pushed into the extruder (as in [Hooke's"
#~ " law](https://en.wikipedia.org/wiki/Hooke%27s_law)) and the pressure "
#~ "necessary to extrude is dominated by the flow rate through the nozzle "
#~ "orifice (as in [Poiseuille's "
#~ "law](https://en.wikipedia.org/wiki/Poiseuille_law)). The key idea is that "
#~ "the relationship between filament, pressure, and flow rate can be modeled "
#~ "using a linear coefficient:"
#~ msgstr ""

#~ msgid ""
#~ "pa_position = nominal_position + pressure_advance_coefficient * "
#~ "nominal_velocity\n"
#~ msgstr ""

#~ msgid ""
#~ "See the [pressure advance](Pressure_Advance.md) document for information on "
#~ "how to find this pressure advance coefficient."
#~ msgstr ""

#~ msgid ""
#~ "The basic pressure advance formula can cause the extruder motor to make "
#~ "sudden velocity changes. Klipper implements \"smoothing\" of the extruder "
#~ "movement to avoid this."
#~ msgstr ""

#~ msgid "![pressure-advance](img/pressure-velocity.png)"
#~ msgstr ""

#~ msgid ""
#~ "The above graph shows an example of two extrusion moves with a non-zero "
#~ "cornering velocity between them. Note that the pressure advance system "
#~ "causes additional filament to be pushed into the extruder during "
#~ "acceleration. The higher the desired filament flow rate, the more filament "
#~ "must be pushed in during acceleration to account for pressure. During head "
#~ "deceleration the extra filament is retracted (the extruder will have a "
#~ "negative velocity)."
#~ msgstr ""

#~ msgid ""
#~ "The \"smoothing\" is implemented using a weighted average of the extruder "
#~ "position over a small time period (as specified by the "
#~ "`pressure_advance_smooth_time` config parameter). This averaging can span "
#~ "multiple g-code moves. Note how the extruder motor will start moving prior "
#~ "to the nominal start of the first extrusion move and will continue to move "
#~ "after the nominal end of the last extrusion move."
#~ msgstr ""

#~ msgid "Key formula for \"smoothed pressure advance\":"
#~ msgstr ""

#~ msgid ""
#~ "smooth_pa_position(t) =\n"
#~ "    ( definitive_integral(pa_position(x) * (smooth_time/2 - abs(t - x)) * dx,\n"
#~ "                          from=t-smooth_time/2, to=t+smooth_time/2)\n"
#~ "     / (smooth_time/2)^2 )\n"
#~ msgstr ""

#~ msgid "Installation"
#~ msgstr ""

#~ msgid ""
#~ "These instructions assume the software will run on a Raspberry Pi computer "
#~ "in conjunction with OctoPrint. It is recommended that a Raspberry Pi 2, 3, "
#~ "or 4 computer be used as the host machine (see the [FAQ](FAQ.md#can-i-run-"
#~ "klipper-on-something-other-than-a-raspberry-pi-3) for other machines)."
#~ msgstr ""

#~ msgid "Obtain a Klipper Configuration File"
#~ msgstr ""

#~ msgid ""
#~ "Most Klipper settings are determined by a \"printer configuration file\" "
#~ "that will be stored on the Raspberry Pi. An appropriate configuration file "
#~ "can often be found by looking in the Klipper [config directory](../config/) "
#~ "for a file starting with a \"printer-\" prefix that corresponds to the "
#~ "target printer. The Klipper configuration file contains technical "
#~ "information about the printer that will be needed during the installation."
#~ msgstr ""

#~ msgid ""
#~ "If there isn't an appropriate printer configuration file in the Klipper "
#~ "config directory then try searching the printer manufacturer's website to "
#~ "see if they have an appropriate Klipper configuration file."
#~ msgstr ""

#~ msgid ""
#~ "If no configuration file for the printer can be found, but the type of "
#~ "printer control board is known, then look for an appropriate [config "
#~ "file](../config/) starting with a \"generic-\" prefix. These example printer"
#~ " board files should allow one to successfully complete the initial "
#~ "installation, but will require some customization to obtain full printer "
#~ "functionality."
#~ msgstr ""

#~ msgid ""
#~ "It is also possible to define a new printer configuration from scratch. "
#~ "However, this requires significant technical knowledge about the printer and"
#~ " its electronics. It is recommended that most users start with an "
#~ "appropriate configuration file. If creating a new custom printer "
#~ "configuration file, then start with the closest example [config "
#~ "file](../config/) and use the Klipper [config "
#~ "reference](Config_Reference.md) for further information."
#~ msgstr ""

#~ msgid "Prepping an OS image"
#~ msgstr ""

#~ msgid ""
#~ "Start by installing [OctoPi](https://github.com/guysoft/OctoPi) on the "
#~ "Raspberry Pi computer. Use OctoPi v0.17.0 or later - see the [OctoPi "
#~ "releases](https://github.com/guysoft/OctoPi/releases) for release "
#~ "information. One should verify that OctoPi boots and that the OctoPrint web "
#~ "server works. After connecting to the OctoPrint web page, follow the prompt "
#~ "to upgrade OctoPrint to v1.4.2 or later."
#~ msgstr ""

#~ msgid ""
#~ "After installing OctoPi and upgrading OctoPrint, it will be necessary to ssh"
#~ " into the target machine to run a handful of system commands. If using a "
#~ "Linux or MacOS desktop, then the \"ssh\" software should already be "
#~ "installed on the desktop. There are free ssh clients available for other "
#~ "desktops (eg, [PuTTY](https://www.chiark.greenend.org.uk/~sgtatham/putty/))."
#~ " Use the ssh utility to connect to the Raspberry Pi (ssh pi@octopi -- "
#~ "password is \"raspberry\") and run the following commands:"
#~ msgstr ""

#~ msgid ""
#~ "git clone https://github.com/Klipper3d/klipper\n"
#~ "./klipper/scripts/install-octopi.sh\n"
#~ msgstr ""

#~ msgid ""
#~ "The above will download Klipper, install some system dependencies, setup "
#~ "Klipper to run at system startup, and start the Klipper host software. It "
#~ "will require an internet connection and it may take a few minutes to "
#~ "complete."
#~ msgstr ""

#~ msgid "Building and flashing the micro-controller"
#~ msgstr ""

#~ msgid ""
#~ "To compile the micro-controller code, start by running these commands on the"
#~ " Raspberry Pi:"
#~ msgstr ""

#~ msgid ""
#~ "The comments at the top of the [printer configuration file](#obtain-a-"
#~ "klipper-configuration-file) should describe the settings that need to be set"
#~ " during \"make menuconfig\". Open the file in a web browser or text editor "
#~ "and look for these instructions near the top of the file. Once the "
#~ "appropriate \"menuconfig\" settings have been configured, press \"Q\" to "
#~ "exit, and then \"Y\" to save. Then run:"
#~ msgstr ""

#~ msgid "make\n"
#~ msgstr ""

#~ msgid ""
#~ "If the comments at the top of the [printer configuration file](#obtain-a-"
#~ "klipper-configuration-file) describe custom steps for \"flashing\" the final"
#~ " image to the printer control board then follow those steps and then proceed"
#~ " to [configuring OctoPrint](#configuring-octoprint-to-use-klipper)."
#~ msgstr ""

#~ msgid ""
#~ "Otherwise, the following steps are often used to \"flash\" the printer "
#~ "control board. First, it is necessary to determine the serial port connected"
#~ " to the micro-controller. Run the following:"
#~ msgstr ""

#~ msgid "ls /dev/serial/by-id/*\n"
#~ msgstr ""

#~ msgid "It should report something similar to the following:"
#~ msgstr ""

#~ msgid "/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0\n"
#~ msgstr ""

#~ msgid ""
#~ "It's common for each printer to have its own unique serial port name. This "
#~ "unique name will be used when flashing the micro-controller. It's possible "
#~ "there may be multiple lines in the above output - if so, choose the line "
#~ "corresponding to the micro-controller (see the [FAQ](FAQ.md#wheres-my-"
#~ "serial-port) for more information)."
#~ msgstr ""

#~ msgid ""
#~ "For common micro-controllers, the code can be flashed with something similar"
#~ " to:"
#~ msgstr ""

#~ msgid ""
#~ "sudo service klipper stop\n"
#~ "make flash FLASH_DEVICE=/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0\n"
#~ "sudo service klipper start\n"
#~ msgstr ""

#~ msgid ""
#~ "Be sure to update the FLASH_DEVICE with the printer's unique serial port "
#~ "name."
#~ msgstr ""

#~ msgid ""
#~ "When flashing for the first time, make sure that OctoPrint is not connected "
#~ "directly to the printer (from the OctoPrint web page, under the "
#~ "\"Connection\" section, click \"Disconnect\")."
#~ msgstr ""

#~ msgid "Configuring OctoPrint to use Klipper"
#~ msgstr ""

#~ msgid ""
#~ "The OctoPrint web server needs to be configured to communicate with the "
#~ "Klipper host software. Using a web browser, login to the OctoPrint web page "
#~ "and then configure the following items:"
#~ msgstr ""

#~ msgid ""
#~ "Navigate to the Settings tab (the wrench icon at the top of the page). Under"
#~ " \"Serial Connection\" in \"Additional serial ports\" add \"/tmp/printer\". "
#~ "Then click \"Save\"."
#~ msgstr ""

#~ msgid ""
#~ "Enter the Settings tab again and under \"Serial Connection\" change the "
#~ "\"Serial Port\" setting to \"/tmp/printer\"."
#~ msgstr ""

#~ msgid ""
#~ "In the Settings tab, navigate to the \"Behavior\" sub-tab and select the "
#~ "\"Cancel any ongoing prints but stay connected to the printer\" option. "
#~ "Click \"Save\"."
#~ msgstr ""

#~ msgid ""
#~ "From the main page, under the \"Connection\" section (at the top left of the"
#~ " page) make sure the \"Serial Port\" is set to \"/tmp/printer\" and click "
#~ "\"Connect\". (If \"/tmp/printer\" is not an available selection then try "
#~ "reloading the page.)"
#~ msgstr ""

#~ msgid ""
#~ "Once connected, navigate to the \"Terminal\" tab and type \"status\" "
#~ "(without the quotes) into the command entry box and click \"Send\". The "
#~ "terminal window will likely report there is an error opening the config file"
#~ " - that means OctoPrint is successfully communicating with Klipper. Proceed "
#~ "to the next section."
#~ msgstr ""

#~ msgid "Configuring Klipper"
#~ msgstr ""

#~ msgid ""
#~ "The next step is to copy the [printer configuration file](#obtain-a-klipper-"
#~ "configuration-file) to the Raspberry Pi."
#~ msgstr ""

#~ msgid ""
#~ "Arguably the easiest way to set the Klipper configuration file is to use a "
#~ "desktop editor that supports editing files over the \"scp\" and/or \"sftp\" "
#~ "protocols. There are freely available tools that support this (eg, "
#~ "Notepad++, WinSCP, and Cyberduck). Load the printer config file in the "
#~ "editor and then save it as a file named \"printer.cfg\" in the home "
#~ "directory of the pi user (ie, /home/pi/printer.cfg)."
#~ msgstr ""

#~ msgid ""
#~ "Alternatively, one can also copy and edit the file directly on the Raspberry"
#~ " Pi via ssh. That may look something like the following (be sure to update "
#~ "the command to use the appropriate printer config filename):"
#~ msgstr ""

#~ msgid ""
#~ "cp ~/klipper/config/example-cartesian.cfg ~/printer.cfg\n"
#~ "nano ~/printer.cfg\n"
#~ msgstr ""

#~ msgid ""
#~ "It's common for each printer to have its own unique name for the micro-"
#~ "controller. The name may change after flashing Klipper, so rerun these steps"
#~ " again even if they were already done when flashing. Run:"
#~ msgstr ""

#~ msgid ""
#~ "Then update the config file with the unique name. For example, update the "
#~ "`[mcu]` section to look something similar to:"
#~ msgstr ""

#~ msgid ""
#~ "[mcu]\n"
#~ "serial: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0\n"
#~ msgstr ""

#~ msgid ""
#~ "After creating and editing the file it will be necessary to issue a "
#~ "\"restart\" command in the OctoPrint web terminal to load the config. A "
#~ "\"status\" command will report the printer is ready if the Klipper config "
#~ "file is successfully read and the micro-controller is successfully found and"
#~ " configured."
#~ msgstr ""

#~ msgid ""
#~ "When customizing the printer config file, it is not uncommon for Klipper to "
#~ "report a configuration error. If an error occurs, make any necessary "
#~ "corrections to the printer config file and issue \"restart\" until "
#~ "\"status\" reports the printer is ready."
#~ msgstr ""

#~ msgid ""
#~ "Klipper reports error messages via the OctoPrint terminal tab. The "
#~ "\"status\" command can be used to re-report error messages. The default "
#~ "Klipper startup script also places a log in **/tmp/klippy.log** which "
#~ "provides more detailed information."
#~ msgstr ""

#~ msgid ""
#~ "After Klipper reports that the printer is ready, proceed to the [config "
#~ "check document](Config_checks.md) to perform some basic checks on the "
#~ "definitions in the config file. See the main [documentation "
#~ "reference](Overview.md) for other information."
#~ msgstr ""

#~ msgid "Hall filament width sensor"
#~ msgstr ""

#~ msgid ""
#~ "This document describes Filament Width Sensor host module. Hardware used for"
#~ " developing this host module is based on two Hall linear sensors (ss49e for "
#~ "example). Sensors in the body are located opposite sides. Principle of "
#~ "operation: two hall sensors work in differential mode, temperature drift "
#~ "same for sensor. Special temperature compensation not needed."
#~ msgstr ""

#~ msgid ""
#~ "You can find designs at "
#~ "[Thingiverse](https://www.thingiverse.com/thing:4138933), an assembly video "
#~ "is also available on [Youtube](https://www.youtube.com/watch?v=TDO9tME8vp4)"
#~ msgstr ""

#~ msgid ""
#~ "To use Hall filament width sensor, read [Config "
#~ "Reference](Config_Reference.md#hall_filament_width_sensor) and [G-Code "
#~ "documentation](G-Codes.md#hall_filament_width_sensor)."
#~ msgstr ""

#~ msgid ""
#~ "Sensor generates two analog output based on calculated filament width. Sum "
#~ "of output voltage always equals to detected filament width. Host module "
#~ "monitors voltage changes and adjusts extrusion multiplier. I use aux2 "
#~ "connector on ramps-like board analog11 and analog12 pins. You can use "
#~ "different pins and differenr boards."
#~ msgstr ""

#~ msgid "Template for menu variables"
#~ msgstr ""

#~ msgid ""
#~ "[menu __main __filament __width_current]\n"
#~ "type: command\n"
#~ "enable: {'hall_filament_width_sensor' in printer}\n"
#~ "name: Dia: {'%.2F' % printer.hall_filament_width_sensor.Diameter}\n"
#~ "index: 0\n"
#~ "\n"
#~ "[menu __main __filament __raw_width_current]\n"
#~ "type: command\n"
#~ "enable: {'hall_filament_width_sensor' in printer}\n"
#~ "name: Raw: {'%4.0F' % printer.hall_filament_width_sensor.Raw}\n"
#~ "index: 1\n"
#~ msgstr ""

#~ msgid "Calibration procedure"
#~ msgstr ""

#~ msgid ""
#~ "To get raw sensor value you can use menu item or "
#~ "**QUERY_RAW_FILAMENT_WIDTH** command in terminal."
#~ msgstr ""

#~ msgid "Insert first calibration rod (1.5 mm size) get first raw sensor value"
#~ msgstr ""

#~ msgid ""
#~ "Insert second calibration rod (2.0 mm size) get second raw sensor value"
#~ msgstr ""

#~ msgid "Save raw sensor values in config parameter `Raw_dia1` and `Raw_dia2`"
#~ msgstr ""

#~ msgid "How to enable sensor"
#~ msgstr ""

#~ msgid "By default, the sensor is disabled at power-on."
#~ msgstr ""

#~ msgid ""
#~ "To enable the sensor, issue **ENABLE_FILAMENT_WIDTH_SENSOR** command or set "
#~ "the `enable` parameter to `true`."
#~ msgstr ""

#~ msgid "Logging"
#~ msgstr ""

#~ msgid "By default, diameter logging is disabled at power-on."
#~ msgstr ""

#~ msgid ""
#~ "Issue **ENABLE_FILAMENT_WIDTH_LOG** command to start logging and issue "
#~ "**DISABLE_FILAMENT_WIDTH_LOG** command to stop logging. To enable logging at"
#~ " power-on, set the `logging` parameter to `true`."
#~ msgstr ""

#~ msgid ""
#~ "Filament diameter is logged on every measurement interval (10 mm by "
#~ "default)."
#~ msgstr ""

#~ msgid "G-Codes"
#~ msgstr ""

#~ msgid ""
#~ "This document describes the commands that Klipper supports. These are "
#~ "commands that one may enter into the OctoPrint terminal tab."
#~ msgstr ""

#~ msgid "G-Code commands"
#~ msgstr ""

#~ msgid "Klipper supports the following standard G-Code commands:"
#~ msgstr ""

#~ msgid "Move (G0 or G1): `G1 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>] [F<speed>]`"
#~ msgstr ""

#~ msgid "Dwell: `G4 P<milliseconds>`"
#~ msgstr ""

#~ msgid "Move to origin: `G28 [X] [Y] [Z]`"
#~ msgstr ""

#~ msgid "Turn off motors: `M18` or `M84`"
#~ msgstr ""

#~ msgid "Wait for current moves to finish: `M400`"
#~ msgstr ""

#~ msgid "Use absolute/relative distances for extrusion: `M82`, `M83`"
#~ msgstr ""

#~ msgid "Use absolute/relative coordinates: `G90`, `G91`"
#~ msgstr ""

#~ msgid "Set position: `G92 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>]`"
#~ msgstr ""

#~ msgid "Set speed factor override percentage: `M220 S<percent>`"
#~ msgstr ""

#~ msgid "Set extrude factor override percentage: `M221 S<percent>`"
#~ msgstr ""

#~ msgid "Set acceleration: `M204 S<value>` OR `M204 P<value> T<value>`"
#~ msgstr ""

#~ msgid ""
#~ "Note: If S is not specified and both P and T are specified, then the "
#~ "acceleration is set to the minimum of P and T. If only one of P or T is "
#~ "specified, the command has no effect."
#~ msgstr ""

#~ msgid "Get extruder temperature: `M105`"
#~ msgstr ""

#~ msgid "Set extruder temperature: `M104 [T<index>] [S<temperature>]`"
#~ msgstr ""

#~ msgid "Set extruder temperature and wait: `M109 [T<index>] S<temperature>`"
#~ msgstr ""

#~ msgid "Note: M109 always waits for temperature to settle at requested value"
#~ msgstr ""

#~ msgid "Set bed temperature: `M140 [S<temperature>]`"
#~ msgstr ""

#~ msgid "Set bed temperature and wait: `M190 S<temperature>`"
#~ msgstr ""

#~ msgid "Note: M190 always waits for temperature to settle at requested value"
#~ msgstr ""

#~ msgid "Set fan speed: `M106 S<value>`"
#~ msgstr ""

#~ msgid "Turn fan off: `M107`"
#~ msgstr ""

#~ msgid "Emergency stop: `M112`"
#~ msgstr ""

#~ msgid "Get current position: `M114`"
#~ msgstr ""

#~ msgid "Get firmware version: `M115`"
#~ msgstr ""

#~ msgid ""
#~ "For further details on the above commands see the [RepRap G-Code "
#~ "documentation](http://reprap.org/wiki/G-code)."
#~ msgstr ""

#~ msgid ""
#~ "Klipper's goal is to support the G-Code commands produced by common 3rd "
#~ "party software (eg, OctoPrint, Printrun, Slic3r, Cura, etc.) in their "
#~ "standard configurations. It is not a goal to support every possible G-Code "
#~ "command. Instead, Klipper prefers human readable [\"extended G-Code "
#~ "commands\"](#additional-commands). Similarly, the G-Code terminal output is "
#~ "only intended to be human readable - see the [API Server "
#~ "document](API_Server.md) if controlling Klipper from external software."
#~ msgstr ""

#~ msgid ""
#~ "If one requires a less common G-Code command then it may be possible to "
#~ "implement it with a custom [gcode_macro config "
#~ "section](Config_Reference.md#gcode_macro). For example, one might use this "
#~ "to implement: `G12`, `G29`, `G30`, `G31`, `M42`, `M80`, `M81`, `T1`, etc."
#~ msgstr ""

#~ msgid "Additional Commands"
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses \"extended\" G-Code commands for general configuration and "
#~ "status. These extended commands all follow a similar format - they start "
#~ "with a command name and may be followed by one or more parameters. For "
#~ "example: `SET_SERVO SERVO=myservo ANGLE=5.3`. In this document, the commands"
#~ " and parameters are shown in uppercase, however they are not case sensitive."
#~ " (So, \"SET_SERVO\" and \"set_servo\" both run the same command.)"
#~ msgstr ""

#~ msgid ""
#~ "This section is organized by Klipper module name, which generally follows "
#~ "the section names specified in the [printer configuration "
#~ "file](Config_Reference.md). Note that some modules are automatically loaded."
#~ msgstr ""

#~ msgid "[adxl345]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when an [adxl345 config "
#~ "section](Config_Reference.md#adxl345) is enabled."
#~ msgstr ""

#~ msgid "ACCELEROMETER_MEASURE"
#~ msgstr ""

#~ msgid ""
#~ "`ACCELEROMETER_MEASURE [CHIP=<config_name>] [NAME=<value>]`: Starts "
#~ "accelerometer measurements at the requested number of samples per second. If"
#~ " CHIP is not specified it defaults to \"adxl345\". The command works in a "
#~ "start-stop mode: when executed for the first time, it starts the "
#~ "measurements, next execution stops them. The results of measurements are "
#~ "written to a file named `/tmp/adxl345-<chip>-<name>.csv` where `<chip>` is "
#~ "the name of the accelerometer chip (`my_chip_name` from `[adxl345 "
#~ "my_chip_name]`) and `<name>` is the optional NAME parameter. If NAME is not "
#~ "specified it defaults to the current time in \"YYYYMMDD_HHMMSS\" format. If "
#~ "the accelerometer does not have a name in its config section (simply "
#~ "`[adxl345]`) then `<chip>` part of the name is not generated."
#~ msgstr ""

#~ msgid "ACCELEROMETER_QUERY"
#~ msgstr ""

#~ msgid ""
#~ "`ACCELEROMETER_QUERY [CHIP=<config_name>] [RATE=<value>]`: queries "
#~ "accelerometer for the current value. If CHIP is not specified it defaults to"
#~ " \"adxl345\". If RATE is not specified, the default value is used. This "
#~ "command is useful to test the connection to the ADXL345 accelerometer: one "
#~ "of the returned values should be a free-fall acceleration (+/- some noise of"
#~ " the chip)."
#~ msgstr ""

#~ msgid "ACCELEROMETER_DEBUG_READ"
#~ msgstr ""

#~ msgid ""
#~ "`ACCELEROMETER_DEBUG_READ [CHIP=<config_name>] REG=<register>`: queries "
#~ "ADXL345 register \"register\" (e.g. 44 or 0x2C). Can be useful for debugging"
#~ " purposes."
#~ msgstr ""

#~ msgid "ACCELEROMETER_DEBUG_WRITE"
#~ msgstr ""

#~ msgid ""
#~ "`ACCELEROMETER_DEBUG_WRITE [CHIP=<config_name>] REG=<register> VAL=<value>`:"
#~ " Writes raw \"value\" into a register \"register\". Both \"value\" and "
#~ "\"register\" can be a decimal or a hexadecimal integer. Use with care, and "
#~ "refer to ADXL345 data sheet for the reference."
#~ msgstr ""

#~ msgid "[angle]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when an [angle config "
#~ "section](Config_Reference.md#angle) is enabled."
#~ msgstr ""

#~ msgid "ANGLE_CALIBRATE"
#~ msgstr ""

#~ msgid ""
#~ "`ANGLE_CALIBRATE CHIP=<chip_name>`: Perform angle calibration on the given "
#~ "sensor (there must be an `[angle chip_name]` config section that has "
#~ "specified a `stepper` parameter). IMPORTANT - this tool will command the "
#~ "stepper motor to move without checking the normal kinematic boundary limits."
#~ " Ideally the motor should be disconnected from any printer carriage before "
#~ "performing calibration. If the stepper can not be disconnected from the "
#~ "printer, make sure the carriage is near the center of its rail before "
#~ "starting calibration. (The stepper motor may move forwards or backwards two "
#~ "full rotations during this test.) After completing this test use the "
#~ "`SAVE_CONFIG` command to save the calibration data to the config file. In "
#~ "order to use this tool the Python \"numpy\" package must be installed (see "
#~ "the [measuring resonance document](Measuring_Resonances.md#software-"
#~ "installation) for more information)."
#~ msgstr ""

#~ msgid "ANGLE_DEBUG_READ"
#~ msgstr ""

#~ msgid ""
#~ "`ANGLE_DEBUG_READ CHIP=<config_name> REG=<register>`: Queries sensor "
#~ "register \"register\" (e.g. 44 or 0x2C). Can be useful for debugging "
#~ "purposes. This is only available for tle5012b chips."
#~ msgstr ""

#~ msgid "ANGLE_DEBUG_WRITE"
#~ msgstr ""

#~ msgid ""
#~ "`ANGLE_DEBUG_WRITE CHIP=<config_name> REG=<register> VAL=<value>`: Writes "
#~ "raw \"value\" into register \"register\". Both \"value\" and \"register\" "
#~ "can be a decimal or a hexadecimal integer. Use with care, and refer to "
#~ "sensor data sheet for the reference. This is only available for tle5012b "
#~ "chips."
#~ msgstr ""

#~ msgid "[bed_mesh]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [bed_mesh config "
#~ "section](Config_Reference.md#bed_mesh) is enabled (also see the [bed mesh "
#~ "guide](Bed_Mesh.md))."
#~ msgstr ""

#~ msgid "BED_MESH_CALIBRATE"
#~ msgstr ""

#~ msgid ""
#~ "`BED_MESH_CALIBRATE [METHOD=manual] [<probe_parameter>=<value>] "
#~ "[<mesh_parameter>=<value>]`: This command probes the bed using generated "
#~ "points specified by the parameters in the config. After probing, a mesh is "
#~ "generated and z-movement is adjusted according to the mesh. See the PROBE "
#~ "command for details on the optional probe parameters. If METHOD=manual is "
#~ "specified then the manual probing tool is activated - see the MANUAL_PROBE "
#~ "command above for details on the additional commands available while this "
#~ "tool is active."
#~ msgstr ""

#~ msgid "BED_MESH_OUTPUT"
#~ msgstr ""

#~ msgid ""
#~ "`BED_MESH_OUTPUT PGP=[<0:1>]`: This command outputs the current probed z "
#~ "values and current mesh values to the terminal. If PGP=1 is specified the X,"
#~ " Y coordinates generated by bed_mesh, along with their associated indices, "
#~ "will be output to the terminal."
#~ msgstr ""

#~ msgid "BED_MESH_MAP"
#~ msgstr ""

#~ msgid ""
#~ "`BED_MESH_MAP`: Like to BED_MESH_OUTPUT, this command prints the current "
#~ "state of the mesh to the terminal. Instead of printing the values in a human"
#~ " readable format, the state is serialized in json format. This allows "
#~ "octoprint plugins to easily capture the data and generate height maps "
#~ "approximating the bed's surface."
#~ msgstr ""

#~ msgid "BED_MESH_CLEAR"
#~ msgstr ""

#~ msgid ""
#~ "`BED_MESH_CLEAR`: This command clears the mesh and removes all z adjustment."
#~ " It is recommended to put this in your end-gcode."
#~ msgstr ""

#~ msgid "BED_MESH_PROFILE"
#~ msgstr ""

#~ msgid ""
#~ "`BED_MESH_PROFILE LOAD=<name> SAVE=<name> REMOVE=<name>`: This command "
#~ "provides profile management for mesh state. LOAD will restore the mesh state"
#~ " from the profile matching the supplied name. SAVE will save the current "
#~ "mesh state to a profile matching the supplied name. Remove will delete the "
#~ "profile matching the supplied name from persistent memory. Note that after "
#~ "SAVE or REMOVE operations have been run the SAVE_CONFIG gcode must be run to"
#~ " make the changes to persistent memory permanent."
#~ msgstr ""

#~ msgid "BED_MESH_OFFSET"
#~ msgstr ""

#~ msgid ""
#~ "`BED_MESH_OFFSET [X=<value>] [Y=<value>]`: Applies X and/or Y offsets to the"
#~ " mesh lookup. This is useful for printers with independent extruders, as an "
#~ "offset is necessary to produce correct Z adjustment after a tool change."
#~ msgstr ""

#~ msgid "[bed_screws]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [bed_screws config "
#~ "section](Config_Reference.md#bed_screws) is enabled (also see the [manual "
#~ "level guide](Manual_Level.md#adjusting-bed-leveling-screws))."
#~ msgstr ""

#~ msgid "BED_SCREWS_ADJUST"
#~ msgstr ""

#~ msgid ""
#~ "`BED_SCREWS_ADJUST`: This command will invoke the bed screws adjustment "
#~ "tool. It will command the nozzle to different locations (as defined in the "
#~ "config file) and allow one to make adjustments to the bed screws so that the"
#~ " bed is a constant distance from the nozzle."
#~ msgstr ""

#~ msgid "[bed_tilt]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [bed_tilt config "
#~ "section](Config_Reference.md#bed_tilt) is enabled."
#~ msgstr ""

#~ msgid "BED_TILT_CALIBRATE"
#~ msgstr ""

#~ msgid ""
#~ "`BED_TILT_CALIBRATE [METHOD=manual] [<probe_parameter>=<value>]`: This "
#~ "command will probe the points specified in the config and then recommend "
#~ "updated x and y tilt adjustments. See the PROBE command for details on the "
#~ "optional probe parameters. If METHOD=manual is specified then the manual "
#~ "probing tool is activated - see the MANUAL_PROBE command above for details "
#~ "on the additional commands available while this tool is active."
#~ msgstr ""

#~ msgid "[bltouch]"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a [bltouch config "
#~ "section](Config_Reference.md#bltouch) is enabled (also see the [BL-Touch "
#~ "guide](BLTouch.md))."
#~ msgstr ""

#~ msgid "BLTOUCH_DEBUG"
#~ msgstr ""

#~ msgid ""
#~ "`BLTOUCH_DEBUG COMMAND=<command>`: This sends a command to the BLTouch. It "
#~ "may be useful for debugging. Available commands are: `pin_down`, "
#~ "`touch_mode`, `pin_up`, `self_test`, `reset`. A BL-Touch V3.0 or V3.1 may "
#~ "also support `set_5V_output_mode`, `set_OD_output_mode`, `output_mode_store`"
#~ " commands."
#~ msgstr ""

#~ msgid "BLTOUCH_STORE"
#~ msgstr ""

#~ msgid ""
#~ "`BLTOUCH_STORE MODE=<output_mode>`: This stores an output mode in the EEPROM"
#~ " of a BLTouch V3.1 Available output_modes are: `5V`, `OD`"
#~ msgstr ""

#~ msgid "[configfile]"
#~ msgstr ""

#~ msgid "The configfile module is automatically loaded."
#~ msgstr ""

#~ msgid "SAVE_CONFIG"
#~ msgstr ""

#~ msgid ""
#~ "`SAVE_CONFIG`: This command will overwrite the main printer config file and "
#~ "restart the host software. This command is used in conjunction with other "
#~ "calibration commands to store the results of calibration tests."
#~ msgstr ""

#~ msgid "[delayed_gcode]"
#~ msgstr ""

#~ msgid ""
#~ "The following command is enabled if a [delayed_gcode config "
#~ "section](Config_Reference.md#delayed_gcode) has been enabled (also see the "
#~ "[template guide](Command_Templates.md#delayed-gcodes))."
#~ msgstr ""

#~ msgid "UPDATE_DELAYED_GCODE"
#~ msgstr ""

#~ msgid ""
#~ "`UPDATE_DELAYED_GCODE [ID=<name>] [DURATION=<seconds>]`: Updates the delay "
#~ "duration for the identified [delayed_gcode] and starts the timer for gcode "
#~ "execution. A value of 0 will cancel a pending delayed gcode from executing."
#~ msgstr ""

#~ msgid "[delta_calibrate]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [delta_calibrate config "
#~ "section](Config_Reference.md#linear-delta-kinematics) is enabled (also see "
#~ "the [delta calibrate guide](Delta_Calibrate.md))."
#~ msgstr ""

#~ msgid "DELTA_CALIBRATE"
#~ msgstr ""

#~ msgid ""
#~ "`DELTA_CALIBRATE [METHOD=manual] [<probe_parameter>=<value>]`: This command "
#~ "will probe seven points on the bed and recommend updated endstop positions, "
#~ "tower angles, and radius. See the PROBE command for details on the optional "
#~ "probe parameters. If METHOD=manual is specified then the manual probing tool"
#~ " is activated - see the MANUAL_PROBE command above for details on the "
#~ "additional commands available while this tool is active."
#~ msgstr ""

#~ msgid "DELTA_ANALYZE"
#~ msgstr ""

#~ msgid ""
#~ "`DELTA_ANALYZE`: This command is used during enhanced delta calibration. See"
#~ " [Delta Calibrate](Delta_Calibrate.md) for details."
#~ msgstr ""

#~ msgid "[display]"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a [display config "
#~ "section](Config_Reference.md#gcode_macro) is enabled."
#~ msgstr ""

#~ msgid "SET_DISPLAY_GROUP"
#~ msgstr ""

#~ msgid ""
#~ "`SET_DISPLAY_GROUP [DISPLAY=<display>] GROUP=<group>`: Set the active "
#~ "display group of an lcd display. This allows to define multiple display data"
#~ " groups in the config, e.g. `[display_data <group> <elementname>]` and "
#~ "switch between them using this extended gcode command. If DISPLAY is not "
#~ "specified it defaults to \"display\" (the primary display)."
#~ msgstr ""

#~ msgid "[display_status]"
#~ msgstr ""

#~ msgid ""
#~ "The display_status module is automatically loaded if a [display config "
#~ "section](Config_Reference.md#display) is enabled. It provides the following "
#~ "standard G-Code commands:"
#~ msgstr ""

#~ msgid "Display Message: `M117 <message>`"
#~ msgstr ""

#~ msgid "Set build percentage: `M73 P<percent>`"
#~ msgstr ""

#~ msgid "Also provided is the following extended G-Code command:"
#~ msgstr ""

#~ msgid ""
#~ "`SET_DISPLAY_TEXT MSG=<message>`: Performs the equivalent of M117, setting "
#~ "the supplied `MSG` as the current display message. If `MSG` is omitted the "
#~ "display will be cleared."
#~ msgstr ""

#~ msgid "[dual_carriage]"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when the [dual_carriage config "
#~ "section](Config_Reference.md#dual_carriage) is enabled."
#~ msgstr ""

#~ msgid "SET_DUAL_CARRIAGE"
#~ msgstr ""

#~ msgid ""
#~ "`SET_DUAL_CARRIAGE CARRIAGE=[0|1]`: This command will set the active "
#~ "carriage. It is typically invoked from the activate_gcode and "
#~ "deactivate_gcode fields in a multiple extruder configuration."
#~ msgstr ""

#~ msgid "[endstop_phase]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when an [endstop_phase config "
#~ "section](Config_Reference.md#endstop_phase) is enabled (also see the "
#~ "[endstop phase guide](Endstop_Phase.md))."
#~ msgstr ""

#~ msgid "ENDSTOP_PHASE_CALIBRATE"
#~ msgstr ""

#~ msgid ""
#~ "`ENDSTOP_PHASE_CALIBRATE [STEPPER=<config_name>]`: If no STEPPER parameter "
#~ "is provided then this command will reports statistics on endstop stepper "
#~ "phases during past homing operations. When a STEPPER parameter is provided "
#~ "it arranges for the given endstop phase setting to be written to the config "
#~ "file (in conjunction with the SAVE_CONFIG command)."
#~ msgstr ""

#~ msgid "[exclude_object]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when an [exclude_object config "
#~ "section](Config_Reference.md#exclude_object) is enabled (also see the "
#~ "[exclude object guide](Exclude_Object.md)):"
#~ msgstr ""

#~ msgid "`EXCLUDE_OBJECT`"
#~ msgstr ""

#~ msgid ""
#~ "`EXCLUDE_OBJECT [NAME=object_name] [CURRENT=1] [RESET=1]`: With no "
#~ "parameters, this will return a list of all currently excluded objects."
#~ msgstr ""

#~ msgid ""
#~ "When the `NAME` parameter is given, the named object will be excluded from "
#~ "printing."
#~ msgstr ""

#~ msgid ""
#~ "When the `CURRENT` parameter is given, the current object will be excluded "
#~ "from printing."
#~ msgstr ""

#~ msgid ""
#~ "When the `RESET` parameter is given, the list of excluded objects will be "
#~ "cleared. Additionally including `NAME` will only reset the named object. "
#~ "This **can** cause print failures, if layers were already skipped."
#~ msgstr ""

#~ msgid "`EXCLUDE_OBJECT_DEFINE`"
#~ msgstr ""

#~ msgid ""
#~ "`EXCLUDE_OBJECT_DEFINE [NAME=object_name [CENTER=X,Y] [POLYGON=[[x,y],...]] "
#~ "[RESET=1] [JSON=1]`: Provides a summary of an object in the file."
#~ msgstr ""

#~ msgid ""
#~ "With no parameters provided, this will list the defined objects known to "
#~ "Klipper. Returns a list of strings, unless the `JSON` parameter is given, "
#~ "when it will return object details in json format."
#~ msgstr ""

#~ msgid ""
#~ "When the `NAME` parameter is included, this defines an object to be "
#~ "excluded."
#~ msgstr ""

#~ msgid ""
#~ "`NAME`: This parameter is required. It is the identifier used by other "
#~ "commands in this module."
#~ msgstr ""

#~ msgid "`CENTER`: An X,Y coordinate for the object."
#~ msgstr ""

#~ msgid ""
#~ "`POLYGON`: An array of X,Y coordinates that provide an outline for the "
#~ "object."
#~ msgstr ""

#~ msgid ""
#~ "When the `RESET` parameter is provided, all defined objects will be cleared,"
#~ " and the `[exclude_object]` module will be reset."
#~ msgstr ""

#~ msgid "`EXCLUDE_OBJECT_START`"
#~ msgstr ""

#~ msgid ""
#~ "`EXCLUDE_OBJECT_START NAME=object_name`: This command takes a `NAME` "
#~ "parameter and denotes the start of the gcode for an object on the current "
#~ "layer."
#~ msgstr ""

#~ msgid "`EXCLUDE_OBJECT_END`"
#~ msgstr ""

#~ msgid ""
#~ "`EXCLUDE_OBJECT_END [NAME=object_name]`: Denotes the end of the object's "
#~ "gcode for the layer. It is paired with `EXCLUDE_OBJECT_START`. A `NAME` "
#~ "parameter is optional, and will only warn when the provided name does not "
#~ "match the current object."
#~ msgstr ""

#~ msgid "[extruder]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available if an [extruder config "
#~ "section](Config_Reference.md#extruder) is enabled:"
#~ msgstr ""

#~ msgid "ACTIVATE_EXTRUDER"
#~ msgstr ""

#~ msgid ""
#~ "`ACTIVATE_EXTRUDER EXTRUDER=<config_name>`: In a printer with multiple "
#~ "[extruder](Config_Reference.md#extruder) config sections, this command "
#~ "changes the active hotend."
#~ msgstr ""

#~ msgid "SET_PRESSURE_ADVANCE"
#~ msgstr ""

#~ msgid ""
#~ "`SET_PRESSURE_ADVANCE [EXTRUDER=<config_name>] [ADVANCE=<pressure_advance>] "
#~ "[SMOOTH_TIME=<pressure_advance_smooth_time>]`: Set pressure advance "
#~ "parameters of an extruder stepper (as defined in an "
#~ "[extruder](Config_Reference.md#extruder) or "
#~ "[extruder_stepper](Config_Reference.md#extruder_stepper) config section). If"
#~ " EXTRUDER is not specified, it defaults to the stepper defined in the active"
#~ " hotend."
#~ msgstr ""

#~ msgid "SET_EXTRUDER_ROTATION_DISTANCE"
#~ msgstr ""

#~ msgid ""
#~ "`SET_EXTRUDER_ROTATION_DISTANCE EXTRUDER=<config_name> "
#~ "[DISTANCE=<distance>]`: Set a new value for the provided extruder stepper's "
#~ "\"rotation distance\" (as defined in an "
#~ "[extruder](Config_Reference.md#extruder) or "
#~ "[extruder_stepper](Config_Reference.md#extruder_stepper) config section). If"
#~ " the rotation distance is a negative number then the stepper motion will be "
#~ "inverted (relative to the stepper direction specified in the config file). "
#~ "Changed settings are not retained on Klipper reset. Use with caution as "
#~ "small changes can result in excessive pressure between extruder and hotend. "
#~ "Do proper calibration with filament before use. If 'DISTANCE' value is not "
#~ "provided then this command will return the current rotation distance."
#~ msgstr ""

#~ msgid "SYNC_EXTRUDER_MOTION"
#~ msgstr ""

#~ msgid ""
#~ "`SYNC_EXTRUDER_MOTION EXTRUDER=<name> MOTION_QUEUE=<name>`: This command "
#~ "will cause the stepper specified by EXTRUDER (as defined in an "
#~ "[extruder](Config_Reference.md#extruder) or "
#~ "[extruder_stepper](Config_Reference.md#extruder_stepper) config section) to "
#~ "become synchronized to the movement of an extruder specified by MOTION_QUEUE"
#~ " (as defined in an [extruder](Config_Reference.md#extruder) config section)."
#~ " If MOTION_QUEUE is an empty string then the stepper will be desynchronized "
#~ "from all extruder movement."
#~ msgstr ""

#~ msgid "SET_EXTRUDER_STEP_DISTANCE"
#~ msgstr ""

#~ msgid "This command is deprecated and will be removed in the near future."
#~ msgstr ""

#~ msgid "SYNC_STEPPER_TO_EXTRUDER"
#~ msgstr ""

#~ msgid "[fan_generic]"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a [fan_generic config "
#~ "section](Config_Reference.md#fan_generic) is enabled."
#~ msgstr ""

#~ msgid "SET_FAN_SPEED"
#~ msgstr ""

#~ msgid ""
#~ "`SET_FAN_SPEED FAN=config_name SPEED=<speed>` This command sets the speed of"
#~ " a fan. \"speed\" must be between 0.0 and 1.0."
#~ msgstr ""

#~ msgid "[filament_switch_sensor]"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a "
#~ "[filament_switch_sensor](Config_Reference.md#filament_switch_sensor) or "
#~ "[filament_motion_sensor](Config_Reference.md#filament_motion_sensor) config "
#~ "section is enabled."
#~ msgstr ""

#~ msgid "QUERY_FILAMENT_SENSOR"
#~ msgstr ""

#~ msgid ""
#~ "`QUERY_FILAMENT_SENSOR SENSOR=<sensor_name>`: Queries the current status of "
#~ "the filament sensor. The data displayed on the terminal will depend on the "
#~ "sensor type defined in the configuration."
#~ msgstr ""

#~ msgid "SET_FILAMENT_SENSOR"
#~ msgstr ""

#~ msgid ""
#~ "`SET_FILAMENT_SENSOR SENSOR=<sensor_name> ENABLE=[0|1]`: Sets the filament "
#~ "sensor on/off. If ENABLE is set to 0, the filament sensor will be disabled, "
#~ "if set to 1 it is enabled."
#~ msgstr ""

#~ msgid "[firmware_retraction]"
#~ msgstr ""

#~ msgid ""
#~ "The following standard G-Code commands are available when the "
#~ "[firmware_retraction config "
#~ "section](Config_Reference.md#firmware_retraction) is enabled. These commands"
#~ " allow you to utilize the firmware retraction feature available in many "
#~ "slicers, to reduce stringing during non-extrusion moves from one part of the"
#~ " print to another. Appropriately configuring pressure advance reduces the "
#~ "length of retraction required."
#~ msgstr ""

#~ msgid ""
#~ "`G10`: Retracts the extruder using the currently configured parameters."
#~ msgstr ""

#~ msgid ""
#~ "`G11`: Unretracts the extruder using the currently configured parameters."
#~ msgstr ""

#~ msgid "The following additional commands are also available."
#~ msgstr ""

#~ msgid "SET_RETRACTION"
#~ msgstr ""

#~ msgid ""
#~ "`SET_RETRACTION [RETRACT_LENGTH=<mm>] [RETRACT_SPEED=<mm/s>] "
#~ "[UNRETRACT_EXTRA_LENGTH=<mm>] [UNRETRACT_SPEED=<mm/s>]`: Adjust the "
#~ "parameters used by firmware retraction. RETRACT_LENGTH determines the length"
#~ " of filament to retract and unretract. The speed of retraction is adjusted "
#~ "via RETRACT_SPEED, and is typically set relatively high. The speed of "
#~ "unretraction is adjusted via UNRETRACT_SPEED, and is not particularly "
#~ "critical, although often lower than RETRACT_SPEED. In some cases it is "
#~ "useful to add a small amount of additional length on unretraction, and this "
#~ "is set via UNRETRACT_EXTRA_LENGTH. SET_RETRACTION is commonly set as part of"
#~ " slicer per-filament configuration, as different filaments require different"
#~ " parameter settings."
#~ msgstr ""

#~ msgid "GET_RETRACTION"
#~ msgstr ""

#~ msgid ""
#~ "`GET_RETRACTION`: Queries the current parameters used by firmware retraction"
#~ " and displays them on the terminal."
#~ msgstr ""

#~ msgid "[force_move]"
#~ msgstr ""

#~ msgid ""
#~ "The force_move module is automatically loaded, however some commands require"
#~ " setting `enable_force_move` in the [printer "
#~ "config](Config_Reference.md#force_move)."
#~ msgstr ""

#~ msgid "STEPPER_BUZZ"
#~ msgstr ""

#~ msgid ""
#~ "`STEPPER_BUZZ STEPPER=<config_name>`: Move the given stepper forward one mm "
#~ "and then backward one mm, repeated 10 times. This is a diagnostic tool to "
#~ "help verify stepper connectivity."
#~ msgstr ""

#~ msgid "FORCE_MOVE"
#~ msgstr ""

#~ msgid ""
#~ "`FORCE_MOVE STEPPER=<config_name> DISTANCE=<value> VELOCITY=<value> "
#~ "[ACCEL=<value>]`: This command will forcibly move the given stepper the "
#~ "given distance (in mm) at the given constant velocity (in mm/s). If ACCEL is"
#~ " specified and is greater than zero, then the given acceleration (in mm/s^2)"
#~ " will be used; otherwise no acceleration is performed. No boundary checks "
#~ "are performed; no kinematic updates are made; other parallel steppers on an "
#~ "axis will not be moved. Use caution as an incorrect command could cause "
#~ "damage! Using this command will almost certainly place the low-level "
#~ "kinematics in an incorrect state; issue a G28 afterwards to reset the "
#~ "kinematics. This command is intended for low-level diagnostics and "
#~ "debugging."
#~ msgstr ""

#~ msgid "SET_KINEMATIC_POSITION"
#~ msgstr ""

#~ msgid ""
#~ "`SET_KINEMATIC_POSITION [X=<value>] [Y=<value>] [Z=<value>]`: Force the low-"
#~ "level kinematic code to believe the toolhead is at the given cartesian "
#~ "position. This is a diagnostic and debugging command; use SET_GCODE_OFFSET "
#~ "and/or G92 for regular axis transformations. If an axis is not specified "
#~ "then it will default to the position that the head was last commanded to. "
#~ "Setting an incorrect or invalid position may lead to internal software "
#~ "errors. This command may invalidate future boundary checks; issue a G28 "
#~ "afterwards to reset the kinematics."
#~ msgstr ""

#~ msgid "[gcode]"
#~ msgstr ""

#~ msgid "The gcode module is automatically loaded."
#~ msgstr ""

#~ msgid "RESTART"
#~ msgstr ""

#~ msgid ""
#~ "`RESTART`: This will cause the host software to reload its config and "
#~ "perform an internal reset. This command will not clear error state from the "
#~ "micro-controller (see FIRMWARE_RESTART) nor will it load new software (see "
#~ "[the FAQ](FAQ.md#how-do-i-upgrade-to-the-latest-software))."
#~ msgstr ""

#~ msgid "FIRMWARE_RESTART"
#~ msgstr ""

#~ msgid ""
#~ "`FIRMWARE_RESTART`: This is similar to a RESTART command, but it also clears"
#~ " any error state from the micro-controller."
#~ msgstr ""

#~ msgid "STATUS"
#~ msgstr ""

#~ msgid "`STATUS`: Report the Klipper host software status."
#~ msgstr ""

#~ msgid "HELP"
#~ msgstr ""

#~ msgid "`HELP`: Report the list of available extended G-Code commands."
#~ msgstr ""

#~ msgid "[gcode_arcs]"
#~ msgstr ""

#~ msgid ""
#~ "The following standard G-Code commands are available if a [gcode_arcs config"
#~ " section](Config_Reference.md#gcode_arcs) is enabled:"
#~ msgstr ""

#~ msgid ""
#~ "Arc Move Clockwise (G2), Arc Move Counter-clockwise (G3): `G2|G3 [X<pos>] "
#~ "[Y<pos>] [Z<pos>] [E<pos>] [F<speed>] I<value> J<value>|I<value> "
#~ "K<value>|J<value> K<value>`"
#~ msgstr ""

#~ msgid "Arc Plane Select: G17 (XY plane), G18 (XZ plane), G19 (YZ plane)"
#~ msgstr ""

#~ msgid "[gcode_macro]"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a [gcode_macro config "
#~ "section](Config_Reference.md#gcode_macro) is enabled (also see the [command "
#~ "templates guide](Command_Templates.md))."
#~ msgstr ""

#~ msgid "SET_GCODE_VARIABLE"
#~ msgstr ""

#~ msgid ""
#~ "`SET_GCODE_VARIABLE MACRO=<macro_name> VARIABLE=<name> VALUE=<value>`: This "
#~ "command allows one to change the value of a gcode_macro variable at run-"
#~ "time. The provided VALUE is parsed as a Python literal."
#~ msgstr ""

#~ msgid "[gcode_move]"
#~ msgstr ""

#~ msgid "The gcode_move module is automatically loaded."
#~ msgstr ""

#~ msgid "GET_POSITION"
#~ msgstr ""

#~ msgid ""
#~ "`GET_POSITION`: Return information on the current location of the toolhead. "
#~ "See the developer documentation of [GET_POSITION "
#~ "output](Code_Overview.md#coordinate-systems) for more information."
#~ msgstr ""

#~ msgid "SET_GCODE_OFFSET"
#~ msgstr ""

#~ msgid ""
#~ "`SET_GCODE_OFFSET [X=<pos>|X_ADJUST=<adjust>] [Y=<pos>|Y_ADJUST=<adjust>] "
#~ "[Z=<pos>|Z_ADJUST=<adjust>] [MOVE=1 [MOVE_SPEED=<speed>]]`: Set a positional"
#~ " offset to apply to future G-Code commands. This is commonly used to "
#~ "virtually change the Z bed offset or to set nozzle XY offsets when switching"
#~ " extruders. For example, if \"SET_GCODE_OFFSET Z=0.2\" is sent, then future "
#~ "G-Code moves will have 0.2mm added to their Z height. If the X_ADJUST style "
#~ "parameters are used, then the adjustment will be added to any existing "
#~ "offset (eg, \"SET_GCODE_OFFSET Z=-0.2\" followed by \"SET_GCODE_OFFSET "
#~ "Z_ADJUST=0.3\" would result in a total Z offset of 0.1). If \"MOVE=1\" is "
#~ "specified then a toolhead move will be issued to apply the given offset "
#~ "(otherwise the offset will take effect on the next absolute G-Code move that"
#~ " specifies the given axis). If \"MOVE_SPEED\" is specified then the toolhead"
#~ " move will be performed with the given speed (in mm/s); otherwise the "
#~ "toolhead move will use the last specified G-Code speed."
#~ msgstr ""

#~ msgid "SAVE_GCODE_STATE"
#~ msgstr ""

#~ msgid ""
#~ "`SAVE_GCODE_STATE [NAME=<state_name>]`: Save the current g-code coordinate "
#~ "parsing state. Saving and restoring the g-code state is useful in scripts "
#~ "and macros. This command saves the current g-code absolute coordinate mode "
#~ "(G90/G91), absolute extrude mode (M82/M83), origin (G92), offset "
#~ "(SET_GCODE_OFFSET), speed override (M220), extruder override (M221), move "
#~ "speed, current XYZ position, and relative extruder \"E\" position. If NAME "
#~ "is provided it allows one to name the saved state to the given string. If "
#~ "NAME is not provided it defaults to \"default\"."
#~ msgstr ""

#~ msgid "RESTORE_GCODE_STATE"
#~ msgstr ""

#~ msgid ""
#~ "`RESTORE_GCODE_STATE [NAME=<state_name>] [MOVE=1 [MOVE_SPEED=<speed>]]`: "
#~ "Restore a state previously saved via SAVE_GCODE_STATE. If \"MOVE=1\" is "
#~ "specified then a toolhead move will be issued to move back to the previous "
#~ "XYZ position. If \"MOVE_SPEED\" is specified then the toolhead move will be "
#~ "performed with the given speed (in mm/s); otherwise the toolhead move will "
#~ "use the restored g-code speed."
#~ msgstr ""

#~ msgid "[hall_filament_width_sensor]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [tsl1401cl filament width "
#~ "sensor config section](Config_Reference.md#tsl1401cl_filament_width_sensor) "
#~ "or [hall filament width sensor config "
#~ "section](Config_Reference.md#hall_filament_width_sensor) is enabled (also "
#~ "see [TSLl401CL Filament Width Sensor](TSL1401CL_Filament_Width_Sensor.md) "
#~ "and [Hall Filament Width Sensor](Hall_Filament_Width_Sensor.md)):"
#~ msgstr ""

#~ msgid "QUERY_FILAMENT_WIDTH"
#~ msgstr ""

#~ msgid "`QUERY_FILAMENT_WIDTH`: Return the current measured filament width."
#~ msgstr ""

#~ msgid "RESET_FILAMENT_WIDTH_SENSOR"
#~ msgstr ""

#~ msgid ""
#~ "`RESET_FILAMENT_WIDTH_SENSOR`: Clear all sensor readings. Helpful after "
#~ "filament change."
#~ msgstr ""

#~ msgid "DISABLE_FILAMENT_WIDTH_SENSOR"
#~ msgstr ""

#~ msgid ""
#~ "`DISABLE_FILAMENT_WIDTH_SENSOR`: Turn off the filament width sensor and stop"
#~ " using it for flow control."
#~ msgstr ""

#~ msgid "ENABLE_FILAMENT_WIDTH_SENSOR"
#~ msgstr ""

#~ msgid ""
#~ "`ENABLE_FILAMENT_WIDTH_SENSOR`: Turn on the filament width sensor and start "
#~ "using it for flow control."
#~ msgstr ""

#~ msgid "QUERY_RAW_FILAMENT_WIDTH"
#~ msgstr ""

#~ msgid ""
#~ "`QUERY_RAW_FILAMENT_WIDTH`: Return the current ADC channel readings and RAW "
#~ "sensor value for calibration points."
#~ msgstr ""

#~ msgid "ENABLE_FILAMENT_WIDTH_LOG"
#~ msgstr ""

#~ msgid "`ENABLE_FILAMENT_WIDTH_LOG`: Turn on diameter logging."
#~ msgstr ""

#~ msgid "DISABLE_FILAMENT_WIDTH_LOG"
#~ msgstr ""

#~ msgid "`DISABLE_FILAMENT_WIDTH_LOG`: Turn off diameter logging."
#~ msgstr ""

#~ msgid "[heaters]"
#~ msgstr ""

#~ msgid ""
#~ "The heaters module is automatically loaded if a heater is defined in the "
#~ "config file."
#~ msgstr ""

#~ msgid "TURN_OFF_HEATERS"
#~ msgstr ""

#~ msgid "`TURN_OFF_HEATERS`: Turn off all heaters."
#~ msgstr ""

#~ msgid "TEMPERATURE_WAIT"
#~ msgstr ""

#~ msgid ""
#~ "`TEMPERATURE_WAIT SENSOR=<config_name> [MINIMUM=<target>] "
#~ "[MAXIMUM=<target>]`: Wait until the given temperature sensor is at or above "
#~ "the supplied MINIMUM and/or at or below the supplied MAXIMUM."
#~ msgstr ""

#~ msgid "SET_HEATER_TEMPERATURE"
#~ msgstr ""

#~ msgid ""
#~ "`SET_HEATER_TEMPERATURE HEATER=<heater_name> [TARGET=<target_temperature>]`:"
#~ " Sets the target temperature for a heater. If a target temperature is not "
#~ "supplied, the target is 0."
#~ msgstr ""

#~ msgid "[idle_timeout]"
#~ msgstr ""

#~ msgid "The idle_timeout module is automatically loaded."
#~ msgstr ""

#~ msgid "SET_IDLE_TIMEOUT"
#~ msgstr ""

#~ msgid ""
#~ "`SET_IDLE_TIMEOUT [TIMEOUT=<timeout>]`: Allows the user to set the idle "
#~ "timeout (in seconds)."
#~ msgstr ""

#~ msgid "[input_shaper]"
#~ msgstr ""

#~ msgid ""
#~ "The following command is enabled if an [input_shaper config "
#~ "section](Config_Reference.md#input_shaper) has been enabled (also see the "
#~ "[resonance compensation guide](Resonance_Compensation.md))."
#~ msgstr ""

#~ msgid "SET_INPUT_SHAPER"
#~ msgstr ""

#~ msgid ""
#~ "`SET_INPUT_SHAPER [SHAPER_FREQ_X=<shaper_freq_x>] "
#~ "[SHAPER_FREQ_Y=<shaper_freq_y>] [DAMPING_RATIO_X=<damping_ratio_x>] "
#~ "[DAMPING_RATIO_Y=<damping_ratio_y>] [SHAPER_TYPE=<shaper>] "
#~ "[SHAPER_TYPE_X=<shaper_type_x>] [SHAPER_TYPE_Y=<shaper_type_y>]`: Modify "
#~ "input shaper parameters. Note that SHAPER_TYPE parameter resets input shaper"
#~ " for both X and Y axes even if different shaper types have been configured "
#~ "in [input_shaper] section. SHAPER_TYPE cannot be used together with either "
#~ "of SHAPER_TYPE_X and SHAPER_TYPE_Y parameters. See [config "
#~ "reference](Config_Reference.md#input_shaper) for more details on each of "
#~ "these parameters."
#~ msgstr ""

#~ msgid "[manual_probe]"
#~ msgstr ""

#~ msgid "The manual_probe module is automatically loaded."
#~ msgstr ""

#~ msgid "MANUAL_PROBE"
#~ msgstr ""

#~ msgid ""
#~ "`MANUAL_PROBE [SPEED=<speed>]`: Run a helper script useful for measuring the"
#~ " height of the nozzle at a given location. If SPEED is specified, it sets "
#~ "the speed of TESTZ commands (the default is 5mm/s). During a manual probe, "
#~ "the following additional commands are available:"
#~ msgstr ""

#~ msgid ""
#~ "`ACCEPT`: This command accepts the current Z position and concludes the "
#~ "manual probing tool."
#~ msgstr ""

#~ msgid "`ABORT`: This command terminates the manual probing tool."
#~ msgstr ""

#~ msgid ""
#~ "`TESTZ Z=<value>`: This command moves the nozzle up or down by the amount "
#~ "specified in \"value\". For example, `TESTZ Z=-.1` would move the nozzle "
#~ "down .1mm while `TESTZ Z=.1` would move the nozzle up .1mm. The value may "
#~ "also be `+`, `-`, `++`, or `--` to move the nozzle up or down an amount "
#~ "relative to previous attempts."
#~ msgstr ""

#~ msgid "Z_ENDSTOP_CALIBRATE"
#~ msgstr ""

#~ msgid ""
#~ "`Z_ENDSTOP_CALIBRATE [SPEED=<speed>]`: Run a helper script useful for "
#~ "calibrating a Z position_endstop config setting. See the MANUAL_PROBE "
#~ "command for details on the parameters and the additional commands available "
#~ "while the tool is active."
#~ msgstr ""

#~ msgid "Z_OFFSET_APPLY_ENDSTOP"
#~ msgstr ""

#~ msgid ""
#~ "`Z_OFFSET_APPLY_ENDSTOP`: Take the current Z Gcode offset (aka, "
#~ "babystepping), and subtract it from the stepper_z endstop_position. This "
#~ "acts to take a frequently used babystepping value, and \"make it "
#~ "permanent\". Requires a `SAVE_CONFIG` to take effect."
#~ msgstr ""

#~ msgid "[manual_stepper]"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a [manual_stepper config "
#~ "section](Config_Reference.md#manual_stepper) is enabled."
#~ msgstr ""

#~ msgid "MANUAL_STEPPER"
#~ msgstr ""

#~ msgid ""
#~ "`MANUAL_STEPPER STEPPER=config_name [ENABLE=[0|1]] [SET_POSITION=<pos>] "
#~ "[SPEED=<speed>] [ACCEL=<accel>] [MOVE=<pos> [STOP_ON_ENDSTOP=[1|2|-1|-2]] "
#~ "[SYNC=0]]`: This command will alter the state of the stepper. Use the ENABLE"
#~ " parameter to enable/disable the stepper. Use the SET_POSITION parameter to "
#~ "force the stepper to think it is at the given position. Use the MOVE "
#~ "parameter to request a movement to the given position. If SPEED and/or ACCEL"
#~ " is specified then the given values will be used instead of the defaults "
#~ "specified in the config file. If an ACCEL of zero is specified then no "
#~ "acceleration will be performed. If STOP_ON_ENDSTOP=1 is specified then the "
#~ "move will end early should the endstop report as triggered (use "
#~ "STOP_ON_ENDSTOP=2 to complete the move without error even if the endstop "
#~ "does not trigger, use -1 or -2 to stop when the endstop reports not "
#~ "triggered). Normally future G-Code commands will be scheduled to run after "
#~ "the stepper move completes, however if a manual stepper move uses SYNC=0 "
#~ "then future G-Code movement commands may run in parallel with the stepper "
#~ "movement."
#~ msgstr ""

#~ msgid "[mcp4018]"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a [mcp4018 config "
#~ "section](Config_Reference.md#mcp4018) is enabled."
#~ msgstr ""

#~ msgid "SET_DIGIPOT"
#~ msgstr ""

#~ msgid ""
#~ "`SET_DIGIPOT DIGIPOT=config_name WIPER=<value>`: This command will change "
#~ "the current value of the digipot. This value should typically be between 0.0"
#~ " and 1.0, unless a 'scale' is defined in the config. When 'scale' is "
#~ "defined, then this value should be between 0.0 and 'scale'."
#~ msgstr ""

#~ msgid "[led]"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when any of the [led config "
#~ "sections](Config_Reference.md#leds) are enabled."
#~ msgstr ""

#~ msgid "SET_LED"
#~ msgstr ""

#~ msgid ""
#~ "`SET_LED LED=<config_name> RED=<value> GREEN=<value> BLUE=<value> "
#~ "WHITE=<value> [INDEX=<index>] [TRANSMIT=0] [SYNC=1]`: This sets the LED "
#~ "output. Each color `<value>` must be between 0.0 and 1.0. The WHITE option "
#~ "is only valid on RGBW LEDs. If the LED supports multiple chips in a daisy-"
#~ "chain then one may specify INDEX to alter the color of just the given chip "
#~ "(1 for the first chip, 2 for the second, etc.). If INDEX is not provided "
#~ "then all LEDs in the daisy-chain will be set to the provided color. If "
#~ "TRANSMIT=0 is specified then the color change will only be made on the next "
#~ "SET_LED command that does not specify TRANSMIT=0; this may be useful in "
#~ "combination with the INDEX parameter to batch multiple updates in a daisy-"
#~ "chain. By default, the SET_LED command will sync it's changes with other "
#~ "ongoing gcode commands. This can lead to undesirable behavior if LEDs are "
#~ "being set while the printer is not printing as it will reset the idle "
#~ "timeout. If careful timing is not needed, the optional SYNC=0 parameter can "
#~ "be specified to apply the changes without resetting the idle timeout."
#~ msgstr ""

#~ msgid "SET_LED_TEMPLATE"
#~ msgstr ""

#~ msgid ""
#~ "`SET_LED_TEMPLATE LED=<led_name> TEMPLATE=<template_name> "
#~ "[<param_x>=<literal>] [INDEX=<index>]`: Assign a "
#~ "[display_template](Config_Reference.md#display_template) to a given "
#~ "[LED](Config_Reference.md#leds). For example, if one defined a "
#~ "`[display_template my_led_template]` config section then one could assign "
#~ "`TEMPLATE=my_led_template` here. The display_template should produce a comma"
#~ " separated string containing four floating point numbers corresponding to "
#~ "red, green, blue, and white color settings. The template will be "
#~ "continuously evaluated and the LED will be automatically set to the "
#~ "resulting colors. One may set display_template parameters to use during "
#~ "template evaluation (parameters will be parsed as Python literals). If INDEX"
#~ " is not specified then all chips in the LED's daisy-chain will be set to the"
#~ " template, otherwise only the chip with the given index will be updated. If "
#~ "TEMPLATE is an empty string then this command will clear any previous "
#~ "template assigned to the LED (one can then use `SET_LED` commands to manage "
#~ "the LED's color settings)."
#~ msgstr ""

#~ msgid "[output_pin]"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when an [output_pin config "
#~ "section](Config_Reference.md#output_pin) is enabled."
#~ msgstr ""

#~ msgid "SET_PIN"
#~ msgstr ""

#~ msgid ""
#~ "`SET_PIN PIN=config_name VALUE=<value> CYCLE_TIME=<cycle_time>`: Note - "
#~ "hardware PWM does not currently support the CYCLE_TIME parameter and will "
#~ "use the cycle time defined in the config."
#~ msgstr ""

#~ msgid "[palette2]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [palette2 config "
#~ "section](Config_Reference.md#palette2) is enabled."
#~ msgstr ""

#~ msgid ""
#~ "Palette prints work by embedding special OCodes (Omega Codes) in the GCode "
#~ "file:"
#~ msgstr ""

#~ msgid ""
#~ "`O1`...`O32`: These codes are read from the GCode stream and processed by "
#~ "this module and passed to the Palette 2 device."
#~ msgstr ""

#~ msgid "PALETTE_CONNECT"
#~ msgstr ""

#~ msgid ""
#~ "`PALETTE_CONNECT`: This command initializes the connection with the Palette "
#~ "2."
#~ msgstr ""

#~ msgid "PALETTE_DISCONNECT"
#~ msgstr ""

#~ msgid "`PALETTE_DISCONNECT`: This command disconnects from the Palette 2."
#~ msgstr ""

#~ msgid "PALETTE_CLEAR"
#~ msgstr ""

#~ msgid ""
#~ "`PALETTE_CLEAR`: This command instructs the Palette 2 to clear all of the "
#~ "input and output paths of filament."
#~ msgstr ""

#~ msgid "PALETTE_CUT"
#~ msgstr ""

#~ msgid ""
#~ "`PALETTE_CUT`: This command instructs the Palette 2 to cut the filament "
#~ "currently loaded in the splice core."
#~ msgstr ""

#~ msgid "PALETTE_SMART_LOAD"
#~ msgstr ""

#~ msgid ""
#~ "`PALETTE_SMART_LOAD`: This command start the smart load sequence on the "
#~ "Palette 2. Filament is loaded automatically by extruding it the distance "
#~ "calibrated on the device for the printer, and instructs the Palette 2 once "
#~ "the loading has been completed. This command is the same as pressing **Smart"
#~ " Load** directly on the Palette 2 screen after the filament load is "
#~ "complete."
#~ msgstr ""

#~ msgid "[pid_calibrate]"
#~ msgstr ""

#~ msgid ""
#~ "The pid_calibrate module is automatically loaded if a heater is defined in "
#~ "the config file."
#~ msgstr ""

#~ msgid "PID_CALIBRATE"
#~ msgstr ""

#~ msgid ""
#~ "`PID_CALIBRATE HEATER=<config_name> TARGET=<temperature> [WRITE_FILE=1]`: "
#~ "Perform a PID calibration test. The specified heater will be enabled until "
#~ "the specified target temperature is reached, and then the heater will be "
#~ "turned off and on for several cycles. If the WRITE_FILE parameter is "
#~ "enabled, then the file /tmp/heattest.txt will be created with a log of all "
#~ "temperature samples taken during the test."
#~ msgstr ""

#~ msgid "[pause_resume]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [pause_resume config "
#~ "section](Config_Reference.md#pause_resume) is enabled:"
#~ msgstr ""

#~ msgid "PAUSE"
#~ msgstr ""

#~ msgid ""
#~ "`PAUSE`: Pauses the current print. The current position is captured for "
#~ "restoration upon resume."
#~ msgstr ""

#~ msgid "RESUME"
#~ msgstr ""

#~ msgid ""
#~ "`RESUME [VELOCITY=<value>]`: Resumes the print from a pause, first restoring"
#~ " the previously captured position. The VELOCITY parameter determines the "
#~ "speed at which the tool should return to the original captured position."
#~ msgstr ""

#~ msgid "CLEAR_PAUSE"
#~ msgstr ""

#~ msgid ""
#~ "`CLEAR_PAUSE`: Clears the current paused state without resuming the print. "
#~ "This is useful if one decides to cancel a print after a PAUSE. It is "
#~ "recommended to add this to your start gcode to make sure the paused state is"
#~ " fresh for each print."
#~ msgstr ""

#~ msgid "CANCEL_PRINT"
#~ msgstr ""

#~ msgid "`CANCEL_PRINT`: Cancels the current print."
#~ msgstr ""

#~ msgid "[print_stats]"
#~ msgstr ""

#~ msgid "The print_stats module is automatically loaded."
#~ msgstr ""

#~ msgid "SET_PRINT_STATS_INFO"
#~ msgstr ""

#~ msgid ""
#~ "`SET_PRINT_STATS_INFO [TOTAL_LAYER=<total_layer_count>] [CURRENT_LAYER= "
#~ "<current_layer>]`: Pass slicer info like layer act and total to Klipper. Add"
#~ " `SET_PRINT_STATS_INFO [TOTAL_LAYER=<total_layer_count>]` to your slicer "
#~ "start gcode section and `SET_PRINT_STATS_INFO [CURRENT_LAYER= "
#~ "<current_layer>]` at the layer change gcode section to pass layer "
#~ "information from your slicer to Klipper."
#~ msgstr ""

#~ msgid "[probe]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when a [probe config "
#~ "section](Config_Reference.md#probe) or [bltouch config "
#~ "section](Config_Reference.md#bltouch) is enabled (also see the [probe "
#~ "calibrate guide](Probe_Calibrate.md))."
#~ msgstr ""

#~ msgid "PROBE"
#~ msgstr ""

#~ msgid ""
#~ "`PROBE [PROBE_SPEED=<mm/s>] [LIFT_SPEED=<mm/s>] [SAMPLES=<count>] "
#~ "[SAMPLE_RETRACT_DIST=<mm>] [SAMPLES_TOLERANCE=<mm>] "
#~ "[SAMPLES_TOLERANCE_RETRIES=<count>] [SAMPLES_RESULT=median|average]`: Move "
#~ "the nozzle downwards until the probe triggers. If any of the optional "
#~ "parameters are provided they override their equivalent setting in the [probe"
#~ " config section](Config_Reference.md#probe)."
#~ msgstr ""

#~ msgid "QUERY_PROBE"
#~ msgstr ""

#~ msgid ""
#~ "`QUERY_PROBE`: Report the current status of the probe (\"triggered\" or "
#~ "\"open\")."
#~ msgstr ""

#~ msgid "PROBE_ACCURACY"
#~ msgstr ""

#~ msgid ""
#~ "`PROBE_ACCURACY [PROBE_SPEED=<mm/s>] [SAMPLES=<count>] "
#~ "[SAMPLE_RETRACT_DIST=<mm>]`: Calculate the maximum, minimum, average, "
#~ "median, and standard deviation of multiple probe samples. By default, 10 "
#~ "SAMPLES are taken. Otherwise the optional parameters default to their "
#~ "equivalent setting in the probe config section."
#~ msgstr ""

#~ msgid "PROBE_CALIBRATE"
#~ msgstr ""

#~ msgid ""
#~ "`PROBE_CALIBRATE [SPEED=<speed>] [<probe_parameter>=<value>]`: Run a helper "
#~ "script useful for calibrating the probe's z_offset. See the PROBE command "
#~ "for details on the optional probe parameters. See the MANUAL_PROBE command "
#~ "for details on the SPEED parameter and the additional commands available "
#~ "while the tool is active. Please note, the PROBE_CALIBRATE command uses the "
#~ "speed variable to move in XY direction as well as Z."
#~ msgstr ""

#~ msgid "Z_OFFSET_APPLY_PROBE"
#~ msgstr ""

#~ msgid ""
#~ "`Z_OFFSET_APPLY_PROBE`: Take the current Z Gcode offset (aka, babystepping),"
#~ " and subtract if from the probe's z_offset. This acts to take a frequently "
#~ "used babystepping value, and \"make it permanent\". Requires a `SAVE_CONFIG`"
#~ " to take effect."
#~ msgstr ""

#~ msgid "[query_adc]"
#~ msgstr ""

#~ msgid "The query_adc module is automatically loaded."
#~ msgstr ""

#~ msgid "QUERY_ADC"
#~ msgstr ""

#~ msgid ""
#~ "`QUERY_ADC [NAME=<config_name>] [PULLUP=<value>]`: Report the last analog "
#~ "value received for a configured analog pin. If NAME is not provided, the "
#~ "list of available adc names are reported. If PULLUP is provided (as a value "
#~ "in Ohms), the raw analog value along with the equivalent resistance given "
#~ "that pullup is reported."
#~ msgstr ""

#~ msgid "[query_endstops]"
#~ msgstr ""

#~ msgid ""
#~ "The query_endstops module is automatically loaded. The following standard "
#~ "G-Code commands are currently available, but using them is not recommended:"
#~ msgstr ""

#~ msgid "Get Endstop Status: `M119` (Use QUERY_ENDSTOPS instead.)"
#~ msgstr ""

#~ msgid "QUERY_ENDSTOPS"
#~ msgstr ""

#~ msgid ""
#~ "`QUERY_ENDSTOPS`: Probe the axis endstops and report if they are "
#~ "\"triggered\" or in an \"open\" state. This command is typically used to "
#~ "verify that an endstop is working correctly."
#~ msgstr ""

#~ msgid "[resonance_tester]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when a [resonance_tester config "
#~ "section](Config_Reference.md#resonance_tester) is enabled (also see the "
#~ "[measuring resonances guide](Measuring_Resonances.md))."
#~ msgstr ""

#~ msgid "MEASURE_AXES_NOISE"
#~ msgstr ""

#~ msgid ""
#~ "`MEASURE_AXES_NOISE`: Measures and outputs the noise for all axes of all "
#~ "enabled accelerometer chips."
#~ msgstr ""

#~ msgid "TEST_RESONANCES"
#~ msgstr ""

#~ msgid ""
#~ "`TEST_RESONANCES AXIS=<axis> OUTPUT=<resonances,raw_data> [NAME=<name>] "
#~ "[FREQ_START=<min_freq>] [FREQ_END=<max_freq>] [HZ_PER_SEC=<hz_per_sec>] "
#~ "[CHIPS=<adxl345_chip_name>] [POINT=x,y,z] [INPUT_SHAPING=[<0:1>]]`: Runs the"
#~ " resonance test in all configured probe points for the requested \"axis\" "
#~ "and measures the acceleration using the accelerometer chips configured for "
#~ "the respective axis. \"axis\" can either be X or Y, or specify an arbitrary "
#~ "direction as `AXIS=dx,dy`, where dx and dy are floating point numbers "
#~ "defining a direction vector (e.g. `AXIS=X`, `AXIS=Y`, or `AXIS=1,-1` to "
#~ "define a diagonal direction). Note that `AXIS=dx,dy` and `AXIS=-dx,-dy` is "
#~ "equivalent. `adxl345_chip_name` can be one or more configured adxl345 "
#~ "chip,delimited with comma, for example `CHIPS=\"adxl345, adxl345 rpi\"`. "
#~ "Note that `adxl345` can be omitted from named adxl345 chips. If POINT is "
#~ "specified it will override the point(s) configured in `[resonance_tester]`. "
#~ "If `INPUT_SHAPING=0` or not set(default), disables input shaping for the "
#~ "resonance testing, because it is not valid to run the resonance testing with"
#~ " the input shaper enabled. `OUTPUT` parameter is a comma-separated list of "
#~ "which outputs will be written. If `raw_data` is requested, then the raw "
#~ "accelerometer data is written into a file or a series of files "
#~ "`/tmp/raw_data_<axis>_[<chip_name>_][<point>_]<name>.csv` with (`<point>_` "
#~ "part of the name generated only if more than 1 probe point is configured or "
#~ "POINT is specified). If `resonances` is specified, the frequency response is"
#~ " calculated (across all probe points) and written into "
#~ "`/tmp/resonances_<axis>_<name>.csv` file. If unset, OUTPUT defaults to "
#~ "`resonances`, and NAME defaults to the current time in \"YYYYMMDD_HHMMSS\" "
#~ "format."
#~ msgstr ""

#~ msgid "SHAPER_CALIBRATE"
#~ msgstr ""

#~ msgid ""
#~ "`SHAPER_CALIBRATE [AXIS=<axis>] [NAME=<name>] [FREQ_START=<min_freq>] "
#~ "[FREQ_END=<max_freq>] [HZ_PER_SEC=<hz_per_sec>] "
#~ "[MAX_SMOOTHING=<max_smoothing>]`: Similarly to `TEST_RESONANCES`, runs the "
#~ "resonance test as configured, and tries to find the optimal parameters for "
#~ "the input shaper for the requested axis (or both X and Y axes if `AXIS` "
#~ "parameter is unset). If `MAX_SMOOTHING` is unset, its value is taken from "
#~ "`[resonance_tester]` section, with the default being unset. See the [Max "
#~ "smoothing](Measuring_Resonances.md#max-smoothing) of the measuring "
#~ "resonances guide for more information on the use of this feature. The "
#~ "results of the tuning are printed to the console, and the frequency "
#~ "responses and the different input shapers values are written to a CSV "
#~ "file(s) `/tmp/calibration_data_<axis>_<name>.csv`. Unless specified, NAME "
#~ "defaults to the current time in \"YYYYMMDD_HHMMSS\" format. Note that the "
#~ "suggested input shaper parameters can be persisted in the config by issuing "
#~ "`SAVE_CONFIG` command."
#~ msgstr ""

#~ msgid "[respond]"
#~ msgstr ""

#~ msgid ""
#~ "The following standard G-Code commands are available when the [respond "
#~ "config section](Config_Reference.md#respond) is enabled:"
#~ msgstr ""

#~ msgid ""
#~ "`M118 <message>`: echo the message prepended with the configured default "
#~ "prefix (or `echo: ` if no prefix is configured)."
#~ msgstr ""

#~ msgid "RESPOND"
#~ msgstr ""

#~ msgid ""
#~ "`RESPOND MSG=\"<message>\"`: echo the message prepended with the configured "
#~ "default prefix (or `echo: ` if no prefix is configured)."
#~ msgstr ""

#~ msgid ""
#~ "`RESPOND TYPE=echo MSG=\"<message>\"`: echo the message prepended with "
#~ "`echo: `."
#~ msgstr ""

#~ msgid ""
#~ "`RESPOND TYPE=echo_no_space MSG=\"<message>\"`: echo the message prepended "
#~ "with `echo:` without a space between prefix and message, helpful for "
#~ "compatibility with some octoprint plugins that expect very specific "
#~ "formatting."
#~ msgstr ""

#~ msgid ""
#~ "`RESPOND TYPE=command MSG=\"<message>\"`: echo the message prepended with "
#~ "`// `. OctoPrint can be configured to respond to these messages (e.g. "
#~ "`RESPOND TYPE=command MSG=action:pause`)."
#~ msgstr ""

#~ msgid ""
#~ "`RESPOND TYPE=error MSG=\"<message>\"`: echo the message prepended with `!! "
#~ "`."
#~ msgstr ""

#~ msgid ""
#~ "`RESPOND PREFIX=<prefix> MSG=\"<message>\"`: echo the message prepended with"
#~ " `<prefix>`. (The `PREFIX` parameter will take priority over the `TYPE` "
#~ "parameter)"
#~ msgstr ""

#~ msgid "[save_variables]"
#~ msgstr ""

#~ msgid ""
#~ "The following command is enabled if a [save_variables config "
#~ "section](Config_Reference.md#save_variables) has been enabled."
#~ msgstr ""

#~ msgid "SAVE_VARIABLE"
#~ msgstr ""

#~ msgid ""
#~ "`SAVE_VARIABLE VARIABLE=<name> VALUE=<value>`: Saves the variable to disk so"
#~ " that it can be used across restarts. All stored variables are loaded into "
#~ "the `printer.save_variables.variables` dict at startup and can be used in "
#~ "gcode macros. The provided VALUE is parsed as a Python literal."
#~ msgstr ""

#~ msgid "[screws_tilt_adjust]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [screws_tilt_adjust config "
#~ "section](Config_Reference.md#screws_tilt_adjust) is enabled (also see the "
#~ "[manual level guide](Manual_Level.md#adjusting-bed-leveling-screws-using-"
#~ "the-bed-probe))."
#~ msgstr ""

#~ msgid "SCREWS_TILT_CALCULATE"
#~ msgstr ""

#~ msgid ""
#~ "`SCREWS_TILT_CALCULATE [DIRECTION=CW|CCW] [MAX_DEVIATION=<value>] "
#~ "[<probe_parameter>=<value>]`: This command will invoke the bed screws "
#~ "adjustment tool. It will command the nozzle to different locations (as "
#~ "defined in the config file) probing the z height and calculate the number of"
#~ " knob turns to adjust the bed level. If DIRECTION is specified, the knob "
#~ "turns will all be in the same direction, clockwise (CW) or counterclockwise "
#~ "(CCW). See the PROBE command for details on the optional probe parameters. "
#~ "IMPORTANT: You MUST always do a G28 before using this command. If "
#~ "MAX_DEVIATION is specified, the command will raise a gcode error if any "
#~ "difference in the screw height relative to the base screw height is greater "
#~ "than the value provided."
#~ msgstr ""

#~ msgid "[sdcard_loop]"
#~ msgstr ""

#~ msgid ""
#~ "When the [sdcard_loop config section](Config_Reference.md#sdcard_loop) is "
#~ "enabled, the following extended commands are available."
#~ msgstr ""

#~ msgid "SDCARD_LOOP_BEGIN"
#~ msgstr ""

#~ msgid ""
#~ "`SDCARD_LOOP_BEGIN COUNT=<count>`: Begin a looped section in the SD print. A"
#~ " count of 0 indicates that the section should be looped indefinitely."
#~ msgstr ""

#~ msgid "SDCARD_LOOP_END"
#~ msgstr ""

#~ msgid "`SDCARD_LOOP_END`: End a looped section in the SD print."
#~ msgstr ""

#~ msgid "SDCARD_LOOP_DESIST"
#~ msgstr ""

#~ msgid ""
#~ "`SDCARD_LOOP_DESIST`: Complete existing loops without further iterations."
#~ msgstr ""

#~ msgid "[servo]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when a [servo config "
#~ "section](Config_Reference.md#servo) is enabled."
#~ msgstr ""

#~ msgid "SET_SERVO"
#~ msgstr ""

#~ msgid ""
#~ "`SET_SERVO SERVO=config_name [ANGLE=<degrees> | WIDTH=<seconds>]`: Set the "
#~ "servo position to the given angle (in degrees) or pulse width (in seconds). "
#~ "Use `WIDTH=0` to disable the servo output."
#~ msgstr ""

#~ msgid "[skew_correction]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [skew_correction config "
#~ "section](Config_Reference.md#skew_correction) is enabled (also see the [Skew"
#~ " Correction](Skew_Correction.md) guide)."
#~ msgstr ""

#~ msgid "SET_SKEW"
#~ msgstr ""

#~ msgid ""
#~ "`SET_SKEW [XY=<ac_length,bd_length,ad_length>] [XZ=<ac,bd,ad>] "
#~ "[YZ=<ac,bd,ad>] [CLEAR=<0|1>]`: Configures the [skew_correction] module with"
#~ " measurements (in mm) taken from a calibration print. One may enter "
#~ "measurements for any combination of planes, planes not entered will retain "
#~ "their current value. If `CLEAR=1` is entered then all skew correction will "
#~ "be disabled."
#~ msgstr ""

#~ msgid "GET_CURRENT_SKEW"
#~ msgstr ""

#~ msgid ""
#~ "`GET_CURRENT_SKEW`: Reports the current printer skew for each plane in both "
#~ "radians and degrees. The skew is calculated based on parameters provided via"
#~ " the `SET_SKEW` gcode."
#~ msgstr ""

#~ msgid "CALC_MEASURED_SKEW"
#~ msgstr ""

#~ msgid ""
#~ "`CALC_MEASURED_SKEW [AC=<ac_length>] [BD=<bd_length>] [AD=<ad_length>]`: "
#~ "Calculates and reports the skew (in radians and degrees) based on a measured"
#~ " print. This can be useful for determining the printer's current skew after "
#~ "correction has been applied. It may also be useful before correction is "
#~ "applied to determine if skew correction is necessary. See [Skew "
#~ "Correction](Skew_Correction.md) for details on skew calibration objects and "
#~ "measurements."
#~ msgstr ""

#~ msgid "SKEW_PROFILE"
#~ msgstr ""

#~ msgid ""
#~ "`SKEW_PROFILE [LOAD=<name>] [SAVE=<name>] [REMOVE=<name>]`: Profile "
#~ "management for skew_correction. LOAD will restore skew state from the "
#~ "profile matching the supplied name. SAVE will save the current skew state to"
#~ " a profile matching the supplied name. Remove will delete the profile "
#~ "matching the supplied name from persistent memory. Note that after SAVE or "
#~ "REMOVE operations have been run the SAVE_CONFIG gcode must be run to make "
#~ "the changes to persistent memory permanent."
#~ msgstr ""

#~ msgid "[smart_effector]"
#~ msgstr ""

#~ msgid ""
#~ "Several commands are available when a [smart_effector config "
#~ "section](Config_Reference.md#smart_effector) is enabled. Be sure to check "
#~ "the official documentation for the Smart Effector on the [Duet3D "
#~ "Wiki](https://duet3d.dozuki.com/Wiki/Smart_effector_and_carriage_adapters_for_delta_printer)"
#~ " before changing the Smart Effector parameters. Also check the [probe "
#~ "calibration guide](Probe_Calibrate.md)."
#~ msgstr ""

#~ msgid "SET_SMART_EFFECTOR"
#~ msgstr ""

#~ msgid ""
#~ "`SET_SMART_EFFECTOR [SENSITIVITY=<sensitivity>] [ACCEL=<accel>] "
#~ "[RECOVERY_TIME=<time>]`: Set the Smart Effector parameters. When "
#~ "`SENSITIVITY` is specified, the respective value is written to the "
#~ "SmartEffector EEPROM (requires `control_pin` to be provided). Acceptable "
#~ "`<sensitivity>` values are 0..255, the default is 50. Lower values require "
#~ "less nozzle contact force to trigger (but there is a higher risk of false "
#~ "triggering due to vibrations during probing), and higher values reduce false"
#~ " triggering (but require larger contact force to trigger). Since the "
#~ "sensitivity is written to EEPROM, it is preserved after the shutdown, and so"
#~ " it does not need to be configured on every printer startup. `ACCEL` and "
#~ "`RECOVERY_TIME` allow to override the corresponding parameters at run-time, "
#~ "see the [config section](Config_Reference.md#smart_effector) of Smart "
#~ "Effector for more info on those parameters."
#~ msgstr ""

#~ msgid "RESET_SMART_EFFECTOR"
#~ msgstr ""

#~ msgid ""
#~ "`RESET_SMART_EFFECTOR`: Resets Smart Effector sensitivity to its factory "
#~ "settings. Requires `control_pin` to be provided in the config section."
#~ msgstr ""

#~ msgid "[stepper_enable]"
#~ msgstr ""

#~ msgid "The stepper_enable module is automatically loaded."
#~ msgstr ""

#~ msgid "SET_STEPPER_ENABLE"
#~ msgstr ""

#~ msgid ""
#~ "`SET_STEPPER_ENABLE STEPPER=<config_name> ENABLE=[0|1]`: Enable or disable "
#~ "only the given stepper. This is a diagnostic and debugging tool and must be "
#~ "used with care. Disabling an axis motor does not reset the homing "
#~ "information. Manually moving a disabled stepper may cause the machine to "
#~ "operate the motor outside of safe limits. This can lead to damage to axis "
#~ "components, hot ends, and print surface."
#~ msgstr ""

#~ msgid "[temperature_fan]"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a [temperature_fan config "
#~ "section](Config_Reference.md#temperature_fan) is enabled."
#~ msgstr ""

#~ msgid "SET_TEMPERATURE_FAN_TARGET"
#~ msgstr ""

#~ msgid ""
#~ "`SET_TEMPERATURE_FAN_TARGET temperature_fan=<temperature_fan_name> "
#~ "[target=<target_temperature>] [min_speed=<min_speed>] "
#~ "[max_speed=<max_speed>]`: Sets the target temperature for a temperature_fan."
#~ " If a target is not supplied, it is set to the specified temperature in the "
#~ "config file. If speeds are not supplied, no change is applied."
#~ msgstr ""

#~ msgid "[tmcXXXX]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when any of the [tmcXXXX config "
#~ "sections](Config_Reference.md#tmc-stepper-driver-configuration) are enabled."
#~ msgstr ""

#~ msgid "DUMP_TMC"
#~ msgstr ""

#~ msgid ""
#~ "`DUMP_TMC STEPPER=<name>`: This command will read the TMC driver registers "
#~ "and report their values."
#~ msgstr ""

#~ msgid "INIT_TMC"
#~ msgstr ""

#~ msgid ""
#~ "`INIT_TMC STEPPER=<name>`: This command will initialize the TMC registers. "
#~ "Needed to re-enable the driver if power to the chip is turned off then back "
#~ "on."
#~ msgstr ""

#~ msgid "SET_TMC_CURRENT"
#~ msgstr ""

#~ msgid ""
#~ "`SET_TMC_CURRENT STEPPER=<name> CURRENT=<amps> HOLDCURRENT=<amps>`: This "
#~ "will adjust the run and hold currents of the TMC driver. (HOLDCURRENT is not"
#~ " applicable to tmc2660 drivers.)"
#~ msgstr ""

#~ msgid "SET_TMC_FIELD"
#~ msgstr ""

#~ msgid ""
#~ "`SET_TMC_FIELD STEPPER=<name> FIELD=<field> VALUE=<value>`: This will alter "
#~ "the value of the specified register field of the TMC driver. This command is"
#~ " intended for low-level diagnostics and debugging only because changing the "
#~ "fields during run-time can lead to undesired and potentially dangerous "
#~ "behavior of your printer. Permanent changes should be made using the printer"
#~ " configuration file instead. No sanity checks are performed for the given "
#~ "values."
#~ msgstr ""

#~ msgid "[toolhead]"
#~ msgstr ""

#~ msgid "The toolhead module is automatically loaded."
#~ msgstr ""

#~ msgid "SET_VELOCITY_LIMIT"
#~ msgstr ""

#~ msgid ""
#~ "`SET_VELOCITY_LIMIT [VELOCITY=<value>] [ACCEL=<value>] "
#~ "[ACCEL_TO_DECEL=<value>] [SQUARE_CORNER_VELOCITY=<value>]`: Modify the "
#~ "printer's velocity limits."
#~ msgstr ""

#~ msgid "[tuning_tower]"
#~ msgstr ""

#~ msgid "The tuning_tower module is automatically loaded."
#~ msgstr ""

#~ msgid "TUNING_TOWER"
#~ msgstr ""

#~ msgid ""
#~ "`TUNING_TOWER COMMAND=<command> PARAMETER=<name> START=<value> "
#~ "[SKIP=<value>] [FACTOR=<value> [BAND=<value>]] | [STEP_DELTA=<value> "
#~ "STEP_HEIGHT=<value>]`: A tool for tuning a parameter on each Z height during"
#~ " a print. The tool will run the given `COMMAND` with the given `PARAMETER` "
#~ "assigned to a value that varies with `Z` according to a formula. Use "
#~ "`FACTOR` if you will use a ruler or calipers to measure the Z height of the "
#~ "optimum value, or `STEP_DELTA` and `STEP_HEIGHT` if the tuning tower model "
#~ "has bands of discrete values as is common with temperature towers. If "
#~ "`SKIP=<value>` is specified, the tuning process doesn't begin until Z height"
#~ " `<value>` is reached, and below that the value will be set to `START`; in "
#~ "this case, the `z_height` used in the formulas below is actually `max(z - "
#~ "skip, 0)`. There are three possible combinations of options:"
#~ msgstr ""

#~ msgid ""
#~ "`FACTOR`: The value changes at a rate of `factor` per millimeter. The "
#~ "formula used is: `value = start + factor * z_height`. You can plug the "
#~ "optimum Z height directly into the formula to determine the optimum "
#~ "parameter value."
#~ msgstr ""

#~ msgid ""
#~ "`FACTOR` and `BAND`: The value changes at an average rate of `factor` per "
#~ "millimeter, but in discrete bands where the adjustment will only be made "
#~ "every `BAND` millimeters of Z height. The formula used is: `value = start + "
#~ "factor * ((floor(z_height / band) + .5) * band)`."
#~ msgstr ""

#~ msgid ""
#~ "`STEP_DELTA` and `STEP_HEIGHT`: The value changes by `STEP_DELTA` every "
#~ "`STEP_HEIGHT` millimeters. The formula used is: `value = start + step_delta "
#~ "* floor(z_height / step_height)`. You can simply count bands or read tuning "
#~ "tower labels to determine the optimum value."
#~ msgstr ""

#~ msgid "[virtual_sdcard]"
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports the following standard G-Code commands if the "
#~ "[virtual_sdcard config section](Config_Reference.md#virtual_sdcard) is "
#~ "enabled:"
#~ msgstr ""

#~ msgid "List SD card: `M20`"
#~ msgstr ""

#~ msgid "Initialize SD card: `M21`"
#~ msgstr ""

#~ msgid "Select SD file: `M23 <filename>`"
#~ msgstr ""

#~ msgid "Start/resume SD print: `M24`"
#~ msgstr ""

#~ msgid "Pause SD print: `M25`"
#~ msgstr ""

#~ msgid "Set SD position: `M26 S<offset>`"
#~ msgstr ""

#~ msgid "Report SD print status: `M27`"
#~ msgstr ""

#~ msgid ""
#~ "In addition, the following extended commands are available when the "
#~ "\"virtual_sdcard\" config section is enabled."
#~ msgstr ""

#~ msgid "SDCARD_PRINT_FILE"
#~ msgstr ""

#~ msgid ""
#~ "`SDCARD_PRINT_FILE FILENAME=<filename>`: Load a file and start SD print."
#~ msgstr ""

#~ msgid "SDCARD_RESET_FILE"
#~ msgstr ""

#~ msgid "`SDCARD_RESET_FILE`: Unload file and clear SD state."
#~ msgstr ""

#~ msgid "[z_thermal_adjust]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [z_thermal_adjust config "
#~ "section](Config_Reference.md#z_thermal_adjust) is enabled."
#~ msgstr ""

#~ msgid "SET_Z_THERMAL_ADJUST"
#~ msgstr ""

#~ msgid ""
#~ "`SET_Z_THERMAL_ADJUST [ENABLE=<0:1>] [TEMP_COEFF=<value>] "
#~ "[REF_TEMP=<value>]`: Enable or disable the Z thermal adjustment with "
#~ "`ENABLE`. Disabling does not remove any adjustment already applied, but will"
#~ " freeze the current adjustment value - this prevents potentially unsafe "
#~ "downward Z movement. Re-enabling can potentially cause upward tool movement "
#~ "as the adjustment is updated and applied. `TEMP_COEFF` allows run-time "
#~ "tuning of the adjustment temperature coefficient (i.e. the `TEMP_COEFF` "
#~ "config parameter). `TEMP_COEFF` values are not saved to the config. "
#~ "`REF_TEMP` manually overrides the reference temperature typically set during"
#~ " homing (for use in e.g. non-standard homing routines) - will be reset "
#~ "automatically upon homing."
#~ msgstr ""

#~ msgid "[z_tilt]"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [z_tilt config "
#~ "section](Config_Reference.md#z_tilt) is enabled."
#~ msgstr ""

#~ msgid "Z_TILT_ADJUST"
#~ msgstr ""

#~ msgid ""
#~ "`Z_TILT_ADJUST [<probe_parameter>=<value>]`: This command will probe the "
#~ "points specified in the config and then make independent adjustments to each"
#~ " Z stepper to compensate for tilt. See the PROBE command for details on the "
#~ "optional probe parameters."
#~ msgstr ""

#~ msgid "Features"
#~ msgstr ""

#~ msgid "Klipper has several compelling features:"
#~ msgstr ""

#~ msgid ""
#~ "High precision stepper movement. Klipper utilizes an application processor "
#~ "(such as a low-cost Raspberry Pi) when calculating printer movements. The "
#~ "application processor determines when to step each stepper motor, it "
#~ "compresses those events, transmits them to the micro-controller, and then "
#~ "the micro-controller executes each event at the requested time. Each stepper"
#~ " event is scheduled with a precision of 25 micro-seconds or better. The "
#~ "software does not use kinematic estimations (such as the Bresenham "
#~ "algorithm) - instead it calculates precise step times based on the physics "
#~ "of acceleration and the physics of the machine kinematics. More precise "
#~ "stepper movement provides quieter and more stable printer operation."
#~ msgstr ""

#~ msgid ""
#~ "Best in class performance. Klipper is able to achieve high stepping rates on"
#~ " both new and old micro-controllers. Even old 8bit micro-controllers can "
#~ "obtain rates over 175K steps per second. On more recent micro-controllers, "
#~ "several million steps per second are possible. Higher stepper rates enable "
#~ "higher print velocities. The stepper event timing remains precise even at "
#~ "high speeds which improves overall stability."
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports printers with multiple micro-controllers. For example, one "
#~ "micro-controller could be used to control an extruder, while another "
#~ "controls the printer's heaters, while a third controls the rest of the "
#~ "printer. The Klipper host software implements clock synchronization to "
#~ "account for clock drift between micro-controllers. No special code is needed"
#~ " to enable multiple micro-controllers - it just requires a few extra lines "
#~ "in the config file."
#~ msgstr ""

#~ msgid ""
#~ "Configuration via simple config file. There's no need to reflash the micro-"
#~ "controller to change a setting. All of Klipper's configuration is stored in "
#~ "a standard config file which can be easily edited. This makes it easier to "
#~ "setup and maintain the hardware."
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports \"Smooth Pressure Advance\" - a mechanism to account for "
#~ "the effects of pressure within an extruder. This reduces extruder \"ooze\" "
#~ "and improves the quality of print corners. Klipper's implementation does not"
#~ " introduce instantaneous extruder speed changes, which improves overall "
#~ "stability and robustness."
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports \"Input Shaping\" to reduce the impact of vibrations on "
#~ "print quality. This can reduce or eliminate \"ringing\" (also known as "
#~ "\"ghosting\", \"echoing\", or \"rippling\") in prints. It may also allow one"
#~ " to obtain faster printing speeds while still maintaining high print "
#~ "quality."
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses an \"iterative solver\" to calculate precise step times from "
#~ "simple kinematic equations. This makes porting Klipper to new types of "
#~ "robots easier and it keeps timing precise even with complex kinematics (no "
#~ "\"line segmentation\" is needed)."
#~ msgstr ""

#~ msgid ""
#~ "Klipper is hardware agnostic. One should get the same precise timing "
#~ "independent of the low-level electronics hardware. The Klipper micro-"
#~ "controller code is designed to faithfully follow the schedule provided by "
#~ "the Klipper host software (or prominently alert the user if it is unable "
#~ "to). This makes it easier to use available hardware, to upgrade to new "
#~ "hardware, and to have confidence in the hardware."
#~ msgstr ""

#~ msgid ""
#~ "Portable code. Klipper works on ARM, AVR, and PRU based micro-controllers. "
#~ "Existing \"reprap\" style printers can run Klipper without hardware "
#~ "modification - just add a Raspberry Pi. Klipper's internal code layout makes"
#~ " it easier to support other micro-controller architectures as well."
#~ msgstr ""

#~ msgid ""
#~ "Simpler code. Klipper uses a very high level language (Python) for most "
#~ "code. The kinematics algorithms, the G-code parsing, the heating and "
#~ "thermistor algorithms, etc. are all written in Python. This makes it easier "
#~ "to develop new functionality."
#~ msgstr ""

#~ msgid ""
#~ "Custom programmable macros. New G-Code commands can be defined in the "
#~ "printer config file (no code changes are necessary). Those commands are "
#~ "programmable - allowing them to produce different actions depending on the "
#~ "state of the printer."
#~ msgstr ""

#~ msgid ""
#~ "Builtin API server. In addition to the standard G-Code interface, Klipper "
#~ "supports a rich JSON based application interface. This enables programmers "
#~ "to build external applications with detailed control of the printer."
#~ msgstr ""

#~ msgid "Additional features"
#~ msgstr ""

#~ msgid "Klipper supports many standard 3d printer features:"
#~ msgstr ""

#~ msgid ""
#~ "Several web interfaces available. Works with Mainsail, Fluidd, OctoPrint and"
#~ " others. This allows the printer to be controlled using a regular web-"
#~ "browser. The same Raspberry Pi that runs Klipper can also run the web "
#~ "interface."
#~ msgstr ""

#~ msgid ""
#~ "Standard G-Code support. Common g-code commands that are produced by typical"
#~ " \"slicers\" (SuperSlicer, Cura, PrusaSlicer, etc.) are supported."
#~ msgstr ""

#~ msgid ""
#~ "Support for multiple extruders. Extruders with shared heaters and extruders "
#~ "on independent carriages (IDEX) are also supported."
#~ msgstr ""

#~ msgid ""
#~ "Support for cartesian, delta, corexy, corexz, hybrid-corexy, hybrid-corexz, "
#~ "deltesian, rotary delta, polar, and cable winch style printers."
#~ msgstr ""

#~ msgid ""
#~ "Automatic bed leveling support. Klipper can be configured for basic bed tilt"
#~ " detection or full mesh bed leveling. If the bed uses multiple Z steppers "
#~ "then Klipper can also level by independently manipulating the Z steppers. "
#~ "Most Z height probes are supported, including BL-Touch probes and servo "
#~ "activated probes."
#~ msgstr ""

#~ msgid ""
#~ "Automatic delta calibration support. The calibration tool can perform basic "
#~ "height calibration as well as an enhanced X and Y dimension calibration. The"
#~ " calibration can be done with a Z height probe or via manual probing."
#~ msgstr ""

#~ msgid ""
#~ "Run-time \"exclude object\" support. When configured, this module may "
#~ "facilitate canceling of just one object in a multi-part print."
#~ msgstr ""

#~ msgid ""
#~ "Support for common temperature sensors (eg, common thermistors, AD595, "
#~ "AD597, AD849x, PT100, PT1000, MAX6675, MAX31855, MAX31856, MAX31865, BME280,"
#~ " HTU21D, DS18B20, and LM75). Custom thermistors and custom analog "
#~ "temperature sensors can also be configured. One can monitor the internal "
#~ "micro-controller temperature sensor and the internal temperature sensor of a"
#~ " Raspberry Pi."
#~ msgstr ""

#~ msgid "Basic thermal heater protection enabled by default."
#~ msgstr ""

#~ msgid ""
#~ "Support for standard fans, nozzle fans, and temperature controlled fans. No "
#~ "need to keep fans running when the printer is idle. Fan speed can be "
#~ "monitored on fans that have a tachometer."
#~ msgstr ""

#~ msgid ""
#~ "Support for run-time configuration of TMC2130, TMC2208/TMC2224, TMC2209, "
#~ "TMC2660, and TMC5160 stepper motor drivers. There is also support for "
#~ "current control of traditional stepper drivers via AD5206, DAC084S085, "
#~ "MCP4451, MCP4728, MCP4018, and PWM pins."
#~ msgstr ""

#~ msgid ""
#~ "Support for common LCD displays attached directly to the printer. A default "
#~ "menu is also available. The contents of the display and menu can be fully "
#~ "customized via the config file."
#~ msgstr ""

#~ msgid ""
#~ "Constant acceleration and \"look-ahead\" support. All printer moves will "
#~ "gradually accelerate from standstill to cruising speed and then decelerate "
#~ "back to a standstill. The incoming stream of G-Code movement commands are "
#~ "queued and analyzed - the acceleration between movements in a similar "
#~ "direction will be optimized to reduce print stalls and improve overall print"
#~ " time."
#~ msgstr ""

#~ msgid ""
#~ "Klipper implements a \"stepper phase endstop\" algorithm that can improve "
#~ "the accuracy of typical endstop switches. When properly tuned it can improve"
#~ " a print's first layer bed adhesion."
#~ msgstr ""

#~ msgid ""
#~ "Support for filament presence sensors, filament motion sensors, and filament"
#~ " width sensors."
#~ msgstr ""

#~ msgid ""
#~ "Support for measuring and recording acceleration using an adxl345, mpu9250, "
#~ "and mpu6050 accelerometers."
#~ msgstr ""

#~ msgid ""
#~ "Support for limiting the top speed of short \"zigzag\" moves to reduce "
#~ "printer vibration and noise. See the [kinematics](Kinematics.md) document "
#~ "for more information."
#~ msgstr ""

#~ msgid ""
#~ "Sample configuration files are available for many common printers. Check the"
#~ " [config directory](../config/) for a list."
#~ msgstr ""

#~ msgid ""
#~ "To get started with Klipper, read the [installation](Installation.md) guide."
#~ msgstr ""

#~ msgid "Step Benchmarks"
#~ msgstr ""

#~ msgid ""
#~ "Below are the results of stepper performance tests. The numbers shown "
#~ "represent total number of steps per second on the micro-controller."
#~ msgstr ""

#~ msgid "Micro-controller"
#~ msgstr ""

#~ msgid "1 stepper active"
#~ msgstr ""

#~ msgid "3 steppers active"
#~ msgstr ""

#~ msgid "16Mhz AVR"
#~ msgstr ""

#~ msgid "157K"
#~ msgstr ""

#~ msgid "99K"
#~ msgstr ""

#~ msgid "20Mhz AVR"
#~ msgstr ""

#~ msgid "196K"
#~ msgstr ""

#~ msgid "123K"
#~ msgstr ""

#~ msgid "SAMD21"
#~ msgstr ""

#~ msgid "686K"
#~ msgstr ""

#~ msgid "471K"
#~ msgstr ""

#~ msgid "STM32F042"
#~ msgstr ""

#~ msgid "814K"
#~ msgstr ""

#~ msgid "578K"
#~ msgstr ""

#~ msgid "Beaglebone PRU"
#~ msgstr ""

#~ msgid "866K"
#~ msgstr ""

#~ msgid "708K"
#~ msgstr ""

#~ msgid "STM32G0B1"
#~ msgstr ""

#~ msgid "1103K"
#~ msgstr ""

#~ msgid "790K"
#~ msgstr ""

#~ msgid "STM32F103"
#~ msgstr ""

#~ msgid "1180K"
#~ msgstr ""

#~ msgid "818K"
#~ msgstr ""

#~ msgid "SAM3X8E"
#~ msgstr ""

#~ msgid "1273K"
#~ msgstr ""

#~ msgid "981K"
#~ msgstr ""

#~ msgid "SAM4S8C"
#~ msgstr ""

#~ msgid "1690K"
#~ msgstr ""

#~ msgid "1385K"
#~ msgstr ""

#~ msgid "LPC1768"
#~ msgstr ""

#~ msgid "1923K"
#~ msgstr ""

#~ msgid "1351K"
#~ msgstr ""

#~ msgid "LPC1769"
#~ msgstr ""

#~ msgid "2353K"
#~ msgstr ""

#~ msgid "1622K"
#~ msgstr ""

#~ msgid "RP2040"
#~ msgstr ""

#~ msgid "2400K"
#~ msgstr ""

#~ msgid "1636K"
#~ msgstr ""

#~ msgid "SAM4E8E"
#~ msgstr ""

#~ msgid "2500K"
#~ msgstr ""

#~ msgid "1674K"
#~ msgstr ""

#~ msgid "SAMD51"
#~ msgstr ""

#~ msgid "3077K"
#~ msgstr ""

#~ msgid "1885K"
#~ msgstr ""

#~ msgid "STM32F407"
#~ msgstr ""

#~ msgid "3652K"
#~ msgstr ""

#~ msgid "2459K"
#~ msgstr ""

#~ msgid "STM32F446"
#~ msgstr ""

#~ msgid "3913K"
#~ msgstr ""

#~ msgid "2634K"
#~ msgstr ""

#~ msgid "STM32H743"
#~ msgstr ""

#~ msgid "9091K"
#~ msgstr ""

#~ msgid "6061K"
#~ msgstr ""

#~ msgid ""
#~ "If unsure of the micro-controller on a particular board, find the "
#~ "appropriate [config file](../config/), and look for the micro-controller "
#~ "name in the comments at the top of that file."
#~ msgstr ""

#~ msgid ""
#~ "Further details on the benchmarks are available in the [Benchmarks "
#~ "document](Benchmarks.md)."
#~ msgstr ""

#~ msgid "Frequently Asked Questions"
#~ msgstr ""

#~ msgid "How can I donate to the project?"
#~ msgstr ""

#~ msgid ""
#~ "Thank you for your support. See the [Sponsors page](Sponsors.md) for "
#~ "information."
#~ msgstr ""

#~ msgid "How do I calculate the rotation_distance config parameter?"
#~ msgstr ""

#~ msgid "See the [rotation distance document](Rotation_Distance.md)."
#~ msgstr ""

#~ msgid "Where's my serial port?"
#~ msgstr ""

#~ msgid ""
#~ "The general way to find a USB serial port is to run `ls /dev/serial/by-id/*`"
#~ " from an ssh terminal on the host machine. It will likely produce output "
#~ "similar to the following:"
#~ msgstr ""

#~ msgid ""
#~ "The name found in the above command is stable and it is possible to use it "
#~ "in the config file and while flashing the micro-controller code. For "
#~ "example, a flash command might look similar to:"
#~ msgstr ""

#~ msgid "and the updated config might look like:"
#~ msgstr ""

#~ msgid ""
#~ "Be sure to copy-and-paste the name from the \"ls\" command that you ran "
#~ "above as the name will be different for each printer."
#~ msgstr ""

#~ msgid ""
#~ "If you are using multiple micro-controllers and they do not have unique ids "
#~ "(common on boards with a CH340 USB chip) then follow the directions above "
#~ "using the command `ls /dev/serial/by-path/*` instead."
#~ msgstr ""

#~ msgid "When the micro-controller restarts the device changes to /dev/ttyUSB1"
#~ msgstr ""

#~ msgid ""
#~ "Follow the directions in the \"[Where's my serial port?](#wheres-my-serial-"
#~ "port)\" section to prevent this from occurring."
#~ msgstr ""

#~ msgid "The \"make flash\" command doesn't work"
#~ msgstr ""

#~ msgid ""
#~ "The code attempts to flash the device using the most common method for each "
#~ "platform. Unfortunately, there is a lot of variance in flashing methods, so "
#~ "the \"make flash\" command may not work on all boards."
#~ msgstr ""

#~ msgid ""
#~ "If you're having an intermittent failure or you do have a standard setup, "
#~ "then double check that Klipper isn't running when flashing (sudo service "
#~ "klipper stop), make sure OctoPrint isn't trying to connect directly to the "
#~ "device (open the Connection tab in the web page and click Disconnect if the "
#~ "Serial Port is set to the device), and make sure FLASH_DEVICE is set "
#~ "correctly for your board (see the [question above](#wheres-my-serial-port))."
#~ msgstr ""

#~ msgid ""
#~ "However, if \"make flash\" just doesn't work for your board, then you will "
#~ "need to manually flash. See if there is a config file in the [config "
#~ "directory](../config) with specific instructions for flashing the device. "
#~ "Also, check the board manufacturer's documentation to see if it describes "
#~ "how to flash the device. Finally, it may be possible to manually flash the "
#~ "device using tools such as \"avrdude\" or \"bossac\" - see the [bootloader "
#~ "document](Bootloaders.md) for additional information."
#~ msgstr ""

#~ msgid "How do I change the serial baud rate?"
#~ msgstr ""

#~ msgid ""
#~ "The recommended baud rate for Klipper is 250000. This baud rate works well "
#~ "on all micro-controller boards that Klipper supports. If you've found an "
#~ "online guide recommending a different baud rate, then ignore that part of "
#~ "the guide and continue with the default value of 250000."
#~ msgstr ""

#~ msgid ""
#~ "If you want to change the baud rate anyway, then the new rate will need to "
#~ "be configured in the micro-controller (during **make menuconfig**) and that "
#~ "updated code will need to be compiled and flashed to the micro-controller. "
#~ "The Klipper printer.cfg file will also need to be updated to match that baud"
#~ " rate (see the [config reference](Config_Reference.md#mcu) for details). For"
#~ " example:"
#~ msgstr ""

#~ msgid ""
#~ "[mcu]\n"
#~ "baud: 250000\n"
#~ msgstr ""

#~ msgid ""
#~ "The baud rate shown on the OctoPrint web page has no impact on the internal "
#~ "Klipper micro-controller baud rate. Always set the OctoPrint baud rate to "
#~ "250000 when using Klipper."
#~ msgstr ""

#~ msgid ""
#~ "The Klipper micro-controller baud rate is not related to the baud rate of "
#~ "the micro-controller's bootloader. See the [bootloader "
#~ "document](Bootloaders.md) for additional information on bootloaders."
#~ msgstr ""

#~ msgid "Can I run Klipper on something other than a Raspberry Pi 3?"
#~ msgstr ""

#~ msgid ""
#~ "The recommended hardware is a Raspberry Pi 2, Raspberry Pi 3, or Raspberry "
#~ "Pi 4."
#~ msgstr ""

#~ msgid ""
#~ "Klipper will run on a Raspberry Pi 1 and on the Raspberry Pi Zero, but these"
#~ " boards don't have enough processing power to run OctoPrint well. It is "
#~ "common for print stalls to occur on these slower machines when printing "
#~ "directly from OctoPrint. (The printer may move faster than OctoPrint can "
#~ "send movement commands.) If you wish to run on one one of these slower "
#~ "boards anyway, consider using the \"virtual_sdcard\" feature when printing "
#~ "(see [config reference](Config_Reference.md#virtual_sdcard) for details)."
#~ msgstr ""

#~ msgid ""
#~ "For running on the Beaglebone, see the [Beaglebone specific installation "
#~ "instructions](Beaglebone.md)."
#~ msgstr ""

#~ msgid ""
#~ "Klipper has been run on other machines. The Klipper host software only "
#~ "requires Python running on a Linux (or similar) computer. However, if you "
#~ "wish to run it on a different machine you will need Linux admin knowledge to"
#~ " install the system prerequisites for that particular machine. See the "
#~ "[install-octopi.sh](../scripts/install-octopi.sh) script for further "
#~ "information on the necessary Linux admin steps."
#~ msgstr ""

#~ msgid ""
#~ "If you are looking to run the Klipper host software on a low-end chip, then "
#~ "be aware that, at a minimum, a machine with \"double precision floating "
#~ "point\" hardware is required."
#~ msgstr ""

#~ msgid ""
#~ "If you are looking to run the Klipper host software on a shared general-"
#~ "purpose desktop or server class machine, then note that Klipper has some "
#~ "real-time scheduling requirements. If, during a print, the host computer "
#~ "also performs an intensive general-purpose computing task (such as "
#~ "defragmenting a hard drive, 3d rendering, heavy swapping, etc.), then it may"
#~ " cause Klipper to report print errors."
#~ msgstr ""

#~ msgid ""
#~ "Note: If you are not using an OctoPi image, be aware that several Linux "
#~ "distributions enable a \"ModemManager\" (or similar) package that can "
#~ "disrupt serial communication. (Which can cause Klipper to report seemingly "
#~ "random \"Lost communication with MCU\" errors.) If you install Klipper on "
#~ "one of these distributions you may need to disable that package."
#~ msgstr ""

#~ msgid "Can I run multiple instances of Klipper on the same host machine?"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to run multiple instances of the Klipper host software, but "
#~ "doing so requires Linux admin knowledge. The Klipper installation scripts "
#~ "ultimately cause the following Unix command to be run:"
#~ msgstr ""

#~ msgid ""
#~ "~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer.cfg -l "
#~ "/tmp/klippy.log\n"
#~ msgstr ""

#~ msgid ""
#~ "One can run multiple instances of the above command as long as each instance"
#~ " has its own printer config file, its own log file, and its own pseudo-tty. "
#~ "For example:"
#~ msgstr ""

#~ msgid ""
#~ "~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer2.cfg -l "
#~ "/tmp/klippy2.log -I /tmp/printer2\n"
#~ msgstr ""

#~ msgid ""
#~ "If you choose to do this, you will need to implement the necessary start, "
#~ "stop, and installation scripts (if any). The [install-"
#~ "octopi.sh](../scripts/install-octopi.sh) script and the [klipper-"
#~ "start.sh](../scripts/klipper-start.sh) script may be useful as examples."
#~ msgstr ""

#~ msgid "Do I have to use OctoPrint?"
#~ msgstr ""

#~ msgid ""
#~ "The Klipper software is not dependent on OctoPrint. It is possible to use "
#~ "alternative software to send commands to Klipper, but doing so requires "
#~ "Linux admin knowledge."
#~ msgstr ""

#~ msgid ""
#~ "Klipper creates a \"virtual serial port\" via the \"/tmp/printer\" file, and"
#~ " it emulates a classic 3d-printer serial interface via that file. In "
#~ "general, alternative software may work with Klipper as long as it can be "
#~ "configured to use \"/tmp/printer\" for the printer serial port."
#~ msgstr ""

#~ msgid "Why can't I move the stepper before homing the printer?"
#~ msgstr ""

#~ msgid ""
#~ "The code does this to reduce the chance of accidentally commanding the head "
#~ "into the bed or a wall. Once the printer is homed the software attempts to "
#~ "verify each move is within the position_min/max defined in the config file. "
#~ "If the motors are disabled (via an M84 or M18 command) then the motors will "
#~ "need to be homed again prior to movement."
#~ msgstr ""

#~ msgid ""
#~ "If you want to move the head after canceling a print via OctoPrint, consider"
#~ " changing the OctoPrint cancel sequence to do that for you. It's configured "
#~ "in OctoPrint via a web browser under: Settings->GCODE Scripts"
#~ msgstr ""

#~ msgid ""
#~ "If you want to move the head after a print finishes, consider adding the "
#~ "desired movement to the \"custom g-code\" section of your slicer."
#~ msgstr ""

#~ msgid ""
#~ "If the printer requires some additional movement as part of the homing "
#~ "process itself (or fundamentally does not have a homing process) then "
#~ "consider using a safe_z_home or homing_override section in the config file. "
#~ "If you need to move a stepper for diagnostic or debugging purposes then "
#~ "consider adding a force_move section to the config file. See [config "
#~ "reference](Config_Reference.md#customized_homing) for further details on "
#~ "these options."
#~ msgstr ""

#~ msgid "Why is the Z position_endstop set to 0.5 in the default configs?"
#~ msgstr ""

#~ msgid ""
#~ "For cartesian style printers the Z position_endstop specifies how far the "
#~ "nozzle is from the bed when the endstop triggers. If possible, it is "
#~ "recommended to use a Z-max endstop and home away from the bed (as this "
#~ "reduces the potential for bed collisions). However, if one must home towards"
#~ " the bed then it is recommended to position the endstop so it triggers when "
#~ "the nozzle is still a small distance away from the bed. This way, when "
#~ "homing the axis, it will stop before the nozzle touches the bed. See the "
#~ "[bed level document](Bed_Level.md) for more information."
#~ msgstr ""

#~ msgid ""
#~ "I converted my config from Marlin and the X/Y axes work fine, but I just get"
#~ " a screeching noise when homing the Z axis"
#~ msgstr ""

#~ msgid ""
#~ "Short answer: First, make sure you have verified the stepper configuration "
#~ "as described in the [config check document](Config_checks.md). If the "
#~ "problem persists, try reducing the max_z_velocity setting in the printer "
#~ "config."
#~ msgstr ""

#~ msgid ""
#~ "Long answer: In practice Marlin can typically only step at a rate of around "
#~ "10000 steps per second. If it is requested to move at a speed that would "
#~ "require a higher step rate then Marlin will generally just step as fast as "
#~ "it can. Klipper is able to achieve much higher step rates, but the stepper "
#~ "motor may not have sufficient torque to move at a higher speed. So, for a Z "
#~ "axis with a high gearing ratio or high microsteps setting the actual "
#~ "obtainable max_z_velocity may be smaller than what is configured in Marlin."
#~ msgstr ""

#~ msgid "My TMC motor driver turns off in the middle of a print"
#~ msgstr ""

#~ msgid ""
#~ "If using the TMC2208 (or TMC2224) driver in \"standalone mode\" then make "
#~ "sure to use the [latest version of Klipper](#how-do-i-upgrade-to-the-latest-"
#~ "software). A workaround for a TMC2208 \"stealthchop\" driver problem was "
#~ "added to Klipper in mid-March of 2020."
#~ msgstr ""

#~ msgid "I keep getting random \"Lost communication with MCU\" errors"
#~ msgstr ""

#~ msgid ""
#~ "This is commonly caused by hardware errors on the USB connection between the"
#~ " host machine and the micro-controller. Things to look for:"
#~ msgstr ""

#~ msgid ""
#~ "Use a good quality USB cable between the host machine and micro-controller. "
#~ "Make sure the plugs are secure."
#~ msgstr ""

#~ msgid ""
#~ "If using a Raspberry Pi, use a [good quality power "
#~ "supply](https://www.raspberrypi.com/documentation/computers/raspberry-"
#~ "pi.html#power-supply) for the Raspberry Pi and use a [good quality USB "
#~ "cable](https://forums.raspberrypi.com/viewtopic.php?p=589877#p589877) to "
#~ "connect that power supply to the Pi. If you get \"under voltage\" warnings "
#~ "from OctoPrint, this is related to the power supply and it must be fixed."
#~ msgstr ""

#~ msgid ""
#~ "Make sure the printer's power supply is not being overloaded. (Power "
#~ "fluctuations to the micro-controller's USB chip may result in resets of that"
#~ " chip.)"
#~ msgstr ""

#~ msgid ""
#~ "Verify stepper, heater, and other printer wires are not crimped or frayed. "
#~ "(Printer movement may place stress on a faulty wire causing it to lose "
#~ "contact, briefly short, or generate excessive noise.)"
#~ msgstr ""

#~ msgid ""
#~ "There have been reports of high USB noise when both the printer's power "
#~ "supply and the host's 5V power supply are mixed. (If you find that the "
#~ "micro-controller powers on when either the printer's power supply is on or "
#~ "the USB cable is plugged in, then it indicates the 5V power supplies are "
#~ "being mixed.) It may help to configure the micro-controller to use power "
#~ "from only one source. (Alternatively, if the micro-controller board can not "
#~ "configure its power source, one may modify a USB cable so that it does not "
#~ "carry 5V power between the host and micro-controller.)"
#~ msgstr ""

#~ msgid "My Raspberry Pi keeps rebooting during prints"
#~ msgstr ""

#~ msgid ""
#~ "This is most likely do to voltage fluctuations. Follow the same "
#~ "troubleshooting steps for a [\"Lost communication with MCU\"](#i-keep-"
#~ "getting-random-lost-communication-with-mcu-errors) error."
#~ msgstr ""

#~ msgid ""
#~ "When I set `restart_method=command` my AVR device just hangs on a restart"
#~ msgstr ""

#~ msgid ""
#~ "Some old versions of the AVR bootloader have a known bug in watchdog event "
#~ "handling. This typically manifests when the printer.cfg file has "
#~ "restart_method set to \"command\". When the bug occurs, the AVR device will "
#~ "be unresponsive until power is removed and reapplied to the device (the "
#~ "power or status LEDs may also blink repeatedly until the power is removed)."
#~ msgstr ""

#~ msgid ""
#~ "The workaround is to use a restart_method other than \"command\" or to flash"
#~ " an updated bootloader to the AVR device. Flashing a new bootloader is a one"
#~ " time step that typically requires an external programmer - see "
#~ "[Bootloaders](Bootloaders.md) for further details."
#~ msgstr ""

#~ msgid "Will the heaters be left on if the Raspberry Pi crashes?"
#~ msgstr ""

#~ msgid ""
#~ "The software has been designed to prevent that. Once the host enables a "
#~ "heater, the host software needs to confirm that enablement every 5 seconds. "
#~ "If the micro-controller does not receive a confirmation every 5 seconds it "
#~ "goes into a \"shutdown\" state which is designed to turn off all heaters and"
#~ " stepper motors."
#~ msgstr ""

#~ msgid ""
#~ "See the \"config_digital_out\" command in the [MCU "
#~ "commands](MCU_Commands.md) document for further details."
#~ msgstr ""

#~ msgid ""
#~ "In addition, the micro-controller software is configured with a minimum and "
#~ "maximum temperature range for each heater at startup (see the min_temp and "
#~ "max_temp parameters in the [config reference](Config_Reference.md#extruder) "
#~ "for details). If the micro-controller detects that the temperature is "
#~ "outside of that range then it will also enter a \"shutdown\" state."
#~ msgstr ""

#~ msgid ""
#~ "Separately, the host software also implements code to check that heaters and"
#~ " temperature sensors are functioning correctly. See the [config "
#~ "reference](Config_Reference.md#verify_heater) for further details."
#~ msgstr ""

#~ msgid "How do I convert a Marlin pin number to a Klipper pin name?"
#~ msgstr ""

#~ msgid ""
#~ "Short answer: A mapping is available in the [sample-"
#~ "aliases.cfg](../config/sample-aliases.cfg) file. Use that file as a guide to"
#~ " finding the actual micro-controller pin names. (It is also possible to copy"
#~ " the relevant [board_pins](Config_Reference.md#board_pins) config section "
#~ "into your config file and use the aliases in your config, but it is "
#~ "preferable to translate and use the actual micro-controller pin names.) Note"
#~ " that the sample-aliases.cfg file uses pin names that start with the prefix "
#~ "\"ar\" instead of \"D\" (eg, Arduino pin `D23` is Klipper alias `ar23`) and "
#~ "the prefix \"analog\" instead of \"A\" (eg, Arduino pin `A14` is Klipper "
#~ "alias `analog14`)."
#~ msgstr ""

#~ msgid ""
#~ "Long answer: Klipper uses the standard pin names defined by the micro-"
#~ "controller. On the Atmega chips these hardware pins have names like `PA4`, "
#~ "`PC7`, or `PD2`."
#~ msgstr ""

#~ msgid ""
#~ "Long ago, the Arduino project decided to avoid using the standard hardware "
#~ "names in favor of their own pin names based on incrementing numbers - these "
#~ "Arduino names generally look like `D23` or `A14`. This was an unfortunate "
#~ "choice that has lead to a great deal of confusion. In particular the Arduino"
#~ " pin numbers frequently don't translate to the same hardware names. For "
#~ "example, `D21` is `PD0` on one common Arduino board, but is `PC7` on another"
#~ " common Arduino board."
#~ msgstr ""

#~ msgid ""
#~ "To avoid this confusion, the core Klipper code uses the standard pin names "
#~ "defined by the micro-controller."
#~ msgstr ""

#~ msgid ""
#~ "Do I have to wire my device to a specific type of micro-controller pin?"
#~ msgstr ""

#~ msgid "It depends on the type of device and type of pin:"
#~ msgstr ""

#~ msgid ""
#~ "ADC pins (or Analog pins): For thermistors and similar \"analog\" sensors, "
#~ "the device must be wired to an \"analog\" or \"ADC\" capable pin on the "
#~ "micro-controller. If you configure Klipper to use a pin that is not analog "
#~ "capable, Klipper will report a \"Not a valid ADC pin\" error."
#~ msgstr ""

#~ msgid ""
#~ "PWM pins (or Timer pins): Klipper does not use hardware PWM by default for "
#~ "any device. So, in general, one may wire heaters, fans, and similar devices "
#~ "to any general purpose IO pin. However, fans and output_pin devices may be "
#~ "optionally configured to use `hardware_pwm: True`, in which case the micro-"
#~ "controller must support hardware PWM on the pin (otherwise, Klipper will "
#~ "report a \"Not a valid PWM pin\" error)."
#~ msgstr ""

#~ msgid ""
#~ "IRQ pins (or Interrupt pins): Klipper does not use hardware interrupts on IO"
#~ " pins, so it is never necessary to wire a device to one of these micro-"
#~ "controller pins."
#~ msgstr ""

#~ msgid ""
#~ "SPI pins: When using hardware SPI it is necessary to wire the pins to the "
#~ "micro-controller's SPI capable pins. However, most devices can be configured"
#~ " to use \"software SPI\", in which case any general purpose IO pins may be "
#~ "used."
#~ msgstr ""

#~ msgid ""
#~ "I2C pins: When using I2C it is necessary to wire the pins to the micro-"
#~ "controller's I2C capable pins."
#~ msgstr ""

#~ msgid ""
#~ "Other devices may be wired to any general purpose IO pin. For example, "
#~ "steppers, heaters, fans, Z probes, servos, LEDs, common hd44780/st7920 LCD "
#~ "displays, the Trinamic UART control line may be wired to any general purpose"
#~ " IO pin."
#~ msgstr ""

#~ msgid "How do I cancel an M109/M190 \"wait for temperature\" request?"
#~ msgstr ""

#~ msgid ""
#~ "Navigate to the OctoPrint terminal tab and issue an M112 command in the "
#~ "terminal box. The M112 command will cause Klipper to enter into a "
#~ "\"shutdown\" state, and it will cause OctoPrint to disconnect from Klipper. "
#~ "Navigate to the OctoPrint connection area and click on \"Connect\" to cause "
#~ "OctoPrint to reconnect. Navigate back to the terminal tab and issue a "
#~ "FIRMWARE_RESTART command to clear the Klipper error state. After completing "
#~ "this sequence, the previous heating request will be canceled and a new print"
#~ " may be started."
#~ msgstr ""

#~ msgid "Can I find out whether the printer has lost steps?"
#~ msgstr ""

#~ msgid ""
#~ "In a way, yes. Home the printer, issue a `GET_POSITION` command, run your "
#~ "print, home again and issue another `GET_POSITION`. Then compare the values "
#~ "in the `mcu:` line."
#~ msgstr ""

#~ msgid ""
#~ "This might be helpful to tune settings like stepper motor currents, "
#~ "accelerations and speeds without needing to actually print something and "
#~ "waste filament: just run some high-speed moves in between the `GET_POSITION`"
#~ " commands."
#~ msgstr ""

#~ msgid ""
#~ "Note that endstop switches themselves tend to trigger at slightly different "
#~ "positions, so a difference of a couple of microsteps is likely the result of"
#~ " endstop inaccuracies. A stepper motor itself can only lose steps in "
#~ "increments of 4 full steps. (So, if one is using 16 microsteps, then a lost "
#~ "step on the stepper would result in the \"mcu:\" step counter being off by a"
#~ " multiple of 64 microsteps.)"
#~ msgstr ""

#~ msgid "Why does Klipper report errors? I lost my print!"
#~ msgstr ""

#~ msgid ""
#~ "Short answer: We want to know if our printers detect a problem so that the "
#~ "underlying issue can be fixed and we can obtain great quality prints. We "
#~ "definitely do not want our printers to silently produce low quality prints."
#~ msgstr ""

#~ msgid ""
#~ "Long answer: Klipper has been engineered to automatically workaround many "
#~ "transient problems. For example, it automatically detects communication "
#~ "errors and will retransmit; it schedules actions in advance and buffers "
#~ "commands at multiple layers to enable precise timing even with intermittent "
#~ "interference. However, should the software detect an error that it can not "
#~ "recover from, if it is commanded to take an invalid action, or if it detects"
#~ " it is hopelessly unable to perform its commanded task, then Klipper will "
#~ "report an error. In these situations there is a high risk of producing a "
#~ "low-quality print (or worse). It is hoped that alerting the user will "
#~ "empower them to fix the underlying issue and improve the overall quality of "
#~ "their prints."
#~ msgstr ""

#~ msgid ""
#~ "There are some related questions: Why doesn't Klipper pause the print "
#~ "instead? Report a warning instead? Check for errors before the print? Ignore"
#~ " errors in user typed commands? etc? Currently Klipper reads commands using "
#~ "the G-Code protocol, and unfortunately the G-Code command protocol is not "
#~ "flexible enough to make these alternatives practical today. There is "
#~ "developer interest in improving the user experience during abnormal events, "
#~ "but it is expected that will require notable infrastructure work (including "
#~ "a shift away from G-Code)."
#~ msgstr ""

#~ msgid "How do I upgrade to the latest software?"
#~ msgstr ""

#~ msgid ""
#~ "The first step to upgrading the software is to review the latest [config "
#~ "changes](Config_Changes.md) document. On occasion, changes are made to the "
#~ "software that require users to update their settings as part of a software "
#~ "upgrade. It is a good idea to review this document prior to upgrading."
#~ msgstr ""

#~ msgid ""
#~ "When ready to upgrade, the general method is to ssh into the Raspberry Pi "
#~ "and run:"
#~ msgstr ""

#~ msgid ""
#~ "cd ~/klipper\n"
#~ "git pull\n"
#~ "~/klipper/scripts/install-octopi.sh\n"
#~ msgstr ""

#~ msgid ""
#~ "Then one can recompile and flash the micro-controller code. For example:"
#~ msgstr ""

#~ msgid ""
#~ "make menuconfig\n"
#~ "make clean\n"
#~ "make\n"
#~ "\n"
#~ "sudo service klipper stop\n"
#~ "make flash FLASH_DEVICE=/dev/ttyACM0\n"
#~ "sudo service klipper start\n"
#~ msgstr ""

#~ msgid ""
#~ "However, it's often the case that only the host software changes. In this "
#~ "case, one can update and restart just the host software with:"
#~ msgstr ""

#~ msgid ""
#~ "cd ~/klipper\n"
#~ "git pull\n"
#~ "sudo service klipper restart\n"
#~ msgstr ""

#~ msgid ""
#~ "If after using this shortcut the software warns about needing to reflash the"
#~ " micro-controller or some other unusual error occurs, then follow the full "
#~ "upgrade steps outlined above."
#~ msgstr ""

#~ msgid ""
#~ "If any errors persist then double check the [config "
#~ "changes](Config_Changes.md) document, as you may need to modify the printer "
#~ "configuration."
#~ msgstr ""

#~ msgid ""
#~ "Note that the RESTART and FIRMWARE_RESTART g-code commands do not load new "
#~ "software - the above \"sudo service klipper restart\" and \"make flash\" "
#~ "commands are needed for a software change to take effect."
#~ msgstr ""

#~ msgid "How do I uninstall Klipper?"
#~ msgstr ""

#~ msgid ""
#~ "On the firmware end, nothing special needs to happen. Just follow the "
#~ "flashing directions for the new firmware."
#~ msgstr ""

#~ msgid ""
#~ "On the raspberry pi end, an uninstall script is available in "
#~ "[scripts/klipper-uninstall.sh](../scripts/klipper-uninstall.sh). For "
#~ "example:"
#~ msgstr ""

#~ msgid ""
#~ "sudo ~/klipper/scripts/klipper-uninstall.sh\n"
#~ "rm -rf ~/klippy-env ~/klipper\n"
#~ msgstr ""

#~ msgid "Exclude Objects"
#~ msgstr ""

#~ msgid ""
#~ "The `[exclude_object]` module allows Klipper to exclude objects while a "
#~ "print is in progress. To enable this feature include an [exclude_object "
#~ "config section](Config_Reference.md#exclude_object) (also see the [command "
#~ "reference](G-Codes.md#exclude-object) and [sample-"
#~ "macros.cfg](../config/sample-macros.cfg) file for a Marlin/RepRapFirmware "
#~ "compatible M486 G-Code macro.)"
#~ msgstr ""

#~ msgid ""
#~ "Unlike other 3D printer firmware options, a printer running Klipper utilizes"
#~ " a suite of components and users have many options to choose from. "
#~ "Therefore, in order to provide a a consistent user experience, the "
#~ "`[exclude_object]` module will establish a contract or API of sorts. The "
#~ "contract covers the contents of the gcode file, how the internal state of "
#~ "the module is controlled, and how that state is provided to clients."
#~ msgstr ""

#~ msgid "Workflow Overview"
#~ msgstr ""

#~ msgid "A typical workflow for printing a file might look like this:"
#~ msgstr ""

#~ msgid ""
#~ "Slicing is completed and the file is uploaded for printing. During the "
#~ "upload, the file is processed and `[exclude_object]` markers are added to "
#~ "the file. Alternately, slicers may be configured to prepare object exclusion"
#~ " markers natively, or in it's own pre-processing step."
#~ msgstr ""

#~ msgid ""
#~ "When printing starts, Klipper will reset the `[exclude_object]` "
#~ "[status](Status_Reference.md#exclude_object)."
#~ msgstr ""

#~ msgid ""
#~ "When Klipper processes the `EXCLUDE_OBJECT_DEFINE` block, it will update the"
#~ " status with the known objects and pass it on to clients."
#~ msgstr ""

#~ msgid ""
#~ "The client may use that information to present a UI to the user so that "
#~ "progress can be tracked. Klipper will update the status to include the "
#~ "currently printing object which the client can use for display purposes."
#~ msgstr ""

#~ msgid ""
#~ "If the user requests that an object be cancelled, the client will issue an "
#~ "`EXCLUDE_OBJECT NAME=<name>` command to Klipper."
#~ msgstr ""

#~ msgid ""
#~ "When Klipper process the command, it will add the object to the list of "
#~ "excluded objects and update the status for the client."
#~ msgstr ""

#~ msgid ""
#~ "The client will receive the updated status from Klipper and can use that "
#~ "information to reflect the object's status in the UI."
#~ msgstr ""

#~ msgid ""
#~ "When printing finishes, the `[exclude_object]` status will continue to be "
#~ "available until another action resets it."
#~ msgstr ""

#~ msgid "The GCode File"
#~ msgstr ""

#~ msgid ""
#~ "The specialized gcode processing needed to support excluding objects does "
#~ "not fit into Klipper's core design goals. Therefore, this module requires "
#~ "that the file is processed before being sent to Klipper for printing. Using "
#~ "a post-process script in the slicer or having middleware process the file on"
#~ " upload are two possibilities for preparing the file for Klipper. A "
#~ "reference post-processing script is available both as an executable and a "
#~ "python library, see [cancelobject-"
#~ "preprocessor](https://github.com/kageurufu/cancelobject-preprocessor)."
#~ msgstr ""

#~ msgid "Object Definitions"
#~ msgstr ""

#~ msgid ""
#~ "The `EXCLUDE_OBJECT_DEFINE` command is used to provide a summary of each "
#~ "object in the gcode file to be printed. Provides a summary of an object in "
#~ "the file. Objects don't need to be defined in order to be referenced by "
#~ "other commands. The primary purpose of this command is to provide "
#~ "information to the UI without needing to parse the entire gcode file."
#~ msgstr ""

#~ msgid ""
#~ "Object definitions are named, to allow users to easily select an object to "
#~ "be excluded, and additional metadata may be provided to allow for graphical "
#~ "cancellation displays. Currently defined metadata includes a `CENTER` X,Y "
#~ "coordinate, and a `POLYGON` list of X,Y points representing a minimal "
#~ "outline of the object. This could be a simple bounding box, or a complicated"
#~ " hull for showing more detailed visualizations of the printed objects. "
#~ "Especially when gcode files include multiple parts with overlapping bounding"
#~ " regions, center points become hard to visually distinguish. `POLYGONS` must"
#~ " be a json-compatible array of point `[X,Y]` tuples without whitespace. "
#~ "Additional parameters will be saved as strings in the object definition and "
#~ "provided in status updates."
#~ msgstr ""

#~ msgid ""
#~ "`EXCLUDE_OBJECT_DEFINE NAME=calibration_pyramid CENTER=50,50 "
#~ "POLYGON=[[40,40],[50,60],[60,40]]`"
#~ msgstr ""

#~ msgid ""
#~ "All available G-Code commands are documented in the [G-Code "
#~ "Reference](./G-Codes.md#excludeobject)"
#~ msgstr ""

#~ msgid "Status Information"
#~ msgstr ""

#~ msgid ""
#~ "The state of this module is provided to clients by the [exclude_object "
#~ "status](Status_Reference.md#exclude_object)."
#~ msgstr ""

#~ msgid "The status is reset when:"
#~ msgstr ""

#~ msgid "The Klipper firmware is restarted."
#~ msgstr ""

#~ msgid ""
#~ "There is a reset of the `[virtual_sdcard]`. Notably, this is reset by "
#~ "Klipper at the start of a print."
#~ msgstr ""

#~ msgid "When an `EXCLUDE_OBJECT_DEFINE RESET=1` command is issued."
#~ msgstr ""

#~ msgid ""
#~ "The list of defined objects is represented in the `exclude_object.objects` "
#~ "status field. In a well defined gcode file, this will be done with "
#~ "`EXCLUDE_OBJECT_DEFINE` commands at the beginning of the file. This will "
#~ "provide clients with object names and coordinates so the UI can provide a "
#~ "graphical representation of the objects if desired."
#~ msgstr ""

#~ msgid ""
#~ "As the print progresses, the `exclude_object.current_object` status field "
#~ "will be updated as Klipper processes `EXCLUDE_OBJECT_START` and "
#~ "`EXCLUDE_OBJECT_END` commands. The `current_object` field will be set even "
#~ "if the object has been excluded. Undefined objects marked with a "
#~ "`EXCLUDE_OBJECT_START` will be added to the known objects to assist in UI "
#~ "hinting, without any additional metadata."
#~ msgstr ""

#~ msgid ""
#~ "As `EXCLUDE_OBJECT` commands are issued, the list of excluded objects is "
#~ "provided in the `exclude_object.excluded_objects` array. Since Klipper looks"
#~ " ahead to process upcoming gcode, there may be a delay between when the "
#~ "command is issued and when the status is updated."
#~ msgstr ""

#~ msgid "Example configurations"
#~ msgstr ""

#~ msgid ""
#~ "This document contains guidelines for contributing an example Klipper "
#~ "configuration to the Klipper github repository (located in the [config "
#~ "directory](../config/))."
#~ msgstr ""

#~ msgid ""
#~ "Note that the [Klipper Community Discourse "
#~ "server](https://community.klipper3d.org) is also a useful resource for "
#~ "finding and sharing config files."
#~ msgstr ""

#~ msgid "Guidelines"
#~ msgstr ""

#~ msgid "Select the appropriate config filename prefix:"
#~ msgstr ""

#~ msgid ""
#~ "The `printer` prefix is used for stock printers sold by a mainstream "
#~ "manufacturer."
#~ msgstr ""

#~ msgid ""
#~ "The `generic` prefix is used for a 3d printer board that may be used in many"
#~ " different types of printers."
#~ msgstr ""

#~ msgid ""
#~ "The `kit` prefix is for 3d printers that are assembled according to a widely"
#~ " used specification. These \"kit\" printers are generally distinct from "
#~ "normal \"printers\" in that they are not sold by a manufacturer."
#~ msgstr ""

#~ msgid ""
#~ "The `sample` prefix is used for config \"snippets\" that one may copy-and-"
#~ "paste into the main config file."
#~ msgstr ""

#~ msgid ""
#~ "The `example` prefix is used to describe printer kinematics. This type of "
#~ "config is typically only added along with code for a new type of printer "
#~ "kinematics."
#~ msgstr ""

#~ msgid ""
#~ "All configuration files must end in a `.cfg` suffix. The `printer` config "
#~ "files must end in a year followed by `.cfg` (eg, `-2019.cfg`). In this case,"
#~ " the year is an approximate year the given printer was sold."
#~ msgstr ""

#~ msgid ""
#~ "Do not use spaces or special characters in the config filename. The filename"
#~ " should contain only characters `A-Z`, `a-z`, `0-9`, `-`, and `.`."
#~ msgstr ""

#~ msgid ""
#~ "Klipper must be able to start `printer`, `generic`, and `kit` example config"
#~ " file without error. These config files should be added to the "
#~ "[test/klippy/printers.test](../test/klippy/printers.test) regression test "
#~ "case. Add new config files to that test case in the appropriate section and "
#~ "in alphabetical order within that section."
#~ msgstr ""

#~ msgid ""
#~ "The example configuration should be for the \"stock\" configuration of the "
#~ "printer. (There are too many \"customized\" configurations to track in the "
#~ "main Klipper repository.) Similarly, we only add example config files for "
#~ "printers, kits, and boards that have mainstream popularity (eg, there should"
#~ " be at least a 100 of them in active use). Consider using the [Klipper "
#~ "Community Discourse server](https://community.klipper3d.org) for other "
#~ "configs."
#~ msgstr ""

#~ msgid ""
#~ "Only specify those devices present on the given printer or board. Do not "
#~ "specify settings specific to your particular setup.For `generic` config "
#~ "files, only those devices on the mainboard should be described. For example,"
#~ " it would not make sense to add a display config section to a \"generic\" "
#~ "config as there is no way to know if the board will be attached to that type"
#~ " of display. If the board has a specific hardware port to facilitate an "
#~ "optional peripheral (eg, a bltouch port) then one can add a \"commented "
#~ "out\" config section for the given device."
#~ msgstr ""

#~ msgid ""
#~ "Do not specify `pressure_advance` in an example config, as that value is "
#~ "specific to the filament, not the printer hardware. Similarly, do not "
#~ "specify `max_extrude_only_velocity` nor `max_extrude_only_accel` settings."
#~ msgstr ""

#~ msgid ""
#~ "Do not specify a config section containing a host path or host hardware. For"
#~ " example, do not specify `[virtual_sdcard]` nor `[temperature_host]` config "
#~ "sections."
#~ msgstr ""

#~ msgid ""
#~ "Only define macros that utilize functionality specific to the given printer "
#~ "or to define g-codes that are commonly emitted by slicers configured for the"
#~ " given printer."
#~ msgstr ""

#~ msgid ""
#~ "Where possible, it is best to use the same wording, phrasing, indentation, "
#~ "and section ordering as the existing config files.The top of each config "
#~ "file should list the type of micro-controller the user should select during "
#~ "\"make menuconfig\". It should also have a reference to "
#~ "\"docs/Config_Reference.md\"."
#~ msgstr ""

#~ msgid ""
#~ "Do not copy the field documentation into the example config files. (Doing so"
#~ " creates a maintenance burden as an update to the documentation would then "
#~ "require changing it in many places.)"
#~ msgstr ""

#~ msgid ""
#~ "Example config files should not contain a \"SAVE_CONFIG\" section. If "
#~ "necessary, copy the relevant fields from the SAVE_CONFIG section to the "
#~ "appropriate section in the main config area."
#~ msgstr ""

#~ msgid "Use `field: value` syntax instead of `field=value`."
#~ msgstr ""

#~ msgid ""
#~ "When adding an extruder `rotation_distance` it is preferable to specify a "
#~ "`gear_ratio` if the extruder has a gearing mechanism. We expect the "
#~ "rotation_distance in the example configs to correlate with the circumference"
#~ " of the hobbed gear in the extruder - it is normally in the range of 20 to "
#~ "35mm. When specifying a `gear_ratio` it is preferable to specify the actual "
#~ "gears on the mechanism (eg, prefer `gear_ratio: 80:20` over `gear_ratio: "
#~ "4:1`). See the [rotation distance document](Rotation_Distance.md#using-a-"
#~ "gear_ratio) for more information."
#~ msgstr ""

#~ msgid ""
#~ "Avoid defining field values that are set to their default value. For "
#~ "example, one should not specify `min_extrude_temp: 170` as that is already "
#~ "the default value."
#~ msgstr ""

#~ msgid "Where possible, lines should not exceed 80 columns."
#~ msgstr ""

#~ msgid ""
#~ "Avoid adding attribution or revision messages to the config files. (For "
#~ "example, avoid adding lines like \"this file was created by ...\".) Place "
#~ "attribution and change history in the git commit message."
#~ msgstr ""

#~ msgid "Do not use any deprecated features in the example config file."
#~ msgstr ""

#~ msgid ""
#~ "Do not disable a default safety system in an example config file. For "
#~ "example, a config should not specify a custom `max_extrude_cross_section`. "
#~ "Do not enable debugging features. For example there should not be a "
#~ "`force_move` config section."
#~ msgstr ""

#~ msgid ""
#~ "All known boards that Klipper supports can use the default serial baud rate "
#~ "of 250000. Do not recommend a different baud rate in an example config file."
#~ msgstr ""

#~ msgid ""
#~ "Example config files are submitted by creating a github \"pull request\". "
#~ "Please also follow the directions in the [contributing "
#~ "document](CONTRIBUTING.md)."
#~ msgstr ""

#~ msgid "Additional notes"
#~ msgstr ""

#~ msgid "Endstop phase"
#~ msgstr ""

#~ msgid ""
#~ "This document describes Klipper's stepper phase adjusted endstop system. "
#~ "This functionality can improve the accuracy of traditional endstop switches."
#~ " It is most useful when using a Trinamic stepper motor driver that has run-"
#~ "time configuration."
#~ msgstr ""

#~ msgid ""
#~ "A typical endstop switch has an accuracy of around 100 microns. (Each time "
#~ "an axis is homed the switch may trigger slightly earlier or slightly later.)"
#~ " Although this is a relatively small error, it can result in unwanted "
#~ "artifacts. In particular, this positional deviation may be noticeable when "
#~ "printing the first layer of an object. In contrast, typical stepper motors "
#~ "can obtain significantly higher precision."
#~ msgstr ""

#~ msgid ""
#~ "The stepper phase adjusted endstop mechanism can use the precision of the "
#~ "stepper motors to improve the precision of the endstop switches. A stepper "
#~ "motor moves by cycling through a series of phases until in completes four "
#~ "\"full steps\". So, a stepper motor using 16 micro-steps would have 64 "
#~ "phases and when moving in a positive direction it would cycle through "
#~ "phases: 0, 1, 2, ... 61, 62, 63, 0, 1, 2, etc. Crucially, when the stepper "
#~ "motor is at a particular position on a linear rail it should always be at "
#~ "the same stepper phase. Thus, when a carriage triggers the endstop switch "
#~ "the stepper controlling that carriage should always be at the same stepper "
#~ "motor phase. Klipper's endstop phase system combines the stepper phase with "
#~ "the endstop trigger to improve the accuracy of the endstop."
#~ msgstr ""

#~ msgid ""
#~ "In order to use this functionality it is necessary to be able to identify "
#~ "the phase of the stepper motor. If one is using Trinamic TMC2130, TMC2208, "
#~ "TMC2224 or TMC2660 drivers in run-time configuration mode (ie, not stand-"
#~ "alone mode) then Klipper can query the stepper phase from the driver. (It is"
#~ " also possible to use this system on traditional stepper drivers if one can "
#~ "reliably reset the stepper drivers - see below for details.)"
#~ msgstr ""

#~ msgid "Calibrating endstop phases"
#~ msgstr ""

#~ msgid ""
#~ "If using Trinamic stepper motor drivers with run-time configuration then one"
#~ " can calibrate the endstop phases using the ENDSTOP_PHASE_CALIBRATE command."
#~ " Start by adding the following to the config file:"
#~ msgstr ""

#~ msgid "[endstop_phase]\n"
#~ msgstr ""

#~ msgid ""
#~ "Then RESTART the printer and run a `G28` command followed by an "
#~ "`ENDSTOP_PHASE_CALIBRATE` command. Then move the toolhead to a new location "
#~ "and run `G28` again. Try moving the toolhead to several different locations "
#~ "and rerun `G28` from each position. Run at least five `G28` commands."
#~ msgstr ""

#~ msgid ""
#~ "After performing the above, the `ENDSTOP_PHASE_CALIBRATE` command will often"
#~ " report the same (or nearly the same) phase for the stepper. This phase can "
#~ "be saved in the config file so that all future G28 commands use that phase. "
#~ "(So, in future homing operations, Klipper will obtain the same position even"
#~ " if the endstop triggers a little earlier or a little later.)"
#~ msgstr ""

#~ msgid ""
#~ "To save the endstop phase for a particular stepper motor, run something like"
#~ " the following:"
#~ msgstr ""

#~ msgid "ENDSTOP_PHASE_CALIBRATE STEPPER=stepper_z\n"
#~ msgstr ""

#~ msgid ""
#~ "Run the above for all the steppers one wishes to save. Typically, one would "
#~ "use this on stepper_z for cartesian and corexy printers, and for stepper_a, "
#~ "stepper_b, and stepper_c on delta printers. Finally, run the following to "
#~ "update the configuration file with the data:"
#~ msgstr ""

#~ msgid ""
#~ "This feature is most useful on delta printers and on the Z endstop of "
#~ "cartesian/corexy printers. It is possible to use this feature on the XY "
#~ "endstops of cartesian printers, but that isn't particularly useful as a "
#~ "minor error in X/Y endstop position is unlikely to impact print quality. It "
#~ "is not valid to use this feature on the XY endstops of corexy printers (as "
#~ "the XY position is not determined by a single stepper on corexy kinematics)."
#~ " It is not valid to use this feature on a printer using a "
#~ "\"probe:z_virtual_endstop\" Z endstop (as the stepper phase is only stable "
#~ "if the endstop is at a static location on a rail)."
#~ msgstr ""

#~ msgid ""
#~ "After calibrating the endstop phase, if the endstop is later moved or "
#~ "adjusted then it will be necessary to recalibrate the endstop. Remove the "
#~ "calibration data from the config file and rerun the steps above."
#~ msgstr ""

#~ msgid ""
#~ "In order to use this system the endstop must be accurate enough to identify "
#~ "the stepper position within two \"full steps\". So, for example, if a "
#~ "stepper is using 16 micro-steps with a step distance of 0.005mm then the "
#~ "endstop must have an accuracy of at least 0.160mm. If one gets \"Endstop "
#~ "stepper_z incorrect phase\" type error messages than in may be due to an "
#~ "endstop that is not sufficiently accurate. If recalibration does not help "
#~ "then disable endstop phase adjustments by removing them from the config "
#~ "file."
#~ msgstr ""

#~ msgid ""
#~ "If one is using a traditional stepper controlled Z axis (as on a cartesian "
#~ "or corexy printer) along with traditional bed leveling screws then it is "
#~ "also possible to use this system to arrange for each print layer to be "
#~ "performed on a \"full step\" boundary. To enable this feature be sure the "
#~ "G-Code slicer is configured with a layer height that is a multiple of a "
#~ "\"full step\", manually enable the endstop_align_zero option in the "
#~ "endstop_phase config section (see [config "
#~ "reference](Config_Reference.md#endstop_phase) for further details), and then"
#~ " re-level the bed screws."
#~ msgstr ""

#~ msgid ""
#~ "It is possible to use this system with traditional (non-Trinamic) stepper "
#~ "motor drivers. However, doing this requires making sure that the stepper "
#~ "motor drivers are reset every time the micro-controller is reset. (If the "
#~ "two are always reset together then Klipper can determine the stepper phase "
#~ "by tracking the total number of steps it has commanded the stepper to move.)"
#~ " Currently, the only way to do this reliably is if both the micro-controller"
#~ " and stepper motor drivers are powered solely from USB and that USB power is"
#~ " provided from a host running on a Raspberry Pi. In this situation one can "
#~ "specify an mcu config with \"restart_method: rpi_usb\" - that option will "
#~ "arrange for the micro-controller to always be reset via a USB power reset, "
#~ "which would arrange for both the micro-controller and stepper motor drivers "
#~ "to be reset together. If using this mechanism, one would then need to "
#~ "manually configure the \"trigger_phase\" config sections (see [config "
#~ "reference](Config_Reference.md#endstop_phase) for the details)."
#~ msgstr ""

#~ msgid "Delta calibration"
#~ msgstr ""

#~ msgid ""
#~ "This document describes Klipper's automatic calibration system for \"delta\""
#~ " style printers."
#~ msgstr ""

#~ msgid ""
#~ "Delta calibration involves finding the tower endstop positions, tower "
#~ "angles, delta radius, and delta arm lengths. These settings control printer "
#~ "motion on a delta printer. Each one of these parameters has a non-obvious "
#~ "and non-linear impact and it is difficult to calibrate them manually. In "
#~ "contrast, the software calibration code can provide excellent results with "
#~ "just a few minutes of time. No special probing hardware is necessary."
#~ msgstr ""

#~ msgid ""
#~ "Ultimately, the delta calibration is dependent on the precision of the tower"
#~ " endstop switches. If one is using Trinamic stepper motor drivers then "
#~ "consider enabling [endstop phase](Endstop_Phase.md) detection to improve the"
#~ " accuracy of those switches."
#~ msgstr ""

#~ msgid "Automatic vs manual probing"
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports calibrating the delta parameters via a manual probing "
#~ "method or via an automatic Z probe."
#~ msgstr ""

#~ msgid ""
#~ "A number of delta printer kits come with automatic Z probes that are not "
#~ "sufficiently accurate (specifically, small differences in arm length can "
#~ "cause effector tilt which can skew an automatic probe). If using an "
#~ "automatic probe then first [calibrate the probe](Probe_Calibrate.md) and "
#~ "then check for a [probe location bias](Probe_Calibrate.md#location-bias-"
#~ "check). If the automatic probe has a bias of more than 25 microns (.025mm) "
#~ "then use manual probing instead. Manual probing only takes a few minutes and"
#~ " it eliminates error introduced by the probe."
#~ msgstr ""

#~ msgid ""
#~ "If using a probe that is mounted on the side of the hotend (that is, it has "
#~ "an X or Y offset) then note that performing delta calibration will "
#~ "invalidate the results of probe calibration. These types of probes are "
#~ "rarely suitable for use on a delta (because minor effector tilt will result "
#~ "in a probe location bias). If using the probe anyway, then be sure to rerun "
#~ "probe calibration after any delta calibration."
#~ msgstr ""

#~ msgid "Basic delta calibration"
#~ msgstr ""

#~ msgid ""
#~ "Klipper has a DELTA_CALIBRATE command that can perform basic delta "
#~ "calibration. This command probes seven different points on the bed and "
#~ "calculates new values for the tower angles, tower endstops, and delta "
#~ "radius."
#~ msgstr ""

#~ msgid ""
#~ "In order to perform this calibration the initial delta parameters (arm "
#~ "lengths, radius, and endstop positions) must be provided and they should "
#~ "have an accuracy to within a few millimeters. Most delta printer kits will "
#~ "provide these parameters - configure the printer with these initial defaults"
#~ " and then go on to run the DELTA_CALIBRATE command as described below. If no"
#~ " defaults are available then search online for a delta calibration guide "
#~ "that can provide a basic starting point."
#~ msgstr ""

#~ msgid ""
#~ "During the delta calibration process it may be necessary for the printer to "
#~ "probe below what would otherwise be considered the plane of the bed. It is "
#~ "typical to permit this during calibration by updating the config so that the"
#~ " printer's `minimum_z_position=-5`. (Once calibration completes, one can "
#~ "remove this setting from the config.)"
#~ msgstr ""

#~ msgid ""
#~ "There are two ways to perform the probing - manual probing (`DELTA_CALIBRATE"
#~ " METHOD=manual`) and automatic probing (`DELTA_CALIBRATE`). The manual "
#~ "probing method will move the head near the bed and then wait for the user to"
#~ " follow the steps described at [\"the paper test\"](Bed_Level.md#the-paper-"
#~ "test) to determine the actual distance between the nozzle and bed at the "
#~ "given location."
#~ msgstr ""

#~ msgid ""
#~ "To perform the basic probe, make sure the config has a [delta_calibrate] "
#~ "section defined and then run the tool:"
#~ msgstr ""

#~ msgid ""
#~ "G28\n"
#~ "DELTA_CALIBRATE METHOD=manual\n"
#~ msgstr ""

#~ msgid ""
#~ "After probing the seven points new delta parameters will be calculated. Save"
#~ " and apply these parameters by running:"
#~ msgstr ""

#~ msgid ""
#~ "The basic calibration should provide delta parameters that are accurate "
#~ "enough for basic printing. If this is a new printer, this is a good time to "
#~ "print some basic objects and verify general functionality."
#~ msgstr ""

#~ msgid "Enhanced delta calibration"
#~ msgstr ""

#~ msgid ""
#~ "The basic delta calibration generally does a good job of calculating delta "
#~ "parameters such that the nozzle is the correct distance from the bed. "
#~ "However, it does not attempt to calibrate X and Y dimensional accuracy. It's"
#~ " a good idea to perform an enhanced delta calibration to verify dimensional "
#~ "accuracy."
#~ msgstr ""

#~ msgid ""
#~ "This calibration procedure requires printing a test object and measuring "
#~ "parts of that test object with digital calipers."
#~ msgstr ""

#~ msgid ""
#~ "Prior to running an enhanced delta calibration one must run the basic delta "
#~ "calibration (via the DELTA_CALIBRATE command) and save the results (via the "
#~ "SAVE_CONFIG command). Make sure there hasn't been any notable change to the "
#~ "printer configuration nor hardware since last performing a basic delta "
#~ "calibration (if unsure, rerun the [basic delta calibration](#basic-delta-"
#~ "calibration), including SAVE_CONFIG, just prior to printing the test object "
#~ "described below.)"
#~ msgstr ""

#~ msgid ""
#~ "Use a slicer to generate G-Code from the "
#~ "[docs/prints/calibrate_size.stl](prints/calibrate_size.stl) file. Slice the "
#~ "object using a slow speed (eg, 40mm/s). If possible, use a stiff plastic "
#~ "(such as PLA) for the object. The object has a diameter of 140mm. If this is"
#~ " too large for the printer then one can scale it down (but be sure to "
#~ "uniformly scale both the X and Y axes). If the printer supports "
#~ "significantly larger prints then this object can also be increased in size. "
#~ "A larger size can improve the measurement accuracy, but good print adhesion "
#~ "is more important than a larger print size."
#~ msgstr ""

#~ msgid ""
#~ "Print the test object and wait for it to fully cool. The commands described "
#~ "below must be run with the same printer settings used to print the "
#~ "calibration object (don't run DELTA_CALIBRATE between printing and "
#~ "measuring, or do something that would otherwise change the printer "
#~ "configuration)."
#~ msgstr ""

#~ msgid ""
#~ "If possible, perform the measurements described below while the object is "
#~ "still attached to the print bed, but don't worry if the part detaches from "
#~ "the bed - just try to avoid bending the object when performing the "
#~ "measurements."
#~ msgstr ""

#~ msgid ""
#~ "Start by measuring the distance between the center pillar and the pillar "
#~ "next to the \"A\" label (which should also be pointing towards the \"A\" "
#~ "tower)."
#~ msgstr ""

#~ msgid "![delta-a-distance](img/delta-a-distance.jpg)"
#~ msgstr ""

#~ msgid ""
#~ "Then go counterclockwise and measure the distances between the center pillar"
#~ " and the other pillars (distance from center to pillar across from C label, "
#~ "distance from center to pillar with B label, etc.)."
#~ msgstr ""

#~ msgid "![delta_cal_e_step1](img/delta_cal_e_step1.png)"
#~ msgstr ""

#~ msgid ""
#~ "Enter these parameters into Klipper with a comma separated list of floating "
#~ "point numbers:"
#~ msgstr ""

#~ msgid ""
#~ "DELTA_ANALYZE "
#~ "CENTER_DISTS=<a_dist>,<far_c_dist>,<b_dist>,<far_a_dist>,<c_dist>,<far_b_dist>\n"
#~ msgstr ""

#~ msgid "Provide the values without spaces between them."
#~ msgstr ""

#~ msgid ""
#~ "Then measure the distance between the A pillar and the pillar across from "
#~ "the C label."
#~ msgstr ""

#~ msgid "![delta-ab-distance](img/delta-outer-distance.jpg)"
#~ msgstr ""

#~ msgid ""
#~ "Then go counterclockwise and measure the distance between the pillar across "
#~ "from C to the B pillar, the distance between the B pillar and the pillar "
#~ "across from A, and so on."
#~ msgstr ""

#~ msgid "![delta_cal_e_step2](img/delta_cal_e_step2.png)"
#~ msgstr ""

#~ msgid "Enter these parameters into Klipper:"
#~ msgstr ""

#~ msgid ""
#~ "DELTA_ANALYZE "
#~ "OUTER_DISTS=<a_to_far_c>,<far_c_to_b>,<b_to_far_a>,<far_a_to_c>,<c_to_far_b>,<far_b_to_a>\n"
#~ msgstr ""

#~ msgid ""
#~ "At this point it is okay to remove the object from the bed. The final "
#~ "measurements are of the pillars themselves. Measure the size of the center "
#~ "pillar along the A spoke, then the B spoke, and then the C spoke."
#~ msgstr ""

#~ msgid "![delta-a-pillar](img/delta-a-pillar.jpg)"
#~ msgstr ""

#~ msgid "![delta_cal_e_step3](img/delta_cal_e_step3.png)"
#~ msgstr ""

#~ msgid "Enter them into Klipper:"
#~ msgstr ""

#~ msgid "DELTA_ANALYZE CENTER_PILLAR_WIDTHS=<a>,<b>,<c>\n"
#~ msgstr ""

#~ msgid ""
#~ "The final measurements are of the outer pillars. Start by measuring the "
#~ "distance of the A pillar along the line from A to the pillar across from C."
#~ msgstr ""

#~ msgid "![delta-ab-pillar](img/delta-outer-pillar.jpg)"
#~ msgstr ""

#~ msgid ""
#~ "Then go counterclockwise and measure the remaining outer pillars (pillar "
#~ "across from C along the line to B, B pillar along the line to pillar across "
#~ "from A, etc.)."
#~ msgstr ""

#~ msgid "![delta_cal_e_step4](img/delta_cal_e_step4.png)"
#~ msgstr ""

#~ msgid "And enter them into Klipper:"
#~ msgstr ""

#~ msgid "DELTA_ANALYZE OUTER_PILLAR_WIDTHS=<a>,<far_c>,<b>,<far_a>,<c>,<far_b>\n"
#~ msgstr ""

#~ msgid ""
#~ "If the object was scaled to a smaller or larger size then provide the scale "
#~ "factor that was used when slicing the object:"
#~ msgstr ""

#~ msgid "DELTA_ANALYZE SCALE=1.0\n"
#~ msgstr ""

#~ msgid ""
#~ "(A scale value of 2.0 would mean the object is twice its original size, 0.5 "
#~ "would be half its original size.)"
#~ msgstr ""

#~ msgid "Finally, perform the enhanced delta calibration by running:"
#~ msgstr ""

#~ msgid "DELTA_ANALYZE CALIBRATE=extended\n"
#~ msgstr ""

#~ msgid ""
#~ "This command can take several minutes to complete. After completion it will "
#~ "calculate updated delta parameters (delta radius, tower angles, endstop "
#~ "positions, and arm lengths). Use the SAVE_CONFIG command to save and apply "
#~ "the settings:"
#~ msgstr ""

#~ msgid ""
#~ "The SAVE_CONFIG command will save both the updated delta parameters and "
#~ "information from the distance measurements. Future DELTA_CALIBRATE commands "
#~ "will also utilize this distance information. Do not attempt to reenter the "
#~ "raw distance measurements after running SAVE_CONFIG, as this command changes"
#~ " the printer configuration and the raw measurements no longer apply."
#~ msgstr ""

#~ msgid ""
#~ "If the delta printer has good dimensional accuracy then the distance between"
#~ " any two pillars should be around 74mm and the width of every pillar should "
#~ "be around 9mm. (Specifically, the goal is for the distance between any two "
#~ "pillars minus the width of one of the pillars to be exactly 65mm.) Should "
#~ "there be a dimensional inaccuracy in the part then the DELTA_ANALYZE routine"
#~ " will calculate new delta parameters using both the distance measurements "
#~ "and the previous height measurements from the last DELTA_CALIBRATE command."
#~ msgstr ""

#~ msgid ""
#~ "DELTA_ANALYZE may produce delta parameters that are surprising. For example,"
#~ " it may suggest arm lengths that do not match the printer's actual arm "
#~ "lengths. Despite this, testing has shown that DELTA_ANALYZE often produces "
#~ "superior results. It is believed that the calculated delta parameters are "
#~ "able to account for slight errors elsewhere in the hardware. For example, "
#~ "small differences in arm length may result in a tilt to the effector and "
#~ "some of that tilt may be accounted for by adjusting the arm length "
#~ "parameters."
#~ msgstr ""

#~ msgid "Using Bed Mesh on a Delta"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to use [bed mesh](Bed_Mesh.md) on a delta. However, it is "
#~ "important to obtain good delta calibration prior to enabling a bed mesh. "
#~ "Running bed mesh with poor delta calibration will result in confusing and "
#~ "poor results."
#~ msgstr ""

#~ msgid ""
#~ "Note that performing delta calibration will invalidate any previously "
#~ "obtained bed mesh. After performing a new delta calibration be sure to rerun"
#~ " BED_MESH_CALIBRATE."
#~ msgstr ""

#~ msgid "Debugging"
#~ msgstr ""

#~ msgid "This document describes some of the Klipper debugging tools."
#~ msgstr ""

#~ msgid "Running the regression tests"
#~ msgstr ""

#~ msgid ""
#~ "The main Klipper GitHub repository uses \"github actions\" to run a series "
#~ "of regression tests. It can be useful to run some of these tests locally."
#~ msgstr ""

#~ msgid "The source code \"whitespace check\" can be run with:"
#~ msgstr ""

#~ msgid "./scripts/check_whitespace.sh\n"
#~ msgstr ""

#~ msgid ""
#~ "The Klippy regression test suite requires \"data dictionaries\" from many "
#~ "platforms. The easiest way to obtain them is to [download them from "
#~ "github](https://github.com/Klipper3d/klipper/issues/1438). Once the data "
#~ "dictionaries are downloaded, use the following to run the regression suite:"
#~ msgstr ""

#~ msgid ""
#~ "tar xfz klipper-dict-20??????.tar.gz\n"
#~ "~/klippy-env/bin/python ~/klipper/scripts/test_klippy.py -d dict/ ~/klipper/test/klippy/*.test\n"
#~ msgstr ""

#~ msgid "Manually sending commands to the micro-controller"
#~ msgstr ""

#~ msgid ""
#~ "Normally, the host klippy.py process would be used to translate gcode "
#~ "commands to Klipper micro-controller commands. However, it's also possible "
#~ "to manually send these MCU commands (functions marked with the "
#~ "DECL_COMMAND() macro in the Klipper source code). To do so, run:"
#~ msgstr ""

#~ msgid "~/klippy-env/bin/python ./klippy/console.py /tmp/pseudoserial\n"
#~ msgstr ""

#~ msgid ""
#~ "See the \"HELP\" command within the tool for more information on its "
#~ "functionality."
#~ msgstr ""

#~ msgid ""
#~ "Some command-line options are available. For more information run: "
#~ "`~/klippy-env/bin/python ./klippy/console.py --help`"
#~ msgstr ""

#~ msgid "Translating gcode files to micro-controller commands"
#~ msgstr ""

#~ msgid ""
#~ "The Klippy host code can run in a batch mode to produce the low-level micro-"
#~ "controller commands associated with a gcode file. Inspecting these low-level"
#~ " commands is useful when trying to understand the actions of the low-level "
#~ "hardware. It can also be useful to compare the difference in micro-"
#~ "controller commands after a code change."
#~ msgstr ""

#~ msgid ""
#~ "To run Klippy in this batch mode, there is a one time step necessary to "
#~ "generate the micro-controller \"data dictionary\". This is done by compiling"
#~ " the micro-controller code to obtain the **out/klipper.dict** file:"
#~ msgstr ""

#~ msgid ""
#~ "make menuconfig\n"
#~ "make\n"
#~ msgstr ""

#~ msgid ""
#~ "Once the above is done it is possible to run Klipper in batch mode (see "
#~ "[installation](Installation.md) for the steps necessary to build the python "
#~ "virtual environment and a printer.cfg file):"
#~ msgstr ""

#~ msgid ""
#~ "~/klippy-env/bin/python ./klippy/klippy.py ~/printer.cfg -i test.gcode -o "
#~ "test.serial -v -d out/klipper.dict\n"
#~ msgstr ""

#~ msgid ""
#~ "The above will produce a file **test.serial** with the binary serial output."
#~ " This output can be translated to readable text with:"
#~ msgstr ""

#~ msgid ""
#~ "~/klippy-env/bin/python ./klippy/parsedump.py out/klipper.dict test.serial >"
#~ " test.txt\n"
#~ msgstr ""

#~ msgid ""
#~ "The resulting file **test.txt** contains a human readable list of micro-"
#~ "controller commands."
#~ msgstr ""

#~ msgid ""
#~ "The batch mode disables certain response / request commands in order to "
#~ "function. As a result, there will be some differences between actual "
#~ "commands and the above output. The generated data is useful for testing and "
#~ "inspection; it is not useful for sending to a real micro-controller."
#~ msgstr ""

#~ msgid "Motion analysis and data logging"
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports logging its internal motion history, which can be later "
#~ "analyzed. To use this feature, Klipper must be started with the [API "
#~ "Server](API_Server.md) enabled."
#~ msgstr ""

#~ msgid "Data logging is enabled with the `data_logger.py` tool. For example:"
#~ msgstr ""

#~ msgid "~/klipper/scripts/motan/data_logger.py /tmp/klippy_uds mylog\n"
#~ msgstr ""

#~ msgid ""
#~ "This command will connect to the Klipper API Server, subscribe to status and"
#~ " motion information, and log the results. Two files are generated - a "
#~ "compressed data file and an index file (eg, `mylog.json.gz` and "
#~ "`mylog.index.gz`). After starting the logging, it is possible to complete "
#~ "prints and other actions - the logging will continue in the background. When"
#~ " done logging, hit `ctrl-c` to exit from the `data_logger.py` tool."
#~ msgstr ""

#~ msgid ""
#~ "The resulting files can be read and graphed using the `motan_graph.py` tool."
#~ " To generate graphs on a Raspberry Pi, a one time step is necessary to "
#~ "install the \"matplotlib\" package:"
#~ msgstr ""

#~ msgid ""
#~ "sudo apt-get update\n"
#~ "sudo apt-get install python-matplotlib\n"
#~ msgstr ""

#~ msgid ""
#~ "However, it may be more convenient to copy the data files to a desktop class"
#~ " machine along with the Python code in the `scripts/motan/` directory. The "
#~ "motion analysis scripts should run on any machine with a recent version of "
#~ "[Python](https://python.org) and [Matplotlib](https://matplotlib.org/) "
#~ "installed."
#~ msgstr ""

#~ msgid "Graphs can be generated with a command like the following:"
#~ msgstr ""

#~ msgid "~/klipper/scripts/motan/motan_graph.py mylog -o mygraph.png\n"
#~ msgstr ""

#~ msgid ""
#~ "One can use the `-g` option to specify the datasets to graph (it takes a "
#~ "Python literal containing a list of lists). For example:"
#~ msgstr ""

#~ msgid ""
#~ "~/klipper/scripts/motan/motan_graph.py mylog -g "
#~ "'[[\"trapq(toolhead,velocity)\"], [\"trapq(toolhead,accel)\"]]'\n"
#~ msgstr ""

#~ msgid ""
#~ "The list of available datasets can be found using the `-l` option - for "
#~ "example:"
#~ msgstr ""

#~ msgid "~/klipper/scripts/motan/motan_graph.py -l\n"
#~ msgstr ""

#~ msgid ""
#~ "It is also possible to specify matplotlib plot options for each dataset:"
#~ msgstr ""

#~ msgid ""
#~ "~/klipper/scripts/motan/motan_graph.py mylog -g "
#~ "'[[\"trapq(toolhead,velocity)?color=red&alpha=0.4\"]]'\n"
#~ msgstr ""

#~ msgid ""
#~ "Many matplotlib options are available; some examples are \"color\", "
#~ "\"label\", \"alpha\", and \"linestyle\"."
#~ msgstr ""

#~ msgid ""
#~ "The `motan_graph.py` tool supports several other command-line options - use "
#~ "the `--help` option to see a list. It may also be convenient to view/modify "
#~ "the [motan_graph.py](../scripts/motan/motan_graph.py) script itself."
#~ msgstr ""

#~ msgid ""
#~ "The raw data logs produced by the `data_logger.py` tool follow the format "
#~ "described in the [API Server](API_Server.md). It may be useful to inspect "
#~ "the data with a Unix command like the following: `gunzip < mylog.json.gz | "
#~ "tr '\\03' '\\n' | less`"
#~ msgstr ""

#~ msgid "Generating load graphs"
#~ msgstr ""

#~ msgid ""
#~ "The Klippy log file (/tmp/klippy.log) stores statistics on bandwidth, micro-"
#~ "controller load, and host buffer load. It can be useful to graph these "
#~ "statistics after a print."
#~ msgstr ""

#~ msgid ""
#~ "To generate a graph, a one time step is necessary to install the "
#~ "\"matplotlib\" package:"
#~ msgstr ""

#~ msgid "Then graphs can be produced with:"
#~ msgstr ""

#~ msgid "~/klipper/scripts/graphstats.py /tmp/klippy.log -o loadgraph.png\n"
#~ msgstr ""

#~ msgid "One can then view the resulting **loadgraph.png** file."
#~ msgstr ""

#~ msgid ""
#~ "Different graphs can be produced. For more information run: "
#~ "`~/klipper/scripts/graphstats.py --help`"
#~ msgstr ""

#~ msgid "Extracting information from the klippy.log file"
#~ msgstr ""

#~ msgid ""
#~ "The Klippy log file (/tmp/klippy.log) also contains debugging information. "
#~ "There is a logextract.py script that may be useful when analyzing a micro-"
#~ "controller shutdown or similar problem. It is typically run with something "
#~ "like:"
#~ msgstr ""

#~ msgid ""
#~ "mkdir work_directory\n"
#~ "cd work_directory\n"
#~ "cp /tmp/klippy.log .\n"
#~ "~/klipper/scripts/logextract.py ./klippy.log\n"
#~ msgstr ""

#~ msgid ""
#~ "The script will extract the printer config file and will extract MCU "
#~ "shutdown information. The information dumps from an MCU shutdown (if "
#~ "present) will be reordered by timestamp to assist in diagnosing cause and "
#~ "effect scenarios."
#~ msgstr ""

#~ msgid "Testing with simulavr"
#~ msgstr ""

#~ msgid ""
#~ "The [simulavr](http://www.nongnu.org/simulavr/) tool enables one to simulate"
#~ " an Atmel ATmega micro-controller. This section describes how one can run "
#~ "test gcode files through simulavr. It is recommended to run this on a "
#~ "desktop class machine (not a Raspberry Pi) as it does require significant "
#~ "cpu to run efficiently."
#~ msgstr ""

#~ msgid ""
#~ "To use simulavr, download the simulavr package and compile with python "
#~ "support. Note that the build system may need to have some packages (such as "
#~ "swig) installed in order to build the python module."
#~ msgstr ""

#~ msgid ""
#~ "git clone git://git.savannah.nongnu.org/simulavr.git\n"
#~ "cd simulavr\n"
#~ "make python\n"
#~ "make build\n"
#~ msgstr ""

#~ msgid ""
#~ "Make sure a file like **./build/pysimulavr/_pysimulavr.*.so** is present "
#~ "after the above compilation:"
#~ msgstr ""

#~ msgid "ls ./build/pysimulavr/_pysimulavr.*.so\n"
#~ msgstr ""

#~ msgid ""
#~ "This commmand should report a specific file (e.g. "
#~ "**./build/pysimulavr/_pysimulavr.cpython-39-x86_64-linux-gnu.so**) and not "
#~ "an error."
#~ msgstr ""

#~ msgid ""
#~ "If you are on a Debian-based system (Debian, Ubuntu, etc.) you can install "
#~ "the following packages and generate *.deb files for system-wide installation"
#~ " of simulavr:"
#~ msgstr ""

#~ msgid ""
#~ "sudo apt update\n"
#~ "sudo apt install g++ make cmake swig rst2pdf help2man texinfo\n"
#~ "make cfgclean python debian\n"
#~ "sudo dpkg -i build/debian/python3-simulavr*.deb\n"
#~ msgstr ""

#~ msgid "To compile Klipper for use in simulavr, run:"
#~ msgstr ""

#~ msgid ""
#~ "cd /path/to/klipper\n"
#~ "make menuconfig\n"
#~ msgstr ""

#~ msgid ""
#~ "and compile the micro-controller software for an AVR atmega644p and select "
#~ "SIMULAVR software emulation support. Then one can compile Klipper (run "
#~ "`make`) and then start the simulation with:"
#~ msgstr ""

#~ msgid ""
#~ "PYTHONPATH=/path/to/simulavr/build/pysimulavr/ ./scripts/avrsim.py "
#~ "out/klipper.elf\n"
#~ msgstr ""

#~ msgid ""
#~ "Note that if you have installed python3-simulavr system-wide, you do not "
#~ "need to set `PYTHONPATH`, and can simply run the simulator as"
#~ msgstr ""

#~ msgid "./scripts/avrsim.py out/klipper.elf\n"
#~ msgstr ""

#~ msgid ""
#~ "Then, with simulavr running in another window, one can run the following to "
#~ "read gcode from a file (eg, \"test.gcode\"), process it with Klippy, and "
#~ "send it to Klipper running in simulavr (see [installation](Installation.md) "
#~ "for the steps necessary to build the python virtual environment):"
#~ msgstr ""

#~ msgid ""
#~ "~/klippy-env/bin/python ./klippy/klippy.py config/generic-simulavr.cfg -i "
#~ "test.gcode -v\n"
#~ msgstr ""

#~ msgid "Using simulavr with gtkwave"
#~ msgstr ""

#~ msgid ""
#~ "One useful feature of simulavr is its ability to create signal wave "
#~ "generation files with the exact timing of events. To do this, follow the "
#~ "directions above, but run avrsim.py with a command-line like the following:"
#~ msgstr ""

#~ msgid ""
#~ "PYTHONPATH=/path/to/simulavr/src/python/ ./scripts/avrsim.py out/klipper.elf"
#~ " -t PORTA.PORT,PORTC.PORT\n"
#~ msgstr ""

#~ msgid ""
#~ "The above would create a file **avrsim.vcd** with information on each change"
#~ " to the GPIOs on PORTA and PORTB. This could then be viewed using gtkwave "
#~ "with:"
#~ msgstr ""

#~ msgid "gtkwave avrsim.vcd\n"
#~ msgstr ""

#~ msgid "Contact"
#~ msgstr ""

#~ msgid "This document provides contact information for Klipper."
#~ msgstr ""

#~ msgid "[Community Forum](#community-forum)"
#~ msgstr ""

#~ msgid "[Discord Chat](#discord-chat)"
#~ msgstr ""

#~ msgid "[I have a question about Klipper](#i-have-a-question-about-klipper)"
#~ msgstr ""

#~ msgid "[I have a feature request](#i-have-a-feature-request)"
#~ msgstr ""

#~ msgid "[Help! It doesn't work!](#help-it-doesnt-work)"
#~ msgstr ""

#~ msgid ""
#~ "[I found a bug in the Klipper software](#i-found-a-bug-in-the-klipper-"
#~ "software)"
#~ msgstr ""

#~ msgid ""
#~ "[I am making changes that I'd like to include in Klipper](#i-am-making-"
#~ "changes-that-id-like-to-include-in-klipper)"
#~ msgstr ""

#~ msgid "[Klipper github](#klipper-github)"
#~ msgstr ""

#~ msgid "Community Forum"
#~ msgstr ""

#~ msgid ""
#~ "There is a [Klipper Community Discourse "
#~ "server](https://community.klipper3d.org) for discussions on Klipper."
#~ msgstr ""

#~ msgid "Discord Chat"
#~ msgstr ""

#~ msgid ""
#~ "There is a Discord server dedicated to Klipper at: "
#~ "<https://discord.klipper3d.org>."
#~ msgstr ""

#~ msgid ""
#~ "This server is run by a community of Klipper enthusiasts dedicated to "
#~ "discussions on Klipper. It allows users to chat with other users in real-"
#~ "time."
#~ msgstr ""

#~ msgid "I have a question about Klipper"
#~ msgstr ""

#~ msgid ""
#~ "Many questions we receive are already answered in the [Klipper "
#~ "documentation](Overview.md). Please be sure to to read the documentation and"
#~ " follow the directions provided there."
#~ msgstr ""

#~ msgid ""
#~ "It is also possible to search for similar questions in the [Klipper "
#~ "Community Forum](#community-forum)."
#~ msgstr ""

#~ msgid ""
#~ "If you are interested in sharing your knowledge and experience with other "
#~ "Klipper users then you can join the [Klipper Community Forum](#community-"
#~ "forum) or [Klipper Discord Chat](#discord-chat). Both are communities where "
#~ "Klipper users can discuss Klipper with other users."
#~ msgstr ""

#~ msgid ""
#~ "Many questions we receive are general 3d-printing questions that are not "
#~ "specific to Klipper. If you have a general question or are experiencing "
#~ "general printing problems, then you will likely get a better response by "
#~ "asking in a general 3d-printing forum or a forum dedicated to your printer "
#~ "hardware."
#~ msgstr ""

#~ msgid "I have a feature request"
#~ msgstr ""

#~ msgid ""
#~ "All new features require someone interested and able to implement that "
#~ "feature. If you are interested in helping to implement or test a new "
#~ "feature, you can search for ongoing developments in the [Klipper Community "
#~ "Forum](#community-forum). There is also [Klipper Discord Chat](#discord-"
#~ "chat) for discussions between collaborators."
#~ msgstr ""

#~ msgid "Help! It doesn't work!"
#~ msgstr ""

#~ msgid ""
#~ "Unfortunately, we receive many more requests for help than we could possibly"
#~ " answer. Most problem reports we see are eventually tracked down to:"
#~ msgstr ""

#~ msgid "Subtle errors in the hardware, or"
#~ msgstr ""

#~ msgid "Not following all the steps described in the Klipper documentation."
#~ msgstr ""

#~ msgid ""
#~ "If you are experiencing problems we recommend you carefully read the "
#~ "[Klipper documentation](Overview.md) and double check that all steps were "
#~ "followed."
#~ msgstr ""

#~ msgid ""
#~ "If you are experiencing a printing problem, then we recommend carefully "
#~ "inspecting the printer hardware (all joints, wires, screws, etc.) and verify"
#~ " nothing is abnormal. We find most printing problems are not related to the "
#~ "Klipper software. If you do find a problem with the printer hardware then "
#~ "you will likely get a better response by searching in a general 3d-printing "
#~ "forum or in a forum dedicated to your printer hardware."
#~ msgstr ""

#~ msgid ""
#~ "It is also possible to search for similar issues in the [Klipper Community "
#~ "Forum](#community-forum)."
#~ msgstr ""

#~ msgid "I found a bug in the Klipper software"
#~ msgstr ""

#~ msgid ""
#~ "Klipper is an open-source project and we appreciate when collaborators "
#~ "diagnose errors in the software."
#~ msgstr ""

#~ msgid ""
#~ "Problems should be reported in the [Klipper Community Forum](#community-"
#~ "forum)."
#~ msgstr ""

#~ msgid ""
#~ "There is important information that will be needed in order to fix a bug. "
#~ "Please follow these steps:"
#~ msgstr ""

#~ msgid ""
#~ "Make sure you are running unmodified code from "
#~ "<https://github.com/Klipper3d/klipper>. If the code has been modified or is "
#~ "obtained from another source, then you should reproduce the problem on the "
#~ "unmodified code from <https://github.com/Klipper3d/klipper> prior to "
#~ "reporting."
#~ msgstr ""

#~ msgid ""
#~ "If possible, run an `M112` command immediately after the undesirable event "
#~ "occurs. This causes Klipper to go into a \"shutdown state\" and it will "
#~ "cause additional debugging information to be written to the log file."
#~ msgstr ""

#~ msgid ""
#~ "Obtain the Klipper log file from the event. The log file has been engineered"
#~ " to answer common questions the Klipper developers have about the software "
#~ "and its environment (software version, hardware type, configuration, event "
#~ "timing, and hundreds of other questions)."
#~ msgstr ""

#~ msgid ""
#~ "The Klipper log file is located in `/tmp/klippy.log` on the Klipper \"host\""
#~ " computer (the Raspberry Pi)."
#~ msgstr ""

#~ msgid ""
#~ "An \"scp\" or \"sftp\" utility is needed to copy this log file to your "
#~ "desktop computer. The \"scp\" utility comes standard with Linux and MacOS "
#~ "desktops. There are freely available scp utilities for other desktops (eg, "
#~ "WinSCP). If using a graphical scp utility that can not directly copy "
#~ "`/tmp/klippy.log` then repeatedly click on `..` or `parent folder` until you"
#~ " get to the root directory, click on the `tmp` folder, and then select the "
#~ "`klippy.log` file."
#~ msgstr ""

#~ msgid ""
#~ "Copy the log file to your desktop so that it can be attached to an issue "
#~ "report."
#~ msgstr ""

#~ msgid ""
#~ "Do not modify the log file in any way; do not provide a snippet of the log. "
#~ "Only the full unmodified log file provides the necessary information."
#~ msgstr ""

#~ msgid "It is a good idea to compress the log file with zip or gzip."
#~ msgstr ""

#~ msgid ""
#~ "Open a new topic on the [Klipper Community Forum](#community-forum) and "
#~ "provide a clear description of the problem. Other Klipper contributors will "
#~ "need to understand what steps were taken, what the desired outcome was, and "
#~ "what outcome actually occurred. The compressed Klipper log file should be "
#~ "attached to that topic."
#~ msgstr ""

#~ msgid "I am making changes that I'd like to include in Klipper"
#~ msgstr ""

#~ msgid "Klipper is open-source software and we appreciate new contributions."
#~ msgstr ""

#~ msgid ""
#~ "New contributions (for both code and documentation) are submitted via Github"
#~ " Pull Requests. See the [CONTRIBUTING document](CONTRIBUTING.md) for "
#~ "important information."
#~ msgstr ""

#~ msgid ""
#~ "There are several [documents for developers](Overview.md#developer-"
#~ "documentation). If you have questions on the code then you can also ask in "
#~ "the [Klipper Community Forum](#community-forum) or on the [Klipper Community"
#~ " Discord](#discord-chat)."
#~ msgstr ""

#~ msgid "Klipper github"
#~ msgstr ""

#~ msgid ""
#~ "Klipper github may be used by contributors to share the status of their work"
#~ " to improve Klipper. It is expected that the person opening a github ticket "
#~ "is actively working on the given task and will be the one performing all the"
#~ " work necessary to accomplish it. The Klipper github is not used for "
#~ "requests, nor to report bugs, nor to ask questions. Use the [Klipper "
#~ "Community Forum](#community-forum) or the [Klipper Community "
#~ "Discord](#discord-chat) instead."
#~ msgstr ""

#~ msgid "Configuration checks"
#~ msgstr ""

#~ msgid ""
#~ "This document provides a list of steps to help confirm the pin settings in "
#~ "the Klipper printer.cfg file. It is a good idea to run through these steps "
#~ "after following the steps in the [installation document](Installation.md)."
#~ msgstr ""

#~ msgid ""
#~ "During this guide, it may be necessary to make changes to the Klipper config"
#~ " file. Be sure to issue a RESTART command after every change to the config "
#~ "file to ensure that the change takes effect (type \"restart\" in the "
#~ "Octoprint terminal tab and then click \"Send\"). It's also a good idea to "
#~ "issue a STATUS command after every RESTART to verify that the config file is"
#~ " successfully loaded."
#~ msgstr ""

#~ msgid "Verify temperature"
#~ msgstr ""

#~ msgid ""
#~ "Start by verifying that temperatures are being properly reported. Navigate "
#~ "to the Octoprint temperature tab."
#~ msgstr ""

#~ msgid "![octoprint-temperature](img/octoprint-temperature.png)"
#~ msgstr ""

#~ msgid ""
#~ "Verify that the temperature of the nozzle and bed (if applicable) are "
#~ "present and not increasing. If it is increasing, remove power from the "
#~ "printer. If the temperatures are not accurate, review the \"sensor_type\" "
#~ "and \"sensor_pin\" settings for the nozzle and/or bed."
#~ msgstr ""

#~ msgid "Verify M112"
#~ msgstr ""

#~ msgid ""
#~ "Navigate to the Octoprint terminal tab and issue an M112 command in the "
#~ "terminal box. This command requests Klipper to go into a \"shutdown\" state."
#~ " It will cause Octoprint to disconnect from Klipper - navigate to the "
#~ "Connection area and click on \"Connect\" to cause Octoprint to reconnect. "
#~ "Then navigate to the Octoprint temperature tab and verify that temperatures "
#~ "continue to update and the temperatures are not increasing. If temperatures "
#~ "are increasing, remove power from the printer."
#~ msgstr ""

#~ msgid ""
#~ "The M112 command causes Klipper to go into a \"shutdown\" state. To clear "
#~ "this state, issue a FIRMWARE_RESTART command in the Octoprint terminal tab."
#~ msgstr ""

#~ msgid "Verify heaters"
#~ msgstr ""

#~ msgid ""
#~ "Navigate to the Octoprint temperature tab and type in 50 followed by enter "
#~ "in the \"Tool\" temperature box. The extruder temperature in the graph "
#~ "should start to increase (within about 30 seconds or so). Then go to the "
#~ "\"Tool\" temperature drop-down box and select \"Off\". After several minutes"
#~ " the temperature should start to return to its initial room temperature "
#~ "value. If the temperature does not increase then verify the \"heater_pin\" "
#~ "setting in the config."
#~ msgstr ""

#~ msgid ""
#~ "If the printer has a heated bed then perform the above test again with the "
#~ "bed."
#~ msgstr ""

#~ msgid "Verify stepper motor enable pin"
#~ msgstr ""

#~ msgid ""
#~ "Verify that all of the printer axes can manually move freely (the stepper "
#~ "motors are disabled). If not, issue an M84 command to disable the motors. If"
#~ " any of the axes still can not move freely, then verify the stepper "
#~ "\"enable_pin\" configuration for the given axis. On most commodity stepper "
#~ "motor drivers, the motor enable pin is \"active low\" and therefore the "
#~ "enable pin should have a \"!\" before the pin (for example, \"enable_pin: "
#~ "!ar38\")."
#~ msgstr ""

#~ msgid "Verify endstops"
#~ msgstr ""

#~ msgid ""
#~ "Manually move all the printer axes so that none of them are in contact with "
#~ "an endstop. Send a QUERY_ENDSTOPS command via the Octoprint terminal tab. It"
#~ " should respond with the current state of all of the configured endstops and"
#~ " they should all report a state of \"open\". For each of the endstops, rerun"
#~ " the QUERY_ENDSTOPS command while manually triggering the endstop. The "
#~ "QUERY_ENDSTOPS command should report the endstop as \"TRIGGERED\"."
#~ msgstr ""

#~ msgid ""
#~ "If the endstop appears inverted (it reports \"open\" when triggered and "
#~ "vice-versa) then add a \"!\" to the pin definition (for example, "
#~ "\"endstop_pin: ^!ar3\"), or remove the \"!\" if there is already one "
#~ "present."
#~ msgstr ""

#~ msgid ""
#~ "If the endstop does not change at all then it generally indicates that the "
#~ "endstop is connected to a different pin. However, it may also require a "
#~ "change to the pullup setting of the pin (the '^' at the start of the "
#~ "endstop_pin name - most printers will use a pullup resistor and the '^' "
#~ "should be present)."
#~ msgstr ""

#~ msgid "Verify stepper motors"
#~ msgstr ""

#~ msgid ""
#~ "Use the STEPPER_BUZZ command to verify the connectivity of each stepper "
#~ "motor. Start by manually positioning the given axis to a midway point and "
#~ "then run `STEPPER_BUZZ STEPPER=stepper_x`. The STEPPER_BUZZ command will "
#~ "cause the given stepper to move one millimeter in a positive direction and "
#~ "then it will return to its starting position. (If the endstop is defined at "
#~ "position_endstop=0 then at the start of each movement the stepper will move "
#~ "away from the endstop.) It will perform this oscillation ten times."
#~ msgstr ""

#~ msgid ""
#~ "If the stepper does not move at all, then verify the \"enable_pin\" and "
#~ "\"step_pin\" settings for the stepper. If the stepper motor moves but does "
#~ "not return to its original position then verify the \"dir_pin\" setting. If "
#~ "the stepper motor oscillates in an incorrect direction, then it generally "
#~ "indicates that the \"dir_pin\" for the axis needs to be inverted. This is "
#~ "done by adding a '!' to the \"dir_pin\" in the printer config file (or "
#~ "removing it if one is already there). If the motor moves significantly more "
#~ "or significantly less than one millimeter then verify the "
#~ "\"rotation_distance\" setting."
#~ msgstr ""

#~ msgid ""
#~ "Run the above test for each stepper motor defined in the config file. (Set "
#~ "the STEPPER parameter of the STEPPER_BUZZ command to the name of the config "
#~ "section that is to be tested.) If there is no filament in the extruder then "
#~ "one can use STEPPER_BUZZ to verify the extruder motor connectivity (use "
#~ "STEPPER=extruder). Otherwise, it's best to test the extruder motor "
#~ "separately (see the next section)."
#~ msgstr ""

#~ msgid ""
#~ "After verifying all endstops and verifying all stepper motors the homing "
#~ "mechanism should be tested. Issue a G28 command to home all axes. Remove "
#~ "power from the printer if it does not home properly. Rerun the endstop and "
#~ "stepper motor verification steps if necessary."
#~ msgstr ""

#~ msgid "Verify extruder motor"
#~ msgstr ""

#~ msgid ""
#~ "To test the extruder motor it will be necessary to heat the extruder to a "
#~ "printing temperature. Navigate to the Octoprint temperature tab and select a"
#~ " target temperature from the temperature drop-down box (or manually enter an"
#~ " appropriate temperature). Wait for the printer to reach the desired "
#~ "temperature. Then navigate to the Octoprint control tab and click the "
#~ "\"Extrude\" button. Verify that the extruder motor turns in the correct "
#~ "direction. If it does not, see the troubleshooting tips in the previous "
#~ "section to confirm the \"enable_pin\", \"step_pin\", and \"dir_pin\" "
#~ "settings for the extruder."
#~ msgstr ""

#~ msgid "Calibrate PID settings"
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports [PID control](https://en.wikipedia.org/wiki/PID_controller)"
#~ " for the extruder and bed heaters. In order to use this control mechanism, "
#~ "it is necessary to calibrate the PID settings on each printer (PID settings "
#~ "found in other firmwares or in the example configuration files often work "
#~ "poorly)."
#~ msgstr ""

#~ msgid ""
#~ "To calibrate the extruder, navigate to the OctoPrint terminal tab and run "
#~ "the PID_CALIBRATE command. For example: `PID_CALIBRATE HEATER=extruder "
#~ "TARGET=170`"
#~ msgstr ""

#~ msgid ""
#~ "At the completion of the tuning test run `SAVE_CONFIG` to update the "
#~ "printer.cfg file the new PID settings."
#~ msgstr ""

#~ msgid ""
#~ "If the printer has a heated bed and it supports being driven by PWM (Pulse "
#~ "Width Modulation) then it is recommended to use PID control for the bed. "
#~ "(When the bed heater is controlled using the PID algorithm it may turn on "
#~ "and off ten times a second, which may not be suitable for heaters using a "
#~ "mechanical switch.) A typical bed PID calibration command is: `PID_CALIBRATE"
#~ " HEATER=heater_bed TARGET=60`"
#~ msgstr ""

#~ msgid "Next steps"
#~ msgstr ""

#~ msgid ""
#~ "This guide is intended to help with basic verification of pin settings in "
#~ "the Klipper configuration file. Be sure to read the [bed "
#~ "leveling](Bed_Level.md) guide. Also see the [Slicers](Slicers.md) document "
#~ "for information on configuring a slicer with Klipper."
#~ msgstr ""

#~ msgid ""
#~ "After one has verified that basic printing works, it is a good idea to "
#~ "consider calibrating [pressure advance](Pressure_Advance.md)."
#~ msgstr ""

#~ msgid ""
#~ "It may be necessary to perform other types of detailed printer calibration -"
#~ " a number of guides are available online to help with this (for example, do "
#~ "a web search for \"3d printer calibration\"). As an example, if you "
#~ "experience the effect called ringing, you may try following [resonance "
#~ "compensation](Resonance_Compensation.md) tuning guide."
#~ msgstr ""

#~ msgid "Configuration reference"
#~ msgstr ""

#~ msgid ""
#~ "This document is a reference for options available in the Klipper config "
#~ "file."
#~ msgstr ""

#~ msgid ""
#~ "The descriptions in this document are formatted so that it is possible to "
#~ "cut-and-paste them into a printer config file. See the [installation "
#~ "document](Installation.md) for information on setting up Klipper and "
#~ "choosing an initial config file."
#~ msgstr ""

#~ msgid "Micro-controller configuration"
#~ msgstr ""

#~ msgid "Format of micro-controller pin names"
#~ msgstr ""

#~ msgid ""
#~ "Many config options require the name of a micro-controller pin. Klipper uses"
#~ " the hardware names for these pins - for example `PA4`."
#~ msgstr ""

#~ msgid ""
#~ "Pin names may be preceded by `!` to indicate that a reverse polarity should "
#~ "be used (eg, trigger on low instead of high)."
#~ msgstr ""

#~ msgid ""
#~ "Input pins may be preceded by `^` to indicate that a hardware pull-up "
#~ "resistor should be enabled for the pin. If the micro-controller supports "
#~ "pull-down resistors then an input pin may alternatively be preceded by `~`."
#~ msgstr ""

#~ msgid ""
#~ "Note, some config sections may \"create\" additional pins. Where this "
#~ "occurs, the config section defining the pins must be listed in the config "
#~ "file before any sections using those pins."
#~ msgstr ""

#~ msgid "[mcu]"
#~ msgstr ""

#~ msgid "Configuration of the primary micro-controller."
#~ msgstr ""

#~ msgid ""
#~ "[mcu]\n"
#~ "serial:\n"
#~ "#   The serial port to connect to the MCU. If unsure (or if it\n"
#~ "#   changes) see the \"Where's my serial port?\" section of the FAQ.\n"
#~ "#   This parameter must be provided when using a serial port.\n"
#~ "#baud: 250000\n"
#~ "#   The baud rate to use. The default is 250000.\n"
#~ "#canbus_uuid:\n"
#~ "#   If using a device connected to a CAN bus then this sets the unique\n"
#~ "#   chip identifier to connect to. This value must be provided when using\n"
#~ "#   CAN bus for communication.\n"
#~ "#canbus_interface:\n"
#~ "#   If using a device connected to a CAN bus then this sets the CAN\n"
#~ "#   network interface to use. The default is 'can0'.\n"
#~ "#restart_method:\n"
#~ "#   This controls the mechanism the host will use to reset the\n"
#~ "#   micro-controller. The choices are 'arduino', 'cheetah', 'rpi_usb',\n"
#~ "#   and 'command'. The 'arduino' method (toggle DTR) is common on\n"
#~ "#   Arduino boards and clones. The 'cheetah' method is a special\n"
#~ "#   method needed for some Fysetc Cheetah boards. The 'rpi_usb' method\n"
#~ "#   is useful on Raspberry Pi boards with micro-controllers powered\n"
#~ "#   over USB - it briefly disables power to all USB ports to\n"
#~ "#   accomplish a micro-controller reset. The 'command' method involves\n"
#~ "#   sending a Klipper command to the micro-controller so that it can\n"
#~ "#   reset itself. The default is 'arduino' if the micro-controller\n"
#~ "#   communicates over a serial port, 'command' otherwise.\n"
#~ msgstr ""

#~ msgid "[mcu my_extra_mcu]"
#~ msgstr ""

#~ msgid ""
#~ "Additional micro-controllers (one may define any number of sections with an "
#~ "\"mcu\" prefix). Additional micro-controllers introduce additional pins that"
#~ " may be configured as heaters, steppers, fans, etc.. For example, if an "
#~ "\"[mcu extra_mcu]\" section is introduced, then pins such as "
#~ "\"extra_mcu:ar9\" may then be used elsewhere in the config (where \"ar9\" is"
#~ " a hardware pin name or alias name on the given mcu)."
#~ msgstr ""

#~ msgid ""
#~ "[mcu my_extra_mcu]\n"
#~ "# See the \"mcu\" section for configuration parameters.\n"
#~ msgstr ""

#~ msgid "Common kinematic settings"
#~ msgstr ""

#~ msgid "[printer]"
#~ msgstr ""

#~ msgid "The printer section controls high level printer settings."
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics:\n"
#~ "#   The type of printer in use. This option may be one of: cartesian,\n"
#~ "#   corexy, corexz, hybrid_corexy, hybrid_corexz, rotary_delta, delta,\n"
#~ "#   deltesian, polar, winch, or none. This parameter must be specified.\n"
#~ "max_velocity:\n"
#~ "#   Maximum velocity (in mm/s) of the toolhead (relative to the\n"
#~ "#   print). This parameter must be specified.\n"
#~ "max_accel:\n"
#~ "#   Maximum acceleration (in mm/s^2) of the toolhead (relative to the\n"
#~ "#   print). This parameter must be specified.\n"
#~ "#max_accel_to_decel:\n"
#~ "#   A pseudo acceleration (in mm/s^2) controlling how fast the\n"
#~ "#   toolhead may go from acceleration to deceleration. It is used to\n"
#~ "#   reduce the top speed of short zig-zag moves (and thus reduce\n"
#~ "#   printer vibration from these moves). The default is half of\n"
#~ "#   max_accel.\n"
#~ "#square_corner_velocity: 5.0\n"
#~ "#   The maximum velocity (in mm/s) that the toolhead may travel a 90\n"
#~ "#   degree corner at. A non-zero value can reduce changes in extruder\n"
#~ "#   flow rates by enabling instantaneous velocity changes of the\n"
#~ "#   toolhead during cornering. This value configures the internal\n"
#~ "#   centripetal velocity cornering algorithm; corners with angles\n"
#~ "#   larger than 90 degrees will have a higher cornering velocity while\n"
#~ "#   corners with angles less than 90 degrees will have a lower\n"
#~ "#   cornering velocity. If this is set to zero then the toolhead will\n"
#~ "#   decelerate to zero at each corner. The default is 5mm/s.\n"
#~ msgstr ""

#~ msgid "[stepper]"
#~ msgstr ""

#~ msgid ""
#~ "Stepper motor definitions. Different printer types (as specified by the "
#~ "\"kinematics\" option in the [printer] config section) require different "
#~ "names for the stepper (eg, `stepper_x` vs `stepper_a`). Below are common "
#~ "stepper definitions."
#~ msgstr ""

#~ msgid ""
#~ "See the [rotation distance document](Rotation_Distance.md) for information "
#~ "on calculating the `rotation_distance` parameter. See the [Multi-MCU "
#~ "homing](Multi_MCU_Homing.md) document for information on homing using "
#~ "multiple micro-controllers."
#~ msgstr ""

#~ msgid ""
#~ "[stepper_x]\n"
#~ "step_pin:\n"
#~ "#   Step GPIO pin (triggered high). This parameter must be provided.\n"
#~ "dir_pin:\n"
#~ "#   Direction GPIO pin (high indicates positive direction). This\n"
#~ "#   parameter must be provided.\n"
#~ "enable_pin:\n"
#~ "#   Enable pin (default is enable high; use ! to indicate enable\n"
#~ "#   low). If this parameter is not provided then the stepper motor\n"
#~ "#   driver must always be enabled.\n"
#~ "rotation_distance:\n"
#~ "#   Distance (in mm) that the axis travels with one full rotation of\n"
#~ "#   the stepper motor (or final gear if gear_ratio is specified).\n"
#~ "#   This parameter must be provided.\n"
#~ "microsteps:\n"
#~ "#   The number of microsteps the stepper motor driver uses. This\n"
#~ "#   parameter must be provided.\n"
#~ "#full_steps_per_rotation: 200\n"
#~ "#   The number of full steps for one rotation of the stepper motor.\n"
#~ "#   Set this to 200 for a 1.8 degree stepper motor or set to 400 for a\n"
#~ "#   0.9 degree motor. The default is 200.\n"
#~ "#gear_ratio:\n"
#~ "#   The gear ratio if the stepper motor is connected to the axis via a\n"
#~ "#   gearbox. For example, one may specify \"5:1\" if a 5 to 1 gearbox is\n"
#~ "#   in use. If the axis has multiple gearboxes one may specify a comma\n"
#~ "#   separated list of gear ratios (for example, \"57:11, 2:1\"). If a\n"
#~ "#   gear_ratio is specified then rotation_distance specifies the\n"
#~ "#   distance the axis travels for one full rotation of the final gear.\n"
#~ "#   The default is to not use a gear ratio.\n"
#~ "#step_pulse_duration:\n"
#~ "#   The minimum time between the step pulse signal edge and the\n"
#~ "#   following \"unstep\" signal edge. This is also used to set the\n"
#~ "#   minimum time between a step pulse and a direction change signal.\n"
#~ "#   The default is 0.000000100 (100ns) for TMC steppers that are\n"
#~ "#   configured in UART or SPI mode, and the default is 0.000002 (which\n"
#~ "#   is 2us) for all other steppers.\n"
#~ "endstop_pin:\n"
#~ "#   Endstop switch detection pin. If this endstop pin is on a\n"
#~ "#   different mcu than the stepper motor then it enables \"multi-mcu\n"
#~ "#   homing\". This parameter must be provided for the X, Y, and Z\n"
#~ "#   steppers on cartesian style printers.\n"
#~ "#position_min: 0\n"
#~ "#   Minimum valid distance (in mm) the user may command the stepper to\n"
#~ "#   move to.  The default is 0mm.\n"
#~ "position_endstop:\n"
#~ "#   Location of the endstop (in mm). This parameter must be provided\n"
#~ "#   for the X, Y, and Z steppers on cartesian style printers.\n"
#~ "position_max:\n"
#~ "#   Maximum valid distance (in mm) the user may command the stepper to\n"
#~ "#   move to. This parameter must be provided for the X, Y, and Z\n"
#~ "#   steppers on cartesian style printers.\n"
#~ "#homing_speed: 5.0\n"
#~ "#   Maximum velocity (in mm/s) of the stepper when homing. The default\n"
#~ "#   is 5mm/s.\n"
#~ "#homing_retract_dist: 5.0\n"
#~ "#   Distance to backoff (in mm) before homing a second time during\n"
#~ "#   homing. Set this to zero to disable the second home. The default\n"
#~ "#   is 5mm.\n"
#~ "#homing_retract_speed:\n"
#~ "#   Speed to use on the retract move after homing in case this should\n"
#~ "#   be different from the homing speed, which is the default for this\n"
#~ "#   parameter\n"
#~ "#second_homing_speed:\n"
#~ "#   Velocity (in mm/s) of the stepper when performing the second home.\n"
#~ "#   The default is homing_speed/2.\n"
#~ "#homing_positive_dir:\n"
#~ "#   If true, homing will cause the stepper to move in a positive\n"
#~ "#   direction (away from zero); if false, home towards zero. It is\n"
#~ "#   better to use the default than to specify this parameter. The\n"
#~ "#   default is true if position_endstop is near position_max and false\n"
#~ "#   if near position_min.\n"
#~ msgstr ""

#~ msgid "Cartesian Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "See [example-cartesian.cfg](../config/example-cartesian.cfg) for an example "
#~ "cartesian kinematics config file."
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to cartesian printers are described here - see "
#~ "[common kinematic settings](#common-kinematic-settings) for available "
#~ "parameters."
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: cartesian\n"
#~ "max_z_velocity:\n"
#~ "#   This sets the maximum velocity (in mm/s) of movement along the z\n"
#~ "#   axis. This setting can be used to restrict the maximum speed of\n"
#~ "#   the z stepper motor. The default is to use max_velocity for\n"
#~ "#   max_z_velocity.\n"
#~ "max_z_accel:\n"
#~ "#   This sets the maximum acceleration (in mm/s^2) of movement along\n"
#~ "#   the z axis. It limits the acceleration of the z stepper motor. The\n"
#~ "#   default is to use max_accel for max_z_accel.\n"
#~ "\n"
#~ "# The stepper_x section is used to describe the stepper controlling\n"
#~ "# the X axis in a cartesian robot.\n"
#~ "[stepper_x]\n"
#~ "\n"
#~ "# The stepper_y section is used to describe the stepper controlling\n"
#~ "# the Y axis in a cartesian robot.\n"
#~ "[stepper_y]\n"
#~ "\n"
#~ "# The stepper_z section is used to describe the stepper controlling\n"
#~ "# the Z axis in a cartesian robot.\n"
#~ "[stepper_z]\n"
#~ msgstr ""

#~ msgid "Linear Delta Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "See [example-delta.cfg](../config/example-delta.cfg) for an example linear "
#~ "delta kinematics config file. See the [delta calibrate "
#~ "guide](Delta_Calibrate.md) for information on calibration."
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to linear delta printers are described here - see "
#~ "[common kinematic settings](#common-kinematic-settings) for available "
#~ "parameters."
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: delta\n"
#~ "max_z_velocity:\n"
#~ "#   For delta printers this limits the maximum velocity (in mm/s) of\n"
#~ "#   moves with z axis movement. This setting can be used to reduce the\n"
#~ "#   maximum speed of up/down moves (which require a higher step rate\n"
#~ "#   than other moves on a delta printer). The default is to use\n"
#~ "#   max_velocity for max_z_velocity.\n"
#~ "#max_z_accel:\n"
#~ "#   This sets the maximum acceleration (in mm/s^2) of movement along\n"
#~ "#   the z axis. Setting this may be useful if the printer can reach higher\n"
#~ "#   acceleration on XY moves than Z moves (eg, when using input shaper).\n"
#~ "#   The default is to use max_accel for max_z_accel.\n"
#~ "#minimum_z_position: 0\n"
#~ "#   The minimum Z position that the user may command the head to move\n"
#~ "#   to. The default is 0.\n"
#~ "delta_radius:\n"
#~ "#   Radius (in mm) of the horizontal circle formed by the three linear\n"
#~ "#   axis towers. This parameter may also be calculated as:\n"
#~ "#    delta_radius = smooth_rod_offset - effector_offset - carriage_offset\n"
#~ "#   This parameter must be provided.\n"
#~ "#print_radius:\n"
#~ "#   The radius (in mm) of valid toolhead XY coordinates. One may use\n"
#~ "#   this setting to customize the range checking of toolhead moves. If\n"
#~ "#   a large value is specified here then it may be possible to command\n"
#~ "#   the toolhead into a collision with a tower. The default is to use\n"
#~ "#   delta_radius for print_radius (which would normally prevent a\n"
#~ "#   tower collision).\n"
#~ "\n"
#~ "# The stepper_a section describes the stepper controlling the front\n"
#~ "# left tower (at 210 degrees). This section also controls the homing\n"
#~ "# parameters (homing_speed, homing_retract_dist) for all towers.\n"
#~ "[stepper_a]\n"
#~ "position_endstop:\n"
#~ "#   Distance (in mm) between the nozzle and the bed when the nozzle is\n"
#~ "#   in the center of the build area and the endstop triggers. This\n"
#~ "#   parameter must be provided for stepper_a; for stepper_b and\n"
#~ "#   stepper_c this parameter defaults to the value specified for\n"
#~ "#   stepper_a.\n"
#~ "arm_length:\n"
#~ "#   Length (in mm) of the diagonal rod that connects this tower to the\n"
#~ "#   print head. This parameter must be provided for stepper_a; for\n"
#~ "#   stepper_b and stepper_c this parameter defaults to the value\n"
#~ "#   specified for stepper_a.\n"
#~ "#angle:\n"
#~ "#   This option specifies the angle (in degrees) that the tower is\n"
#~ "#   at. The default is 210 for stepper_a, 330 for stepper_b, and 90\n"
#~ "#   for stepper_c.\n"
#~ "\n"
#~ "# The stepper_b section describes the stepper controlling the front\n"
#~ "# right tower (at 330 degrees).\n"
#~ "[stepper_b]\n"
#~ "\n"
#~ "# The stepper_c section describes the stepper controlling the rear\n"
#~ "# tower (at 90 degrees).\n"
#~ "[stepper_c]\n"
#~ "\n"
#~ "# The delta_calibrate section enables a DELTA_CALIBRATE extended\n"
#~ "# g-code command that can calibrate the tower endstop positions and\n"
#~ "# angles.\n"
#~ "[delta_calibrate]\n"
#~ "radius:\n"
#~ "#   Radius (in mm) of the area that may be probed. This is the radius\n"
#~ "#   of nozzle coordinates to be probed; if using an automatic probe\n"
#~ "#   with an XY offset then choose a radius small enough so that the\n"
#~ "#   probe always fits over the bed. This parameter must be provided.\n"
#~ "#speed: 50\n"
#~ "#   The speed (in mm/s) of non-probing moves during the calibration.\n"
#~ "#   The default is 50.\n"
#~ "#horizontal_move_z: 5\n"
#~ "#   The height (in mm) that the head should be commanded to move to\n"
#~ "#   just prior to starting a probe operation. The default is 5.\n"
#~ msgstr ""

#~ msgid "Deltesian Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "See [example-deltesian.cfg](../config/example-deltesian.cfg) for an example "
#~ "deltesian kinematics config file."
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to deltesian printers are described here - see "
#~ "[common kinematic settings](#common-kinematic-settings) for available "
#~ "parameters."
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: deltesian\n"
#~ "max_z_velocity:\n"
#~ "#   For deltesian printers, this limits the maximum velocity (in mm/s) of\n"
#~ "#   moves with z axis movement. This setting can be used to reduce the\n"
#~ "#   maximum speed of up/down moves (which require a higher step rate\n"
#~ "#   than other moves on a deltesian printer). The default is to use\n"
#~ "#   max_velocity for max_z_velocity.\n"
#~ "#max_z_accel:\n"
#~ "#   This sets the maximum acceleration (in mm/s^2) of movement along\n"
#~ "#   the z axis. Setting this may be useful if the printer can reach higher\n"
#~ "#   acceleration on XY moves than Z moves (eg, when using input shaper).\n"
#~ "#   The default is to use max_accel for max_z_accel.\n"
#~ "#minimum_z_position: 0\n"
#~ "#   The minimum Z position that the user may command the head to move\n"
#~ "#   to. The default is 0.\n"
#~ "#min_angle: 5\n"
#~ "#   This represents the minimum angle (in degrees) relative to horizontal\n"
#~ "#   that the deltesian arms are allowed to achieve. This parameter is\n"
#~ "#   intended to restrict the arms from becomming completely horizontal,\n"
#~ "#   which would risk accidental inversion of the XZ axis. The default is 5.\n"
#~ "#print_width:\n"
#~ "#   The distance (in mm) of valid toolhead X coordinates. One may use\n"
#~ "#   this setting to customize the range checking of toolhead moves. If\n"
#~ "#   a large value is specified here then it may be possible to command\n"
#~ "#   the toolhead into a collision with a tower. This setting usually\n"
#~ "#   corresponds to bed width (in mm).\n"
#~ "#slow_ratio: 3\n"
#~ "#   The ratio used to limit velocity and acceleration on moves near the\n"
#~ "#   extremes of the X axis. If vertical distance divided by horizontal\n"
#~ "#   distance exceeds the value of slow_ratio, then velocity and\n"
#~ "#   acceleration are limited to half their nominal values. If vertical\n"
#~ "#   distance divided by horizontal distance exceeds twice the value of\n"
#~ "#   the slow_ratio, then velocity and acceleration are limited to one\n"
#~ "#   quarter of their nominal values. The default is 3.\n"
#~ "\n"
#~ "# The stepper_left section is used to describe the stepper controlling\n"
#~ "# the left tower. This section also controls the homing parameters\n"
#~ "# (homing_speed, homing_retract_dist) for all towers.\n"
#~ "[stepper_left]\n"
#~ "position_endstop:\n"
#~ "#   Distance (in mm) between the nozzle and the bed when the nozzle is\n"
#~ "#   in the center of the build area and the endstops are triggered. This\n"
#~ "#   parameter must be provided for stepper_left; for stepper_right this\n"
#~ "#   parameter defaults to the value specified for stepper_left.\n"
#~ "arm_length:\n"
#~ "#   Length (in mm) of the diagonal rod that connects the tower carriage to\n"
#~ "#   the print head. This parameter must be provided for stepper_left; for\n"
#~ "#   stepper_right, this parameter defaults to the value specified for\n"
#~ "#   stepper_left.\n"
#~ "arm_x_length:\n"
#~ "#   Horizontal distance between the print head and the tower when the\n"
#~ "#   printers is homed. This parameter must be provided for stepper_left;\n"
#~ "#   for stepper_right, this parameter defaults to the value specified for\n"
#~ "#   stepper_left.\n"
#~ "\n"
#~ "# The stepper_right section is used to desribe the stepper controlling the\n"
#~ "# right tower.\n"
#~ "[stepper_right]\n"
#~ "\n"
#~ "# The stepper_y section is used to describe the stepper controlling\n"
#~ "# the Y axis in a deltesian robot.\n"
#~ "[stepper_y]\n"
#~ msgstr ""

#~ msgid "CoreXY Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "See [example-corexy.cfg](../config/example-corexy.cfg) for an example corexy"
#~ " (and h-bot) kinematics file."
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to corexy printers are described here - see [common"
#~ " kinematic settings](#common-kinematic-settings) for available parameters."
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: corexy\n"
#~ "max_z_velocity:\n"
#~ "#   This sets the maximum velocity (in mm/s) of movement along the z\n"
#~ "#   axis. This setting can be used to restrict the maximum speed of\n"
#~ "#   the z stepper motor. The default is to use max_velocity for\n"
#~ "#   max_z_velocity.\n"
#~ "max_z_accel:\n"
#~ "#   This sets the maximum acceleration (in mm/s^2) of movement along\n"
#~ "#   the z axis. It limits the acceleration of the z stepper motor. The\n"
#~ "#   default is to use max_accel for max_z_accel.\n"
#~ "\n"
#~ "# The stepper_x section is used to describe the X axis as well as the\n"
#~ "# stepper controlling the X+Y movement.\n"
#~ "[stepper_x]\n"
#~ "\n"
#~ "# The stepper_y section is used to describe the Y axis as well as the\n"
#~ "# stepper controlling the X-Y movement.\n"
#~ "[stepper_y]\n"
#~ "\n"
#~ "# The stepper_z section is used to describe the stepper controlling\n"
#~ "# the Z axis.\n"
#~ "[stepper_z]\n"
#~ msgstr ""

#~ msgid "CoreXZ Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "See [example-corexz.cfg](../config/example-corexz.cfg) for an example corexz"
#~ " kinematics config file."
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to corexz printers are described here - see [common"
#~ " kinematic settings](#common-kinematic-settings) for available parameters."
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: corexz\n"
#~ "max_z_velocity:\n"
#~ "#   This sets the maximum velocity (in mm/s) of movement along the z\n"
#~ "#   axis. The default is to use max_velocity for max_z_velocity.\n"
#~ "max_z_accel:\n"
#~ "#   This sets the maximum acceleration (in mm/s^2) of movement along\n"
#~ "#   the z axis. The default is to use max_accel for max_z_accel.\n"
#~ "\n"
#~ "# The stepper_x section is used to describe the X axis as well as the\n"
#~ "# stepper controlling the X+Z movement.\n"
#~ "[stepper_x]\n"
#~ "\n"
#~ "# The stepper_y section is used to describe the stepper controlling\n"
#~ "# the Y axis.\n"
#~ "[stepper_y]\n"
#~ "\n"
#~ "# The stepper_z section is used to describe the Z axis as well as the\n"
#~ "# stepper controlling the X-Z movement.\n"
#~ "[stepper_z]\n"
#~ msgstr ""

#~ msgid "Hybrid-CoreXY Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "See [example-hybrid-corexy.cfg](../config/example-hybrid-corexy.cfg) for an "
#~ "example hybrid corexy kinematics config file."
#~ msgstr ""

#~ msgid "This kinematic is also known as Markforged kinematic."
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to hybrid corexy printers are described here see "
#~ "[common kinematic settings](#common-kinematic-settings) for available "
#~ "parameters."
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: hybrid_corexy\n"
#~ "max_z_velocity:\n"
#~ "#   This sets the maximum velocity (in mm/s) of movement along the z\n"
#~ "#   axis. The default is to use max_velocity for max_z_velocity.\n"
#~ "max_z_accel:\n"
#~ "#   This sets the maximum acceleration (in mm/s^2) of movement along\n"
#~ "#   the z axis. The default is to use max_accel for max_z_accel.\n"
#~ "\n"
#~ "# The stepper_x section is used to describe the X axis as well as the\n"
#~ "# stepper controlling the X-Y movement.\n"
#~ "[stepper_x]\n"
#~ "\n"
#~ "# The stepper_y section is used to describe the stepper controlling\n"
#~ "# the Y axis.\n"
#~ "[stepper_y]\n"
#~ "\n"
#~ "# The stepper_z section is used to describe the stepper controlling\n"
#~ "# the Z axis.\n"
#~ "[stepper_z]\n"
#~ msgstr ""

#~ msgid "Hybrid-CoreXZ Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "See [example-hybrid-corexz.cfg](../config/example-hybrid-corexz.cfg) for an "
#~ "example hybrid corexz kinematics config file."
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: hybrid_corexz\n"
#~ "max_z_velocity:\n"
#~ "#   This sets the maximum velocity (in mm/s) of movement along the z\n"
#~ "#   axis. The default is to use max_velocity for max_z_velocity.\n"
#~ "max_z_accel:\n"
#~ "#   This sets the maximum acceleration (in mm/s^2) of movement along\n"
#~ "#   the z axis. The default is to use max_accel for max_z_accel.\n"
#~ "\n"
#~ "# The stepper_x section is used to describe the X axis as well as the\n"
#~ "# stepper controlling the X-Z movement.\n"
#~ "[stepper_x]\n"
#~ "\n"
#~ "# The stepper_y section is used to describe the stepper controlling\n"
#~ "# the Y axis.\n"
#~ "[stepper_y]\n"
#~ "\n"
#~ "# The stepper_z section is used to describe the stepper controlling\n"
#~ "# the Z axis.\n"
#~ "[stepper_z]\n"
#~ msgstr ""

#~ msgid "Polar Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "See [example-polar.cfg](../config/example-polar.cfg) for an example polar "
#~ "kinematics config file."
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to polar printers are described here - see [common "
#~ "kinematic settings](#common-kinematic-settings) for available parameters."
#~ msgstr ""

#~ msgid ""
#~ "POLAR KINEMATICS ARE A WORK IN PROGRESS. Moves around the 0, 0 position are "
#~ "known to not work properly."
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: polar\n"
#~ "max_z_velocity:\n"
#~ "#   This sets the maximum velocity (in mm/s) of movement along the z\n"
#~ "#   axis. This setting can be used to restrict the maximum speed of\n"
#~ "#   the z stepper motor. The default is to use max_velocity for\n"
#~ "#   max_z_velocity.\n"
#~ "max_z_accel:\n"
#~ "#   This sets the maximum acceleration (in mm/s^2) of movement along\n"
#~ "#   the z axis. It limits the acceleration of the z stepper motor. The\n"
#~ "#   default is to use max_accel for max_z_accel.\n"
#~ "\n"
#~ "# The stepper_bed section is used to describe the stepper controlling\n"
#~ "# the bed.\n"
#~ "[stepper_bed]\n"
#~ "gear_ratio:\n"
#~ "#   A gear_ratio must be specified and rotation_distance may not be\n"
#~ "#   specified. For example, if the bed has an 80 toothed pulley driven\n"
#~ "#   by a stepper with a 16 toothed pulley then one would specify a\n"
#~ "#   gear ratio of \"80:16\". This parameter must be provided.\n"
#~ "\n"
#~ "# The stepper_arm section is used to describe the stepper controlling\n"
#~ "# the carriage on the arm.\n"
#~ "[stepper_arm]\n"
#~ "\n"
#~ "# The stepper_z section is used to describe the stepper controlling\n"
#~ "# the Z axis.\n"
#~ "[stepper_z]\n"
#~ msgstr ""

#~ msgid "Rotary delta Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "See [example-rotary-delta.cfg](../config/example-rotary-delta.cfg) for an "
#~ "example rotary delta kinematics config file."
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to rotary delta printers are described here - see "
#~ "[common kinematic settings](#common-kinematic-settings) for available "
#~ "parameters."
#~ msgstr ""

#~ msgid ""
#~ "ROTARY DELTA KINEMATICS ARE A WORK IN PROGRESS. Homing moves may timeout and"
#~ " some boundary checks are not implemented."
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: rotary_delta\n"
#~ "max_z_velocity:\n"
#~ "#   For delta printers this limits the maximum velocity (in mm/s) of\n"
#~ "#   moves with z axis movement. This setting can be used to reduce the\n"
#~ "#   maximum speed of up/down moves (which require a higher step rate\n"
#~ "#   than other moves on a delta printer). The default is to use\n"
#~ "#   max_velocity for max_z_velocity.\n"
#~ "#minimum_z_position: 0\n"
#~ "#   The minimum Z position that the user may command the head to move\n"
#~ "#   to.  The default is 0.\n"
#~ "shoulder_radius:\n"
#~ "#   Radius (in mm) of the horizontal circle formed by the three\n"
#~ "#   shoulder joints, minus the radius of the circle formed by the\n"
#~ "#   effector joints. This parameter may also be calculated as:\n"
#~ "#     shoulder_radius = (delta_f - delta_e) / sqrt(12)\n"
#~ "#   This parameter must be provided.\n"
#~ "shoulder_height:\n"
#~ "#   Distance (in mm) of the shoulder joints from the bed, minus the\n"
#~ "#   effector toolhead height. This parameter must be provided.\n"
#~ "\n"
#~ "# The stepper_a section describes the stepper controlling the rear\n"
#~ "# right arm (at 30 degrees). This section also controls the homing\n"
#~ "# parameters (homing_speed, homing_retract_dist) for all arms.\n"
#~ "[stepper_a]\n"
#~ "gear_ratio:\n"
#~ "#   A gear_ratio must be specified and rotation_distance may not be\n"
#~ "#   specified. For example, if the arm has an 80 toothed pulley driven\n"
#~ "#   by a pulley with 16 teeth, which is in turn connected to a 60\n"
#~ "#   toothed pulley driven by a stepper with a 16 toothed pulley, then\n"
#~ "#   one would specify a gear ratio of \"80:16, 60:16\". This parameter\n"
#~ "#   must be provided.\n"
#~ "position_endstop:\n"
#~ "#   Distance (in mm) between the nozzle and the bed when the nozzle is\n"
#~ "#   in the center of the build area and the endstop triggers. This\n"
#~ "#   parameter must be provided for stepper_a; for stepper_b and\n"
#~ "#   stepper_c this parameter defaults to the value specified for\n"
#~ "#   stepper_a.\n"
#~ "upper_arm_length:\n"
#~ "#   Length (in mm) of the arm connecting the \"shoulder joint\" to the\n"
#~ "#   \"elbow joint\". This parameter must be provided for stepper_a; for\n"
#~ "#   stepper_b and stepper_c this parameter defaults to the value\n"
#~ "#   specified for stepper_a.\n"
#~ "lower_arm_length:\n"
#~ "#   Length (in mm) of the arm connecting the \"elbow joint\" to the\n"
#~ "#   \"effector joint\". This parameter must be provided for stepper_a;\n"
#~ "#   for stepper_b and stepper_c this parameter defaults to the value\n"
#~ "#   specified for stepper_a.\n"
#~ "#angle:\n"
#~ "#   This option specifies the angle (in degrees) that the arm is at.\n"
#~ "#   The default is 30 for stepper_a, 150 for stepper_b, and 270 for\n"
#~ "#   stepper_c.\n"
#~ "\n"
#~ "# The stepper_b section describes the stepper controlling the rear\n"
#~ "# left arm (at 150 degrees).\n"
#~ "[stepper_b]\n"
#~ "\n"
#~ "# The stepper_c section describes the stepper controlling the front\n"
#~ "# arm (at 270 degrees).\n"
#~ "[stepper_c]\n"
#~ "\n"
#~ "# The delta_calibrate section enables a DELTA_CALIBRATE extended\n"
#~ "# g-code command that can calibrate the shoulder endstop positions.\n"
#~ "[delta_calibrate]\n"
#~ "radius:\n"
#~ "#   Radius (in mm) of the area that may be probed. This is the radius\n"
#~ "#   of nozzle coordinates to be probed; if using an automatic probe\n"
#~ "#   with an XY offset then choose a radius small enough so that the\n"
#~ "#   probe always fits over the bed. This parameter must be provided.\n"
#~ "#speed: 50\n"
#~ "#   The speed (in mm/s) of non-probing moves during the calibration.\n"
#~ "#   The default is 50.\n"
#~ "#horizontal_move_z: 5\n"
#~ "#   The height (in mm) that the head should be commanded to move to\n"
#~ "#   just prior to starting a probe operation. The default is 5.\n"
#~ msgstr ""

#~ msgid "Cable winch Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "See the [example-winch.cfg](../config/example-winch.cfg) for an example "
#~ "cable winch kinematics config file."
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to cable winch printers are described here - see "
#~ "[common kinematic settings](#common-kinematic-settings) for available "
#~ "parameters."
#~ msgstr ""

#~ msgid ""
#~ "CABLE WINCH SUPPORT IS EXPERIMENTAL. Homing is not implemented on cable "
#~ "winch kinematics. In order to home the printer, manually send movement "
#~ "commands until the toolhead is at 0, 0, 0 and then issue a `G28` command."
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: winch\n"
#~ "\n"
#~ "# The stepper_a section describes the stepper connected to the first\n"
#~ "# cable winch. A minimum of 3 and a maximum of 26 cable winches may be\n"
#~ "# defined (stepper_a to stepper_z) though it is common to define 4.\n"
#~ "[stepper_a]\n"
#~ "rotation_distance:\n"
#~ "#   The rotation_distance is the nominal distance (in mm) the toolhead\n"
#~ "#   moves towards the cable winch for each full rotation of the\n"
#~ "#   stepper motor. This parameter must be provided.\n"
#~ "anchor_x:\n"
#~ "anchor_y:\n"
#~ "anchor_z:\n"
#~ "#   The X, Y, and Z position of the cable winch in cartesian space.\n"
#~ "#   These parameters must be provided.\n"
#~ msgstr ""

#~ msgid "None Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to define a special \"none\" kinematics to disable kinematic "
#~ "support in Klipper. This may be useful for controlling devices that are not "
#~ "typical 3d-printers or for debugging purposes."
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: none\n"
#~ "max_velocity: 1\n"
#~ "max_accel: 1\n"
#~ "#   The max_velocity and max_accel parameters must be defined. The\n"
#~ "#   values are not used for \"none\" kinematics.\n"
#~ msgstr ""

#~ msgid "Common extruder and heated bed support"
#~ msgstr ""

#~ msgid ""
#~ "The extruder section is used to describe the heater parameters for the "
#~ "nozzle hotend along with the stepper controlling the extruder. See the "
#~ "[command reference](G-Codes.md#extruder) for additional information. See the"
#~ " [pressure advance guide](Pressure_Advance.md) for information on tuning "
#~ "pressure advance."
#~ msgstr ""

#~ msgid ""
#~ "[extruder]\n"
#~ "step_pin:\n"
#~ "dir_pin:\n"
#~ "enable_pin:\n"
#~ "microsteps:\n"
#~ "rotation_distance:\n"
#~ "#full_steps_per_rotation:\n"
#~ "#gear_ratio:\n"
#~ "#   See the \"stepper\" section for a description of the above\n"
#~ "#   parameters. If none of the above parameters are specified then no\n"
#~ "#   stepper will be associated with the nozzle hotend (though a\n"
#~ "#   SYNC_EXTRUDER_MOTION command may associate one at run-time).\n"
#~ "nozzle_diameter:\n"
#~ "#   Diameter of the nozzle orifice (in mm). This parameter must be\n"
#~ "#   provided.\n"
#~ "filament_diameter:\n"
#~ "#   The nominal diameter of the raw filament (in mm) as it enters the\n"
#~ "#   extruder. This parameter must be provided.\n"
#~ "#max_extrude_cross_section:\n"
#~ "#   Maximum area (in mm^2) of an extrusion cross section (eg,\n"
#~ "#   extrusion width multiplied by layer height). This setting prevents\n"
#~ "#   excessive amounts of extrusion during relatively small XY moves.\n"
#~ "#   If a move requests an extrusion rate that would exceed this value\n"
#~ "#   it will cause an error to be returned. The default is: 4.0 *\n"
#~ "#   nozzle_diameter^2\n"
#~ "#instantaneous_corner_velocity: 1.000\n"
#~ "#   The maximum instantaneous velocity change (in mm/s) of the\n"
#~ "#   extruder during the junction of two moves. The default is 1mm/s.\n"
#~ "#max_extrude_only_distance: 50.0\n"
#~ "#   Maximum length (in mm of raw filament) that a retraction or\n"
#~ "#   extrude-only move may have. If a retraction or extrude-only move\n"
#~ "#   requests a distance greater than this value it will cause an error\n"
#~ "#   to be returned. The default is 50mm.\n"
#~ "#max_extrude_only_velocity:\n"
#~ "#max_extrude_only_accel:\n"
#~ "#   Maximum velocity (in mm/s) and acceleration (in mm/s^2) of the\n"
#~ "#   extruder motor for retractions and extrude-only moves. These\n"
#~ "#   settings do not have any impact on normal printing moves. If not\n"
#~ "#   specified then they are calculated to match the limit an XY\n"
#~ "#   printing move with a cross section of 4.0*nozzle_diameter^2 would\n"
#~ "#   have.\n"
#~ "#pressure_advance: 0.0\n"
#~ "#   The amount of raw filament to push into the extruder during\n"
#~ "#   extruder acceleration. An equal amount of filament is retracted\n"
#~ "#   during deceleration. It is measured in millimeters per\n"
#~ "#   millimeter/second. The default is 0, which disables pressure\n"
#~ "#   advance.\n"
#~ "#pressure_advance_smooth_time: 0.040\n"
#~ "#   A time range (in seconds) to use when calculating the average\n"
#~ "#   extruder velocity for pressure advance. A larger value results in\n"
#~ "#   smoother extruder movements. This parameter may not exceed 200ms.\n"
#~ "#   This setting only applies if pressure_advance is non-zero. The\n"
#~ "#   default is 0.040 (40 milliseconds).\n"
#~ "#\n"
#~ "# The remaining variables describe the extruder heater.\n"
#~ "heater_pin:\n"
#~ "#   PWM output pin controlling the heater. This parameter must be\n"
#~ "#   provided.\n"
#~ "#max_power: 1.0\n"
#~ "#   The maximum power (expressed as a value from 0.0 to 1.0) that the\n"
#~ "#   heater_pin may be set to. The value 1.0 allows the pin to be set\n"
#~ "#   fully enabled for extended periods, while a value of 0.5 would\n"
#~ "#   allow the pin to be enabled for no more than half the time. This\n"
#~ "#   setting may be used to limit the total power output (over extended\n"
#~ "#   periods) to the heater. The default is 1.0.\n"
#~ "sensor_type:\n"
#~ "#   Type of sensor - common thermistors are \"EPCOS 100K B57560G104F\",\n"
#~ "#   \"ATC Semitec 104GT-2\", \"ATC Semitec 104NT-4-R025H42G\", \"Generic\n"
#~ "#   3950\",\"Honeywell 100K 135-104LAG-J01\", \"NTC 100K MGB18-104F39050L32\",\n"
#~ "#   \"SliceEngineering 450\", and \"TDK NTCG104LH104JT1\". See the\n"
#~ "#   \"Temperature sensors\" section for other sensors. This parameter\n"
#~ "#   must be provided.\n"
#~ "sensor_pin:\n"
#~ "#   Analog input pin connected to the sensor. This parameter must be\n"
#~ "#   provided.\n"
#~ "#pullup_resistor: 4700\n"
#~ "#   The resistance (in ohms) of the pullup attached to the thermistor.\n"
#~ "#   This parameter is only valid when the sensor is a thermistor. The\n"
#~ "#   default is 4700 ohms.\n"
#~ "#smooth_time: 1.0\n"
#~ "#   A time value (in seconds) over which temperature measurements will\n"
#~ "#   be smoothed to reduce the impact of measurement noise. The default\n"
#~ "#   is 1 seconds.\n"
#~ "control:\n"
#~ "#   Control algorithm (either pid or watermark). This parameter must\n"
#~ "#   be provided.\n"
#~ "pid_Kp:\n"
#~ "pid_Ki:\n"
#~ "pid_Kd:\n"
#~ "#   The proportional (pid_Kp), integral (pid_Ki), and derivative\n"
#~ "#   (pid_Kd) settings for the PID feedback control system. Klipper\n"
#~ "#   evaluates the PID settings with the following general formula:\n"
#~ "#     heater_pwm = (Kp*error + Ki*integral(error) - Kd*derivative(error)) / 255\n"
#~ "#   Where \"error\" is \"requested_temperature - measured_temperature\"\n"
#~ "#   and \"heater_pwm\" is the requested heating rate with 0.0 being full\n"
#~ "#   off and 1.0 being full on. Consider using the PID_CALIBRATE\n"
#~ "#   command to obtain these parameters. The pid_Kp, pid_Ki, and pid_Kd\n"
#~ "#   parameters must be provided for PID heaters.\n"
#~ "#max_delta: 2.0\n"
#~ "#   On 'watermark' controlled heaters this is the number of degrees in\n"
#~ "#   Celsius above the target temperature before disabling the heater\n"
#~ "#   as well as the number of degrees below the target before\n"
#~ "#   re-enabling the heater. The default is 2 degrees Celsius.\n"
#~ "#pwm_cycle_time: 0.100\n"
#~ "#   Time in seconds for each software PWM cycle of the heater. It is\n"
#~ "#   not recommended to set this unless there is an electrical\n"
#~ "#   requirement to switch the heater faster than 10 times a second.\n"
#~ "#   The default is 0.100 seconds.\n"
#~ "#min_extrude_temp: 170\n"
#~ "#   The minimum temperature (in Celsius) at which extruder move\n"
#~ "#   commands may be issued. The default is 170 Celsius.\n"
#~ "min_temp:\n"
#~ "max_temp:\n"
#~ "#   The maximum range of valid temperatures (in Celsius) that the\n"
#~ "#   heater must remain within. This controls a safety feature\n"
#~ "#   implemented in the micro-controller code - should the measured\n"
#~ "#   temperature ever fall outside this range then the micro-controller\n"
#~ "#   will go into a shutdown state. This check can help detect some\n"
#~ "#   heater and sensor hardware failures. Set this range just wide\n"
#~ "#   enough so that reasonable temperatures do not result in an error.\n"
#~ "#   These parameters must be provided.\n"
#~ msgstr ""

#~ msgid "[heater_bed]"
#~ msgstr ""

#~ msgid ""
#~ "The heater_bed section describes a heated bed. It uses the same heater "
#~ "settings described in the \"extruder\" section."
#~ msgstr ""

#~ msgid ""
#~ "[heater_bed]\n"
#~ "heater_pin:\n"
#~ "sensor_type:\n"
#~ "sensor_pin:\n"
#~ "control:\n"
#~ "min_temp:\n"
#~ "max_temp:\n"
#~ "#   See the \"extruder\" section for a description of the above parameters.\n"
#~ msgstr ""

#~ msgid "Bed level support"
#~ msgstr ""

#~ msgid ""
#~ "Mesh Bed Leveling. One may define a bed_mesh config section to enable move "
#~ "transformations that offset the z axis based on a mesh generated from probed"
#~ " points. When using a probe to home the z-axis, it is recommended to define "
#~ "a safe_z_home section in printer.cfg to home toward the center of the print "
#~ "area."
#~ msgstr ""

#~ msgid ""
#~ "See the [bed mesh guide](Bed_Mesh.md) and [command "
#~ "reference](G-Codes.md#bed_mesh) for additional information."
#~ msgstr ""

#~ msgid "Visual Examples:"
#~ msgstr ""

#~ msgid ""
#~ " rectangular bed, probe_count = 3, 3:\n"
#~ "             x---x---x (max_point)\n"
#~ "             |\n"
#~ "             x---x---x\n"
#~ "                     |\n"
#~ " (min_point) x---x---x\n"
#~ "\n"
#~ " round bed, round_probe_count = 5, bed_radius = r:\n"
#~ "                 x (0, r) end\n"
#~ "               /\n"
#~ "             x---x---x\n"
#~ "                       \\\n"
#~ " (-r, 0) x---x---x---x---x (r, 0)\n"
#~ "           \\\n"
#~ "             x---x---x\n"
#~ "                   /\n"
#~ "                 x  (0, -r) start\n"
#~ msgstr ""

#~ msgid ""
#~ "[bed_mesh]\n"
#~ "#speed: 50\n"
#~ "#   The speed (in mm/s) of non-probing moves during the calibration.\n"
#~ "#   The default is 50.\n"
#~ "#horizontal_move_z: 5\n"
#~ "#   The height (in mm) that the head should be commanded to move to\n"
#~ "#   just prior to starting a probe operation. The default is 5.\n"
#~ "#mesh_radius:\n"
#~ "#   Defines the radius of the mesh to probe for round beds. Note that\n"
#~ "#   the radius is relative to the coordinate specified by the\n"
#~ "#   mesh_origin option. This parameter must be provided for round beds\n"
#~ "#   and omitted for rectangular beds.\n"
#~ "#mesh_origin:\n"
#~ "#   Defines the center X, Y coordinate of the mesh for round beds. This\n"
#~ "#   coordinate is relative to the probe's location. It may be useful\n"
#~ "#   to adjust the mesh_origin in an effort to maximize the size of the\n"
#~ "#   mesh radius. Default is 0, 0. This parameter must be omitted for\n"
#~ "#   rectangular beds.\n"
#~ "#mesh_min:\n"
#~ "#   Defines the minimum X, Y coordinate of the mesh for rectangular\n"
#~ "#   beds. This coordinate is relative to the probe's location. This\n"
#~ "#   will be the first point probed, nearest to the origin. This\n"
#~ "#   parameter must be provided for rectangular beds.\n"
#~ "#mesh_max:\n"
#~ "#   Defines the maximum X, Y coordinate of the mesh for rectangular\n"
#~ "#   beds. Adheres to the same principle as mesh_min, however this will\n"
#~ "#   be the furthest point probed from the bed's origin. This parameter\n"
#~ "#   must be provided for rectangular beds.\n"
#~ "#probe_count: 3, 3\n"
#~ "#   For rectangular beds, this is a comma separate pair of integer\n"
#~ "#   values X, Y defining the number of points to probe along each\n"
#~ "#   axis. A single value is also valid, in which case that value will\n"
#~ "#   be applied to both axes. Default is 3, 3.\n"
#~ "#round_probe_count: 5\n"
#~ "#   For round beds, this integer value defines the maximum number of\n"
#~ "#   points to probe along each axis. This value must be an odd number.\n"
#~ "#   Default is 5.\n"
#~ "#fade_start: 1.0\n"
#~ "#   The gcode z position in which to start phasing out z-adjustment\n"
#~ "#   when fade is enabled. Default is 1.0.\n"
#~ "#fade_end: 0.0\n"
#~ "#   The gcode z position in which phasing out completes. When set to a\n"
#~ "#   value below fade_start, fade is disabled. It should be noted that\n"
#~ "#   fade may add unwanted scaling along the z-axis of a print. If a\n"
#~ "#   user wishes to enable fade, a value of 10.0 is recommended.\n"
#~ "#   Default is 0.0, which disables fade.\n"
#~ "#fade_target:\n"
#~ "#   The z position in which fade should converge. When this value is\n"
#~ "#   set to a non-zero value it must be within the range of z-values in\n"
#~ "#   the mesh. Users that wish to converge to the z homing position\n"
#~ "#   should set this to 0. Default is the average z value of the mesh.\n"
#~ "#split_delta_z: .025\n"
#~ "#   The amount of Z difference (in mm) along a move that will trigger\n"
#~ "#   a split. Default is .025.\n"
#~ "#move_check_distance: 5.0\n"
#~ "#   The distance (in mm) along a move to check for split_delta_z.\n"
#~ "#   This is also the minimum length that a move can be split. Default\n"
#~ "#   is 5.0.\n"
#~ "#mesh_pps: 2, 2\n"
#~ "#   A comma separated pair of integers X, Y defining the number of\n"
#~ "#   points per segment to interpolate in the mesh along each axis. A\n"
#~ "#   \"segment\" can be defined as the space between each probed point.\n"
#~ "#   The user may enter a single value which will be applied to both\n"
#~ "#   axes. Default is 2, 2.\n"
#~ "#algorithm: lagrange\n"
#~ "#   The interpolation algorithm to use. May be either \"lagrange\" or\n"
#~ "#   \"bicubic\". This option will not affect 3x3 grids, which are forced\n"
#~ "#   to use lagrange sampling. Default is lagrange.\n"
#~ "#bicubic_tension: .2\n"
#~ "#   When using the bicubic algorithm the tension parameter above may\n"
#~ "#   be applied to change the amount of slope interpolated. Larger\n"
#~ "#   numbers will increase the amount of slope, which results in more\n"
#~ "#   curvature in the mesh. Default is .2.\n"
#~ "#relative_reference_index:\n"
#~ "#   A point index in the mesh to reference all z values to. Enabling\n"
#~ "#   this parameter produces a mesh relative to the probed z position\n"
#~ "#   at the provided index.\n"
#~ "#faulty_region_1_min:\n"
#~ "#faulty_region_1_max:\n"
#~ "#   Optional points that define a faulty region.  See docs/Bed_Mesh.md\n"
#~ "#   for details on faulty regions.  Up to 99 faulty regions may be added.\n"
#~ "#   By default no faulty regions are set.\n"
#~ msgstr ""

#~ msgid ""
#~ "Bed tilt compensation. One may define a bed_tilt config section to enable "
#~ "move transformations that account for a tilted bed. Note that bed_mesh and "
#~ "bed_tilt are incompatible; both cannot be defined."
#~ msgstr ""

#~ msgid ""
#~ "See the [command reference](G-Codes.md#bed_tilt) for additional information."
#~ msgstr ""

#~ msgid ""
#~ "[bed_tilt]\n"
#~ "#x_adjust: 0\n"
#~ "#   The amount to add to each move's Z height for each mm on the X\n"
#~ "#   axis. The default is 0.\n"
#~ "#y_adjust: 0\n"
#~ "#   The amount to add to each move's Z height for each mm on the Y\n"
#~ "#   axis. The default is 0.\n"
#~ "#z_adjust: 0\n"
#~ "#   The amount to add to the Z height when the nozzle is nominally at\n"
#~ "#   0, 0. The default is 0.\n"
#~ "# The remaining parameters control a BED_TILT_CALIBRATE extended\n"
#~ "# g-code command that may be used to calibrate appropriate x and y\n"
#~ "# adjustment parameters.\n"
#~ "#points:\n"
#~ "#   A list of X, Y coordinates (one per line; subsequent lines\n"
#~ "#   indented) that should be probed during a BED_TILT_CALIBRATE\n"
#~ "#   command. Specify coordinates of the nozzle and be sure the probe\n"
#~ "#   is above the bed at the given nozzle coordinates. The default is\n"
#~ "#   to not enable the command.\n"
#~ "#speed: 50\n"
#~ "#   The speed (in mm/s) of non-probing moves during the calibration.\n"
#~ "#   The default is 50.\n"
#~ "#horizontal_move_z: 5\n"
#~ "#   The height (in mm) that the head should be commanded to move to\n"
#~ "#   just prior to starting a probe operation. The default is 5.\n"
#~ msgstr ""

#~ msgid ""
#~ "Tool to help adjust bed leveling screws. One may define a [bed_screws] "
#~ "config section to enable a BED_SCREWS_ADJUST g-code command."
#~ msgstr ""

#~ msgid ""
#~ "See the [leveling guide](Manual_Level.md#adjusting-bed-leveling-screws) and "
#~ "[command reference](G-Codes.md#bed_screws) for additional information."
#~ msgstr ""

#~ msgid ""
#~ "[bed_screws]\n"
#~ "#screw1:\n"
#~ "#   The X, Y coordinate of the first bed leveling screw. This is a\n"
#~ "#   position to command the nozzle to that is directly above the bed\n"
#~ "#   screw (or as close as possible while still being above the bed).\n"
#~ "#   This parameter must be provided.\n"
#~ "#screw1_name:\n"
#~ "#   An arbitrary name for the given screw. This name is displayed when\n"
#~ "#   the helper script runs. The default is to use a name based upon\n"
#~ "#   the screw XY location.\n"
#~ "#screw1_fine_adjust:\n"
#~ "#   An X, Y coordinate to command the nozzle to so that one can fine\n"
#~ "#   tune the bed leveling screw. The default is to not perform fine\n"
#~ "#   adjustments on the bed screw.\n"
#~ "#screw2:\n"
#~ "#screw2_name:\n"
#~ "#screw2_fine_adjust:\n"
#~ "#...\n"
#~ "#   Additional bed leveling screws. At least three screws must be\n"
#~ "#   defined.\n"
#~ "#horizontal_move_z: 5\n"
#~ "#   The height (in mm) that the head should be commanded to move to\n"
#~ "#   when moving from one screw location to the next. The default is 5.\n"
#~ "#probe_height: 0\n"
#~ "#   The height of the probe (in mm) after adjusting for the thermal\n"
#~ "#   expansion of bed and nozzle. The default is zero.\n"
#~ "#speed: 50\n"
#~ "#   The speed (in mm/s) of non-probing moves during the calibration.\n"
#~ "#   The default is 50.\n"
#~ "#probe_speed: 5\n"
#~ "#   The speed (in mm/s) when moving from a horizontal_move_z position\n"
#~ "#   to a probe_height position. The default is 5.\n"
#~ msgstr ""

#~ msgid ""
#~ "Tool to help adjust bed screws tilt using Z probe. One may define a "
#~ "screws_tilt_adjust config section to enable a SCREWS_TILT_CALCULATE g-code "
#~ "command."
#~ msgstr ""

#~ msgid ""
#~ "See the [leveling guide](Manual_Level.md#adjusting-bed-leveling-screws-"
#~ "using-the-bed-probe) and [command reference](G-Codes.md#screws_tilt_adjust) "
#~ "for additional information."
#~ msgstr ""

#~ msgid ""
#~ "[screws_tilt_adjust]\n"
#~ "#screw1:\n"
#~ "#   The (X, Y) coordinate of the first bed leveling screw. This is a\n"
#~ "#   position to command the nozzle to so that the probe is directly\n"
#~ "#   above the bed screw (or as close as possible while still being\n"
#~ "#   above the bed). This is the base screw used in calculations. This\n"
#~ "#   parameter must be provided.\n"
#~ "#screw1_name:\n"
#~ "#   An arbitrary name for the given screw. This name is displayed when\n"
#~ "#   the helper script runs. The default is to use a name based upon\n"
#~ "#   the screw XY location.\n"
#~ "#screw2:\n"
#~ "#screw2_name:\n"
#~ "#...\n"
#~ "#   Additional bed leveling screws. At least two screws must be\n"
#~ "#   defined.\n"
#~ "#speed: 50\n"
#~ "#   The speed (in mm/s) of non-probing moves during the calibration.\n"
#~ "#   The default is 50.\n"
#~ "#horizontal_move_z: 5\n"
#~ "#   The height (in mm) that the head should be commanded to move to\n"
#~ "#   just prior to starting a probe operation. The default is 5.\n"
#~ "#screw_thread: CW-M3\n"
#~ "#   The type of screw used for bed level, M3, M4 or M5 and the\n"
#~ "#   direction of the knob used to level the bed, clockwise decrease\n"
#~ "#   counter-clockwise decrease.\n"
#~ "#   Accepted values: CW-M3, CCW-M3, CW-M4, CCW-M4, CW-M5, CCW-M5.\n"
#~ "#   Default value is CW-M3, most printers use an M3 screw and\n"
#~ "#   turning the knob clockwise decrease distance.\n"
#~ msgstr ""

#~ msgid ""
#~ "Multiple Z stepper tilt adjustment. This feature enables independent "
#~ "adjustment of multiple z steppers (see the \"stepper_z1\" section) to adjust"
#~ " for tilt. If this section is present then a Z_TILT_ADJUST extended [G-Code "
#~ "command](G-Codes.md#z_tilt) becomes available."
#~ msgstr ""

#~ msgid ""
#~ "[z_tilt]\n"
#~ "#z_positions:\n"
#~ "#   A list of X, Y coordinates (one per line; subsequent lines\n"
#~ "#   indented) describing the location of each bed \"pivot point\". The\n"
#~ "#   \"pivot point\" is the point where the bed attaches to the given Z\n"
#~ "#   stepper. It is described using nozzle coordinates (the X, Y position\n"
#~ "#   of the nozzle if it could move directly above the point). The\n"
#~ "#   first entry corresponds to stepper_z, the second to stepper_z1,\n"
#~ "#   the third to stepper_z2, etc. This parameter must be provided.\n"
#~ "#points:\n"
#~ "#   A list of X, Y coordinates (one per line; subsequent lines\n"
#~ "#   indented) that should be probed during a Z_TILT_ADJUST command.\n"
#~ "#   Specify coordinates of the nozzle and be sure the probe is above\n"
#~ "#   the bed at the given nozzle coordinates. This parameter must be\n"
#~ "#   provided.\n"
#~ "#speed: 50\n"
#~ "#   The speed (in mm/s) of non-probing moves during the calibration.\n"
#~ "#   The default is 50.\n"
#~ "#horizontal_move_z: 5\n"
#~ "#   The height (in mm) that the head should be commanded to move to\n"
#~ "#   just prior to starting a probe operation. The default is 5.\n"
#~ "#retries: 0\n"
#~ "#   Number of times to retry if the probed points aren't within\n"
#~ "#   tolerance.\n"
#~ "#retry_tolerance: 0\n"
#~ "#   If retries are enabled then retry if largest and smallest probed\n"
#~ "#   points differ more than retry_tolerance. Note the smallest unit of\n"
#~ "#   change here would be a single step. However if you are probing\n"
#~ "#   more points than steppers then you will likely have a fixed\n"
#~ "#   minimum value for the range of probed points which you can learn\n"
#~ "#   by observing command output.\n"
#~ msgstr ""

#~ msgid "[quad_gantry_level]"
#~ msgstr ""

#~ msgid ""
#~ "Moving gantry leveling using 4 independently controlled Z motors. Corrects "
#~ "hyperbolic parabola effects (potato chip) on moving gantry which is more "
#~ "flexible. WARNING: Using this on a moving bed may lead to undesirable "
#~ "results. If this section is present then a QUAD_GANTRY_LEVEL extended G-Code"
#~ " command becomes available. This routine assumes the following Z motor "
#~ "configuration:"
#~ msgstr ""

#~ msgid ""
#~ " ----------------\n"
#~ " |Z1          Z2|\n"
#~ " |  ---------   |\n"
#~ " |  |       |   |\n"
#~ " |  |       |   |\n"
#~ " |  x--------   |\n"
#~ " |Z           Z3|\n"
#~ " ----------------\n"
#~ msgstr ""

#~ msgid "Where x is the 0, 0 point on the bed"
#~ msgstr ""

#~ msgid ""
#~ "[quad_gantry_level]\n"
#~ "#gantry_corners:\n"
#~ "#   A newline separated list of X, Y coordinates describing the two\n"
#~ "#   opposing corners of the gantry. The first entry corresponds to Z,\n"
#~ "#   the second to Z2. This parameter must be provided.\n"
#~ "#points:\n"
#~ "#   A newline separated list of four X, Y points that should be probed\n"
#~ "#   during a QUAD_GANTRY_LEVEL command. Order of the locations is\n"
#~ "#   important, and should correspond to Z, Z1, Z2, and Z3 location in\n"
#~ "#   order. This parameter must be provided. For maximum accuracy,\n"
#~ "#   ensure your probe offsets are configured.\n"
#~ "#speed: 50\n"
#~ "#   The speed (in mm/s) of non-probing moves during the calibration.\n"
#~ "#   The default is 50.\n"
#~ "#horizontal_move_z: 5\n"
#~ "#   The height (in mm) that the head should be commanded to move to\n"
#~ "#   just prior to starting a probe operation. The default is 5.\n"
#~ "#max_adjust: 4\n"
#~ "#   Safety limit if an adjustment greater than this value is requested\n"
#~ "#   quad_gantry_level will abort.\n"
#~ "#retries: 0\n"
#~ "#   Number of times to retry if the probed points aren't within\n"
#~ "#   tolerance.\n"
#~ "#retry_tolerance: 0\n"
#~ "#   If retries are enabled then retry if largest and smallest probed\n"
#~ "#   points differ more than retry_tolerance.\n"
#~ msgstr ""

#~ msgid ""
#~ "Printer Skew Correction. It is possible to use software to correct printer "
#~ "skew across 3 planes, xy, xz, yz. This is done by printing a calibration "
#~ "model along a plane and measuring three lengths. Due to the nature of skew "
#~ "correction these lengths are set via gcode. See [Skew "
#~ "Correction](Skew_Correction.md) and [Command "
#~ "Reference](G-Codes.md#skew_correction) for details."
#~ msgstr ""

#~ msgid "[skew_correction]\n"
#~ msgstr ""

#~ msgid ""
#~ "Temperature-dependant toolhead Z position adjustment. Compensate for "
#~ "vertical toolhead movement caused by thermal expansion of the printer's "
#~ "frame in real-time using a temperature sensor (typically coupled to a "
#~ "vertical section of frame)."
#~ msgstr ""

#~ msgid "See also: [extended g-code commands](G-Codes.md#z_thermal_adjust)."
#~ msgstr ""

#~ msgid ""
#~ "[z_thermal_adjust]\n"
#~ "#temp_coeff:\n"
#~ "#   The temperature coefficient of expansion, in mm/degC. For example, a\n"
#~ "#   temp_coeff of 0.01 mm/degC will move the Z axis downwards by 0.01 mm for\n"
#~ "#   every degree Celsius that the temperature sensor increases. Defaults to\n"
#~ "#   0.0 mm/degC, which applies no adjustment.\n"
#~ "#smooth_time:\n"
#~ "#   Smoothing window applied to the temperature sensor, in seconds. Can reduce\n"
#~ "#   motor noise from excessive small corrections in response to sensor noise.\n"
#~ "#   The default is 2.0 seconds.\n"
#~ "#z_adjust_off_above:\n"
#~ "#   Disables adjustments above this Z height [mm]. The last computed correction\n"
#~ "#   will remain applied until the toolhead moves below the specified Z height\n"
#~ "#   again. The default is 99999999.0 mm (always on).\n"
#~ "#max_z_adjustment:\n"
#~ "#   Maximum absolute adjustment that can be applied to the Z axis [mm]. The\n"
#~ "#   default is 99999999.0 mm (unlimited).\n"
#~ "#sensor_type:\n"
#~ "#sensor_pin:\n"
#~ "#min_temp:\n"
#~ "#max_temp:\n"
#~ "#   Temperature sensor configuration.\n"
#~ "#   See the \"extruder\" section for the definition of the above\n"
#~ "#   parameters.\n"
#~ "#gcode_id:\n"
#~ "#   See the \"heater_generic\" section for the definition of this\n"
#~ "#   parameter.\n"
#~ msgstr ""

#~ msgid "Customized homing"
#~ msgstr ""

#~ msgid "[safe_z_home]"
#~ msgstr ""

#~ msgid ""
#~ "Safe Z homing. One may use this mechanism to home the Z axis at a specific "
#~ "X, Y coordinate. This is useful if the toolhead, for example has to move to "
#~ "the center of the bed before Z can be homed."
#~ msgstr ""

#~ msgid ""
#~ "[safe_z_home]\n"
#~ "home_xy_position:\n"
#~ "#   A X, Y coordinate (e.g. 100, 100) where the Z homing should be\n"
#~ "#   performed. This parameter must be provided.\n"
#~ "#speed: 50.0\n"
#~ "#   Speed at which the toolhead is moved to the safe Z home\n"
#~ "#   coordinate. The default is 50 mm/s\n"
#~ "#z_hop:\n"
#~ "#   Distance (in mm) to lift the Z axis prior to homing. This is\n"
#~ "#   applied to any homing command, even if it doesn't home the Z axis.\n"
#~ "#   If the Z axis is already homed and the current Z position is less\n"
#~ "#   than z_hop, then this will lift the head to a height of z_hop. If\n"
#~ "#   the Z axis is not already homed the head is lifted by z_hop.\n"
#~ "#   The default is to not implement Z hop.\n"
#~ "#z_hop_speed: 15.0\n"
#~ "#   Speed (in mm/s) at which the Z axis is lifted prior to homing. The\n"
#~ "#   default is 15 mm/s.\n"
#~ "#move_to_previous: False\n"
#~ "#   When set to True, the X and Y axes are reset to their previous\n"
#~ "#   positions after Z axis homing. The default is False.\n"
#~ msgstr ""

#~ msgid "[homing_override]"
#~ msgstr ""

#~ msgid ""
#~ "Homing override. One may use this mechanism to run a series of g-code "
#~ "commands in place of a G28 found in the normal g-code input. This may be "
#~ "useful on printers that require a specific procedure to home the machine."
#~ msgstr ""

#~ msgid ""
#~ "[homing_override]\n"
#~ "gcode:\n"
#~ "#   A list of G-Code commands to execute in place of G28 commands\n"
#~ "#   found in the normal g-code input. See docs/Command_Templates.md\n"
#~ "#   for G-Code format. If a G28 is contained in this list of commands\n"
#~ "#   then it will invoke the normal homing procedure for the printer.\n"
#~ "#   The commands listed here must home all axes. This parameter must\n"
#~ "#   be provided.\n"
#~ "#axes: xyz\n"
#~ "#   The axes to override. For example, if this is set to \"z\" then the\n"
#~ "#   override script will only be run when the z axis is homed (eg, via\n"
#~ "#   a \"G28\" or \"G28 Z0\" command). Note, the override script should\n"
#~ "#   still home all axes. The default is \"xyz\" which causes the\n"
#~ "#   override script to be run in place of all G28 commands.\n"
#~ "#set_position_x:\n"
#~ "#set_position_y:\n"
#~ "#set_position_z:\n"
#~ "#   If specified, the printer will assume the axis is at the specified\n"
#~ "#   position prior to running the above g-code commands. Setting this\n"
#~ "#   disables homing checks for that axis. This may be useful if the\n"
#~ "#   head must move prior to invoking the normal G28 mechanism for an\n"
#~ "#   axis. The default is to not force a position for an axis.\n"
#~ msgstr ""

#~ msgid ""
#~ "Stepper phase adjusted endstops. To use this feature, define a config "
#~ "section with an \"endstop_phase\" prefix followed by the name of the "
#~ "corresponding stepper config section (for example, \"[endstop_phase "
#~ "stepper_z]\"). This feature can improve the accuracy of endstop switches. "
#~ "Add a bare \"[endstop_phase]\" declaration to enable the "
#~ "ENDSTOP_PHASE_CALIBRATE command."
#~ msgstr ""

#~ msgid ""
#~ "See the [endstop phases guide](Endstop_Phase.md) and [command "
#~ "reference](G-Codes.md#endstop_phase) for additional information."
#~ msgstr ""

#~ msgid ""
#~ "[endstop_phase stepper_z]\n"
#~ "#endstop_accuracy:\n"
#~ "#   Sets the expected accuracy (in mm) of the endstop. This represents\n"
#~ "#   the maximum error distance the endstop may trigger (eg, if an\n"
#~ "#   endstop may occasionally trigger 100um early or up to 100um late\n"
#~ "#   then set this to 0.200 for 200um). The default is\n"
#~ "#   4*rotation_distance/full_steps_per_rotation.\n"
#~ "#trigger_phase:\n"
#~ "#   This specifies the phase of the stepper motor driver to expect\n"
#~ "#   when hitting the endstop. It is composed of two numbers separated\n"
#~ "#   by a forward slash character - the phase and the total number of\n"
#~ "#   phases (eg, \"7/64\"). Only set this value if one is sure the\n"
#~ "#   stepper motor driver is reset every time the mcu is reset. If this\n"
#~ "#   is not set, then the stepper phase will be detected on the first\n"
#~ "#   home and that phase will be used on all subsequent homes.\n"
#~ "#endstop_align_zero: False\n"
#~ "#   If true then the position_endstop of the axis will effectively be\n"
#~ "#   modified so that the zero position for the axis occurs at a full\n"
#~ "#   step on the stepper motor. (If used on the Z axis and the print\n"
#~ "#   layer height is a multiple of a full step distance then every\n"
#~ "#   layer will occur on a full step.) The default is False.\n"
#~ msgstr ""

#~ msgid "G-Code macros and events"
#~ msgstr ""

#~ msgid ""
#~ "G-Code macros (one may define any number of sections with a \"gcode_macro\" "
#~ "prefix). See the [command template guide](Command_Templates.md) for more "
#~ "information."
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro my_cmd]\n"
#~ "#gcode:\n"
#~ "#   A list of G-Code commands to execute in place of \"my_cmd\". See\n"
#~ "#   docs/Command_Templates.md for G-Code format. This parameter must\n"
#~ "#   be provided.\n"
#~ "#variable_<name>:\n"
#~ "#   One may specify any number of options with a \"variable_\" prefix.\n"
#~ "#   The given variable name will be assigned the given value (parsed\n"
#~ "#   as a Python literal) and will be available during macro expansion.\n"
#~ "#   For example, a config with \"variable_fan_speed = 75\" might have\n"
#~ "#   gcode commands containing \"M106 S{ fan_speed * 255 }\". Variables\n"
#~ "#   can be changed at run-time using the SET_GCODE_VARIABLE command\n"
#~ "#   (see docs/Command_Templates.md for details). Variable names may\n"
#~ "#   not use upper case characters.\n"
#~ "#rename_existing:\n"
#~ "#   This option will cause the macro to override an existing G-Code\n"
#~ "#   command and provide the previous definition of the command via the\n"
#~ "#   name provided here. This can be used to override builtin G-Code\n"
#~ "#   commands. Care should be taken when overriding commands as it can\n"
#~ "#   cause complex and unexpected results. The default is to not\n"
#~ "#   override an existing G-Code command.\n"
#~ "#description: G-Code macro\n"
#~ "#   This will add a short description used at the HELP command or while\n"
#~ "#   using the auto completion feature. Default \"G-Code macro\"\n"
#~ msgstr ""

#~ msgid ""
#~ "Execute a gcode on a set delay. See the [command template "
#~ "guide](Command_Templates.md#delayed-gcodes) and [command "
#~ "reference](G-Codes.md#delayed_gcode) for more information."
#~ msgstr ""

#~ msgid ""
#~ "[delayed_gcode my_delayed_gcode]\n"
#~ "gcode:\n"
#~ "#   A list of G-Code commands to execute when the delay duration has\n"
#~ "#   elapsed. G-Code templates are supported. This parameter must be\n"
#~ "#   provided.\n"
#~ "#initial_duration: 0.0\n"
#~ "#   The duration of the initial delay (in seconds). If set to a\n"
#~ "#   non-zero value the delayed_gcode will execute the specified number\n"
#~ "#   of seconds after the printer enters the \"ready\" state. This can be\n"
#~ "#   useful for initialization procedures or a repeating delayed_gcode.\n"
#~ "#   If set to 0 the delayed_gcode will not execute on startup.\n"
#~ "#   Default is 0.\n"
#~ msgstr ""

#~ msgid ""
#~ "Support saving variables to disk so that they are retained across restarts. "
#~ "See [command templates](Command_Templates.md#save-variables-to-disk) and "
#~ "[G-Code reference](G-Codes.md#save_variables) for further information."
#~ msgstr ""

#~ msgid ""
#~ "[save_variables]\n"
#~ "filename:\n"
#~ "#   Required - provide a filename that would be used to save the\n"
#~ "#   variables to disk e.g. ~/variables.cfg\n"
#~ msgstr ""

#~ msgid ""
#~ "Idle timeout. An idle timeout is automatically enabled - add an explicit "
#~ "idle_timeout config section to change the default settings."
#~ msgstr ""

#~ msgid ""
#~ "[idle_timeout]\n"
#~ "#gcode:\n"
#~ "#   A list of G-Code commands to execute on an idle timeout. See\n"
#~ "#   docs/Command_Templates.md for G-Code format. The default is to run\n"
#~ "#   \"TURN_OFF_HEATERS\" and \"M84\".\n"
#~ "#timeout: 600\n"
#~ "#   Idle time (in seconds) to wait before running the above G-Code\n"
#~ "#   commands. The default is 600 seconds.\n"
#~ msgstr ""

#~ msgid "Optional G-Code features"
#~ msgstr ""

#~ msgid ""
#~ "A virtual sdcard may be useful if the host machine is not fast enough to run"
#~ " OctoPrint well. It allows the Klipper host software to directly print gcode"
#~ " files stored in a directory on the host using standard sdcard G-Code "
#~ "commands (eg, M24)."
#~ msgstr ""

#~ msgid ""
#~ "[virtual_sdcard]\n"
#~ "path:\n"
#~ "#   The path of the local directory on the host machine to look for\n"
#~ "#   g-code files. This is a read-only directory (sdcard file writes\n"
#~ "#   are not supported). One may point this to OctoPrint's upload\n"
#~ "#   directory (generally ~/.octoprint/uploads/ ). This parameter must\n"
#~ "#   be provided.\n"
#~ "#on_error_gcode:\n"
#~ "#   A list of G-Code commands to execute when an error is reported.\n"
#~ "\n"
#~ msgstr ""

#~ msgid ""
#~ "Some printers with stage-clearing features, such as a part ejector or a belt"
#~ " printer, can find use in looping sections of the sdcard file. (For example,"
#~ " to print the same part over and over, or repeat the a section of a part for"
#~ " a chain or other repeated pattern)."
#~ msgstr ""

#~ msgid ""
#~ "See the [command reference](G-Codes.md#sdcard_loop) for supported commands. "
#~ "See the [sample-macros.cfg](../config/sample-macros.cfg) file for a Marlin "
#~ "compatible M808 G-Code macro."
#~ msgstr ""

#~ msgid "[sdcard_loop]\n"
#~ msgstr ""

#~ msgid ""
#~ "Support manually moving stepper motors for diagnostic purposes. Note, using "
#~ "this feature may place the printer in an invalid state - see the [command "
#~ "reference](G-Codes.md#force_move) for important details."
#~ msgstr ""

#~ msgid ""
#~ "[force_move]\n"
#~ "#enable_force_move: False\n"
#~ "#   Set to true to enable FORCE_MOVE and SET_KINEMATIC_POSITION\n"
#~ "#   extended G-Code commands. The default is false.\n"
#~ msgstr ""

#~ msgid ""
#~ "Pause/Resume functionality with support of position capture and restore. See"
#~ " the [command reference](G-Codes.md#pause_resume) for more information."
#~ msgstr ""

#~ msgid ""
#~ "[pause_resume]\n"
#~ "#recover_velocity: 50.\n"
#~ "#   When capture/restore is enabled, the speed at which to return to\n"
#~ "#   the captured position (in mm/s). Default is 50.0 mm/s.\n"
#~ msgstr ""

#~ msgid ""
#~ "Firmware filament retraction. This enables G10 (retract) and G11 (unretract)"
#~ " GCODE commands issued by many slicers. The parameters below provide startup"
#~ " defaults, although the values can be adjusted via the SET_RETRACTION "
#~ "[command](G-Codes.md#firmware_retraction)), allowing per-filament settings "
#~ "and runtime tuning."
#~ msgstr ""

#~ msgid ""
#~ "[firmware_retraction]\n"
#~ "#retract_length: 0\n"
#~ "#   The length of filament (in mm) to retract when G10 is activated,\n"
#~ "#   and to unretract when G11 is activated (but see\n"
#~ "#   unretract_extra_length below). The default is 0 mm.\n"
#~ "#retract_speed: 20\n"
#~ "#   The speed of retraction, in mm/s. The default is 20 mm/s.\n"
#~ "#unretract_extra_length: 0\n"
#~ "#   The length (in mm) of *additional* filament to add when\n"
#~ "#   unretracting.\n"
#~ "#unretract_speed: 10\n"
#~ "#   The speed of unretraction, in mm/s. The default is 10 mm/s.\n"
#~ msgstr ""

#~ msgid "Support for gcode arc (G2/G3) commands."
#~ msgstr ""

#~ msgid ""
#~ "[gcode_arcs]\n"
#~ "#resolution: 1.0\n"
#~ "#   An arc will be split into segments. Each segment's length will\n"
#~ "#   equal the resolution in mm set above. Lower values will produce a\n"
#~ "#   finer arc, but also more work for your machine. Arcs smaller than\n"
#~ "#   the configured value will become straight lines. The default is\n"
#~ "#   1mm.\n"
#~ msgstr ""

#~ msgid "Enable the \"M118\" and \"RESPOND\" extended [commands](G-Codes.md#respond)."
#~ msgstr ""

#~ msgid ""
#~ "[respond]\n"
#~ "#default_type: echo\n"
#~ "#   Sets the default prefix of the \"M118\" and \"RESPOND\" output to one\n"
#~ "#   of the following:\n"
#~ "#       echo: \"echo: \" (This is the default)\n"
#~ "#       command: \"// \"\n"
#~ "#       error: \"!! \"\n"
#~ "#default_prefix: echo:\n"
#~ "#   Directly sets the default prefix. If present, this value will\n"
#~ "#   override the \"default_type\".\n"
#~ msgstr ""

#~ msgid ""
#~ "Enables support to exclude or cancel individual objects during the printing "
#~ "process."
#~ msgstr ""

#~ msgid ""
#~ "See the [exclude objects guide](Exclude_Object.md) and [command "
#~ "reference](G-Codes.md#excludeobject) for additional information. See the "
#~ "[sample-macros.cfg](../config/sample-macros.cfg) file for a "
#~ "Marlin/RepRapFirmware compatible M486 G-Code macro."
#~ msgstr ""

#~ msgid "[exclude_object]\n"
#~ msgstr ""

#~ msgid "Resonance compensation"
#~ msgstr ""

#~ msgid ""
#~ "Enables [resonance compensation](Resonance_Compensation.md). Also see the "
#~ "[command reference](G-Codes.md#input_shaper)."
#~ msgstr ""

#~ msgid ""
#~ "[input_shaper]\n"
#~ "#shaper_freq_x: 0\n"
#~ "#   A frequency (in Hz) of the input shaper for X axis. This is\n"
#~ "#   usually a resonance frequency of X axis that the input shaper\n"
#~ "#   should suppress. For more complex shapers, like 2- and 3-hump EI\n"
#~ "#   input shapers, this parameter can be set from different\n"
#~ "#   considerations. The default value is 0, which disables input\n"
#~ "#   shaping for X axis.\n"
#~ "#shaper_freq_y: 0\n"
#~ "#   A frequency (in Hz) of the input shaper for Y axis. This is\n"
#~ "#   usually a resonance frequency of Y axis that the input shaper\n"
#~ "#   should suppress. For more complex shapers, like 2- and 3-hump EI\n"
#~ "#   input shapers, this parameter can be set from different\n"
#~ "#   considerations. The default value is 0, which disables input\n"
#~ "#   shaping for Y axis.\n"
#~ "#shaper_type: mzv\n"
#~ "#   A type of the input shaper to use for both X and Y axes. Supported\n"
#~ "#   shapers are zv, mzv, zvd, ei, 2hump_ei, and 3hump_ei. The default\n"
#~ "#   is mzv input shaper.\n"
#~ "#shaper_type_x:\n"
#~ "#shaper_type_y:\n"
#~ "#   If shaper_type is not set, these two parameters can be used to\n"
#~ "#   configure different input shapers for X and Y axes. The same\n"
#~ "#   values are supported as for shaper_type parameter.\n"
#~ "#damping_ratio_x: 0.1\n"
#~ "#damping_ratio_y: 0.1\n"
#~ "#   Damping ratios of vibrations of X and Y axes used by input shapers\n"
#~ "#   to improve vibration suppression. Default value is 0.1 which is a\n"
#~ "#   good all-round value for most printers. In most circumstances this\n"
#~ "#   parameter requires no tuning and should not be changed.\n"
#~ msgstr ""

#~ msgid ""
#~ "Support for ADXL345 accelerometers. This support allows one to query "
#~ "accelerometer measurements from the sensor. This enables an "
#~ "ACCELEROMETER_MEASURE command (see [G-Codes](G-Codes.md#adxl345) for more "
#~ "information). The default chip name is \"default\", but one may specify an "
#~ "explicit name (eg, [adxl345 my_chip_name])."
#~ msgstr ""

#~ msgid ""
#~ "[adxl345]\n"
#~ "cs_pin:\n"
#~ "#   The SPI enable pin for the sensor. This parameter must be provided.\n"
#~ "#spi_speed: 5000000\n"
#~ "#   The SPI speed (in hz) to use when communicating with the chip.\n"
#~ "#   The default is 5000000.\n"
#~ "#spi_bus:\n"
#~ "#spi_software_sclk_pin:\n"
#~ "#spi_software_mosi_pin:\n"
#~ "#spi_software_miso_pin:\n"
#~ "#   See the \"common SPI settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#axes_map: x, y, z\n"
#~ "#   The accelerometer axis for each of the printer's X, Y, and Z axes.\n"
#~ "#   This may be useful if the accelerometer is mounted in an\n"
#~ "#   orientation that does not match the printer orientation. For\n"
#~ "#   example, one could set this to \"y, x, z\" to swap the X and Y axes.\n"
#~ "#   It is also possible to negate an axis if the accelerometer\n"
#~ "#   direction is reversed (eg, \"x, z, -y\"). The default is \"x, y, z\".\n"
#~ "#rate: 3200\n"
#~ "#   Output data rate for ADXL345. ADXL345 supports the following data\n"
#~ "#   rates: 3200, 1600, 800, 400, 200, 100, 50, and 25. Note that it is\n"
#~ "#   not recommended to change this rate from the default 3200, and\n"
#~ "#   rates below 800 will considerably affect the quality of resonance\n"
#~ "#   measurements.\n"
#~ msgstr ""

#~ msgid "[mpu9250]"
#~ msgstr ""

#~ msgid ""
#~ "Support for MPU-9250, MPU-9255, MPU-9255, MPU-6050, and MPU-6500 "
#~ "accelerometers (one may define any number of sections with an \"mpu9250\" "
#~ "prefix)."
#~ msgstr ""

#~ msgid ""
#~ "[mpu9250 my_accelerometer]\n"
#~ "#i2c_address:\n"
#~ "#   Default is 104 (0x68). If AD0 is high, it would be 0x69 instead.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed: 400000\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters. The default \"i2c_speed\" is 400000.\n"
#~ "#axes_map: x, y, z\n"
#~ "#   See the \"adxl345\" section for information on this parameter.\n"
#~ msgstr ""

#~ msgid ""
#~ "Support for resonance testing and automatic input shaper calibration. In "
#~ "order to use most of the functionality of this module, additional software "
#~ "dependencies must be installed; refer to [Measuring "
#~ "Resonances](Measuring_Resonances.md) and the [command "
#~ "reference](G-Codes.md#resonance_tester) for more information. See the [Max "
#~ "smoothing](Measuring_Resonances.md#max-smoothing) section of the measuring "
#~ "resonances guide for more information on `max_smoothing` parameter and its "
#~ "use."
#~ msgstr ""

#~ msgid ""
#~ "[resonance_tester]\n"
#~ "#probe_points:\n"
#~ "#   A list of X, Y, Z coordinates of points (one point per line) to test\n"
#~ "#   resonances at. At least one point is required. Make sure that all\n"
#~ "#   points with some safety margin in XY plane (~a few centimeters)\n"
#~ "#   are reachable by the toolhead.\n"
#~ "#accel_chip:\n"
#~ "#   A name of the accelerometer chip to use for measurements. If\n"
#~ "#   adxl345 chip was defined without an explicit name, this parameter\n"
#~ "#   can simply reference it as \"accel_chip: adxl345\", otherwise an\n"
#~ "#   explicit name must be supplied as well, e.g. \"accel_chip: adxl345\n"
#~ "#   my_chip_name\". Either this, or the next two parameters must be\n"
#~ "#   set.\n"
#~ "#accel_chip_x:\n"
#~ "#accel_chip_y:\n"
#~ "#   Names of the accelerometer chips to use for measurements for each\n"
#~ "#   of the axis. Can be useful, for instance, on bed slinger printer,\n"
#~ "#   if two separate accelerometers are mounted on the bed (for Y axis)\n"
#~ "#   and on the toolhead (for X axis). These parameters have the same\n"
#~ "#   format as 'accel_chip' parameter. Only 'accel_chip' or these two\n"
#~ "#   parameters must be provided.\n"
#~ "#max_smoothing:\n"
#~ "#   Maximum input shaper smoothing to allow for each axis during shaper\n"
#~ "#   auto-calibration (with 'SHAPER_CALIBRATE' command). By default no\n"
#~ "#   maximum smoothing is specified. Refer to Measuring_Resonances guide\n"
#~ "#   for more details on using this feature.\n"
#~ "#min_freq: 5\n"
#~ "#   Minimum frequency to test for resonances. The default is 5 Hz.\n"
#~ "#max_freq: 133.33\n"
#~ "#   Maximum frequency to test for resonances. The default is 133.33 Hz.\n"
#~ "#accel_per_hz: 75\n"
#~ "#   This parameter is used to determine which acceleration to use to\n"
#~ "#   test a specific frequency: accel = accel_per_hz * freq. Higher the\n"
#~ "#   value, the higher is the energy of the oscillations. Can be set to\n"
#~ "#   a lower than the default value if the resonances get too strong on\n"
#~ "#   the printer. However, lower values make measurements of\n"
#~ "#   high-frequency resonances less precise. The default value is 75\n"
#~ "#   (mm/sec).\n"
#~ "#hz_per_sec: 1\n"
#~ "#   Determines the speed of the test. When testing all frequencies in\n"
#~ "#   range [min_freq, max_freq], each second the frequency increases by\n"
#~ "#   hz_per_sec. Small values make the test slow, and the large values\n"
#~ "#   will decrease the precision of the test. The default value is 1.0\n"
#~ "#   (Hz/sec == sec^-2).\n"
#~ msgstr ""

#~ msgid "Config file helpers"
#~ msgstr ""

#~ msgid "[board_pins]"
#~ msgstr ""

#~ msgid ""
#~ "Board pin aliases (one may define any number of sections with a "
#~ "\"board_pins\" prefix). Use this to define aliases for the pins on a micro-"
#~ "controller."
#~ msgstr ""

#~ msgid ""
#~ "[board_pins my_aliases]\n"
#~ "mcu: mcu\n"
#~ "#   A comma separated list of micro-controllers that may use the\n"
#~ "#   aliases. The default is to apply the aliases to the main \"mcu\".\n"
#~ "aliases:\n"
#~ "aliases_<name>:\n"
#~ "#   A comma separated list of \"name=value\" aliases to create for the\n"
#~ "#   given micro-controller. For example, \"EXP1_1=PE6\" would create an\n"
#~ "#   \"EXP1_1\" alias for the \"PE6\" pin. However, if \"value\" is enclosed\n"
#~ "#   in \"<>\" then \"name\" is created as a reserved pin (for example,\n"
#~ "#   \"EXP1_9=<GND>\" would reserve \"EXP1_9\"). Any number of options\n"
#~ "#   starting with \"aliases_\" may be specified.\n"
#~ msgstr ""

#~ msgid "[include]"
#~ msgstr ""

#~ msgid ""
#~ "Include file support. One may include additional config file from the main "
#~ "printer config file. Wildcards may also be used (eg, \"configs/*.cfg\")."
#~ msgstr ""

#~ msgid "[include my_other_config.cfg]\n"
#~ msgstr ""

#~ msgid "[duplicate_pin_override]"
#~ msgstr ""

#~ msgid ""
#~ "This tool allows a single micro-controller pin to be defined multiple times "
#~ "in a config file without normal error checking. This is intended for "
#~ "diagnostic and debugging purposes. This section is not needed where Klipper "
#~ "supports using the same pin multiple times, and using this override may "
#~ "cause confusing and unexpected results."
#~ msgstr ""

#~ msgid ""
#~ "[duplicate_pin_override]\n"
#~ "pins:\n"
#~ "#   A comma separated list of pins that may be used multiple times in\n"
#~ "#   a config file without normal error checks. This parameter must be\n"
#~ "#   provided.\n"
#~ msgstr ""

#~ msgid "Bed probing hardware"
#~ msgstr ""

#~ msgid ""
#~ "Z height probe. One may define this section to enable Z height probing "
#~ "hardware. When this section is enabled, PROBE and QUERY_PROBE extended "
#~ "[g-code commands](G-Codes.md#probe) become available. Also, see the [probe "
#~ "calibrate guide](Probe_Calibrate.md). The probe section also creates a "
#~ "virtual \"probe:z_virtual_endstop\" pin. One may set the stepper_z "
#~ "endstop_pin to this virtual pin on cartesian style printers that use the "
#~ "probe in place of a z endstop. If using \"probe:z_virtual_endstop\" then do "
#~ "not define a position_endstop in the stepper_z config section."
#~ msgstr ""

#~ msgid ""
#~ "[probe]\n"
#~ "pin:\n"
#~ "#   Probe detection pin. If the pin is on a different microcontroller\n"
#~ "#   than the Z steppers then it enables \"multi-mcu homing\". This\n"
#~ "#   parameter must be provided.\n"
#~ "#deactivate_on_each_sample: True\n"
#~ "#   This determines if Klipper should execute deactivation gcode\n"
#~ "#   between each probe attempt when performing a multiple probe\n"
#~ "#   sequence. The default is True.\n"
#~ "#x_offset: 0.0\n"
#~ "#   The distance (in mm) between the probe and the nozzle along the\n"
#~ "#   x-axis. The default is 0.\n"
#~ "#y_offset: 0.0\n"
#~ "#   The distance (in mm) between the probe and the nozzle along the\n"
#~ "#   y-axis. The default is 0.\n"
#~ "z_offset:\n"
#~ "#   The distance (in mm) between the bed and the nozzle when the probe\n"
#~ "#   triggers. This parameter must be provided.\n"
#~ "#speed: 5.0\n"
#~ "#   Speed (in mm/s) of the Z axis when probing. The default is 5mm/s.\n"
#~ "#samples: 1\n"
#~ "#   The number of times to probe each point. The probed z-values will\n"
#~ "#   be averaged. The default is to probe 1 time.\n"
#~ "#sample_retract_dist: 2.0\n"
#~ "#   The distance (in mm) to lift the toolhead between each sample (if\n"
#~ "#   sampling more than once). The default is 2mm.\n"
#~ "#lift_speed:\n"
#~ "#   Speed (in mm/s) of the Z axis when lifting the probe between\n"
#~ "#   samples. The default is to use the same value as the 'speed'\n"
#~ "#   parameter.\n"
#~ "#samples_result: average\n"
#~ "#   The calculation method when sampling more than once - either\n"
#~ "#   \"median\" or \"average\". The default is average.\n"
#~ "#samples_tolerance: 0.100\n"
#~ "#   The maximum Z distance (in mm) that a sample may differ from other\n"
#~ "#   samples. If this tolerance is exceeded then either an error is\n"
#~ "#   reported or the attempt is restarted (see\n"
#~ "#   samples_tolerance_retries). The default is 0.100mm.\n"
#~ "#samples_tolerance_retries: 0\n"
#~ "#   The number of times to retry if a sample is found that exceeds\n"
#~ "#   samples_tolerance. On a retry, all current samples are discarded\n"
#~ "#   and the probe attempt is restarted. If a valid set of samples are\n"
#~ "#   not obtained in the given number of retries then an error is\n"
#~ "#   reported. The default is zero which causes an error to be reported\n"
#~ "#   on the first sample that exceeds samples_tolerance.\n"
#~ "#activate_gcode:\n"
#~ "#   A list of G-Code commands to execute prior to each probe attempt.\n"
#~ "#   See docs/Command_Templates.md for G-Code format. This may be\n"
#~ "#   useful if the probe needs to be activated in some way. Do not\n"
#~ "#   issue any commands here that move the toolhead (eg, G1). The\n"
#~ "#   default is to not run any special G-Code commands on activation.\n"
#~ "#deactivate_gcode:\n"
#~ "#   A list of G-Code commands to execute after each probe attempt\n"
#~ "#   completes. See docs/Command_Templates.md for G-Code format. Do not\n"
#~ "#   issue any commands here that move the toolhead. The default is to\n"
#~ "#   not run any special G-Code commands on deactivation.\n"
#~ msgstr ""

#~ msgid ""
#~ "BLTouch probe. One may define this section (instead of a probe section) to "
#~ "enable a BLTouch probe. See [BL-Touch guide](BLTouch.md) and [command "
#~ "reference](G-Codes.md#bltouch) for further information. A virtual "
#~ "\"probe:z_virtual_endstop\" pin is also created (see the \"probe\" section "
#~ "for the details)."
#~ msgstr ""

#~ msgid ""
#~ "[bltouch]\n"
#~ "sensor_pin:\n"
#~ "#   Pin connected to the BLTouch sensor pin. Most BLTouch devices\n"
#~ "#   require a pullup on the sensor pin (prefix the pin name with \"^\").\n"
#~ "#   This parameter must be provided.\n"
#~ "control_pin:\n"
#~ "#   Pin connected to the BLTouch control pin. This parameter must be\n"
#~ "#   provided.\n"
#~ "#pin_move_time: 0.680\n"
#~ "#   The amount of time (in seconds) to wait for the BLTouch pin to\n"
#~ "#   move up or down. The default is 0.680 seconds.\n"
#~ "#stow_on_each_sample: True\n"
#~ "#   This determines if Klipper should command the pin to move up\n"
#~ "#   between each probe attempt when performing a multiple probe\n"
#~ "#   sequence. Read the directions in docs/BLTouch.md before setting\n"
#~ "#   this to False. The default is True.\n"
#~ "#probe_with_touch_mode: False\n"
#~ "#   If this is set to True then Klipper will probe with the device in\n"
#~ "#   \"touch_mode\". The default is False (probing in \"pin_down\" mode).\n"
#~ "#pin_up_reports_not_triggered: True\n"
#~ "#   Set if the BLTouch consistently reports the probe in a \"not\n"
#~ "#   triggered\" state after a successful \"pin_up\" command. This should\n"
#~ "#   be True for all genuine BLTouch devices. Read the directions in\n"
#~ "#   docs/BLTouch.md before setting this to False. The default is True.\n"
#~ "#pin_up_touch_mode_reports_triggered: True\n"
#~ "#   Set if the BLTouch consistently reports a \"triggered\" state after\n"
#~ "#   the commands \"pin_up\" followed by \"touch_mode\". This should be\n"
#~ "#   True for all genuine BLTouch devices. Read the directions in\n"
#~ "#   docs/BLTouch.md before setting this to False. The default is True.\n"
#~ "#set_output_mode:\n"
#~ "#   Request a specific sensor pin output mode on the BLTouch V3.0 (and\n"
#~ "#   later). This setting should not be used on other types of probes.\n"
#~ "#   Set to \"5V\" to request a sensor pin output of 5 Volts (only use if\n"
#~ "#   the controller board needs 5V mode and is 5V tolerant on its input\n"
#~ "#   signal line). Set to \"OD\" to request the sensor pin output use\n"
#~ "#   open drain mode. The default is to not request an output mode.\n"
#~ "#x_offset:\n"
#~ "#y_offset:\n"
#~ "#z_offset:\n"
#~ "#speed:\n"
#~ "#lift_speed:\n"
#~ "#samples:\n"
#~ "#sample_retract_dist:\n"
#~ "#samples_result:\n"
#~ "#samples_tolerance:\n"
#~ "#samples_tolerance_retries:\n"
#~ "#   See the \"probe\" section for information on these parameters.\n"
#~ msgstr ""

#~ msgid ""
#~ "The \"Smart Effector\" from Duet3d implements a Z probe using a force "
#~ "sensor. One may define this section instead of `[probe]` to enable the Smart"
#~ " Effector specific features. This also enables [runtime "
#~ "commands](G-Codes.md#smart_effector) to adjust the parameters of the Smart "
#~ "Effector at run time."
#~ msgstr ""

#~ msgid ""
#~ "[smart_effector]\n"
#~ "pin:\n"
#~ "#   Pin connected to the Smart Effector Z Probe output pin (pin 5). Note that\n"
#~ "#   pullup resistor on the board is generally not required. However, if the\n"
#~ "#   output pin is connected to the board pin with a pullup resistor, that\n"
#~ "#   resistor must be high value (e.g. 10K Ohm or more). Some boards have a low\n"
#~ "#   value pullup resistor on the Z probe input, which will likely result in an\n"
#~ "#   always-triggered probe state. In this case, connect the Smart Effector to\n"
#~ "#   a different pin on the board. This parameter is required.\n"
#~ "#control_pin:\n"
#~ "#   Pin connected to the Smart Effector control input pin (pin 7). If provided,\n"
#~ "#   Smart Effector sensitivity programming commands become available.\n"
#~ "#probe_accel:\n"
#~ "#   If set, limits the acceleration of the probing moves (in mm/sec^2).\n"
#~ "#   A sudden large acceleration at the beginning of the probing move may\n"
#~ "#   cause spurious probe triggering, especially if the hotend is heavy.\n"
#~ "#   To prevent that, it may be necessary to reduce the acceleration of\n"
#~ "#   the probing moves via this parameter.\n"
#~ "#recovery_time: 0.4\n"
#~ "#   A delay between the travel moves and the probing moves in seconds. A fast\n"
#~ "#   travel move prior to probing may result in a spurious probe triggering.\n"
#~ "#   This may cause 'Probe triggered prior to movement' errors if no delay\n"
#~ "#   is set. Value 0 disables the recovery delay.\n"
#~ "#   Default value is 0.4.\n"
#~ "#x_offset:\n"
#~ "#y_offset:\n"
#~ "#   Should be left unset (or set to 0).\n"
#~ "z_offset:\n"
#~ "#   Trigger height of the probe. Start with -0.1 (mm), and adjust later using\n"
#~ "#   `PROBE_CALIBRATE` command. This parameter must be provided.\n"
#~ "#speed:\n"
#~ "#   Speed (in mm/s) of the Z axis when probing. It is recommended to start\n"
#~ "#   with the probing speed of 20 mm/s and adjust it as necessary to improve\n"
#~ "#   the accuracy and repeatability of the probe triggering.\n"
#~ "#samples:\n"
#~ "#sample_retract_dist:\n"
#~ "#samples_result:\n"
#~ "#samples_tolerance:\n"
#~ "#samples_tolerance_retries:\n"
#~ "#activate_gcode:\n"
#~ "#deactivate_gcode:\n"
#~ "#deactivate_on_each_sample:\n"
#~ "#   See the \"probe\" section for more information on the parameters above.\n"
#~ msgstr ""

#~ msgid "Additional stepper motors and extruders"
#~ msgstr ""

#~ msgid "[stepper_z1]"
#~ msgstr ""

#~ msgid ""
#~ "Multi-stepper axes. On a cartesian style printer, the stepper controlling a "
#~ "given axis may have additional config blocks defining steppers that should "
#~ "be stepped in concert with the primary stepper. One may define any number of"
#~ " sections with a numeric suffix starting at 1 (for example, \"stepper_z1\", "
#~ "\"stepper_z2\", etc.)."
#~ msgstr ""

#~ msgid ""
#~ "[stepper_z1]\n"
#~ "#step_pin:\n"
#~ "#dir_pin:\n"
#~ "#enable_pin:\n"
#~ "#microsteps:\n"
#~ "#rotation_distance:\n"
#~ "#   See the \"stepper\" section for the definition of the above parameters.\n"
#~ "#endstop_pin:\n"
#~ "#   If an endstop_pin is defined for the additional stepper then the\n"
#~ "#   stepper will home until the endstop is triggered. Otherwise, the\n"
#~ "#   stepper will home until the endstop on the primary stepper for the\n"
#~ "#   axis is triggered.\n"
#~ msgstr ""

#~ msgid "[extruder1]"
#~ msgstr ""

#~ msgid ""
#~ "In a multi-extruder printer add an additional extruder section for each "
#~ "additional extruder. The additional extruder sections should be named "
#~ "\"extruder1\", \"extruder2\", \"extruder3\", and so on. See the \"extruder\""
#~ " section for a description of available parameters."
#~ msgstr ""

#~ msgid ""
#~ "See [sample-multi-extruder.cfg](../config/sample-multi-extruder.cfg) for an "
#~ "example configuration."
#~ msgstr ""

#~ msgid ""
#~ "[extruder1]\n"
#~ "#step_pin:\n"
#~ "#dir_pin:\n"
#~ "#...\n"
#~ "#   See the \"extruder\" section for available stepper and heater\n"
#~ "#   parameters.\n"
#~ "#shared_heater:\n"
#~ "#   This option is deprecated and should no longer be specified.\n"
#~ msgstr ""

#~ msgid ""
#~ "Support for cartesian printers with dual carriages on a single axis. The "
#~ "active carriage is set via the SET_DUAL_CARRIAGE extended g-code command. "
#~ "The \"SET_DUAL_CARRIAGE CARRIAGE=1\" command will activate the carriage "
#~ "defined in this section (CARRIAGE=0 will return activation to the primary "
#~ "carriage). Dual carriage support is typically combined with extra extruders "
#~ "- the SET_DUAL_CARRIAGE command is often called at the same time as the "
#~ "ACTIVATE_EXTRUDER command. Be sure to park the carriages during "
#~ "deactivation."
#~ msgstr ""

#~ msgid ""
#~ "See [sample-idex.cfg](../config/sample-idex.cfg) for an example "
#~ "configuration."
#~ msgstr ""

#~ msgid ""
#~ "[dual_carriage]\n"
#~ "axis:\n"
#~ "#   The axis this extra carriage is on (either x or y). This parameter\n"
#~ "#   must be provided.\n"
#~ "#step_pin:\n"
#~ "#dir_pin:\n"
#~ "#enable_pin:\n"
#~ "#microsteps:\n"
#~ "#rotation_distance:\n"
#~ "#endstop_pin:\n"
#~ "#position_endstop:\n"
#~ "#position_min:\n"
#~ "#position_max:\n"
#~ "#   See the \"stepper\" section for the definition of the above parameters.\n"
#~ msgstr ""

#~ msgid "[extruder_stepper]"
#~ msgstr ""

#~ msgid ""
#~ "Support for additional steppers synchronized to the movement of an extruder "
#~ "(one may define any number of sections with an \"extruder_stepper\" prefix)."
#~ msgstr ""

#~ msgid "See the [command reference](G-Codes.md#extruder) for more information."
#~ msgstr ""

#~ msgid ""
#~ "[extruder_stepper my_extra_stepper]\n"
#~ "extruder:\n"
#~ "#   The extruder this stepper is synchronized to. If this is set to an\n"
#~ "#   empty string then the stepper will not be synchronized to an\n"
#~ "#   extruder. This parameter must be provided.\n"
#~ "#step_pin:\n"
#~ "#dir_pin:\n"
#~ "#enable_pin:\n"
#~ "#microsteps:\n"
#~ "#rotation_distance:\n"
#~ "#   See the \"stepper\" section for the definition of the above\n"
#~ "#   parameters.\n"
#~ msgstr ""

#~ msgid ""
#~ "Manual steppers (one may define any number of sections with a "
#~ "\"manual_stepper\" prefix). These are steppers that are controlled by the "
#~ "MANUAL_STEPPER g-code command. For example: \"MANUAL_STEPPER "
#~ "STEPPER=my_stepper MOVE=10 SPEED=5\". See "
#~ "[G-Codes](G-Codes.md#manual_stepper) file for a description of the "
#~ "MANUAL_STEPPER command. The steppers are not connected to the normal printer"
#~ " kinematics."
#~ msgstr ""

#~ msgid ""
#~ "[manual_stepper my_stepper]\n"
#~ "#step_pin:\n"
#~ "#dir_pin:\n"
#~ "#enable_pin:\n"
#~ "#microsteps:\n"
#~ "#rotation_distance:\n"
#~ "#   See the \"stepper\" section for a description of these parameters.\n"
#~ "#velocity:\n"
#~ "#   Set the default velocity (in mm/s) for the stepper. This value\n"
#~ "#   will be used if a MANUAL_STEPPER command does not specify a SPEED\n"
#~ "#   parameter. The default is 5mm/s.\n"
#~ "#accel:\n"
#~ "#   Set the default acceleration (in mm/s^2) for the stepper. An\n"
#~ "#   acceleration of zero will result in no acceleration. This value\n"
#~ "#   will be used if a MANUAL_STEPPER command does not specify an ACCEL\n"
#~ "#   parameter. The default is zero.\n"
#~ "#endstop_pin:\n"
#~ "#   Endstop switch detection pin. If specified, then one may perform\n"
#~ "#   \"homing moves\" by adding a STOP_ON_ENDSTOP parameter to\n"
#~ "#   MANUAL_STEPPER movement commands.\n"
#~ msgstr ""

#~ msgid "Custom heaters and sensors"
#~ msgstr ""

#~ msgid "[verify_heater]"
#~ msgstr ""

#~ msgid ""
#~ "Heater and temperature sensor verification. Heater verification is "
#~ "automatically enabled for each heater that is configured on the printer. Use"
#~ " verify_heater sections to change the default settings."
#~ msgstr ""

#~ msgid ""
#~ "[verify_heater heater_config_name]\n"
#~ "#max_error: 120\n"
#~ "#   The maximum \"cumulative temperature error\" before raising an\n"
#~ "#   error. Smaller values result in stricter checking and larger\n"
#~ "#   values allow for more time before an error is reported.\n"
#~ "#   Specifically, the temperature is inspected once a second and if it\n"
#~ "#   is close to the target temperature then an internal \"error\n"
#~ "#   counter\" is reset; otherwise, if the temperature is below the\n"
#~ "#   target range then the counter is increased by the amount the\n"
#~ "#   reported temperature differs from that range. Should the counter\n"
#~ "#   exceed this \"max_error\" then an error is raised. The default is\n"
#~ "#   120.\n"
#~ "#check_gain_time:\n"
#~ "#   This controls heater verification during initial heating. Smaller\n"
#~ "#   values result in stricter checking and larger values allow for\n"
#~ "#   more time before an error is reported. Specifically, during\n"
#~ "#   initial heating, as long as the heater increases in temperature\n"
#~ "#   within this time frame (specified in seconds) then the internal\n"
#~ "#   \"error counter\" is reset. The default is 20 seconds for extruders\n"
#~ "#   and 60 seconds for heater_bed.\n"
#~ "#hysteresis: 5\n"
#~ "#   The maximum temperature difference (in Celsius) to a target\n"
#~ "#   temperature that is considered in range of the target. This\n"
#~ "#   controls the max_error range check. It is rare to customize this\n"
#~ "#   value. The default is 5.\n"
#~ "#heating_gain: 2\n"
#~ "#   The minimum temperature (in Celsius) that the heater must increase\n"
#~ "#   by during the check_gain_time check. It is rare to customize this\n"
#~ "#   value. The default is 2.\n"
#~ msgstr ""

#~ msgid "[homing_heaters]"
#~ msgstr ""

#~ msgid "Tool to disable heaters when homing or probing an axis."
#~ msgstr ""

#~ msgid ""
#~ "[homing_heaters]\n"
#~ "#steppers:\n"
#~ "#   A comma separated list of steppers that should cause heaters to be\n"
#~ "#   disabled. The default is to disable heaters for any homing/probing\n"
#~ "#   move.\n"
#~ "#   Typical example: stepper_z\n"
#~ "#heaters:\n"
#~ "#   A comma separated list of heaters to disable during homing/probing\n"
#~ "#   moves. The default is to disable all heaters.\n"
#~ "#   Typical example: extruder, heater_bed\n"
#~ msgstr ""

#~ msgid "[thermistor]"
#~ msgstr ""

#~ msgid ""
#~ "Custom thermistors (one may define any number of sections with a "
#~ "\"thermistor\" prefix). A custom thermistor may be used in the sensor_type "
#~ "field of a heater config section. (For example, if one defines a "
#~ "\"[thermistor my_thermistor]\" section then one may use a \"sensor_type: "
#~ "my_thermistor\" when defining a heater.) Be sure to place the thermistor "
#~ "section in the config file above its first use in a heater section."
#~ msgstr ""

#~ msgid ""
#~ "[thermistor my_thermistor]\n"
#~ "#temperature1:\n"
#~ "#resistance1:\n"
#~ "#temperature2:\n"
#~ "#resistance2:\n"
#~ "#temperature3:\n"
#~ "#resistance3:\n"
#~ "#   Three resistance measurements (in Ohms) at the given temperatures\n"
#~ "#   (in Celsius). The three measurements will be used to calculate the\n"
#~ "#   Steinhart-Hart coefficients for the thermistor. These parameters\n"
#~ "#   must be provided when using Steinhart-Hart to define the\n"
#~ "#   thermistor.\n"
#~ "#beta:\n"
#~ "#   Alternatively, one may define temperature1, resistance1, and beta\n"
#~ "#   to define the thermistor parameters. This parameter must be\n"
#~ "#   provided when using \"beta\" to define the thermistor.\n"
#~ msgstr ""

#~ msgid "[adc_temperature]"
#~ msgstr ""

#~ msgid ""
#~ "Custom ADC temperature sensors (one may define any number of sections with "
#~ "an \"adc_temperature\" prefix). This allows one to define a custom "
#~ "temperature sensor that measures a voltage on an Analog to Digital Converter"
#~ " (ADC) pin and uses linear interpolation between a set of configured "
#~ "temperature/voltage (or temperature/resistance) measurements to determine "
#~ "the temperature. The resulting sensor can be used as a sensor_type in a "
#~ "heater section. (For example, if one defines a \"[adc_temperature "
#~ "my_sensor]\" section then one may use a \"sensor_type: my_sensor\" when "
#~ "defining a heater.) Be sure to place the sensor section in the config file "
#~ "above its first use in a heater section."
#~ msgstr ""

#~ msgid ""
#~ "[adc_temperature my_sensor]\n"
#~ "#temperature1:\n"
#~ "#voltage1:\n"
#~ "#temperature2:\n"
#~ "#voltage2:\n"
#~ "#...\n"
#~ "#   A set of temperatures (in Celsius) and voltages (in Volts) to use\n"
#~ "#   as reference when converting a temperature. A heater section using\n"
#~ "#   this sensor may also specify adc_voltage and voltage_offset\n"
#~ "#   parameters to define the ADC voltage (see \"Common temperature\n"
#~ "#   amplifiers\" section for details). At least two measurements must\n"
#~ "#   be provided.\n"
#~ "#temperature1:\n"
#~ "#resistance1:\n"
#~ "#temperature2:\n"
#~ "#resistance2:\n"
#~ "#...\n"
#~ "#   Alternatively one may specify a set of temperatures (in Celsius)\n"
#~ "#   and resistance (in Ohms) to use as reference when converting a\n"
#~ "#   temperature. A heater section using this sensor may also specify a\n"
#~ "#   pullup_resistor parameter (see \"extruder\" section for details). At\n"
#~ "#   least two measurements must be provided.\n"
#~ msgstr ""

#~ msgid "[heater_generic]"
#~ msgstr ""

#~ msgid ""
#~ "Generic heaters (one may define any number of sections with a "
#~ "\"heater_generic\" prefix). These heaters behave similarly to standard "
#~ "heaters (extruders, heated beds). Use the SET_HEATER_TEMPERATURE command "
#~ "(see [G-Codes](G-Codes.md#heaters) for details) to set the target "
#~ "temperature."
#~ msgstr ""

#~ msgid ""
#~ "[heater_generic my_generic_heater]\n"
#~ "#gcode_id:\n"
#~ "#   The id to use when reporting the temperature in the M105 command.\n"
#~ "#   This parameter must be provided.\n"
#~ "#heater_pin:\n"
#~ "#max_power:\n"
#~ "#sensor_type:\n"
#~ "#sensor_pin:\n"
#~ "#smooth_time:\n"
#~ "#control:\n"
#~ "#pid_Kp:\n"
#~ "#pid_Ki:\n"
#~ "#pid_Kd:\n"
#~ "#pwm_cycle_time:\n"
#~ "#min_temp:\n"
#~ "#max_temp:\n"
#~ "#   See the \"extruder\" section for the definition of the above\n"
#~ "#   parameters.\n"
#~ msgstr ""

#~ msgid "[temperature_sensor]"
#~ msgstr ""

#~ msgid ""
#~ "Generic temperature sensors. One can define any number of additional "
#~ "temperature sensors that are reported via the M105 command."
#~ msgstr ""

#~ msgid ""
#~ "[temperature_sensor my_sensor]\n"
#~ "#sensor_type:\n"
#~ "#sensor_pin:\n"
#~ "#min_temp:\n"
#~ "#max_temp:\n"
#~ "#   See the \"extruder\" section for the definition of the above\n"
#~ "#   parameters.\n"
#~ "#gcode_id:\n"
#~ "#   See the \"heater_generic\" section for the definition of this\n"
#~ "#   parameter.\n"
#~ msgstr ""

#~ msgid "Temperature sensors"
#~ msgstr ""

#~ msgid ""
#~ "Klipper includes definitions for many types of temperature sensors. These "
#~ "sensors may be used in any config section that requires a temperature sensor"
#~ " (such as an `[extruder]` or `[heater_bed]` section)."
#~ msgstr ""

#~ msgid "Common thermistors"
#~ msgstr ""

#~ msgid ""
#~ "Common thermistors. The following parameters are available in heater "
#~ "sections that use one of these sensors."
#~ msgstr ""

#~ msgid ""
#~ "sensor_type:\n"
#~ "#   One of \"EPCOS 100K B57560G104F\", \"ATC Semitec 104GT-2\",\n"
#~ "#   \"ATC Semitec 104NT-4-R025H42G\", \"Generic 3950\",\n"
#~ "#   \"Honeywell 100K 135-104LAG-J01\", \"NTC 100K MGB18-104F39050L32\",\n"
#~ "#   \"SliceEngineering 450\", or \"TDK NTCG104LH104JT1\"\n"
#~ "sensor_pin:\n"
#~ "#   Analog input pin connected to the thermistor. This parameter must\n"
#~ "#   be provided.\n"
#~ "#pullup_resistor: 4700\n"
#~ "#   The resistance (in ohms) of the pullup attached to the thermistor.\n"
#~ "#   The default is 4700 ohms.\n"
#~ "#inline_resistor: 0\n"
#~ "#   The resistance (in ohms) of an extra (not heat varying) resistor\n"
#~ "#   that is placed inline with the thermistor. It is rare to set this.\n"
#~ "#   The default is 0 ohms.\n"
#~ msgstr ""

#~ msgid "Common temperature amplifiers"
#~ msgstr ""

#~ msgid ""
#~ "Common temperature amplifiers. The following parameters are available in "
#~ "heater sections that use one of these sensors."
#~ msgstr ""

#~ msgid ""
#~ "sensor_type:\n"
#~ "#   One of \"PT100 INA826\", \"AD595\", \"AD597\", \"AD8494\", \"AD8495\",\n"
#~ "#   \"AD8496\", or \"AD8497\".\n"
#~ "sensor_pin:\n"
#~ "#   Analog input pin connected to the sensor. This parameter must be\n"
#~ "#   provided.\n"
#~ "#adc_voltage: 5.0\n"
#~ "#   The ADC comparison voltage (in Volts). The default is 5 volts.\n"
#~ "#voltage_offset: 0\n"
#~ "#   The ADC voltage offset (in Volts). The default is 0.\n"
#~ msgstr ""

#~ msgid "Directly connected PT1000 sensor"
#~ msgstr ""

#~ msgid ""
#~ "Directly connected PT1000 sensor. The following parameters are available in "
#~ "heater sections that use one of these sensors."
#~ msgstr ""

#~ msgid ""
#~ "sensor_type: PT1000\n"
#~ "sensor_pin:\n"
#~ "#   Analog input pin connected to the sensor. This parameter must be\n"
#~ "#   provided.\n"
#~ "#pullup_resistor: 4700\n"
#~ "#   The resistance (in ohms) of the pullup attached to the sensor. The\n"
#~ "#   default is 4700 ohms.\n"
#~ msgstr ""

#~ msgid "MAXxxxxx temperature sensors"
#~ msgstr ""

#~ msgid ""
#~ "MAXxxxxx serial peripheral interface (SPI) temperature based sensors. The "
#~ "following parameters are available in heater sections that use one of these "
#~ "sensor types."
#~ msgstr ""

#~ msgid ""
#~ "sensor_type:\n"
#~ "#   One of \"MAX6675\", \"MAX31855\", \"MAX31856\", or \"MAX31865\".\n"
#~ "sensor_pin:\n"
#~ "#   The chip select line for the sensor chip. This parameter must be\n"
#~ "#   provided.\n"
#~ "#spi_speed: 4000000\n"
#~ "#   The SPI speed (in hz) to use when communicating with the chip.\n"
#~ "#   The default is 4000000.\n"
#~ "#spi_bus:\n"
#~ "#spi_software_sclk_pin:\n"
#~ "#spi_software_mosi_pin:\n"
#~ "#spi_software_miso_pin:\n"
#~ "#   See the \"common SPI settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#tc_type: K\n"
#~ "#tc_use_50Hz_filter: False\n"
#~ "#tc_averaging_count: 1\n"
#~ "#   The above parameters control the sensor parameters of MAX31856\n"
#~ "#   chips. The defaults for each parameter are next to the parameter\n"
#~ "#   name in the above list.\n"
#~ "#rtd_nominal_r: 100\n"
#~ "#rtd_reference_r: 430\n"
#~ "#rtd_num_of_wires: 2\n"
#~ "#rtd_use_50Hz_filter: False\n"
#~ "#   The above parameters control the sensor parameters of MAX31865\n"
#~ "#   chips. The defaults for each parameter are next to the parameter\n"
#~ "#   name in the above list.\n"
#~ msgstr ""

#~ msgid "BMP280/BME280/BME680 temperature sensor"
#~ msgstr ""

#~ msgid ""
#~ "BMP280/BME280/BME680 two wire interface (I2C) environmental sensors. Note "
#~ "that these sensors are not intended for use with extruders and heater beds, "
#~ "but rather for monitoring ambient temperature (C), pressure (hPa), relative "
#~ "humidity and in case of the BME680 gas level. See [sample-"
#~ "macros.cfg](../config/sample-macros.cfg) for a gcode_macro that may be used "
#~ "to report pressure and humidity in addition to temperature."
#~ msgstr ""

#~ msgid ""
#~ "sensor_type: BME280\n"
#~ "#i2c_address:\n"
#~ "#   Default is 118 (0x76). Some BME280 sensors have an address of 119\n"
#~ "#   (0x77).\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ msgstr ""

#~ msgid "HTU21D sensor"
#~ msgstr ""

#~ msgid ""
#~ "HTU21D family two wire interface (I2C) environmental sensor. Note that this "
#~ "sensor is not intended for use with extruders and heater beds, but rather "
#~ "for monitoring ambient temperature (C) and relative humidity. See [sample-"
#~ "macros.cfg](../config/sample-macros.cfg) for a gcode_macro that may be used "
#~ "to report humidity in addition to temperature."
#~ msgstr ""

#~ msgid ""
#~ "sensor_type:\n"
#~ "#   Must be \"HTU21D\" , \"SI7013\", \"SI7020\", \"SI7021\" or \"SHT21\"\n"
#~ "#i2c_address:\n"
#~ "#   Default is 64 (0x40).\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#htu21d_hold_master:\n"
#~ "#   If the sensor can hold the I2C buf while reading. If True no other\n"
#~ "#   bus communication can be performed while reading is in progress.\n"
#~ "#   Default is False.\n"
#~ "#htu21d_resolution:\n"
#~ "#   The resolution of temperature and humidity reading.\n"
#~ "#   Valid values are:\n"
#~ "#    'TEMP14_HUM12' -> 14bit for Temp and 12bit for humidity\n"
#~ "#    'TEMP13_HUM10' -> 13bit for Temp and 10bit for humidity\n"
#~ "#    'TEMP12_HUM08' -> 12bit for Temp and 08bit for humidity\n"
#~ "#    'TEMP11_HUM11' -> 11bit for Temp and 11bit for humidity\n"
#~ "#   Default is: \"TEMP11_HUM11\"\n"
#~ "#htu21d_report_time:\n"
#~ "#   Interval in seconds between readings. Default is 30\n"
#~ msgstr ""

#~ msgid "LM75 temperature sensor"
#~ msgstr ""

#~ msgid ""
#~ "LM75/LM75A two wire (I2C) connected temperature sensors. These sensors have "
#~ "a range of -55~125 C, so are usable for e.g. chamber temperature monitoring."
#~ " They can also function as simple fan/heater controllers."
#~ msgstr ""

#~ msgid ""
#~ "sensor_type: LM75\n"
#~ "#i2c_address:\n"
#~ "#   Default is 72 (0x48). Normal range is 72-79 (0x48-0x4F) and the 3\n"
#~ "#   low bits of the address are configured via pins on the chip\n"
#~ "#   (usually with jumpers or hard wired).\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#lm75_report_time:\n"
#~ "#   Interval in seconds between readings. Default is 0.8, with minimum\n"
#~ "#   0.5.\n"
#~ msgstr ""

#~ msgid "Builtin micro-controller temperature sensor"
#~ msgstr ""

#~ msgid ""
#~ "The atsam, atsamd, and stm32 micro-controllers contain an internal "
#~ "temperature sensor. One can use the \"temperature_mcu\" sensor to monitor "
#~ "these temperatures."
#~ msgstr ""

#~ msgid ""
#~ "sensor_type: temperature_mcu\n"
#~ "#sensor_mcu: mcu\n"
#~ "#   The micro-controller to read from. The default is \"mcu\".\n"
#~ "#sensor_temperature1:\n"
#~ "#sensor_adc1:\n"
#~ "#   Specify the above two parameters (a temperature in Celsius and an\n"
#~ "#   ADC value as a float between 0.0 and 1.0) to calibrate the\n"
#~ "#   micro-controller temperature. This may improve the reported\n"
#~ "#   temperature accuracy on some chips. A typical way to obtain this\n"
#~ "#   calibration information is to completely remove power from the\n"
#~ "#   printer for a few hours (to ensure it is at the ambient\n"
#~ "#   temperature), then power it up and use the QUERY_ADC command to\n"
#~ "#   obtain an ADC measurement. Use some other temperature sensor on\n"
#~ "#   the printer to find the corresponding ambient temperature. The\n"
#~ "#   default is to use the factory calibration data on the\n"
#~ "#   micro-controller (if applicable) or the nominal values from the\n"
#~ "#   micro-controller specification.\n"
#~ "#sensor_temperature2:\n"
#~ "#sensor_adc2:\n"
#~ "#   If sensor_temperature1/sensor_adc1 is specified then one may also\n"
#~ "#   specify sensor_temperature2/sensor_adc2 calibration data. Doing so\n"
#~ "#   may provide calibrated \"temperature slope\" information. The\n"
#~ "#   default is to use the factory calibration data on the\n"
#~ "#   micro-controller (if applicable) or the nominal values from the\n"
#~ "#   micro-controller specification.\n"
#~ msgstr ""

#~ msgid "Host temperature sensor"
#~ msgstr ""

#~ msgid ""
#~ "Temperature from the machine (eg Raspberry Pi) running the host software."
#~ msgstr ""

#~ msgid ""
#~ "sensor_type: temperature_host\n"
#~ "#sensor_path:\n"
#~ "#   The path to temperature system file. The default is\n"
#~ "#   \"/sys/class/thermal/thermal_zone0/temp\" which is the temperature\n"
#~ "#   system file on a Raspberry Pi computer.\n"
#~ msgstr ""

#~ msgid "DS18B20 temperature sensor"
#~ msgstr ""

#~ msgid ""
#~ "DS18B20 is a 1-wire (w1) digital temperature sensor. Note that this sensor "
#~ "is not intended for use with extruders and heater beds, but rather for "
#~ "monitoring ambient temperature (C). These sensors have range up to 125 C, so"
#~ " are usable for e.g. chamber temperature monitoring. They can also function "
#~ "as simple fan/heater controllers. DS18B20 sensors are only supported on the "
#~ "\"host mcu\", e.g. the Raspberry Pi. The w1-gpio Linux kernel module must be"
#~ " installed."
#~ msgstr ""

#~ msgid ""
#~ "sensor_type: DS18B20\n"
#~ "serial_no:\n"
#~ "#   Each 1-wire device has a unique serial number used to identify the device,\n"
#~ "#   usually in the format 28-031674b175ff. This parameter must be provided.\n"
#~ "#   Attached 1-wire devices can be listed using the following Linux command:\n"
#~ "#   ls /sys/bus/w1/devices/\n"
#~ "#ds18_report_time:\n"
#~ "#   Interval in seconds between readings. Default is 3.0, with a minimum of 1.0\n"
#~ "#sensor_mcu:\n"
#~ "#   The micro-controller to read from. Must be the host_mcu\n"
#~ msgstr ""

#~ msgid "Fans"
#~ msgstr ""

#~ msgid "[fan]"
#~ msgstr ""

#~ msgid "Print cooling fan."
#~ msgstr ""

#~ msgid ""
#~ "[fan]\n"
#~ "pin:\n"
#~ "#   Output pin controlling the fan. This parameter must be provided.\n"
#~ "#max_power: 1.0\n"
#~ "#   The maximum power (expressed as a value from 0.0 to 1.0) that the\n"
#~ "#   pin may be set to. The value 1.0 allows the pin to be set fully\n"
#~ "#   enabled for extended periods, while a value of 0.5 would allow the\n"
#~ "#   pin to be enabled for no more than half the time. This setting may\n"
#~ "#   be used to limit the total power output (over extended periods) to\n"
#~ "#   the fan. If this value is less than 1.0 then fan speed requests\n"
#~ "#   will be scaled between zero and max_power (for example, if\n"
#~ "#   max_power is .9 and a fan speed of 80% is requested then the fan\n"
#~ "#   power will be set to 72%). The default is 1.0.\n"
#~ "#shutdown_speed: 0\n"
#~ "#   The desired fan speed (expressed as a value from 0.0 to 1.0) if\n"
#~ "#   the micro-controller software enters an error state. The default\n"
#~ "#   is 0.\n"
#~ "#cycle_time: 0.010\n"
#~ "#   The amount of time (in seconds) for each PWM power cycle to the\n"
#~ "#   fan. It is recommended this be 10 milliseconds or greater when\n"
#~ "#   using software based PWM. The default is 0.010 seconds.\n"
#~ "#hardware_pwm: False\n"
#~ "#   Enable this to use hardware PWM instead of software PWM. Most fans\n"
#~ "#   do not work well with hardware PWM, so it is not recommended to\n"
#~ "#   enable this unless there is an electrical requirement to switch at\n"
#~ "#   very high speeds. When using hardware PWM the actual cycle time is\n"
#~ "#   constrained by the implementation and may be significantly\n"
#~ "#   different than the requested cycle_time. The default is False.\n"
#~ "#kick_start_time: 0.100\n"
#~ "#   Time (in seconds) to run the fan at full speed when either first\n"
#~ "#   enabling or increasing it by more than 50% (helps get the fan\n"
#~ "#   spinning). The default is 0.100 seconds.\n"
#~ "#off_below: 0.0\n"
#~ "#   The minimum input speed which will power the fan (expressed as a\n"
#~ "#   value from 0.0 to 1.0). When a speed lower than off_below is\n"
#~ "#   requested the fan will instead be turned off. This setting may be\n"
#~ "#   used to prevent fan stalls and to ensure kick starts are\n"
#~ "#   effective. The default is 0.0.\n"
#~ "#\n"
#~ "#   This setting should be recalibrated whenever max_power is adjusted.\n"
#~ "#   To calibrate this setting, start with off_below set to 0.0 and the\n"
#~ "#   fan spinning. Gradually lower the fan speed to determine the lowest\n"
#~ "#   input speed which reliably drives the fan without stalls. Set\n"
#~ "#   off_below to the duty cycle corresponding to this value (for\n"
#~ "#   example, 12% -> 0.12) or slightly higher.\n"
#~ "#tachometer_pin:\n"
#~ "#   Tachometer input pin for monitoring fan speed. A pullup is generally\n"
#~ "#   required. This parameter is optional.\n"
#~ "#tachometer_ppr: 2\n"
#~ "#   When tachometer_pin is specified, this is the number of pulses per\n"
#~ "#   revolution of the tachometer signal. For a BLDC fan this is\n"
#~ "#   normally half the number of poles. The default is 2.\n"
#~ "#tachometer_poll_interval: 0.0015\n"
#~ "#   When tachometer_pin is specified, this is the polling period of the\n"
#~ "#   tachometer pin, in seconds. The default is 0.0015, which is fast\n"
#~ "#   enough for fans below 10000 RPM at 2 PPR. This must be smaller than\n"
#~ "#   30/(tachometer_ppr*rpm), with some margin, where rpm is the\n"
#~ "#   maximum speed (in RPM) of the fan.\n"
#~ "#enable_pin:\n"
#~ "#   Optional pin to enable power to the fan. This can be useful for fans\n"
#~ "#   with dedicated PWM inputs. Some of these fans stay on even at 0% PWM\n"
#~ "#   input. In such a case, the PWM pin can be used normally, and e.g. a\n"
#~ "#   ground-switched FET(standard fan pin) can be used to control power to\n"
#~ "#   the fan.\n"
#~ msgstr ""

#~ msgid "[heater_fan]"
#~ msgstr ""

#~ msgid ""
#~ "Heater cooling fans (one may define any number of sections with a "
#~ "\"heater_fan\" prefix). A \"heater fan\" is a fan that will be enabled "
#~ "whenever its associated heater is active. By default, a heater_fan has a "
#~ "shutdown_speed equal to max_power."
#~ msgstr ""

#~ msgid ""
#~ "[heater_fan my_nozzle_fan]\n"
#~ "#pin:\n"
#~ "#max_power:\n"
#~ "#shutdown_speed:\n"
#~ "#cycle_time:\n"
#~ "#hardware_pwm:\n"
#~ "#kick_start_time:\n"
#~ "#off_below:\n"
#~ "#tachometer_pin:\n"
#~ "#tachometer_ppr:\n"
#~ "#tachometer_poll_interval:\n"
#~ "#enable_pin:\n"
#~ "#   See the \"fan\" section for a description of the above parameters.\n"
#~ "#heater: extruder\n"
#~ "#   Name of the config section defining the heater that this fan is\n"
#~ "#   associated with. If a comma separated list of heater names is\n"
#~ "#   provided here, then the fan will be enabled when any of the given\n"
#~ "#   heaters are enabled. The default is \"extruder\".\n"
#~ "#heater_temp: 50.0\n"
#~ "#   A temperature (in Celsius) that the heater must drop below before\n"
#~ "#   the fan is disabled. The default is 50 Celsius.\n"
#~ "#fan_speed: 1.0\n"
#~ "#   The fan speed (expressed as a value from 0.0 to 1.0) that the fan\n"
#~ "#   will be set to when its associated heater is enabled. The default\n"
#~ "#   is 1.0\n"
#~ msgstr ""

#~ msgid "[controller_fan]"
#~ msgstr ""

#~ msgid ""
#~ "Controller cooling fan (one may define any number of sections with a "
#~ "\"controller_fan\" prefix). A \"controller fan\" is a fan that will be "
#~ "enabled whenever its associated heater or its associated stepper driver is "
#~ "active. The fan will stop whenever an idle_timeout is reached to ensure no "
#~ "overheating will occur after deactivating a watched component."
#~ msgstr ""

#~ msgid ""
#~ "[controller_fan my_controller_fan]\n"
#~ "#pin:\n"
#~ "#max_power:\n"
#~ "#shutdown_speed:\n"
#~ "#cycle_time:\n"
#~ "#hardware_pwm:\n"
#~ "#kick_start_time:\n"
#~ "#off_below:\n"
#~ "#tachometer_pin:\n"
#~ "#tachometer_ppr:\n"
#~ "#tachometer_poll_interval:\n"
#~ "#enable_pin:\n"
#~ "#   See the \"fan\" section for a description of the above parameters.\n"
#~ "#fan_speed: 1.0\n"
#~ "#   The fan speed (expressed as a value from 0.0 to 1.0) that the fan\n"
#~ "#   will be set to when a heater or stepper driver is active.\n"
#~ "#   The default is 1.0\n"
#~ "#idle_timeout:\n"
#~ "#   The amount of time (in seconds) after a stepper driver or heater\n"
#~ "#   was active and the fan should be kept running. The default\n"
#~ "#   is 30 seconds.\n"
#~ "#idle_speed:\n"
#~ "#   The fan speed (expressed as a value from 0.0 to 1.0) that the fan\n"
#~ "#   will be set to when a heater or stepper driver was active and\n"
#~ "#   before the idle_timeout is reached. The default is fan_speed.\n"
#~ "#heater:\n"
#~ "#stepper:\n"
#~ "#   Name of the config section defining the heater/stepper that this fan\n"
#~ "#   is associated with. If a comma separated list of heater/stepper names\n"
#~ "#   is provided here, then the fan will be enabled when any of the given\n"
#~ "#   heaters/steppers are enabled. The default heater is \"extruder\", the\n"
#~ "#   default stepper is all of them.\n"
#~ msgstr ""

#~ msgid ""
#~ "Temperature-triggered cooling fans (one may define any number of sections "
#~ "with a \"temperature_fan\" prefix). A \"temperature fan\" is a fan that will"
#~ " be enabled whenever its associated sensor is above a set temperature. By "
#~ "default, a temperature_fan has a shutdown_speed equal to max_power."
#~ msgstr ""

#~ msgid ""
#~ "See the [command reference](G-Codes.md#temperature_fan) for additional "
#~ "information."
#~ msgstr ""

#~ msgid ""
#~ "[temperature_fan my_temp_fan]\n"
#~ "#pin:\n"
#~ "#max_power:\n"
#~ "#shutdown_speed:\n"
#~ "#cycle_time:\n"
#~ "#hardware_pwm:\n"
#~ "#kick_start_time:\n"
#~ "#off_below:\n"
#~ "#tachometer_pin:\n"
#~ "#tachometer_ppr:\n"
#~ "#tachometer_poll_interval:\n"
#~ "#enable_pin:\n"
#~ "#   See the \"fan\" section for a description of the above parameters.\n"
#~ "#sensor_type:\n"
#~ "#sensor_pin:\n"
#~ "#control:\n"
#~ "#max_delta:\n"
#~ "#min_temp:\n"
#~ "#max_temp:\n"
#~ "#   See the \"extruder\" section for a description of the above parameters.\n"
#~ "#pid_Kp:\n"
#~ "#pid_Ki:\n"
#~ "#pid_Kd:\n"
#~ "#   The proportional (pid_Kp), integral (pid_Ki), and derivative\n"
#~ "#   (pid_Kd) settings for the PID feedback control system. Klipper\n"
#~ "#   evaluates the PID settings with the following general formula:\n"
#~ "#     fan_pwm = max_power - (Kp*e + Ki*integral(e) - Kd*derivative(e)) / 255\n"
#~ "#   Where \"e\" is \"target_temperature - measured_temperature\" and\n"
#~ "#   \"fan_pwm\" is the requested fan rate with 0.0 being full off and\n"
#~ "#   1.0 being full on. The pid_Kp, pid_Ki, and pid_Kd parameters must\n"
#~ "#   be provided when the PID control algorithm is enabled.\n"
#~ "#pid_deriv_time: 2.0\n"
#~ "#   A time value (in seconds) over which temperature measurements will\n"
#~ "#   be smoothed when using the PID control algorithm. This may reduce\n"
#~ "#   the impact of measurement noise. The default is 2 seconds.\n"
#~ "#target_temp: 40.0\n"
#~ "#   A temperature (in Celsius) that will be the target temperature.\n"
#~ "#   The default is 40 degrees.\n"
#~ "#max_speed: 1.0\n"
#~ "#   The fan speed (expressed as a value from 0.0 to 1.0) that the fan\n"
#~ "#   will be set to when the sensor temperature exceeds the set value.\n"
#~ "#   The default is 1.0.\n"
#~ "#min_speed: 0.3\n"
#~ "#   The minimum fan speed (expressed as a value from 0.0 to 1.0) that\n"
#~ "#   the fan will be set to for PID temperature fans.\n"
#~ "#   The default is 0.3.\n"
#~ "#gcode_id:\n"
#~ "#   If set, the temperature will be reported in M105 queries using the\n"
#~ "#   given id. The default is to not report the temperature via M105.\n"
#~ msgstr ""

#~ msgid ""
#~ "Manually controlled fan (one may define any number of sections with a "
#~ "\"fan_generic\" prefix). The speed of a manually controlled fan is set with "
#~ "the SET_FAN_SPEED [gcode command](G-Codes.md#fan_generic)."
#~ msgstr ""

#~ msgid ""
#~ "[fan_generic extruder_partfan]\n"
#~ "#pin:\n"
#~ "#max_power:\n"
#~ "#shutdown_speed:\n"
#~ "#cycle_time:\n"
#~ "#hardware_pwm:\n"
#~ "#kick_start_time:\n"
#~ "#off_below:\n"
#~ "#tachometer_pin:\n"
#~ "#tachometer_ppr:\n"
#~ "#tachometer_poll_interval:\n"
#~ "#enable_pin:\n"
#~ "#   See the \"fan\" section for a description of the above parameters.\n"
#~ msgstr ""

#~ msgid "LEDs"
#~ msgstr ""

#~ msgid ""
#~ "Support for LEDs (and LED strips) controlled via micro-controller PWM pins "
#~ "(one may define any number of sections with an \"led\" prefix). See the "
#~ "[command reference](G-Codes.md#led) for more information."
#~ msgstr ""

#~ msgid ""
#~ "[led my_led]\n"
#~ "#red_pin:\n"
#~ "#green_pin:\n"
#~ "#blue_pin:\n"
#~ "#white_pin:\n"
#~ "#   The pin controlling the given LED color. At least one of the above\n"
#~ "#   parameters must be provided.\n"
#~ "#cycle_time: 0.010\n"
#~ "#   The amount of time (in seconds) per PWM cycle. It is recommended\n"
#~ "#   this be 10 milliseconds or greater when using software based PWM.\n"
#~ "#   The default is 0.010 seconds.\n"
#~ "#hardware_pwm: False\n"
#~ "#   Enable this to use hardware PWM instead of software PWM. When\n"
#~ "#   using hardware PWM the actual cycle time is constrained by the\n"
#~ "#   implementation and may be significantly different than the\n"
#~ "#   requested cycle_time. The default is False.\n"
#~ "#initial_RED: 0.0\n"
#~ "#initial_GREEN: 0.0\n"
#~ "#initial_BLUE: 0.0\n"
#~ "#initial_WHITE: 0.0\n"
#~ "#   Sets the initial LED color. Each value should be between 0.0 and\n"
#~ "#   1.0. The default for each color is 0.\n"
#~ msgstr ""

#~ msgid "[neopixel]"
#~ msgstr ""

#~ msgid ""
#~ "Neopixel (aka WS2812) LED support (one may define any number of sections "
#~ "with a \"neopixel\" prefix). See the [command reference](G-Codes.md#led) for"
#~ " more information."
#~ msgstr ""

#~ msgid ""
#~ "Note that the [linux mcu](RPi_microcontroller.md) implementation does not "
#~ "currently support directly connected neopixels. The current design using the"
#~ " Linux kernel interface does not allow this scenario because the kernel GPIO"
#~ " interface is not fast enough to provide the required pulse rates."
#~ msgstr ""

#~ msgid ""
#~ "[neopixel my_neopixel]\n"
#~ "pin:\n"
#~ "#   The pin connected to the neopixel. This parameter must be\n"
#~ "#   provided.\n"
#~ "#chain_count:\n"
#~ "#   The number of Neopixel chips that are \"daisy chained\" to the\n"
#~ "#   provided pin. The default is 1 (which indicates only a single\n"
#~ "#   Neopixel is connected to the pin).\n"
#~ "#color_order: GRB\n"
#~ "#   Set the pixel order required by the LED hardware (using a string\n"
#~ "#   containing the letters R, G, B, W with W optional). Alternatively,\n"
#~ "#   this may be a comma separated list of pixel orders - one for each\n"
#~ "#   LED in the chain. The default is GRB.\n"
#~ "#initial_RED: 0.0\n"
#~ "#initial_GREEN: 0.0\n"
#~ "#initial_BLUE: 0.0\n"
#~ "#initial_WHITE: 0.0\n"
#~ "#   See the \"led\" section for information on these parameters.\n"
#~ msgstr ""

#~ msgid "[dotstar]"
#~ msgstr ""

#~ msgid ""
#~ "Dotstar (aka APA102) LED support (one may define any number of sections with"
#~ " a \"dotstar\" prefix). See the [command reference](G-Codes.md#led) for more"
#~ " information."
#~ msgstr ""

#~ msgid ""
#~ "[dotstar my_dotstar]\n"
#~ "data_pin:\n"
#~ "#   The pin connected to the data line of the dotstar. This parameter\n"
#~ "#   must be provided.\n"
#~ "clock_pin:\n"
#~ "#   The pin connected to the clock line of the dotstar. This parameter\n"
#~ "#   must be provided.\n"
#~ "#chain_count:\n"
#~ "#   See the \"neopixel\" section for information on this parameter.\n"
#~ "#initial_RED: 0.0\n"
#~ "#initial_GREEN: 0.0\n"
#~ "#initial_BLUE: 0.0\n"
#~ "#   See the \"led\" section for information on these parameters.\n"
#~ msgstr ""

#~ msgid "[pca9533]"
#~ msgstr ""

#~ msgid "PCA9533 LED support. The PCA9533 is used on the mightyboard."
#~ msgstr ""

#~ msgid ""
#~ "[pca9533 my_pca9533]\n"
#~ "#i2c_address: 98\n"
#~ "#   The i2c address that the chip is using on the i2c bus. Use 98 for\n"
#~ "#   the PCA9533/1, 99 for the PCA9533/2. The default is 98.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#initial_RED: 0.0\n"
#~ "#initial_GREEN: 0.0\n"
#~ "#initial_BLUE: 0.0\n"
#~ "#initial_WHITE: 0.0\n"
#~ "#   See the \"led\" section for information on these parameters.\n"
#~ msgstr ""

#~ msgid "[pca9632]"
#~ msgstr ""

#~ msgid "PCA9632 LED support. The PCA9632 is used on the FlashForge Dreamer."
#~ msgstr ""

#~ msgid ""
#~ "[pca9632 my_pca9632]\n"
#~ "#i2c_address: 98\n"
#~ "#   The i2c address that the chip is using on the i2c bus. This may be\n"
#~ "#   96, 97, 98, or 99.  The default is 98.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#scl_pin:\n"
#~ "#sda_pin:\n"
#~ "#   Alternatively, if the pca9632 is not connected to a hardware I2C\n"
#~ "#   bus, then one may specify the \"clock\" (scl_pin) and \"data\"\n"
#~ "#   (sda_pin) pins. The default is to use hardware I2C.\n"
#~ "#color_order: RGBW\n"
#~ "#   Set the pixel order of the LED (using a string containing the\n"
#~ "#   letters R, G, B, W). The default is RGBW.\n"
#~ "#initial_RED: 0.0\n"
#~ "#initial_GREEN: 0.0\n"
#~ "#initial_BLUE: 0.0\n"
#~ "#initial_WHITE: 0.0\n"
#~ "#   See the \"led\" section for information on these parameters.\n"
#~ msgstr ""

#~ msgid "Additional servos, buttons, and other pins"
#~ msgstr ""

#~ msgid ""
#~ "Servos (one may define any number of sections with a \"servo\" prefix). The "
#~ "servos may be controlled using the SET_SERVO [g-code "
#~ "command](G-Codes.md#servo). For example: SET_SERVO SERVO=my_servo ANGLE=180"
#~ msgstr ""

#~ msgid ""
#~ "[servo my_servo]\n"
#~ "pin:\n"
#~ "#   PWM output pin controlling the servo. This parameter must be\n"
#~ "#   provided.\n"
#~ "#maximum_servo_angle: 180\n"
#~ "#   The maximum angle (in degrees) that this servo can be set to. The\n"
#~ "#   default is 180 degrees.\n"
#~ "#minimum_pulse_width: 0.001\n"
#~ "#   The minimum pulse width time (in seconds). This should correspond\n"
#~ "#   with an angle of 0 degrees. The default is 0.001 seconds.\n"
#~ "#maximum_pulse_width: 0.002\n"
#~ "#   The maximum pulse width time (in seconds). This should correspond\n"
#~ "#   with an angle of maximum_servo_angle. The default is 0.002\n"
#~ "#   seconds.\n"
#~ "#initial_angle:\n"
#~ "#   Initial angle (in degrees) to set the servo to. The default is to\n"
#~ "#   not send any signal at startup.\n"
#~ "#initial_pulse_width:\n"
#~ "#   Initial pulse width time (in seconds) to set the servo to. (This\n"
#~ "#   is only valid if initial_angle is not set.) The default is to not\n"
#~ "#   send any signal at startup.\n"
#~ msgstr ""

#~ msgid "[gcode_button]"
#~ msgstr ""

#~ msgid ""
#~ "Execute gcode when a button is pressed or released (or when a pin changes "
#~ "state). You can check the state of the button by using `QUERY_BUTTON "
#~ "button=my_gcode_button`."
#~ msgstr ""

#~ msgid ""
#~ "[gcode_button my_gcode_button]\n"
#~ "pin:\n"
#~ "#   The pin on which the button is connected. This parameter must be\n"
#~ "#   provided.\n"
#~ "#analog_range:\n"
#~ "#   Two comma separated resistances (in Ohms) specifying the minimum\n"
#~ "#   and maximum resistance range for the button. If analog_range is\n"
#~ "#   provided then the pin must be an analog capable pin. The default\n"
#~ "#   is to use digital gpio for the button.\n"
#~ "#analog_pullup_resistor:\n"
#~ "#   The pullup resistance (in Ohms) when analog_range is specified.\n"
#~ "#   The default is 4700 ohms.\n"
#~ "#press_gcode:\n"
#~ "#   A list of G-Code commands to execute when the button is pressed.\n"
#~ "#   G-Code templates are supported. This parameter must be provided.\n"
#~ "#release_gcode:\n"
#~ "#   A list of G-Code commands to execute when the button is released.\n"
#~ "#   G-Code templates are supported. The default is to not run any\n"
#~ "#   commands on a button release.\n"
#~ msgstr ""

#~ msgid ""
#~ "Run-time configurable output pins (one may define any number of sections "
#~ "with an \"output_pin\" prefix). Pins configured here will be setup as output"
#~ " pins and one may modify them at run-time using \"SET_PIN PIN=my_pin "
#~ "VALUE=.1\" type extended [g-code commands](G-Codes.md#output_pin)."
#~ msgstr ""

#~ msgid ""
#~ "[output_pin my_pin]\n"
#~ "pin:\n"
#~ "#   The pin to configure as an output. This parameter must be\n"
#~ "#   provided.\n"
#~ "#pwm: False\n"
#~ "#   Set if the output pin should be capable of pulse-width-modulation.\n"
#~ "#   If this is true, the value fields should be between 0 and 1; if it\n"
#~ "#   is false the value fields should be either 0 or 1. The default is\n"
#~ "#   False.\n"
#~ "#static_value:\n"
#~ "#   If this is set, then the pin is assigned to this value at startup\n"
#~ "#   and the pin can not be changed during runtime. A static pin uses\n"
#~ "#   slightly less ram in the micro-controller. The default is to use\n"
#~ "#   runtime configuration of pins.\n"
#~ "#value:\n"
#~ "#   The value to initially set the pin to during MCU configuration.\n"
#~ "#   The default is 0 (for low voltage).\n"
#~ "#shutdown_value:\n"
#~ "#   The value to set the pin to on an MCU shutdown event. The default\n"
#~ "#   is 0 (for low voltage).\n"
#~ "#maximum_mcu_duration:\n"
#~ "#   The maximum duration a non-shutdown value may be driven by the MCU\n"
#~ "#   without an acknowledge from the host.\n"
#~ "#   If host can not keep up with an update, the MCU will shutdown\n"
#~ "#   and set all pins to their respective shutdown values.\n"
#~ "#   Default: 0 (disabled)\n"
#~ "#   Usual values are around 5 seconds.\n"
#~ "#cycle_time: 0.100\n"
#~ "#   The amount of time (in seconds) per PWM cycle. It is recommended\n"
#~ "#   this be 10 milliseconds or greater when using software based PWM.\n"
#~ "#   The default is 0.100 seconds for pwm pins.\n"
#~ "#hardware_pwm: False\n"
#~ "#   Enable this to use hardware PWM instead of software PWM. When\n"
#~ "#   using hardware PWM the actual cycle time is constrained by the\n"
#~ "#   implementation and may be significantly different than the\n"
#~ "#   requested cycle_time. The default is False.\n"
#~ "#scale:\n"
#~ "#   This parameter can be used to alter how the 'value' and\n"
#~ "#   'shutdown_value' parameters are interpreted for pwm pins. If\n"
#~ "#   provided, then the 'value' parameter should be between 0.0 and\n"
#~ "#   'scale'. This may be useful when configuring a PWM pin that\n"
#~ "#   controls a stepper voltage reference. The 'scale' can be set to\n"
#~ "#   the equivalent stepper amperage if the PWM were fully enabled, and\n"
#~ "#   then the 'value' parameter can be specified using the desired\n"
#~ "#   amperage for the stepper. The default is to not scale the 'value'\n"
#~ "#   parameter.\n"
#~ msgstr ""

#~ msgid "[static_digital_output]"
#~ msgstr ""

#~ msgid ""
#~ "Statically configured digital output pins (one may define any number of "
#~ "sections with a \"static_digital_output\" prefix). Pins configured here will"
#~ " be setup as a GPIO output during MCU configuration. They can not be changed"
#~ " at run-time."
#~ msgstr ""

#~ msgid ""
#~ "[static_digital_output my_output_pins]\n"
#~ "pins:\n"
#~ "#   A comma separated list of pins to be set as GPIO output pins. The\n"
#~ "#   pin will be set to a high level unless the pin name is prefaced\n"
#~ "#   with \"!\". This parameter must be provided.\n"
#~ msgstr ""

#~ msgid "[multi_pin]"
#~ msgstr ""

#~ msgid ""
#~ "Multiple pin outputs (one may define any number of sections with a "
#~ "\"multi_pin\" prefix). A multi_pin output creates an internal pin alias that"
#~ " can modify multiple output pins each time the alias pin is set. For "
#~ "example, one could define a \"[multi_pin my_fan]\" object containing two "
#~ "pins and then set \"pin=multi_pin:my_fan\" in the \"[fan]\" section - on "
#~ "each fan change both output pins would be updated. These aliases may not be "
#~ "used with stepper motor pins."
#~ msgstr ""

#~ msgid ""
#~ "[multi_pin my_multi_pin]\n"
#~ "pins:\n"
#~ "#   A comma separated list of pins associated with this alias. This\n"
#~ "#   parameter must be provided.\n"
#~ msgstr ""

#~ msgid "TMC stepper driver configuration"
#~ msgstr ""

#~ msgid ""
#~ "Configuration of Trinamic stepper motor drivers in UART/SPI mode. Additional"
#~ " information is in the [TMC Drivers guide](TMC_Drivers.md) and in the "
#~ "[command reference](G-Codes.md#tmcxxxx)."
#~ msgstr ""

#~ msgid "[tmc2130]"
#~ msgstr ""

#~ msgid ""
#~ "Configure a TMC2130 stepper motor driver via SPI bus. To use this feature, "
#~ "define a config section with a \"tmc2130\" prefix followed by the name of "
#~ "the corresponding stepper config section (for example, \"[tmc2130 "
#~ "stepper_x]\")."
#~ msgstr ""

#~ msgid ""
#~ "[tmc2130 stepper_x]\n"
#~ "cs_pin:\n"
#~ "#   The pin corresponding to the TMC2130 chip select line. This pin\n"
#~ "#   will be set to low at the start of SPI messages and raised to high\n"
#~ "#   after the message completes. This parameter must be provided.\n"
#~ "#spi_speed:\n"
#~ "#spi_bus:\n"
#~ "#spi_software_sclk_pin:\n"
#~ "#spi_software_mosi_pin:\n"
#~ "#spi_software_miso_pin:\n"
#~ "#   See the \"common SPI settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#chain_position:\n"
#~ "#chain_length:\n"
#~ "#   These parameters configure an SPI daisy chain. The two parameters\n"
#~ "#   define the stepper position in the chain and the total chain length.\n"
#~ "#   Position 1 corresponds to the stepper that connects to the MOSI signal.\n"
#~ "#   The default is to not use an SPI daisy chain.\n"
#~ "#interpolate: True\n"
#~ "#   If true, enable step interpolation (the driver will internally\n"
#~ "#   step at a rate of 256 micro-steps). This interpolation does\n"
#~ "#   introduce a small systemic positional deviation - see\n"
#~ "#   TMC_Drivers.md for details. The default is True.\n"
#~ "run_current:\n"
#~ "#   The amount of current (in amps RMS) to configure the driver to use\n"
#~ "#   during stepper movement. This parameter must be provided.\n"
#~ "#hold_current:\n"
#~ "#   The amount of current (in amps RMS) to configure the driver to use\n"
#~ "#   when the stepper is not moving. Setting a hold_current is not\n"
#~ "#   recommended (see TMC_Drivers.md for details). The default is to\n"
#~ "#   not reduce the current.\n"
#~ "#sense_resistor: 0.110\n"
#~ "#   The resistance (in ohms) of the motor sense resistor. The default\n"
#~ "#   is 0.110 ohms.\n"
#~ "#stealthchop_threshold: 0\n"
#~ "#   The velocity (in mm/s) to set the \"stealthChop\" threshold to. When\n"
#~ "#   set, \"stealthChop\" mode will be enabled if the stepper motor\n"
#~ "#   velocity is below this value. The default is 0, which disables\n"
#~ "#   \"stealthChop\" mode.\n"
#~ "#driver_IHOLDDELAY: 8\n"
#~ "#driver_TPOWERDOWN: 0\n"
#~ "#driver_TBL: 1\n"
#~ "#driver_TOFF: 4\n"
#~ "#driver_HEND: 7\n"
#~ "#driver_HSTRT: 0\n"
#~ "#driver_PWM_AUTOSCALE: True\n"
#~ "#driver_PWM_FREQ: 1\n"
#~ "#driver_PWM_GRAD: 4\n"
#~ "#driver_PWM_AMPL: 128\n"
#~ "#driver_SGT: 0\n"
#~ "#   Set the given register during the configuration of the TMC2130\n"
#~ "#   chip. This may be used to set custom motor parameters. The\n"
#~ "#   defaults for each parameter are next to the parameter name in the\n"
#~ "#   above list.\n"
#~ "#diag0_pin:\n"
#~ "#diag1_pin:\n"
#~ "#   The micro-controller pin attached to one of the DIAG lines of the\n"
#~ "#   TMC2130 chip. Only a single diag pin should be specified. The pin\n"
#~ "#   is \"active low\" and is thus normally prefaced with \"^!\". Setting\n"
#~ "#   this creates a \"tmc2130_stepper_x:virtual_endstop\" virtual pin\n"
#~ "#   which may be used as the stepper's endstop_pin. Doing this enables\n"
#~ "#   \"sensorless homing\". (Be sure to also set driver_SGT to an\n"
#~ "#   appropriate sensitivity value.) The default is to not enable\n"
#~ "#   sensorless homing.\n"
#~ msgstr ""

#~ msgid "[tmc2208]"
#~ msgstr ""

#~ msgid ""
#~ "Configure a TMC2208 (or TMC2224) stepper motor driver via single wire UART. "
#~ "To use this feature, define a config section with a \"tmc2208\" prefix "
#~ "followed by the name of the corresponding stepper config section (for "
#~ "example, \"[tmc2208 stepper_x]\")."
#~ msgstr ""

#~ msgid ""
#~ "[tmc2208 stepper_x]\n"
#~ "uart_pin:\n"
#~ "#   The pin connected to the TMC2208 PDN_UART line. This parameter\n"
#~ "#   must be provided.\n"
#~ "#tx_pin:\n"
#~ "#   If using separate receive and transmit lines to communicate with\n"
#~ "#   the driver then set uart_pin to the receive pin and tx_pin to the\n"
#~ "#   transmit pin. The default is to use uart_pin for both reading and\n"
#~ "#   writing.\n"
#~ "#select_pins:\n"
#~ "#   A comma separated list of pins to set prior to accessing the\n"
#~ "#   tmc2208 UART. This may be useful for configuring an analog mux for\n"
#~ "#   UART communication. The default is to not configure any pins.\n"
#~ "#interpolate: True\n"
#~ "#   If true, enable step interpolation (the driver will internally\n"
#~ "#   step at a rate of 256 micro-steps). This interpolation does\n"
#~ "#   introduce a small systemic positional deviation - see\n"
#~ "#   TMC_Drivers.md for details. The default is True.\n"
#~ "run_current:\n"
#~ "#   The amount of current (in amps RMS) to configure the driver to use\n"
#~ "#   during stepper movement. This parameter must be provided.\n"
#~ "#hold_current:\n"
#~ "#   The amount of current (in amps RMS) to configure the driver to use\n"
#~ "#   when the stepper is not moving. Setting a hold_current is not\n"
#~ "#   recommended (see TMC_Drivers.md for details). The default is to\n"
#~ "#   not reduce the current.\n"
#~ "#sense_resistor: 0.110\n"
#~ "#   The resistance (in ohms) of the motor sense resistor. The default\n"
#~ "#   is 0.110 ohms.\n"
#~ "#stealthchop_threshold: 0\n"
#~ "#   The velocity (in mm/s) to set the \"stealthChop\" threshold to. When\n"
#~ "#   set, \"stealthChop\" mode will be enabled if the stepper motor\n"
#~ "#   velocity is below this value. The default is 0, which disables\n"
#~ "#   \"stealthChop\" mode.\n"
#~ "#driver_IHOLDDELAY: 8\n"
#~ "#driver_TPOWERDOWN: 20\n"
#~ "#driver_TBL: 2\n"
#~ "#driver_TOFF: 3\n"
#~ "#driver_HEND: 0\n"
#~ "#driver_HSTRT: 5\n"
#~ "#driver_PWM_AUTOGRAD: True\n"
#~ "#driver_PWM_AUTOSCALE: True\n"
#~ "#driver_PWM_LIM: 12\n"
#~ "#driver_PWM_REG: 8\n"
#~ "#driver_PWM_FREQ: 1\n"
#~ "#driver_PWM_GRAD: 14\n"
#~ "#driver_PWM_OFS: 36\n"
#~ "#   Set the given register during the configuration of the TMC2208\n"
#~ "#   chip. This may be used to set custom motor parameters. The\n"
#~ "#   defaults for each parameter are next to the parameter name in the\n"
#~ "#   above list.\n"
#~ msgstr ""

#~ msgid "[tmc2209]"
#~ msgstr ""

#~ msgid ""
#~ "Configure a TMC2209 stepper motor driver via single wire UART. To use this "
#~ "feature, define a config section with a \"tmc2209\" prefix followed by the "
#~ "name of the corresponding stepper config section (for example, \"[tmc2209 "
#~ "stepper_x]\")."
#~ msgstr ""

#~ msgid ""
#~ "[tmc2209 stepper_x]\n"
#~ "uart_pin:\n"
#~ "#tx_pin:\n"
#~ "#select_pins:\n"
#~ "#interpolate: True\n"
#~ "run_current:\n"
#~ "#hold_current:\n"
#~ "#sense_resistor: 0.110\n"
#~ "#stealthchop_threshold: 0\n"
#~ "#   See the \"tmc2208\" section for the definition of these parameters.\n"
#~ "#uart_address:\n"
#~ "#   The address of the TMC2209 chip for UART messages (an integer\n"
#~ "#   between 0 and 3). This is typically used when multiple TMC2209\n"
#~ "#   chips are connected to the same UART pin. The default is zero.\n"
#~ "#driver_IHOLDDELAY: 8\n"
#~ "#driver_TPOWERDOWN: 20\n"
#~ "#driver_TBL: 2\n"
#~ "#driver_TOFF: 3\n"
#~ "#driver_HEND: 0\n"
#~ "#driver_HSTRT: 5\n"
#~ "#driver_PWM_AUTOGRAD: True\n"
#~ "#driver_PWM_AUTOSCALE: True\n"
#~ "#driver_PWM_LIM: 12\n"
#~ "#driver_PWM_REG: 8\n"
#~ "#driver_PWM_FREQ: 1\n"
#~ "#driver_PWM_GRAD: 14\n"
#~ "#driver_PWM_OFS: 36\n"
#~ "#driver_SGTHRS: 0\n"
#~ "#   Set the given register during the configuration of the TMC2209\n"
#~ "#   chip. This may be used to set custom motor parameters. The\n"
#~ "#   defaults for each parameter are next to the parameter name in the\n"
#~ "#   above list.\n"
#~ "#diag_pin:\n"
#~ "#   The micro-controller pin attached to the DIAG line of the TMC2209\n"
#~ "#   chip. The pin is normally prefaced with \"^\" to enable a pullup.\n"
#~ "#   Setting this creates a \"tmc2209_stepper_x:virtual_endstop\" virtual\n"
#~ "#   pin which may be used as the stepper's endstop_pin. Doing this\n"
#~ "#   enables \"sensorless homing\". (Be sure to also set driver_SGTHRS to\n"
#~ "#   an appropriate sensitivity value.) The default is to not enable\n"
#~ "#   sensorless homing.\n"
#~ msgstr ""

#~ msgid "[tmc2660]"
#~ msgstr ""

#~ msgid ""
#~ "Configure a TMC2660 stepper motor driver via SPI bus. To use this feature, "
#~ "define a config section with a tmc2660 prefix followed by the name of the "
#~ "corresponding stepper config section (for example, \"[tmc2660 stepper_x]\")."
#~ msgstr ""

#~ msgid ""
#~ "[tmc2660 stepper_x]\n"
#~ "cs_pin:\n"
#~ "#   The pin corresponding to the TMC2660 chip select line. This pin\n"
#~ "#   will be set to low at the start of SPI messages and set to high\n"
#~ "#   after the message transfer completes. This parameter must be\n"
#~ "#   provided.\n"
#~ "#spi_speed: 4000000\n"
#~ "#   SPI bus frequency used to communicate with the TMC2660 stepper\n"
#~ "#   driver. The default is 4000000.\n"
#~ "#spi_bus:\n"
#~ "#spi_software_sclk_pin:\n"
#~ "#spi_software_mosi_pin:\n"
#~ "#spi_software_miso_pin:\n"
#~ "#   See the \"common SPI settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#interpolate: True\n"
#~ "#   If true, enable step interpolation (the driver will internally\n"
#~ "#   step at a rate of 256 micro-steps). This only works if microsteps\n"
#~ "#   is set to 16. Interpolation does introduce a small systemic\n"
#~ "#   positional deviation - see TMC_Drivers.md for details. The default\n"
#~ "#   is True.\n"
#~ "run_current:\n"
#~ "#   The amount of current (in amps RMS) used by the driver during\n"
#~ "#   stepper movement. This parameter must be provided.\n"
#~ "#sense_resistor:\n"
#~ "#   The resistance (in ohms) of the motor sense resistor. This\n"
#~ "#   parameter must be provided.\n"
#~ "#idle_current_percent: 100\n"
#~ "#   The percentage of the run_current the stepper driver will be\n"
#~ "#   lowered to when the idle timeout expires (you need to set up the\n"
#~ "#   timeout using a [idle_timeout] config section). The current will\n"
#~ "#   be raised again once the stepper has to move again. Make sure to\n"
#~ "#   set this to a high enough value such that the steppers do not lose\n"
#~ "#   their position. There is also small delay until the current is\n"
#~ "#   raised again, so take this into account when commanding fast moves\n"
#~ "#   while the stepper is idling. The default is 100 (no reduction).\n"
#~ "#driver_TBL: 2\n"
#~ "#driver_RNDTF: 0\n"
#~ "#driver_HDEC: 0\n"
#~ "#driver_CHM: 0\n"
#~ "#driver_HEND: 3\n"
#~ "#driver_HSTRT: 3\n"
#~ "#driver_TOFF: 4\n"
#~ "#driver_SEIMIN: 0\n"
#~ "#driver_SEDN: 0\n"
#~ "#driver_SEMAX: 0\n"
#~ "#driver_SEUP: 0\n"
#~ "#driver_SEMIN: 0\n"
#~ "#driver_SFILT: 0\n"
#~ "#driver_SGT: 0\n"
#~ "#driver_SLPH: 0\n"
#~ "#driver_SLPL: 0\n"
#~ "#driver_DISS2G: 0\n"
#~ "#driver_TS2G: 3\n"
#~ "#   Set the given parameter during the configuration of the TMC2660\n"
#~ "#   chip. This may be used to set custom driver parameters. The\n"
#~ "#   defaults for each parameter are next to the parameter name in the\n"
#~ "#   list above. See the TMC2660 datasheet about what each parameter\n"
#~ "#   does and what the restrictions on parameter combinations are. Be\n"
#~ "#   especially aware of the CHOPCONF register, where setting CHM to\n"
#~ "#   either zero or one will lead to layout changes (the first bit of\n"
#~ "#   HDEC) is interpreted as the MSB of HSTRT in this case).\n"
#~ msgstr ""

#~ msgid "[tmc5160]"
#~ msgstr ""

#~ msgid ""
#~ "Configure a TMC5160 stepper motor driver via SPI bus. To use this feature, "
#~ "define a config section with a \"tmc5160\" prefix followed by the name of "
#~ "the corresponding stepper config section (for example, \"[tmc5160 "
#~ "stepper_x]\")."
#~ msgstr ""

#~ msgid ""
#~ "[tmc5160 stepper_x]\n"
#~ "cs_pin:\n"
#~ "#   The pin corresponding to the TMC5160 chip select line. This pin\n"
#~ "#   will be set to low at the start of SPI messages and raised to high\n"
#~ "#   after the message completes. This parameter must be provided.\n"
#~ "#spi_speed:\n"
#~ "#spi_bus:\n"
#~ "#spi_software_sclk_pin:\n"
#~ "#spi_software_mosi_pin:\n"
#~ "#spi_software_miso_pin:\n"
#~ "#   See the \"common SPI settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#chain_position:\n"
#~ "#chain_length:\n"
#~ "#   These parameters configure an SPI daisy chain. The two parameters\n"
#~ "#   define the stepper position in the chain and the total chain length.\n"
#~ "#   Position 1 corresponds to the stepper that connects to the MOSI signal.\n"
#~ "#   The default is to not use an SPI daisy chain.\n"
#~ "#interpolate: True\n"
#~ "#   If true, enable step interpolation (the driver will internally\n"
#~ "#   step at a rate of 256 micro-steps). The default is True.\n"
#~ "run_current:\n"
#~ "#   The amount of current (in amps RMS) to configure the driver to use\n"
#~ "#   during stepper movement. This parameter must be provided.\n"
#~ "#hold_current:\n"
#~ "#   The amount of current (in amps RMS) to configure the driver to use\n"
#~ "#   when the stepper is not moving. Setting a hold_current is not\n"
#~ "#   recommended (see TMC_Drivers.md for details). The default is to\n"
#~ "#   not reduce the current.\n"
#~ "#sense_resistor: 0.075\n"
#~ "#   The resistance (in ohms) of the motor sense resistor. The default\n"
#~ "#   is 0.075 ohms.\n"
#~ "#stealthchop_threshold: 0\n"
#~ "#   The velocity (in mm/s) to set the \"stealthChop\" threshold to. When\n"
#~ "#   set, \"stealthChop\" mode will be enabled if the stepper motor\n"
#~ "#   velocity is below this value. The default is 0, which disables\n"
#~ "#   \"stealthChop\" mode.\n"
#~ "#driver_IHOLDDELAY: 6\n"
#~ "#driver_TPOWERDOWN: 10\n"
#~ "#driver_TBL: 2\n"
#~ "#driver_TOFF: 3\n"
#~ "#driver_HEND: 2\n"
#~ "#driver_HSTRT: 5\n"
#~ "#driver_FD3: 0\n"
#~ "#driver_TPFD: 4\n"
#~ "#driver_CHM: 0\n"
#~ "#driver_VHIGHFS: 0\n"
#~ "#driver_VHIGHCHM: 0\n"
#~ "#driver_DISS2G: 0\n"
#~ "#driver_DISS2VS: 0\n"
#~ "#driver_PWM_AUTOSCALE: True\n"
#~ "#driver_PWM_AUTOGRAD: True\n"
#~ "#driver_PWM_FREQ: 0\n"
#~ "#driver_FREEWHEEL: 0\n"
#~ "#driver_PWM_GRAD: 0\n"
#~ "#driver_PWM_OFS: 30\n"
#~ "#driver_PWM_REG: 4\n"
#~ "#driver_PWM_LIM: 12\n"
#~ "#driver_SGT: 0\n"
#~ "#driver_SEMIN: 0\n"
#~ "#driver_SEUP: 0\n"
#~ "#driver_SEMAX: 0\n"
#~ "#driver_SEDN: 0\n"
#~ "#driver_SEIMIN: 0\n"
#~ "#driver_SFILT: 0\n"
#~ "#   Set the given register during the configuration of the TMC5160\n"
#~ "#   chip. This may be used to set custom motor parameters. The\n"
#~ "#   defaults for each parameter are next to the parameter name in the\n"
#~ "#   above list.\n"
#~ "#diag0_pin:\n"
#~ "#diag1_pin:\n"
#~ "#   The micro-controller pin attached to one of the DIAG lines of the\n"
#~ "#   TMC5160 chip. Only a single diag pin should be specified. The pin\n"
#~ "#   is \"active low\" and is thus normally prefaced with \"^!\". Setting\n"
#~ "#   this creates a \"tmc5160_stepper_x:virtual_endstop\" virtual pin\n"
#~ "#   which may be used as the stepper's endstop_pin. Doing this enables\n"
#~ "#   \"sensorless homing\". (Be sure to also set driver_SGT to an\n"
#~ "#   appropriate sensitivity value.) The default is to not enable\n"
#~ "#   sensorless homing.\n"
#~ msgstr ""

#~ msgid "Run-time stepper motor current configuration"
#~ msgstr ""

#~ msgid "[ad5206]"
#~ msgstr ""

#~ msgid ""
#~ "Statically configured AD5206 digipots connected via SPI bus (one may define "
#~ "any number of sections with an \"ad5206\" prefix)."
#~ msgstr ""

#~ msgid ""
#~ "[ad5206 my_digipot]\n"
#~ "enable_pin:\n"
#~ "#   The pin corresponding to the AD5206 chip select line. This pin\n"
#~ "#   will be set to low at the start of SPI messages and raised to high\n"
#~ "#   after the message completes. This parameter must be provided.\n"
#~ "#spi_speed:\n"
#~ "#spi_bus:\n"
#~ "#spi_software_sclk_pin:\n"
#~ "#spi_software_mosi_pin:\n"
#~ "#spi_software_miso_pin:\n"
#~ "#   See the \"common SPI settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#channel_1:\n"
#~ "#channel_2:\n"
#~ "#channel_3:\n"
#~ "#channel_4:\n"
#~ "#channel_5:\n"
#~ "#channel_6:\n"
#~ "#   The value to statically set the given AD5206 channel to. This is\n"
#~ "#   typically set to a number between 0.0 and 1.0 with 1.0 being the\n"
#~ "#   highest resistance and 0.0 being the lowest resistance. However,\n"
#~ "#   the range may be changed with the 'scale' parameter (see below).\n"
#~ "#   If a channel is not specified then it is left unconfigured.\n"
#~ "#scale:\n"
#~ "#   This parameter can be used to alter how the 'channel_x' parameters\n"
#~ "#   are interpreted. If provided, then the 'channel_x' parameters\n"
#~ "#   should be between 0.0 and 'scale'. This may be useful when the\n"
#~ "#   AD5206 is used to set stepper voltage references. The 'scale' can\n"
#~ "#   be set to the equivalent stepper amperage if the AD5206 were at\n"
#~ "#   its highest resistance, and then the 'channel_x' parameters can be\n"
#~ "#   specified using the desired amperage value for the stepper. The\n"
#~ "#   default is to not scale the 'channel_x' parameters.\n"
#~ msgstr ""

#~ msgid "[mcp4451]"
#~ msgstr ""

#~ msgid ""
#~ "Statically configured MCP4451 digipot connected via I2C bus (one may define "
#~ "any number of sections with an \"mcp4451\" prefix)."
#~ msgstr ""

#~ msgid ""
#~ "[mcp4451 my_digipot]\n"
#~ "i2c_address:\n"
#~ "#   The i2c address that the chip is using on the i2c bus. This\n"
#~ "#   parameter must be provided.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#wiper_0:\n"
#~ "#wiper_1:\n"
#~ "#wiper_2:\n"
#~ "#wiper_3:\n"
#~ "#   The value to statically set the given MCP4451 \"wiper\" to. This is\n"
#~ "#   typically set to a number between 0.0 and 1.0 with 1.0 being the\n"
#~ "#   highest resistance and 0.0 being the lowest resistance. However,\n"
#~ "#   the range may be changed with the 'scale' parameter (see below).\n"
#~ "#   If a wiper is not specified then it is left unconfigured.\n"
#~ "#scale:\n"
#~ "#   This parameter can be used to alter how the 'wiper_x' parameters\n"
#~ "#   are interpreted. If provided, then the 'wiper_x' parameters should\n"
#~ "#   be between 0.0 and 'scale'. This may be useful when the MCP4451 is\n"
#~ "#   used to set stepper voltage references. The 'scale' can be set to\n"
#~ "#   the equivalent stepper amperage if the MCP4451 were at its highest\n"
#~ "#   resistance, and then the 'wiper_x' parameters can be specified\n"
#~ "#   using the desired amperage value for the stepper. The default is\n"
#~ "#   to not scale the 'wiper_x' parameters.\n"
#~ msgstr ""

#~ msgid "[mcp4728]"
#~ msgstr ""

#~ msgid ""
#~ "Statically configured MCP4728 digital-to-analog converter connected via I2C "
#~ "bus (one may define any number of sections with an \"mcp4728\" prefix)."
#~ msgstr ""

#~ msgid ""
#~ "[mcp4728 my_dac]\n"
#~ "#i2c_address: 96\n"
#~ "#   The i2c address that the chip is using on the i2c bus. The default\n"
#~ "#   is 96.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#channel_a:\n"
#~ "#channel_b:\n"
#~ "#channel_c:\n"
#~ "#channel_d:\n"
#~ "#   The value to statically set the given MCP4728 channel to. This is\n"
#~ "#   typically set to a number between 0.0 and 1.0 with 1.0 being the\n"
#~ "#   highest voltage (2.048V) and 0.0 being the lowest voltage.\n"
#~ "#   However, the range may be changed with the 'scale' parameter (see\n"
#~ "#   below). If a channel is not specified then it is left\n"
#~ "#   unconfigured.\n"
#~ "#scale:\n"
#~ "#   This parameter can be used to alter how the 'channel_x' parameters\n"
#~ "#   are interpreted. If provided, then the 'channel_x' parameters\n"
#~ "#   should be between 0.0 and 'scale'. This may be useful when the\n"
#~ "#   MCP4728 is used to set stepper voltage references. The 'scale' can\n"
#~ "#   be set to the equivalent stepper amperage if the MCP4728 were at\n"
#~ "#   its highest voltage (2.048V), and then the 'channel_x' parameters\n"
#~ "#   can be specified using the desired amperage value for the\n"
#~ "#   stepper. The default is to not scale the 'channel_x' parameters.\n"
#~ msgstr ""

#~ msgid ""
#~ "Statically configured MCP4018 digipot connected via two gpio \"bit banging\""
#~ " pins (one may define any number of sections with an \"mcp4018\" prefix)."
#~ msgstr ""

#~ msgid ""
#~ "[mcp4018 my_digipot]\n"
#~ "scl_pin:\n"
#~ "#   The SCL \"clock\" pin. This parameter must be provided.\n"
#~ "sda_pin:\n"
#~ "#   The SDA \"data\" pin. This parameter must be provided.\n"
#~ "wiper:\n"
#~ "#   The value to statically set the given MCP4018 \"wiper\" to. This is\n"
#~ "#   typically set to a number between 0.0 and 1.0 with 1.0 being the\n"
#~ "#   highest resistance and 0.0 being the lowest resistance. However,\n"
#~ "#   the range may be changed with the 'scale' parameter (see below).\n"
#~ "#   This parameter must be provided.\n"
#~ "#scale:\n"
#~ "#   This parameter can be used to alter how the 'wiper' parameter is\n"
#~ "#   interpreted. If provided, then the 'wiper' parameter should be\n"
#~ "#   between 0.0 and 'scale'. This may be useful when the MCP4018 is\n"
#~ "#   used to set stepper voltage references. The 'scale' can be set to\n"
#~ "#   the equivalent stepper amperage if the MCP4018 is at its highest\n"
#~ "#   resistance, and then the 'wiper' parameter can be specified using\n"
#~ "#   the desired amperage value for the stepper. The default is to not\n"
#~ "#   scale the 'wiper' parameter.\n"
#~ msgstr ""

#~ msgid "Display support"
#~ msgstr ""

#~ msgid "Support for a display attached to the micro-controller."
#~ msgstr ""

#~ msgid ""
#~ "[display]\n"
#~ "lcd_type:\n"
#~ "#   The type of LCD chip in use. This may be \"hd44780\", \"hd44780_spi\",\n"
#~ "#   \"st7920\", \"emulated_st7920\", \"uc1701\", \"ssd1306\", or \"sh1106\".\n"
#~ "#   See the display sections below for information on each type and\n"
#~ "#   additional parameters they provide. This parameter must be\n"
#~ "#   provided.\n"
#~ "#display_group:\n"
#~ "#   The name of the display_data group to show on the display. This\n"
#~ "#   controls the content of the screen (see the \"display_data\" section\n"
#~ "#   for more information). The default is _default_20x4 for hd44780\n"
#~ "#   displays and _default_16x4 for other displays.\n"
#~ "#menu_timeout:\n"
#~ "#   Timeout for menu. Being inactive this amount of seconds will\n"
#~ "#   trigger menu exit or return to root menu when having autorun\n"
#~ "#   enabled. The default is 0 seconds (disabled)\n"
#~ "#menu_root:\n"
#~ "#   Name of the main menu section to show when clicking the encoder\n"
#~ "#   on the home screen. The defaults is __main, and this shows the\n"
#~ "#   the default menus as defined in klippy/extras/display/menu.cfg\n"
#~ "#menu_reverse_navigation:\n"
#~ "#   When enabled it will reverse up and down directions for list\n"
#~ "#   navigation. The default is False. This parameter is optional.\n"
#~ "#encoder_pins:\n"
#~ "#   The pins connected to encoder. 2 pins must be provided when using\n"
#~ "#   encoder. This parameter must be provided when using menu.\n"
#~ "#encoder_steps_per_detent:\n"
#~ "#   How many steps the encoder emits per detent (\"click\"). If the\n"
#~ "#   encoder takes two detents to move between entries or moves two\n"
#~ "#   entries from one detent, try changing this. Allowed values are 2\n"
#~ "#   (half-stepping) or 4 (full-stepping). The default is 4.\n"
#~ "#click_pin:\n"
#~ "#   The pin connected to 'enter' button or encoder 'click'. This\n"
#~ "#   parameter must be provided when using menu. The presence of an\n"
#~ "#   'analog_range_click_pin' config parameter turns this parameter\n"
#~ "#   from digital to analog.\n"
#~ "#back_pin:\n"
#~ "#   The pin connected to 'back' button. This parameter is optional,\n"
#~ "#   menu can be used without it. The presence of an\n"
#~ "#   'analog_range_back_pin' config parameter turns this parameter from\n"
#~ "#   digital to analog.\n"
#~ "#up_pin:\n"
#~ "#   The pin connected to 'up' button. This parameter must be provided\n"
#~ "#   when using menu without encoder. The presence of an\n"
#~ "#   'analog_range_up_pin' config parameter turns this parameter from\n"
#~ "#   digital to analog.\n"
#~ "#down_pin:\n"
#~ "#   The pin connected to 'down' button. This parameter must be\n"
#~ "#   provided when using menu without encoder. The presence of an\n"
#~ "#   'analog_range_down_pin' config parameter turns this parameter from\n"
#~ "#   digital to analog.\n"
#~ "#kill_pin:\n"
#~ "#   The pin connected to 'kill' button. This button will call\n"
#~ "#   emergency stop. The presence of an 'analog_range_kill_pin' config\n"
#~ "#   parameter turns this parameter from digital to analog.\n"
#~ "#analog_pullup_resistor: 4700\n"
#~ "#   The resistance (in ohms) of the pullup attached to the analog\n"
#~ "#   button. The default is 4700 ohms.\n"
#~ "#analog_range_click_pin:\n"
#~ "#   The resistance range for a 'enter' button. Range minimum and\n"
#~ "#   maximum comma-separated values must be provided when using analog\n"
#~ "#   button.\n"
#~ "#analog_range_back_pin:\n"
#~ "#   The resistance range for a 'back' button. Range minimum and\n"
#~ "#   maximum comma-separated values must be provided when using analog\n"
#~ "#   button.\n"
#~ "#analog_range_up_pin:\n"
#~ "#   The resistance range for a 'up' button. Range minimum and maximum\n"
#~ "#   comma-separated values must be provided when using analog button.\n"
#~ "#analog_range_down_pin:\n"
#~ "#   The resistance range for a 'down' button. Range minimum and\n"
#~ "#   maximum comma-separated values must be provided when using analog\n"
#~ "#   button.\n"
#~ "#analog_range_kill_pin:\n"
#~ "#   The resistance range for a 'kill' button. Range minimum and\n"
#~ "#   maximum comma-separated values must be provided when using analog\n"
#~ "#   button.\n"
#~ msgstr ""

#~ msgid "hd44780 display"
#~ msgstr ""

#~ msgid ""
#~ "Information on configuring hd44780 displays (which is used in "
#~ "\"RepRapDiscount 2004 Smart Controller\" type displays)."
#~ msgstr ""

#~ msgid ""
#~ "[display]\n"
#~ "lcd_type: hd44780\n"
#~ "#   Set to \"hd44780\" for hd44780 displays.\n"
#~ "rs_pin:\n"
#~ "e_pin:\n"
#~ "d4_pin:\n"
#~ "d5_pin:\n"
#~ "d6_pin:\n"
#~ "d7_pin:\n"
#~ "#   The pins connected to an hd44780 type lcd. These parameters must\n"
#~ "#   be provided.\n"
#~ "#hd44780_protocol_init: True\n"
#~ "#   Perform 8-bit/4-bit protocol initialization on an hd44780 display.\n"
#~ "#   This is necessary on real hd44780 devices. However, one may need\n"
#~ "#   to disable this on some \"clone\" devices. The default is True.\n"
#~ "#line_length:\n"
#~ "#   Set the number of characters per line for an hd44780 type lcd.\n"
#~ "#   Possible values are 20 (default) and 16. The number of lines is\n"
#~ "#   fixed to 4.\n"
#~ "...\n"
#~ msgstr ""

#~ msgid "hd44780_spi display"
#~ msgstr ""

#~ msgid ""
#~ "Information on configuring an hd44780_spi display - a 20x04 display "
#~ "controlled via a hardware \"shift register\" (which is used in mightyboard "
#~ "based printers)."
#~ msgstr ""

#~ msgid ""
#~ "[display]\n"
#~ "lcd_type: hd44780_spi\n"
#~ "#   Set to \"hd44780_spi\" for hd44780_spi displays.\n"
#~ "latch_pin:\n"
#~ "spi_software_sclk_pin:\n"
#~ "spi_software_mosi_pin:\n"
#~ "spi_software_miso_pin:\n"
#~ "#   The pins connected to the shift register controlling the display.\n"
#~ "#   The spi_software_miso_pin needs to be set to an unused pin of the\n"
#~ "#   printer mainboard as the shift register does not have a MISO pin,\n"
#~ "#   but the software spi implementation requires this pin to be\n"
#~ "#   configured.\n"
#~ "#hd44780_protocol_init: True\n"
#~ "#   Perform 8-bit/4-bit protocol initialization on an hd44780 display.\n"
#~ "#   This is necessary on real hd44780 devices. However, one may need\n"
#~ "#   to disable this on some \"clone\" devices. The default is True.\n"
#~ "#line_length:\n"
#~ "#   Set the number of characters per line for an hd44780 type lcd.\n"
#~ "#   Possible values are 20 (default) and 16. The number of lines is\n"
#~ "#   fixed to 4.\n"
#~ "...\n"
#~ msgstr ""

#~ msgid "st7920 display"
#~ msgstr ""

#~ msgid ""
#~ "Information on configuring st7920 displays (which is used in "
#~ "\"RepRapDiscount 12864 Full Graphic Smart Controller\" type displays)."
#~ msgstr ""

#~ msgid ""
#~ "[display]\n"
#~ "lcd_type: st7920\n"
#~ "#   Set to \"st7920\" for st7920 displays.\n"
#~ "cs_pin:\n"
#~ "sclk_pin:\n"
#~ "sid_pin:\n"
#~ "#   The pins connected to an st7920 type lcd. These parameters must be\n"
#~ "#   provided.\n"
#~ "...\n"
#~ msgstr ""

#~ msgid "emulated_st7920 display"
#~ msgstr ""

#~ msgid ""
#~ "Information on configuring an emulated st7920 display - found in some \"2.4 "
#~ "inch touchscreen devices\" and similar."
#~ msgstr ""

#~ msgid ""
#~ "[display]\n"
#~ "lcd_type: emulated_st7920\n"
#~ "#   Set to \"emulated_st7920\" for emulated_st7920 displays.\n"
#~ "en_pin:\n"
#~ "spi_software_sclk_pin:\n"
#~ "spi_software_mosi_pin:\n"
#~ "spi_software_miso_pin:\n"
#~ "#   The pins connected to an emulated_st7920 type lcd. The en_pin\n"
#~ "#   corresponds to the cs_pin of the st7920 type lcd,\n"
#~ "#   spi_software_sclk_pin corresponds to sclk_pin and\n"
#~ "#   spi_software_mosi_pin corresponds to sid_pin. The\n"
#~ "#   spi_software_miso_pin needs to be set to an unused pin of the\n"
#~ "#   printer mainboard as the st7920 as no MISO pin but the software\n"
#~ "#   spi implementation requires this pin to be configured.\n"
#~ "...\n"
#~ msgstr ""

#~ msgid "uc1701 display"
#~ msgstr ""

#~ msgid ""
#~ "Information on configuring uc1701 displays (which is used in \"MKS Mini "
#~ "12864\" type displays)."
#~ msgstr ""

#~ msgid ""
#~ "[display]\n"
#~ "lcd_type: uc1701\n"
#~ "#   Set to \"uc1701\" for uc1701 displays.\n"
#~ "cs_pin:\n"
#~ "a0_pin:\n"
#~ "#   The pins connected to a uc1701 type lcd. These parameters must be\n"
#~ "#   provided.\n"
#~ "#rst_pin:\n"
#~ "#   The pin connected to the \"rst\" pin on the lcd. If it is not\n"
#~ "#   specified then the hardware must have a pull-up on the\n"
#~ "#   corresponding lcd line.\n"
#~ "#contrast:\n"
#~ "#   The contrast to set. The value may range from 0 to 63 and the\n"
#~ "#   default is 40.\n"
#~ "...\n"
#~ msgstr ""

#~ msgid "ssd1306 and sh1106 displays"
#~ msgstr ""

#~ msgid "Information on configuring ssd1306 and sh1106 displays."
#~ msgstr ""

#~ msgid ""
#~ "[display]\n"
#~ "lcd_type:\n"
#~ "#   Set to either \"ssd1306\" or \"sh1106\" for the given display type.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   Optional parameters available for displays connected via an i2c\n"
#~ "#   bus. See the \"common I2C settings\" section for a description of\n"
#~ "#   the above parameters.\n"
#~ "#cs_pin:\n"
#~ "#dc_pin:\n"
#~ "#spi_speed:\n"
#~ "#spi_bus:\n"
#~ "#spi_software_sclk_pin:\n"
#~ "#spi_software_mosi_pin:\n"
#~ "#spi_software_miso_pin:\n"
#~ "#   The pins connected to the lcd when in \"4-wire\" spi mode. See the\n"
#~ "#   \"common SPI settings\" section for a description of the parameters\n"
#~ "#   that start with \"spi_\". The default is to use i2c mode for the\n"
#~ "#   display.\n"
#~ "#reset_pin:\n"
#~ "#   A reset pin may be specified on the display. If it is not\n"
#~ "#   specified then the hardware must have a pull-up on the\n"
#~ "#   corresponding lcd line.\n"
#~ "#contrast:\n"
#~ "#   The contrast to set. The value may range from 0 to 256 and the\n"
#~ "#   default is 239.\n"
#~ "#vcomh: 0\n"
#~ "#   Set the Vcomh value on the display. This value is associated with\n"
#~ "#   a \"smearing\" effect on some OLED displays. The value may range\n"
#~ "#   from 0 to 63. Default is 0.\n"
#~ "#invert: False\n"
#~ "#   TRUE inverts the pixels on certain OLED displays.  The default is\n"
#~ "#   False.\n"
#~ "#x_offset: 0\n"
#~ "#   Set the horizontal offset value on SH1106 displays. The default is\n"
#~ "#   0.\n"
#~ "...\n"
#~ msgstr ""

#~ msgid "[display_data]"
#~ msgstr ""

#~ msgid ""
#~ "Support for displaying custom data on an lcd screen. One may create any "
#~ "number of display groups and any number of data items under those groups. "
#~ "The display will show all the data items for a given group if the "
#~ "display_group option in the [display] section is set to the given group "
#~ "name."
#~ msgstr ""

#~ msgid ""
#~ "A [default set of display groups](../klippy/extras/display/display.cfg) are "
#~ "automatically created. One can replace or extend these display_data items by"
#~ " overriding the defaults in the main printer.cfg config file."
#~ msgstr ""

#~ msgid ""
#~ "[display_data my_group_name my_data_name]\n"
#~ "position:\n"
#~ "#   Comma separated row and column of the display position that should\n"
#~ "#   be used to display the information. This parameter must be\n"
#~ "#   provided.\n"
#~ "text:\n"
#~ "#   The text to show at the given position. This field is evaluated\n"
#~ "#   using command templates (see docs/Command_Templates.md). This\n"
#~ "#   parameter must be provided.\n"
#~ msgstr ""

#~ msgid "[display_template]"
#~ msgstr ""

#~ msgid ""
#~ "Display data text \"macros\" (one may define any number of sections with a "
#~ "display_template prefix). See the [command templates](Command_Templates.md) "
#~ "document for information on template evaluation."
#~ msgstr ""

#~ msgid ""
#~ "This feature allows one to reduce repetitive definitions in display_data "
#~ "sections. One may use the builtin `render()` function in display_data "
#~ "sections to evaluate a template. For example, if one were to define "
#~ "`[display_template my_template]` then one could use `{ render('my_template')"
#~ " }` in a display_data section."
#~ msgstr ""

#~ msgid ""
#~ "This feature can also be used for continuous LED updates using the "
#~ "[SET_LED_TEMPLATE](G-Codes.md#set_led_template) command."
#~ msgstr ""

#~ msgid ""
#~ "[display_template my_template_name]\n"
#~ "#param_<name>:\n"
#~ "#   One may specify any number of options with a \"param_\" prefix. The\n"
#~ "#   given name will be assigned the given value (parsed as a Python\n"
#~ "#   literal) and will be available during macro expansion. If the\n"
#~ "#   parameter is passed in the call to render() then that value will\n"
#~ "#   be used during macro expansion. For example, a config with\n"
#~ "#   \"param_speed = 75\" might have a caller with\n"
#~ "#   \"render('my_template_name', param_speed=80)\". Parameter names may\n"
#~ "#   not use upper case characters.\n"
#~ "text:\n"
#~ "#   The text to return when the this template is rendered. This field\n"
#~ "#   is evaluated using command templates (see\n"
#~ "#   docs/Command_Templates.md). This parameter must be provided.\n"
#~ msgstr ""

#~ msgid "[display_glyph]"
#~ msgstr ""

#~ msgid ""
#~ "Display a custom glyph on displays that support it. The given name will be "
#~ "assigned the given display data which can then be referenced in the display "
#~ "templates by their name surrounded by two \"tilde\" symbols i.e. "
#~ "`~my_display_glyph~`"
#~ msgstr ""

#~ msgid ""
#~ "See [sample-glyphs.cfg](../config/sample-glyphs.cfg) for some examples."
#~ msgstr ""

#~ msgid ""
#~ "[display_glyph my_display_glyph]\n"
#~ "#data:\n"
#~ "#   The display data, stored as 16 lines consisting of 16 bits (1 per\n"
#~ "#   pixel) where '.' is a blank pixel and '*' is an on pixel (e.g.,\n"
#~ "#   \"****************\" to display a solid horizontal line).\n"
#~ "#   Alternatively, one can use '0' for a blank pixel and '1' for an on\n"
#~ "#   pixel. Put each display line into a separate config line. The\n"
#~ "#   glyph must consist of exactly 16 lines with 16 bits each. This\n"
#~ "#   parameter is optional.\n"
#~ "#hd44780_data:\n"
#~ "#   Glyph to use on 20x4 hd44780 displays. The glyph must consist of\n"
#~ "#   exactly 8 lines with 5 bits each. This parameter is optional.\n"
#~ "#hd44780_slot:\n"
#~ "#   The hd44780 hardware index (0..7) to store the glyph at. If\n"
#~ "#   multiple distinct images use the same slot then make sure to only\n"
#~ "#   use one of those images in any given screen. This parameter is\n"
#~ "#   required if hd44780_data is specified.\n"
#~ msgstr ""

#~ msgid "[display my_extra_display]"
#~ msgstr ""

#~ msgid ""
#~ "If a primary [display] section has been defined in printer.cfg as shown "
#~ "above it is possible to define multiple auxiliary displays. Note that "
#~ "auxiliary displays do not currently support menu functionality, thus they do"
#~ " not support the \"menu\" options or button configuration."
#~ msgstr ""

#~ msgid ""
#~ "[display my_extra_display]\n"
#~ "# See the \"display\" section for available parameters.\n"
#~ msgstr ""

#~ msgid "[menu]"
#~ msgstr ""

#~ msgid "Customizable lcd display menus."
#~ msgstr ""

#~ msgid ""
#~ "A [default set of menus](../klippy/extras/display/menu.cfg) are "
#~ "automatically created. One can replace or extend the menu by overriding the "
#~ "defaults in the main printer.cfg config file."
#~ msgstr ""

#~ msgid ""
#~ "See the [command template document](Command_Templates.md#menu-templates) for"
#~ " information on menu attributes available during template rendering."
#~ msgstr ""

#~ msgid ""
#~ "# Common parameters available for all menu config sections.\n"
#~ "#[menu __some_list __some_name]\n"
#~ "#type: disabled\n"
#~ "#   Permanently disabled menu element, only required attribute is 'type'.\n"
#~ "#   Allows you to easily disable/hide existing menu items.\n"
#~ "\n"
#~ "#[menu some_name]\n"
#~ "#type:\n"
#~ "#   One of command, input, list, text:\n"
#~ "#       command - basic menu element with various script triggers\n"
#~ "#       input   - same like 'command' but has value changing capabilities.\n"
#~ "#                 Press will start/stop edit mode.\n"
#~ "#       list    - it allows for menu items to be grouped together in a\n"
#~ "#                 scrollable list.  Add to the list by creating menu\n"
#~ "#                 configurations using \"some_list\" as a prefix - for\n"
#~ "#                 example: [menu some_list some_item_in_the_list]\n"
#~ "#       vsdlist - same as 'list' but will append files from virtual sdcard\n"
#~ "#                 (will be removed in the future)\n"
#~ "#name:\n"
#~ "#   Name of menu item - evaluated as a template.\n"
#~ "#enable:\n"
#~ "#   Template that evaluates to True or False.\n"
#~ "#index:\n"
#~ "#   Position where an item needs to be inserted in list. By default\n"
#~ "#   the item is added at the end.\n"
#~ "\n"
#~ "#[menu some_list]\n"
#~ "#type: list\n"
#~ "#name:\n"
#~ "#enable:\n"
#~ "#   See above for a description of these parameters.\n"
#~ "\n"
#~ "#[menu some_list some_command]\n"
#~ "#type: command\n"
#~ "#name:\n"
#~ "#enable:\n"
#~ "#   See above for a description of these parameters.\n"
#~ "#gcode:\n"
#~ "#   Script to run on button click or long click. Evaluated as a\n"
#~ "#   template.\n"
#~ "\n"
#~ "#[menu some_list some_input]\n"
#~ "#type: input\n"
#~ "#name:\n"
#~ "#enable:\n"
#~ "#   See above for a description of these parameters.\n"
#~ "#input:\n"
#~ "#   Initial value to use when editing - evaluated as a template.\n"
#~ "#   Result must be float.\n"
#~ "#input_min:\n"
#~ "#   Minimum value of range - evaluated as a template. Default -99999.\n"
#~ "#input_max:\n"
#~ "#   Maximum value of range - evaluated as a template. Default 99999.\n"
#~ "#input_step:\n"
#~ "#   Editing step - Must be a positive integer or float value. It has\n"
#~ "#   internal fast rate step. When \"(input_max - input_min) /\n"
#~ "#   input_step > 100\" then fast rate step is 10 * input_step else fast\n"
#~ "#   rate step is same input_step.\n"
#~ "#realtime:\n"
#~ "#   This attribute accepts static boolean value. When enabled then\n"
#~ "#   gcode script is run after each value change. The default is False.\n"
#~ "#gcode:\n"
#~ "#   Script to run on button click, long click or value change.\n"
#~ "#   Evaluated as a template. The button click will trigger the edit\n"
#~ "#   mode start or end.\n"
#~ msgstr ""

#~ msgid "Filament sensors"
#~ msgstr ""

#~ msgid ""
#~ "Filament Switch Sensor. Support for filament insert and runout detection "
#~ "using a switch sensor, such as an endstop switch."
#~ msgstr ""

#~ msgid ""
#~ "See the [command reference](G-Codes.md#filament_switch_sensor) for more "
#~ "information."
#~ msgstr ""

#~ msgid ""
#~ "[filament_switch_sensor my_sensor]\n"
#~ "#pause_on_runout: True\n"
#~ "#   When set to True, a PAUSE will execute immediately after a runout\n"
#~ "#   is detected. Note that if pause_on_runout is False and the\n"
#~ "#   runout_gcode is omitted then runout detection is disabled. Default\n"
#~ "#   is True.\n"
#~ "#runout_gcode:\n"
#~ "#   A list of G-Code commands to execute after a filament runout is\n"
#~ "#   detected. See docs/Command_Templates.md for G-Code format. If\n"
#~ "#   pause_on_runout is set to True this G-Code will run after the\n"
#~ "#   PAUSE is complete. The default is not to run any G-Code commands.\n"
#~ "#insert_gcode:\n"
#~ "#   A list of G-Code commands to execute after a filament insert is\n"
#~ "#   detected. See docs/Command_Templates.md for G-Code format. The\n"
#~ "#   default is not to run any G-Code commands, which disables insert\n"
#~ "#   detection.\n"
#~ "#event_delay: 3.0\n"
#~ "#   The minimum amount of time in seconds to delay between events.\n"
#~ "#   Events triggered during this time period will be silently\n"
#~ "#   ignored. The default is 3 seconds.\n"
#~ "#pause_delay: 0.5\n"
#~ "#   The amount of time to delay, in seconds, between the pause command\n"
#~ "#   dispatch and execution of the runout_gcode. It may be useful to\n"
#~ "#   increase this delay if OctoPrint exhibits strange pause behavior.\n"
#~ "#   Default is 0.5 seconds.\n"
#~ "#switch_pin:\n"
#~ "#   The pin on which the switch is connected. This parameter must be\n"
#~ "#   provided.\n"
#~ msgstr ""

#~ msgid "[filament_motion_sensor]"
#~ msgstr ""

#~ msgid ""
#~ "Filament Motion Sensor. Support for filament insert and runout detection "
#~ "using an encoder that toggles the output pin during filament movement "
#~ "through the sensor."
#~ msgstr ""

#~ msgid ""
#~ "[filament_motion_sensor my_sensor]\n"
#~ "detection_length: 7.0\n"
#~ "#   The minimum length of filament pulled through the sensor to trigger\n"
#~ "#   a state change on the switch_pin\n"
#~ "#   Default is 7 mm.\n"
#~ "extruder:\n"
#~ "#   The name of the extruder section this sensor is associated with.\n"
#~ "#   This parameter must be provided.\n"
#~ "switch_pin:\n"
#~ "#pause_on_runout:\n"
#~ "#runout_gcode:\n"
#~ "#insert_gcode:\n"
#~ "#event_delay:\n"
#~ "#pause_delay:\n"
#~ "#   See the \"filament_switch_sensor\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ msgstr ""

#~ msgid "[tsl1401cl_filament_width_sensor]"
#~ msgstr ""

#~ msgid ""
#~ "TSLl401CL Based Filament Width Sensor. See the "
#~ "[guide](TSL1401CL_Filament_Width_Sensor.md) for more information."
#~ msgstr ""

#~ msgid ""
#~ "[tsl1401cl_filament_width_sensor]\n"
#~ "#pin:\n"
#~ "#default_nominal_filament_diameter: 1.75 # (mm)\n"
#~ "#   Maximum allowed filament diameter difference as mm.\n"
#~ "#max_difference: 0.2\n"
#~ "#   The distance from sensor to the melting chamber as mm.\n"
#~ "#measurement_delay: 100\n"
#~ msgstr ""

#~ msgid ""
#~ "Hall filament width sensor (see [Hall Filament Width "
#~ "Sensor](Hall_Filament_Width_Sensor.md))."
#~ msgstr ""

#~ msgid ""
#~ "[hall_filament_width_sensor]\n"
#~ "adc1:\n"
#~ "adc2:\n"
#~ "#   Analog input pins connected to the sensor. These parameters must\n"
#~ "#   be provided.\n"
#~ "#cal_dia1: 1.50\n"
#~ "#cal_dia2: 2.00\n"
#~ "#   The calibration values (in mm) for the sensors. The default is\n"
#~ "#   1.50 for cal_dia1 and 2.00 for cal_dia2.\n"
#~ "#raw_dia1: 9500\n"
#~ "#raw_dia2: 10500\n"
#~ "#   The raw calibration values for the sensors. The default is 9500\n"
#~ "#   for raw_dia1 and 10500 for raw_dia2.\n"
#~ "#default_nominal_filament_diameter: 1.75\n"
#~ "#   The nominal filament diameter. This parameter must be provided.\n"
#~ "#max_difference: 0.200\n"
#~ "#   Maximum allowed filament diameter difference in millimeters (mm).\n"
#~ "#   If difference between nominal filament diameter and sensor output\n"
#~ "#   is more than +- max_difference, extrusion multiplier is set back\n"
#~ "#   to %100. The default is 0.200.\n"
#~ "#measurement_delay: 70\n"
#~ "#   The distance from sensor to the melting chamber/hot-end in\n"
#~ "#   millimeters (mm). The filament between the sensor and the hot-end\n"
#~ "#   will be treated as the default_nominal_filament_diameter. Host\n"
#~ "#   module works with FIFO logic. It keeps each sensor value and\n"
#~ "#   position in an array and POP them back in correct position. This\n"
#~ "#   parameter must be provided.\n"
#~ "#enable: False\n"
#~ "#   Sensor enabled or disabled after power on. The default is to\n"
#~ "#   disable.\n"
#~ "#measurement_interval: 10\n"
#~ "#   The approximate distance (in mm) between sensor readings. The\n"
#~ "#   default is 10mm.\n"
#~ "#logging: False\n"
#~ "#   Out diameter to terminal and klipper.log can be turn on|of by\n"
#~ "#   command.\n"
#~ "#min_diameter: 1.0\n"
#~ "#   Minimal diameter for trigger virtual filament_switch_sensor.\n"
#~ "#use_current_dia_while_delay: False\n"
#~ "#   Use the current diameter instead of the nominal diameter while\n"
#~ "#   the measurement delay has not run through.\n"
#~ "#pause_on_runout:\n"
#~ "#runout_gcode:\n"
#~ "#insert_gcode:\n"
#~ "#event_delay:\n"
#~ "#pause_delay:\n"
#~ "#   See the \"filament_switch_sensor\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ msgstr ""

#~ msgid "Board specific hardware support"
#~ msgstr ""

#~ msgid "[sx1509]"
#~ msgstr ""

#~ msgid ""
#~ "Configure an SX1509 I2C to GPIO expander. Due to the delay incurred by I2C "
#~ "communication you should NOT use SX1509 pins as stepper enable, step or dir "
#~ "pins or any other pin that requires fast bit-banging. They are best used as "
#~ "static or gcode controlled digital outputs or hardware-pwm pins for e.g. "
#~ "fans. One may define any number of sections with an \"sx1509\" prefix. Each "
#~ "expander provides a set of 16 pins (sx1509_my_sx1509:PIN_0 to "
#~ "sx1509_my_sx1509:PIN_15) which can be used in the printer configuration."
#~ msgstr ""

#~ msgid ""
#~ "See the [generic-duet2-duex.cfg](../config/generic-duet2-duex.cfg) file for "
#~ "an example."
#~ msgstr ""

#~ msgid ""
#~ "[sx1509 my_sx1509]\n"
#~ "i2c_address:\n"
#~ "#   I2C address used by this expander. Depending on the hardware\n"
#~ "#   jumpers this is one out of the following addresses: 62 63 112\n"
#~ "#   113. This parameter must be provided.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#i2c_bus:\n"
#~ "#   If the I2C implementation of your micro-controller supports\n"
#~ "#   multiple I2C busses, you may specify the bus name here. The\n"
#~ "#   default is to use the default micro-controller i2c bus.\n"
#~ msgstr ""

#~ msgid "[samd_sercom]"
#~ msgstr ""

#~ msgid ""
#~ "SAMD SERCOM configuration to specify which pins to use on a given SERCOM. "
#~ "One may define any number of sections with a \"samd_sercom\" prefix. Each "
#~ "SERCOM must be configured prior to using it as SPI or I2C peripheral. Place "
#~ "this config section above any other section that makes use of SPI or I2C "
#~ "buses."
#~ msgstr ""

#~ msgid ""
#~ "[samd_sercom my_sercom]\n"
#~ "sercom:\n"
#~ "#   The name of the sercom bus to configure in the micro-controller.\n"
#~ "#   Available names are \"sercom0\", \"sercom1\", etc.. This parameter\n"
#~ "#   must be provided.\n"
#~ "tx_pin:\n"
#~ "#   MOSI pin for SPI communication, or SDA (data) pin for I2C\n"
#~ "#   communication. The pin must have a valid pinmux configuration\n"
#~ "#   for the given SERCOM peripheral. This parameter must be provided.\n"
#~ "#rx_pin:\n"
#~ "#   MISO pin for SPI communication. This pin is not used for I2C\n"
#~ "#   communication (I2C uses tx_pin for both sending and receiving).\n"
#~ "#   The pin must have a valid pinmux configuration for the given\n"
#~ "#   SERCOM peripheral. This parameter is optional.\n"
#~ "clk_pin:\n"
#~ "#   CLK pin for SPI communication, or SCL (clock) pin for I2C\n"
#~ "#   communication. The pin must have a valid pinmux configuration\n"
#~ "#   for the given SERCOM peripheral. This parameter must be provided.\n"
#~ msgstr ""

#~ msgid "[adc_scaled]"
#~ msgstr ""

#~ msgid ""
#~ "Duet2 Maestro analog scaling by vref and vssa readings. Defining an "
#~ "adc_scaled section enables virtual adc pins (such as \"my_name:PB0\") that "
#~ "are automatically adjusted by the board's vref and vssa monitoring pins. Be "
#~ "sure to define this config section above any config sections that use one "
#~ "these virtual pins."
#~ msgstr ""

#~ msgid ""
#~ "See the [generic-duet2-maestro.cfg](../config/generic-duet2-maestro.cfg) "
#~ "file for an example."
#~ msgstr ""

#~ msgid ""
#~ "[adc_scaled my_name]\n"
#~ "vref_pin:\n"
#~ "#   The ADC pin to use for VREF monitoring. This parameter must be\n"
#~ "#   provided.\n"
#~ "vssa_pin:\n"
#~ "#   The ADC pin to use for VSSA monitoring. This parameter must be\n"
#~ "#   provided.\n"
#~ "#smooth_time: 2.0\n"
#~ "#   A time value (in seconds) over which the vref and vssa\n"
#~ "#   measurements will be smoothed to reduce the impact of measurement\n"
#~ "#   noise. The default is 2 seconds.\n"
#~ msgstr ""

#~ msgid "[replicape]"
#~ msgstr ""

#~ msgid ""
#~ "Replicape support - see the [beaglebone guide](Beaglebone.md) and the "
#~ "[generic-replicape.cfg](../config/generic-replicape.cfg) file for an "
#~ "example."
#~ msgstr ""

#~ msgid ""
#~ "# The \"replicape\" config section adds \"replicape:stepper_x_enable\"\n"
#~ "# virtual stepper enable pins (for steppers X, Y, Z, E, and H) and\n"
#~ "# \"replicape:power_x\" PWM output pins (for hotbed, e, h, fan0, fan1,\n"
#~ "# fan2, and fan3) that may then be used elsewhere in the config file.\n"
#~ "[replicape]\n"
#~ "revision:\n"
#~ "#   The replicape hardware revision. Currently only revision \"B3\" is\n"
#~ "#   supported. This parameter must be provided.\n"
#~ "#enable_pin: !gpio0_20\n"
#~ "#   The replicape global enable pin. The default is !gpio0_20 (aka\n"
#~ "#   P9_41).\n"
#~ "host_mcu:\n"
#~ "#   The name of the mcu config section that communicates with the\n"
#~ "#   Klipper \"linux process\" mcu instance. This parameter must be\n"
#~ "#   provided.\n"
#~ "#standstill_power_down: False\n"
#~ "#   This parameter controls the CFG6_ENN line on all stepper\n"
#~ "#   motors. True sets the enable lines to \"open\". The default is\n"
#~ "#   False.\n"
#~ "#stepper_x_microstep_mode:\n"
#~ "#stepper_y_microstep_mode:\n"
#~ "#stepper_z_microstep_mode:\n"
#~ "#stepper_e_microstep_mode:\n"
#~ "#stepper_h_microstep_mode:\n"
#~ "#   This parameter controls the CFG1 and CFG2 pins of the given\n"
#~ "#   stepper motor driver. Available options are: disable, 1, 2,\n"
#~ "#   spread2, 4, 16, spread4, spread16, stealth4, and stealth16. The\n"
#~ "#   default is disable.\n"
#~ "#stepper_x_current:\n"
#~ "#stepper_y_current:\n"
#~ "#stepper_z_current:\n"
#~ "#stepper_e_current:\n"
#~ "#stepper_h_current:\n"
#~ "#   The configured maximum current (in Amps) of the stepper motor\n"
#~ "#   driver. This parameter must be provided if the stepper is not in a\n"
#~ "#   disable mode.\n"
#~ "#stepper_x_chopper_off_time_high:\n"
#~ "#stepper_y_chopper_off_time_high:\n"
#~ "#stepper_z_chopper_off_time_high:\n"
#~ "#stepper_e_chopper_off_time_high:\n"
#~ "#stepper_h_chopper_off_time_high:\n"
#~ "#   This parameter controls the CFG0 pin of the stepper motor driver\n"
#~ "#   (True sets CFG0 high, False sets it low). The default is False.\n"
#~ "#stepper_x_chopper_hysteresis_high:\n"
#~ "#stepper_y_chopper_hysteresis_high:\n"
#~ "#stepper_z_chopper_hysteresis_high:\n"
#~ "#stepper_e_chopper_hysteresis_high:\n"
#~ "#stepper_h_chopper_hysteresis_high:\n"
#~ "#   This parameter controls the CFG4 pin of the stepper motor driver\n"
#~ "#   (True sets CFG4 high, False sets it low). The default is False.\n"
#~ "#stepper_x_chopper_blank_time_high:\n"
#~ "#stepper_y_chopper_blank_time_high:\n"
#~ "#stepper_z_chopper_blank_time_high:\n"
#~ "#stepper_e_chopper_blank_time_high:\n"
#~ "#stepper_h_chopper_blank_time_high:\n"
#~ "#   This parameter controls the CFG5 pin of the stepper motor driver\n"
#~ "#   (True sets CFG5 high, False sets it low). The default is True.\n"
#~ msgstr ""

#~ msgid "Other Custom Modules"
#~ msgstr ""

#~ msgid ""
#~ "Palette 2 multimaterial support - provides a tighter integration supporting "
#~ "Palette 2 devices in connected mode."
#~ msgstr ""

#~ msgid ""
#~ "This modules also requires `[virtual_sdcard]` and `[pause_resume]` for full "
#~ "functionality."
#~ msgstr ""

#~ msgid ""
#~ "If you use this module, do not use the Palette 2 plugin for Octoprint as "
#~ "they will conflict, and 1 will fail to initialize properly likely aborting "
#~ "your print."
#~ msgstr ""

#~ msgid ""
#~ "If you use Octoprint and stream gcode over the serial port instead of "
#~ "printing from virtual_sd, then remo **M1** and **M0** from *Pausing "
#~ "commands* in *Settings > Serial Connection > Firmware & protocol* will "
#~ "prevent the need to start print on the Palette 2 and unpausing in Octoprint "
#~ "for your print to begin."
#~ msgstr ""

#~ msgid ""
#~ "[palette2]\n"
#~ "serial:\n"
#~ "#   The serial port to connect to the Palette 2.\n"
#~ "#baud: 115200\n"
#~ "#   The baud rate to use. The default is 115200.\n"
#~ "#feedrate_splice: 0.8\n"
#~ "#   The feedrate to use when splicing, default is 0.8\n"
#~ "#feedrate_normal: 1.0\n"
#~ "#   The feedrate to use after splicing, default is 1.0\n"
#~ "#auto_load_speed: 2\n"
#~ "#   Extrude feedrate when autoloading, default is 2 (mm/s)\n"
#~ "#auto_cancel_variation: 0.1\n"
#~ "#   Auto cancel print when ping varation is above this threshold\n"
#~ msgstr ""

#~ msgid ""
#~ "Magnetic hall angle sensor support for reading stepper motor angle shaft "
#~ "measurements using a1333, as5047d, or tle5012b SPI chips. The measurements "
#~ "are available via the [API Server](API_Server.md) and [motion analysis "
#~ "tool](Debugging.md#motion-analysis-and-data-logging). See the [G-Code "
#~ "reference](G-Codes.md#angle) for available commands."
#~ msgstr ""

#~ msgid ""
#~ "[angle my_angle_sensor]\n"
#~ "sensor_type:\n"
#~ "#   The type of the magnetic hall sensor chip. Available choices are\n"
#~ "#   \"a1333\", \"as5047d\", and \"tle5012b\". This parameter must be\n"
#~ "#   specified.\n"
#~ "#sample_period: 0.000400\n"
#~ "#   The query period (in seconds) to use during measurements. The\n"
#~ "#   default is 0.000400 (which is 2500 samples per second).\n"
#~ "#stepper:\n"
#~ "#   The name of the stepper that the angle sensor is attached to (eg,\n"
#~ "#   \"stepper_x\"). Setting this value enables an angle calibration\n"
#~ "#   tool. To use this feature, the Python \"numpy\" package must be\n"
#~ "#   installed. The default is to not enable angle calibration for the\n"
#~ "#   angle sensor.\n"
#~ "cs_pin:\n"
#~ "#   The SPI enable pin for the sensor. This parameter must be provided.\n"
#~ "#spi_speed:\n"
#~ "#spi_bus:\n"
#~ "#spi_software_sclk_pin:\n"
#~ "#spi_software_mosi_pin:\n"
#~ "#spi_software_miso_pin:\n"
#~ "#   See the \"common SPI settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ msgstr ""

#~ msgid "Common bus parameters"
#~ msgstr ""

#~ msgid "Common SPI settings"
#~ msgstr ""

#~ msgid ""
#~ "The following parameters are generally available for devices using an SPI "
#~ "bus."
#~ msgstr ""

#~ msgid ""
#~ "#spi_speed:\n"
#~ "#   The SPI speed (in hz) to use when communicating with the device.\n"
#~ "#   The default depends on the type of device.\n"
#~ "#spi_bus:\n"
#~ "#   If the micro-controller supports multiple SPI busses then one may\n"
#~ "#   specify the micro-controller bus name here. The default depends on\n"
#~ "#   the type of micro-controller.\n"
#~ "#spi_software_sclk_pin:\n"
#~ "#spi_software_mosi_pin:\n"
#~ "#spi_software_miso_pin:\n"
#~ "#   Specify the above parameters to use \"software based SPI\". This\n"
#~ "#   mode does not require micro-controller hardware support (typically\n"
#~ "#   any general purpose pins may be used). The default is to not use\n"
#~ "#   \"software spi\".\n"
#~ msgstr ""

#~ msgid "Common I2C settings"
#~ msgstr ""

#~ msgid ""
#~ "The following parameters are generally available for devices using an I2C "
#~ "bus."
#~ msgstr ""

#~ msgid ""
#~ "Note that Klipper's current micro-controller support for i2c is generally "
#~ "not tolerant to line noise. Unexpected errors on the i2c wires may result in"
#~ " Klipper raising a run-time error. Klipper's support for error recovery "
#~ "varies between each micro-controller type. It is generally recommended to "
#~ "only use i2c devices that are on the same printed circuit board as the "
#~ "micro-controller."
#~ msgstr ""

#~ msgid ""
#~ "Most Klipper micro-controller implementations only support an `i2c_speed` of"
#~ " 100000. The Klipper \"linux\" micro-controller supports a 400000 speed, but"
#~ " it must be [set in the operating system](RPi_microcontroller.md#optional-"
#~ "enabling-i2c) and the `i2c_speed` parameter is otherwise ignored. The "
#~ "Klipper \"rp2040\" micro-controller supports a rate of 400000 via the "
#~ "`i2c_speed` parameter. All other Klipper micro-controllers use a 100000 rate"
#~ " and ignore the `i2c_speed` parameter."
#~ msgstr ""

#~ msgid ""
#~ "#i2c_address:\n"
#~ "#   The i2c address of the device. This must specified as a decimal\n"
#~ "#   number (not in hex). The default depends on the type of device.\n"
#~ "#i2c_mcu:\n"
#~ "#   The name of the micro-controller that the chip is connected to.\n"
#~ "#   The default is \"mcu\".\n"
#~ "#i2c_bus:\n"
#~ "#   If the micro-controller supports multiple I2C busses then one may\n"
#~ "#   specify the micro-controller bus name here. The default depends on\n"
#~ "#   the type of micro-controller.\n"
#~ "#i2c_speed:\n"
#~ "#   The I2C speed (in Hz) to use when communicating with the device.\n"
#~ "#   The Klipper implementation on most micro-controllers is hard-coded\n"
#~ "#   to 100000 and changing this value has no effect. The default is\n"
#~ "#   100000.\n"
#~ msgstr ""

#~ msgid "Configuration Changes"
#~ msgstr ""

#~ msgid ""
#~ "This document covers recent software changes to the config file that are not"
#~ " backwards compatible. It is a good idea to review this document when "
#~ "upgrading the Klipper software."
#~ msgstr ""

#~ msgid "All dates in this document are approximate."
#~ msgstr ""

#~ msgid "Changes"
#~ msgstr ""

#~ msgid ""
#~ "20221122: Previously, with safe_z_home, it was possible that the z_hop after"
#~ " the g28 homing would go in the negative z direction. Now, a z_hop is "
#~ "performed after g28 only if it results in a positive hop, mirroring the "
#~ "behavior of the z_hop that occurs before the g28 homing."
#~ msgstr ""

#~ msgid ""
#~ "20220616: It was previously possible to flash an rp2040 in bootloader mode "
#~ "by running `make flash FLASH_DEVICE=first`. The equivalent command is now "
#~ "`make flash FLASH_DEVICE=2e8a:0003`."
#~ msgstr ""

#~ msgid ""
#~ "20220612: The rp2040 micro-controller now has a workaround for the "
#~ "\"rp2040-e5\" USB errata. This should make initial USB connections more "
#~ "reliable. However, it may result in a change in behavior for the gpio15 pin."
#~ " It is unlikely the gpio15 behavior change will be noticeable."
#~ msgstr ""

#~ msgid ""
#~ "20220407: The temperature_fan `pid_integral_max` config option has been "
#~ "removed (it was deprecated on 20210612)."
#~ msgstr ""

#~ msgid ""
#~ "20220407: The default color order for pca9632 LEDs is now \"RGBW\". Add an "
#~ "explicit `color_order: RBGW` setting to the pca9632 config section to obtain"
#~ " the previous behavior."
#~ msgstr ""

#~ msgid ""
#~ "20220330: The format of the `printer.neopixel.color_data` status information"
#~ " for neopixel and dotstar modules has changed. The information is now stored"
#~ " as a list of color lists (instead of a list of dictionaries). See the "
#~ "[status reference](Status_Reference.md#led) for details."
#~ msgstr ""

#~ msgid ""
#~ "20220307: `M73` will no longer set print progress to 0 if `P` is missing."
#~ msgstr ""

#~ msgid ""
#~ "20220304: There is no longer a default for the `extruder` parameter of "
#~ "[extruder_stepper](Config_Reference.md#extruder_stepper) config sections. If"
#~ " desired, specify `extruder: extruder` explicitly to associate the stepper "
#~ "motor with the \"extruder\" motion queue at startup."
#~ msgstr ""

#~ msgid ""
#~ "20220210: The `SYNC_STEPPER_TO_EXTRUDER` command is deprecated; the "
#~ "`SET_EXTRUDER_STEP_DISTANCE` command is deprecated; the "
#~ "[extruder](Config_Reference.md#extruder) `shared_heater` config option is "
#~ "deprecated. These features will be removed in the near future. Replace "
#~ "`SET_EXTRUDER_STEP_DISTANCE` with `SET_EXTRUDER_ROTATION_DISTANCE`. Replace "
#~ "`SYNC_STEPPER_TO_EXTRUDER` with `SYNC_EXTRUDER_MOTION`. Replace extruder "
#~ "config sections using `shared_heater` with "
#~ "[extruder_stepper](Config_Reference.md#extruder_stepper) config sections and"
#~ " update any activation macros to use "
#~ "[SYNC_EXTRUDER_MOTION](G-Codes.md#sync_extruder_motion)."
#~ msgstr ""

#~ msgid ""
#~ "20220116: The tmc2130, tmc2208, tmc2209, and tmc2660 `run_current` "
#~ "calculation code has changed. For some `run_current` settings the drivers "
#~ "may now be configured differently. This new configuration should be more "
#~ "accurate, but it may invalidate previous tmc driver tuning."
#~ msgstr ""

#~ msgid ""
#~ "20211230: Scripts to tune input shaper (`scripts/calibrate_shaper.py` and "
#~ "`scripts/graph_accelerometer.py`) were migrated to use Python3 by default. "
#~ "As a result, users must install Python3 versions of certain packages (e.g. "
#~ "`sudo apt install python3-numpy python3-matplotlib`) to continue using these"
#~ " scripts. For more details, refer to [Software "
#~ "installation](Measuring_Resonances.md#software-installation). Alternatively,"
#~ " users can temporarily force the execution of these scripts under Python 2 "
#~ "by explicitly calling Python2 interpretor in the console: `python2 "
#~ "~/klipper/scripts/calibrate_shaper.py ...`"
#~ msgstr ""

#~ msgid ""
#~ "20211110: The \"NTC 100K beta 3950\" temperature sensor is deprecated. This "
#~ "sensor will be removed in the near future. Most users will find the "
#~ "\"Generic 3950\" temperature sensor more accurate. To continue to use the "
#~ "older (typically less accurate) definition, define a custom "
#~ "[thermistor](Config_Reference.md#thermistor) with `temperature1: 25`, "
#~ "`resistance1: 100000`, and `beta: 3950`."
#~ msgstr ""

#~ msgid ""
#~ "20211104: The \"step pulse duration\" option in \"make menuconfig\" has been"
#~ " removed. The default step duration for TMC drivers configured in UART or "
#~ "SPI mode is now 100ns. A new `step_pulse_duration` setting in the [stepper "
#~ "config section](Config_Reference.md#stepper) should be set for all steppers "
#~ "that need a custom pulse duration."
#~ msgstr ""

#~ msgid ""
#~ "20211102: Several deprecated features have been removed. The stepper "
#~ "`step_distance` option has been removed (deprecated on 20201222). The "
#~ "`rpi_temperature` sensor alias has been removed (deprecated on 20210219). "
#~ "The mcu `pin_map` option has been removed (deprecated on 20210325). The "
#~ "gcode_macro `default_parameter_<name>` and macro access to command "
#~ "parameters other than via the `params` pseudo-variable has been removed "
#~ "(deprecated on 20210503). The heater `pid_integral_max` option has been "
#~ "removed (deprecated on 20210612)."
#~ msgstr ""

#~ msgid "20210929: Klipper v0.10.0 released."
#~ msgstr ""

#~ msgid ""
#~ "20210903: The default [`smooth_time`](Config_Reference.md#extruder) for "
#~ "heaters has changed to 1 second (from 2 seconds). For most printers this "
#~ "will result in more stable temperature control."
#~ msgstr ""

#~ msgid ""
#~ "20210830: The default adxl345 name is now \"adxl345\". The default CHIP "
#~ "parameter for the `ACCELEROMETER_MEASURE` and `ACCELEROMETER_QUERY` is now "
#~ "also \"adxl345\"."
#~ msgstr ""

#~ msgid ""
#~ "20210830: The adxl345 ACCELEROMETER_MEASURE command no longer supports a "
#~ "RATE parameter. To alter the query rate, update the printer.cfg file and "
#~ "issue a RESTART command."
#~ msgstr ""

#~ msgid ""
#~ "20210821: Several config settings in `printer.configfile.settings` will now "
#~ "be reported as lists instead of raw strings. If the actual raw string is "
#~ "desired, use `printer.configfile.config` instead."
#~ msgstr ""

#~ msgid ""
#~ "20210819: In some cases, a `G28` homing move may end in a position that is "
#~ "nominally outside the valid movement range. In rare situations this may "
#~ "result in confusing \"Move out of range\" errors after homing. If this "
#~ "occurs, change your start scripts to move the toolhead to a valid position "
#~ "immediately after homing."
#~ msgstr ""

#~ msgid ""
#~ "20210814: The analog only pseudo-pins on the atmega168 and atmega328 have "
#~ "been renamed from PE0/PE1 to PE2/PE3."
#~ msgstr ""

#~ msgid ""
#~ "20210720: A controller_fan section now monitors all stepper motors by "
#~ "default (not just the kinematic stepper motors). If the previous behavior is"
#~ " desired, see the `stepper` config option in the [config "
#~ "reference](Config_Reference.md#controller_fan)."
#~ msgstr ""

#~ msgid ""
#~ "20210703: A `samd_sercom` config section must now specify the sercom bus it "
#~ "is configuring via the `sercom` option."
#~ msgstr ""

#~ msgid ""
#~ "20210612: The `pid_integral_max` config option in heater and temperature_fan"
#~ " sections is deprecated. The option will be removed in the near future."
#~ msgstr ""

#~ msgid ""
#~ "20210503: The gcode_macro `default_parameter_<name>` config option is "
#~ "deprecated. Use the `params` pseudo-variable to access macro parameters. "
#~ "Other methods for accessing macro parameters will be removed in the near "
#~ "future. Most users can replace a `default_parameter_NAME: VALUE` config "
#~ "option with a line like the following in the start of the macro: ` {% set "
#~ "NAME = params.NAME|default(VALUE)|float %}`. See the [Command Templates "
#~ "document](Command_Templates.md#macro-parameters) for examples."
#~ msgstr ""

#~ msgid ""
#~ "20210430: The SET_VELOCITY_LIMIT (and M204) command may now set a velocity, "
#~ "acceleration, and square_corner_velocity larger than the specified values in"
#~ " the config file."
#~ msgstr ""

#~ msgid ""
#~ "20210325: Support for the `pin_map` config option is deprecated. Use the "
#~ "[sample-aliases.cfg](../config/sample-aliases.cfg) file to translate to the "
#~ "actual micro-controller pin names. The `pin_map` config option will be "
#~ "removed in the near future."
#~ msgstr ""

#~ msgid ""
#~ "20210313: Klipper's support for micro-controllers that communicate with CAN "
#~ "bus has changed. If using CAN bus then all micro-controllers must be "
#~ "reflashed and the [Klipper configuration must be updated](CANBUS.md)."
#~ msgstr ""

#~ msgid ""
#~ "20210310: The TMC2660 default for driver_SFILT has been changed from 1 to 0."
#~ msgstr ""

#~ msgid ""
#~ "20210227: TMC stepper motor drivers in UART or SPI mode are now queried once"
#~ " per second whenever they are enabled - if the driver can not be contacted "
#~ "or if the driver reports an error, then Klipper will transition to a "
#~ "shutdown state."
#~ msgstr ""

#~ msgid ""
#~ "20210219: The `rpi_temperature` module has been renamed to "
#~ "`temperature_host`. Replace any occurrences of `sensor_type: "
#~ "rpi_temperature` with `sensor_type: temperature_host`. The path to the "
#~ "temperature file may be specified in the `sensor_path` config variable. The "
#~ "`rpi_temperature` name is deprecated and will be removed in the near future."
#~ msgstr ""

#~ msgid ""
#~ "20210201: The `TEST_RESONANCES` command will now disable input shaping if it"
#~ " was previously enabled (and re-enable it after the test). In order to "
#~ "override this behavior and keep the input shaping enabled, one can pass an "
#~ "additional parameter `INPUT_SHAPING=1` to the command."
#~ msgstr ""

#~ msgid ""
#~ "20210201: The `ACCELEROMETER_MEASURE` command will now append the name of "
#~ "the accelerometer chip to the output file name if the chip was given a name "
#~ "in the corresponding adxl345 section of the printer.cfg."
#~ msgstr ""

#~ msgid ""
#~ "20201222: The `step_distance` setting in the stepper config sections is "
#~ "deprecated. It is advised to update the config to use the "
#~ "[`rotation_distance`](Rotation_Distance.md) setting. Support for "
#~ "`step_distance` will be removed in the near future."
#~ msgstr ""

#~ msgid ""
#~ "20201218: The `endstop_phase` setting in the endstop_phase module has been "
#~ "replaced with `trigger_phase`. If using the endstop phases module then it "
#~ "will be necessary to convert to [`rotation_distance`](Rotation_Distance.md) "
#~ "and recalibrate any endstop phases by running the ENDSTOP_PHASE_CALIBRATE "
#~ "command."
#~ msgstr ""

#~ msgid ""
#~ "20201218: Rotary delta and polar printers must now specify a `gear_ratio` "
#~ "for their rotary steppers, and they may no longer specify a `step_distance` "
#~ "parameter. See the [config reference](Config_Reference.md#stepper) for the "
#~ "format of the new gear_ratio paramter."
#~ msgstr ""

#~ msgid ""
#~ "20201213: It is not valid to specify a Z \"position_endstop\" when using "
#~ "\"probe:z_virtual_endstop\". An error will now be raised if a Z "
#~ "\"position_endstop\" is specified with \"probe:z_virtual_endstop\". Remove "
#~ "the Z \"position_endstop\" definition to fix the error."
#~ msgstr ""

#~ msgid ""
#~ "20201120: The `[board_pins]` config section now specifies the mcu name in an"
#~ " explicit `mcu:` parameter. If using board_pins for a secondary mcu, then "
#~ "the config must be updated to specify that name. See the [config "
#~ "reference](Config_Reference.md#board_pins) for further details."
#~ msgstr ""

#~ msgid ""
#~ "20201112: The time reported by `print_stats.print_duration` has changed. The"
#~ " duration prior to the first detected extrusion is now excluded."
#~ msgstr ""

#~ msgid ""
#~ "20201029: The neopixel `color_order_GRB` config option has been removed. If "
#~ "necessary, update the config to set the new `color_order` option to RGB, "
#~ "GRB, RGBW, or GRBW."
#~ msgstr ""

#~ msgid ""
#~ "20201029: The serial option in the mcu config section no longer defaults to "
#~ "/dev/ttyS0. In the rare situation where /dev/ttyS0 is the desired serial "
#~ "port, it must be specified explicitly."
#~ msgstr ""

#~ msgid "20201020: Klipper v0.9.0 released."
#~ msgstr ""

#~ msgid ""
#~ "20200902: The RTD resistance-to-temperature calculation for MAX31865 "
#~ "converters has been corrected to not read low. If you are using such a "
#~ "device, you should recalibrate your print temperature and PID settings."
#~ msgstr ""

#~ msgid ""
#~ "20200816: The gcode macro `printer.gcode` object has been renamed to "
#~ "`printer.gcode_move`. Several undocumented variables in `printer.toolhead` "
#~ "and `printer.gcode` have been removed. See docs/Command_Templates.md for a "
#~ "list of available template variables."
#~ msgstr ""

#~ msgid ""
#~ "20200816: The gcode macro \"action_\" system has changed. Replace any calls "
#~ "to `printer.gcode.action_emergency_stop()` with `action_emergency_stop()`, "
#~ "`printer.gcode.action_respond_info()` with `action_respond_info()`, and "
#~ "`printer.gcode.action_respond_error()` with `action_raise_error()`."
#~ msgstr ""

#~ msgid ""
#~ "20200809: The menu system has been rewritten. If the menu has been "
#~ "customized then it will be necessary to update to the new configuration. See"
#~ " config/example-menu.cfg for configuration details and see "
#~ "klippy/extras/display/menu.cfg for examples."
#~ msgstr ""

#~ msgid ""
#~ "20200731: The behavior of the `progress` attribute reported by the "
#~ "`virtual_sdcard` printer object has changed. Progress is no longer reset to "
#~ "0 when a print is paused. It will now always report progress based on the "
#~ "internal file position, or 0 if no file is currently loaded."
#~ msgstr ""

#~ msgid ""
#~ "20200725: The servo `enable` config parameter and the SET_SERVO `ENABLE` "
#~ "parameter have been removed. Update any macros to use `SET_SERVO "
#~ "SERVO=my_servo WIDTH=0` to disable a servo."
#~ msgstr ""

#~ msgid ""
#~ "20200608: The LCD display support has changed the name of some internal "
#~ "\"glyphs\". If a custom display layout was implemented it may be necessary "
#~ "to update to the latest glyph names (see klippy/extras/display/display.cfg "
#~ "for a list of available glyphs)."
#~ msgstr ""

#~ msgid ""
#~ "20200606: The pin names on linux mcu have changed. Pins now have names of "
#~ "the form `gpiochip<chipid>/gpio<gpio>`. For gpiochip0 you can also use a "
#~ "short `gpio<gpio>`. For example, what was previously referred to as `P20` "
#~ "now becomes `gpio20` or `gpiochip0/gpio20`."
#~ msgstr ""

#~ msgid ""
#~ "20200603: The default 16x4 LCD layout will no longer show the estimated time"
#~ " remaining in a print. (Only the elapsed time will be shown.) If the old "
#~ "behavior is desired one can customize the menu display with that information"
#~ " (see the description of display_data in config/example-extras.cfg for "
#~ "details)."
#~ msgstr ""

#~ msgid ""
#~ "20200531: The default USB vendor/product id is now 0x1d50/0x614e. These new "
#~ "ids are reserved for Klipper (thanks to the openmoko project). This change "
#~ "should not require any config changes, but the new ids may appear in system "
#~ "logs."
#~ msgstr ""

#~ msgid ""
#~ "20200524: The default value for the tmc5160 pwm_freq field is now zero "
#~ "(instead of one)."
#~ msgstr ""

#~ msgid ""
#~ "20200425: The gcode_macro command template variable `printer.heater` was "
#~ "renamed to `printer.heaters`."
#~ msgstr ""

#~ msgid ""
#~ "20200313: The default lcd layout for multi-extruder printers with a 16x4 "
#~ "screen has changed. The single extruder screen layout is now the default and"
#~ " it will show the currently active extruder. To use the previous display "
#~ "layout set \"display_group: _multiextruder_16x4\" in the [display] section "
#~ "of the printer.cfg file."
#~ msgstr ""

#~ msgid ""
#~ "20200308: The default `__test` menu item was removed. If the config file has"
#~ " a custom menu then be sure to remove all references to this `__test` menu "
#~ "item."
#~ msgstr ""

#~ msgid ""
#~ "20200308: The menu \"deck\" and \"card\" options were removed. To customize "
#~ "the layout of an lcd screen use the new display_data config sections (see "
#~ "config/example-extras.cfg for the details)."
#~ msgstr ""

#~ msgid ""
#~ "20200109: The bed_mesh module now references the probe's location in for the"
#~ " mesh configuration. As such, some configuration options have been renamed "
#~ "to more accurately reflect their intended functionality. For rectangular "
#~ "beds, `min_point` and `max_point` have been renamed to `mesh_min` and "
#~ "`mesh_max` respectively. For round beds, `bed_radius` has been renamed to "
#~ "`mesh_radius`. A new `mesh_origin` option has also been added for round "
#~ "beds. Note that these changes are also incompatible with previously saved "
#~ "mesh profiles. If an incompatible profile is detected it will be ignored and"
#~ " scheduled for removal. The removal process can be completed by issuing the "
#~ "SAVE_CONFIG command. The user will need to re-calibrate each profile."
#~ msgstr ""

#~ msgid ""
#~ "20191218: The display config section no longer supports \"lcd_type: "
#~ "st7567\". Use the \"uc1701\" display type instead - set \"lcd_type: uc1701\""
#~ " and change the \"rs_pin: some_pin\" to \"rst_pin: some_pin\". It may also "
#~ "be necessary to add a \"contrast: 60\" config setting."
#~ msgstr ""

#~ msgid ""
#~ "20191210: The builtin T0, T1, T2, ... commands have been removed. The "
#~ "extruder activate_gcode and deactivate_gcode config options have been "
#~ "removed. If these commands (and scripts) are needed then define individual "
#~ "[gcode_macro T0] style macros that call the ACTIVATE_EXTRUDER command. See "
#~ "the config/sample-idex.cfg and sample-multi-extruder.cfg files for examples."
#~ msgstr ""

#~ msgid ""
#~ "20191210: Support for the M206 command has been removed. Replace with calls "
#~ "to SET_GCODE_OFFSET. If support for M206 is needed, add a [gcode_macro M206]"
#~ " config section that calls SET_GCODE_OFFSET. (For example \"SET_GCODE_OFFSET"
#~ " Z=-{params.Z}\".)"
#~ msgstr ""

#~ msgid ""
#~ "20191202: Support for the undocumented \"S\" parameter of the \"G4\" command"
#~ " has been removed. Replace any occurrences of S with the standard \"P\" "
#~ "parameter (the delay specified in milliseconds)."
#~ msgstr ""

#~ msgid ""
#~ "20191126: The USB names have changed on micro-controllers with native USB "
#~ "support. They now use a unique chip id by default (where available). If an "
#~ "\"mcu\" config section uses a \"serial\" setting that starts with "
#~ "\"/dev/serial/by-id/\" then it may be necessary to update the config. Run "
#~ "\"ls /dev/serial/by-id/*\" in an ssh terminal to determine the new id."
#~ msgstr ""

#~ msgid ""
#~ "20191121: The pressure_advance_lookahead_time parameter has been removed. "
#~ "See example.cfg for alternate configuration settings."
#~ msgstr ""

#~ msgid ""
#~ "20191112: The tmc stepper driver virtual enable capability is now "
#~ "automatically enabled if the stepper does not have a dedicated stepper "
#~ "enable pin. Remove references to tmcXXXX:virtual_enable from the config. The"
#~ " ability to control multiple pins in the stepper enable_pin config has been "
#~ "removed. If multiple pins are needed then use a multi_pin config section."
#~ msgstr ""

#~ msgid ""
#~ "20191107: The primary extruder config section must be specified as "
#~ "\"extruder\" and may no longer be specified as \"extruder0\". Gcode command "
#~ "templates that query the extruder status are now accessed via "
#~ "\"{printer.extruder}\"."
#~ msgstr ""

#~ msgid "20191021: Klipper v0.8.0 released"
#~ msgstr ""

#~ msgid ""
#~ "20191003: The move_to_previous option in [safe_z_homing] now defaults to "
#~ "False. (It was effectively False prior to 20190918.)"
#~ msgstr ""

#~ msgid ""
#~ "20190918: The zhop option in [safe_z_homing] is always re-applied after Z "
#~ "axis homing completed. This might need users to update custom scripts based "
#~ "on this module."
#~ msgstr ""

#~ msgid "20190806: The SET_NEOPIXEL command has been renamed to SET_LED."
#~ msgstr ""

#~ msgid ""
#~ "20190726: The mcp4728 digital-to-analog code has changed. The default "
#~ "i2c_address is now 0x60 and the voltage reference is now relative to the "
#~ "mcp4728's internal 2.048 volt reference."
#~ msgstr ""

#~ msgid ""
#~ "20190710: The z_hop option was removed from the [firmware_retract] config "
#~ "section. The z_hop support was incomplete and could cause incorrect behavior"
#~ " with several common slicers."
#~ msgstr ""

#~ msgid ""
#~ "20190710: The optional parameters of the PROBE_ACCURACY command have "
#~ "changed. It may be necessary to update any macros or scripts that use that "
#~ "command."
#~ msgstr ""

#~ msgid ""
#~ "20190628: All configuration options have been removed from the "
#~ "[skew_correction] section. Configuration for skew_correction is now done via"
#~ " the SET_SKEW gcode. See [Skew Correction](Skew_Correction.md) for "
#~ "recommended usage."
#~ msgstr ""

#~ msgid ""
#~ "20190607: The \"variable_X\" parameters of gcode_macro (along with the VALUE"
#~ " parameter of SET_GCODE_VARIABLE) are now parsed as Python literals. If a "
#~ "value needs to be assigned a string then wrap the value in quotes so that it"
#~ " is evaluated as a string."
#~ msgstr ""

#~ msgid ""
#~ "20190606: The \"samples\", \"samples_result\", and \"sample_retract_dist\" "
#~ "config options have been moved to the \"probe\" config section. These "
#~ "options are no longer supported in the \"delta_calibrate\", \"bed_tilt\", "
#~ "\"bed_mesh\", \"screws_tilt_adjust\", \"z_tilt\", or \"quad_gantry_level\" "
#~ "config sections."
#~ msgstr ""

#~ msgid ""
#~ "20190528: The magic \"status\" variable in gcode_macro template evaluation "
#~ "has been renamed to \"printer\"."
#~ msgstr ""

#~ msgid ""
#~ "20190520: The SET_GCODE_OFFSET command has changed; update any g-code macros"
#~ " accordingly. The command will no longer apply the requested offset to the "
#~ "next G1 command. The old behavior may be approximated by using the new "
#~ "\"MOVE=1\" parameter."
#~ msgstr ""

#~ msgid ""
#~ "20190404: The Python host software packages were updated. Users will need to"
#~ " rerun the ~/klipper/scripts/install-octopi.sh script (or otherwise upgrade "
#~ "the python dependencies if not using a standard OctoPi installation)."
#~ msgstr ""

#~ msgid ""
#~ "20190404: The i2c_bus and spi_bus parameters (in various config sections) "
#~ "now take a bus name instead of a number."
#~ msgstr ""

#~ msgid ""
#~ "20190404: The sx1509 config parameters have changed. The 'address' parameter"
#~ " is now 'i2c_address' and it must be specified as a decimal number. Where "
#~ "0x3E was previously used, specify 62."
#~ msgstr ""

#~ msgid ""
#~ "20190328: The min_speed value in [temperature_fan] config will now be "
#~ "respected and the fan will always run at this speed or higher in PID mode."
#~ msgstr ""

#~ msgid ""
#~ "20190322: The default value for \"driver_HEND\" in [tmc2660] config sections"
#~ " was changed from 6 to 3. The \"driver_VSENSE\" field was removed (it is now"
#~ " automatically calculated from run_current)."
#~ msgstr ""

#~ msgid ""
#~ "20190310: The [controller_fan] config section now always takes a name (such "
#~ "as [controller_fan my_controller_fan])."
#~ msgstr ""

#~ msgid ""
#~ "20190308: The \"driver_BLANK_TIME_SELECT\" field in [tmc2130] and [tmc2208] "
#~ "config sections has been renamed to \"driver_TBL\"."
#~ msgstr ""

#~ msgid ""
#~ "20190308: The [tmc2660] config section has changed. A new sense_resistor "
#~ "config parameter must now be provided. The meaning of several of the "
#~ "driver_XXX parameters has changed."
#~ msgstr ""

#~ msgid ""
#~ "20190228: Users of SPI or I2C on SAMD21 boards must now specify the bus pins"
#~ " via a [samd_sercom] config section."
#~ msgstr ""

#~ msgid ""
#~ "20190224: The bed_shape option has been removed from bed_mesh. The radius "
#~ "option has been renamed to bed_radius. Users with round beds should supply "
#~ "the bed_radius and round_probe_count options."
#~ msgstr ""

#~ msgid ""
#~ "20190107: The i2c_address parameter in the mcp4451 config section changed. "
#~ "This is a common setting on Smoothieboards. The new value is half the old "
#~ "value (88 should be changed to 44, and 90 should be changed to 45)."
#~ msgstr ""

#~ msgid "20181220: Klipper v0.7.0 released"
#~ msgstr ""

#~ msgid "Commands templates"
#~ msgstr ""

#~ msgid ""
#~ "This document provides information on implementing G-Code command sequences "
#~ "in gcode_macro (and similar) config sections."
#~ msgstr ""

#~ msgid "G-Code Macro Naming"
#~ msgstr ""

#~ msgid ""
#~ "Case is not important for the G-Code macro name - MY_MACRO and my_macro will"
#~ " evaluate the same and may be called in either upper or lower case. If any "
#~ "numbers are used in the macro name then they must all be at the end of the "
#~ "name (eg, TEST_MACRO25 is valid, but MACRO25_TEST3 is not)."
#~ msgstr ""

#~ msgid "Formatting of G-Code in the config"
#~ msgstr ""

#~ msgid ""
#~ "Indentation is important when defining a macro in the config file. To "
#~ "specify a multi-line G-Code sequence it is important for each line to have "
#~ "proper indentation. For example:"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro blink_led]\n"
#~ "gcode:\n"
#~ "  SET_PIN PIN=my_led VALUE=1\n"
#~ "  G4 P2000\n"
#~ "  SET_PIN PIN=my_led VALUE=0\n"
#~ msgstr ""

#~ msgid ""
#~ "Note how the `gcode:` config option always starts at the beginning of the "
#~ "line and subsequent lines in the G-Code macro never start at the beginning."
#~ msgstr ""

#~ msgid "Add a description to your macro"
#~ msgstr ""

#~ msgid ""
#~ "To help identify the functionality a short description can be added. Add "
#~ "`description:` with a short text to describe the functionality. Default is "
#~ "\"G-Code macro\" if not specified. For example:"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro blink_led]\n"
#~ "description: Blink my_led one time\n"
#~ "gcode:\n"
#~ "  SET_PIN PIN=my_led VALUE=1\n"
#~ "  G4 P2000\n"
#~ "  SET_PIN PIN=my_led VALUE=0\n"
#~ msgstr ""

#~ msgid ""
#~ "The terminal will display the description when you use the `HELP` command or"
#~ " the autocomplete function."
#~ msgstr ""

#~ msgid "Save/Restore state for G-Code moves"
#~ msgstr ""

#~ msgid ""
#~ "Unfortunately, the G-Code command language can be challenging to use. The "
#~ "standard mechanism to move the toolhead is via the `G1` command (the `G0` "
#~ "command is an alias for `G1` and it can be used interchangeably with it). "
#~ "However, this command relies on the \"G-Code parsing state\" setup by `M82`,"
#~ " `M83`, `G90`, `G91`, `G92`, and previous `G1` commands. When creating a "
#~ "G-Code macro it is a good idea to always explicitly set the G-Code parsing "
#~ "state prior to issuing a `G1` command. (Otherwise, there is a risk the `G1` "
#~ "command will make an undesirable request.)"
#~ msgstr ""

#~ msgid ""
#~ "A common way to accomplish that is to wrap the `G1` moves in "
#~ "`SAVE_GCODE_STATE`, `G91`, and `RESTORE_GCODE_STATE`. For example:"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro MOVE_UP]\n"
#~ "gcode:\n"
#~ "  SAVE_GCODE_STATE NAME=my_move_up_state\n"
#~ "  G91\n"
#~ "  G1 Z10 F300\n"
#~ "  RESTORE_GCODE_STATE NAME=my_move_up_state\n"
#~ msgstr ""

#~ msgid ""
#~ "The `G91` command places the G-Code parsing state into \"relative move "
#~ "mode\" and the `RESTORE_GCODE_STATE` command restores the state to what it "
#~ "was prior to entering the macro. Be sure to specify an explicit speed (via "
#~ "the `F` parameter) on the first `G1` command."
#~ msgstr ""

#~ msgid "Template expansion"
#~ msgstr ""

#~ msgid ""
#~ "The gcode_macro `gcode:` config section is evaluated using the Jinja2 "
#~ "template language. One can evaluate expressions at run-time by wrapping them"
#~ " in `{ }` characters or use conditional statements wrapped in `{% %}`. See "
#~ "the [Jinja2 documentation](http://jinja.pocoo.org/docs/2.10/templates/) for "
#~ "further information on the syntax."
#~ msgstr ""

#~ msgid "An example of a complex macro:"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro clean_nozzle]\n"
#~ "gcode:\n"
#~ "  {% set wipe_count = 8 %}\n"
#~ "  SAVE_GCODE_STATE NAME=clean_nozzle_state\n"
#~ "  G90\n"
#~ "  G0 Z15 F300\n"
#~ "  {% for wipe in range(wipe_count) %}\n"
#~ "    {% for coordinate in [(275, 4),(235, 4)] %}\n"
#~ "      G0 X{coordinate[0]} Y{coordinate[1] + 0.25 * wipe} Z9.7 F12000\n"
#~ "    {% endfor %}\n"
#~ "  {% endfor %}\n"
#~ "  RESTORE_GCODE_STATE NAME=clean_nozzle_state\n"
#~ msgstr ""

#~ msgid "Macro parameters"
#~ msgstr ""

#~ msgid ""
#~ "It is often useful to inspect parameters passed to the macro when it is "
#~ "called. These parameters are available via the `params` pseudo-variable. For"
#~ " example, if the macro:"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro SET_PERCENT]\n"
#~ "gcode:\n"
#~ "  M117 Now at { params.VALUE|float * 100 }%\n"
#~ msgstr ""

#~ msgid ""
#~ "were invoked as `SET_PERCENT VALUE=.2` it would evaluate to `M117 Now at "
#~ "20%`. Note that parameter names are always in upper-case when evaluated in "
#~ "the macro and are always passed as strings. If performing math then they "
#~ "must be explicitly converted to integers or floats."
#~ msgstr ""

#~ msgid ""
#~ "It's common to use the Jinja2 `set` directive to use a default parameter and"
#~ " assign the result to a local name. For example:"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro SET_BED_TEMPERATURE]\n"
#~ "gcode:\n"
#~ "  {% set bed_temp = params.TEMPERATURE|default(40)|float %}\n"
#~ "  M140 S{bed_temp}\n"
#~ msgstr ""

#~ msgid "The \"rawparams\" variable"
#~ msgstr ""

#~ msgid ""
#~ "The full unparsed parameters for the running macro can be access via the "
#~ "`rawparams` pseudo-variable."
#~ msgstr ""

#~ msgid ""
#~ "Note that this will include any comments that were part of the original "
#~ "command."
#~ msgstr ""

#~ msgid ""
#~ "See the [sample-macros.cfg](../config/sample-macros.cfg) file for an example"
#~ " showing how to override the `M117` command using `rawparams`."
#~ msgstr ""

#~ msgid "The \"printer\" Variable"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to inspect (and alter) the current state of the printer via "
#~ "the `printer` pseudo-variable. For example:"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro slow_fan]\n"
#~ "gcode:\n"
#~ "  M106 S{ printer.fan.speed * 0.9 * 255}\n"
#~ msgstr ""

#~ msgid ""
#~ "Available fields are defined in the [Status Reference](Status_Reference.md) "
#~ "document."
#~ msgstr ""

#~ msgid ""
#~ "Important! Macros are first evaluated in entirety and only then are the "
#~ "resulting commands executed. If a macro issues a command that alters the "
#~ "state of the printer, the results of that state change will not be visible "
#~ "during the evaluation of the macro. This can also result in subtle behavior "
#~ "when a macro generates commands that call other macros, as the called macro "
#~ "is evaluated when it is invoked (which is after the entire evaluation of the"
#~ " calling macro)."
#~ msgstr ""

#~ msgid ""
#~ "By convention, the name immediately following `printer` is the name of a "
#~ "config section. So, for example, `printer.fan` refers to the fan object "
#~ "created by the `[fan]` config section. There are some exceptions to this "
#~ "rule - notably the `gcode_move` and `toolhead` objects. If the config "
#~ "section contains spaces in it, then one can access it via the `[ ]` accessor"
#~ " - for example: `printer[\"generic_heater my_chamber_heater\"].temperature`."
#~ msgstr ""

#~ msgid ""
#~ "Note that the Jinja2 `set` directive can assign a local name to an object in"
#~ " the `printer` hierarchy. This can make macros more readable and reduce "
#~ "typing. For example:"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro QUERY_HTU21D]\n"
#~ "gcode:\n"
#~ "    {% set sensor = printer[\"htu21d my_sensor\"] %}\n"
#~ "    M117 Temp:{sensor.temperature} Humidity:{sensor.humidity}\n"
#~ msgstr ""

#~ msgid "Actions"
#~ msgstr ""

#~ msgid ""
#~ "There are some commands available that can alter the state of the printer. "
#~ "For example, `{ action_emergency_stop() }` would cause the printer to go "
#~ "into a shutdown state. Note that these actions are taken at the time that "
#~ "the macro is evaluated, which may be a significant amount of time before the"
#~ " generated g-code commands are executed."
#~ msgstr ""

#~ msgid "Available \"action\" commands:"
#~ msgstr ""

#~ msgid ""
#~ "`action_respond_info(msg)`: Write the given `msg` to the /tmp/printer "
#~ "pseudo-terminal. Each line of `msg` will be sent with a \"// \" prefix."
#~ msgstr ""

#~ msgid ""
#~ "`action_raise_error(msg)`: Abort the current macro (and any calling macros) "
#~ "and write the given `msg` to the /tmp/printer pseudo-terminal. The first "
#~ "line of `msg` will be sent with a \"!! \" prefix and subsequent lines will "
#~ "have a \"// \" prefix."
#~ msgstr ""

#~ msgid ""
#~ "`action_emergency_stop(msg)`: Transition the printer to a shutdown state. "
#~ "The `msg` parameter is optional, it may be useful to describe the reason for"
#~ " the shutdown."
#~ msgstr ""

#~ msgid ""
#~ "`action_call_remote_method(method_name)`: Calls a method registered by a "
#~ "remote client. If the method takes parameters they should be provided via "
#~ "keyword arguments, ie: `action_call_remote_method(\"print_stuff\", "
#~ "my_arg=\"hello_world\")`"
#~ msgstr ""

#~ msgid "Variables"
#~ msgstr ""

#~ msgid ""
#~ "The SET_GCODE_VARIABLE command may be useful for saving state between macro "
#~ "calls. Variable names may not contain any upper case characters. For "
#~ "example:"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro start_probe]\n"
#~ "variable_bed_temp: 0\n"
#~ "gcode:\n"
#~ "  # Save target temperature to bed_temp variable\n"
#~ "  SET_GCODE_VARIABLE MACRO=start_probe VARIABLE=bed_temp VALUE={printer.heater_bed.target}\n"
#~ "  # Disable bed heater\n"
#~ "  M140\n"
#~ "  # Perform probe\n"
#~ "  PROBE\n"
#~ "  # Call finish_probe macro at completion of probe\n"
#~ "  finish_probe\n"
#~ "\n"
#~ "[gcode_macro finish_probe]\n"
#~ "gcode:\n"
#~ "  # Restore temperature\n"
#~ "  M140 S{printer[\"gcode_macro start_probe\"].bed_temp}\n"
#~ msgstr ""

#~ msgid ""
#~ "Be sure to take the timing of macro evaluation and command execution into "
#~ "account when using SET_GCODE_VARIABLE."
#~ msgstr ""

#~ msgid "Delayed Gcodes"
#~ msgstr ""

#~ msgid ""
#~ "The [delayed_gcode] configuration option can be used to execute a delayed "
#~ "gcode sequence:"
#~ msgstr ""

#~ msgid ""
#~ "[delayed_gcode clear_display]\n"
#~ "gcode:\n"
#~ "  M117\n"
#~ "\n"
#~ "[gcode_macro load_filament]\n"
#~ "gcode:\n"
#~ " G91\n"
#~ " G1 E50\n"
#~ " G90\n"
#~ " M400\n"
#~ " M117 Load Complete!\n"
#~ " UPDATE_DELAYED_GCODE ID=clear_display DURATION=10\n"
#~ msgstr ""

#~ msgid ""
#~ "When the `load_filament` macro above executes, it will display a \"Load "
#~ "Complete!\" message after the extrusion is finished. The last line of gcode "
#~ "enables the \"clear_display\" delayed_gcode, set to execute in 10 seconds."
#~ msgstr ""

#~ msgid ""
#~ "The `initial_duration` config option can be set to execute the delayed_gcode"
#~ " on printer startup. The countdown begins when the printer enters the "
#~ "\"ready\" state. For example, the below delayed_gcode will execute 5 seconds"
#~ " after the printer is ready, initializing the display with a \"Welcome!\" "
#~ "message:"
#~ msgstr ""

#~ msgid ""
#~ "[delayed_gcode welcome]\n"
#~ "initial_duration: 5.\n"
#~ "gcode:\n"
#~ "  M117 Welcome!\n"
#~ msgstr ""

#~ msgid ""
#~ "Its possible for a delayed gcode to repeat by updating itself in the gcode "
#~ "option:"
#~ msgstr ""

#~ msgid ""
#~ "[delayed_gcode report_temp]\n"
#~ "initial_duration: 2.\n"
#~ "gcode:\n"
#~ "  {action_respond_info(\"Extruder Temp: %.1f\" % (printer.extruder0.temperature))}\n"
#~ "  UPDATE_DELAYED_GCODE ID=report_temp DURATION=2\n"
#~ msgstr ""

#~ msgid ""
#~ "The above delayed_gcode will send \"// Extruder Temp: [ex0_temp]\" to "
#~ "Octoprint every 2 seconds. This can be canceled with the following gcode:"
#~ msgstr ""

#~ msgid "UPDATE_DELAYED_GCODE ID=report_temp DURATION=0\n"
#~ msgstr ""

#~ msgid "Menu templates"
#~ msgstr ""

#~ msgid ""
#~ "If a [display config section](Config_Reference.md#display) is enabled, then "
#~ "it is possible to customize the menu with [menu](Config_Reference.md#menu) "
#~ "config sections."
#~ msgstr ""

#~ msgid "The following read-only attributes are available in menu templates:"
#~ msgstr ""

#~ msgid "`menu.width` - element width (number of display columns)"
#~ msgstr ""

#~ msgid "`menu.ns` - element namespace"
#~ msgstr ""

#~ msgid "`menu.event` - name of the event that triggered the script"
#~ msgstr ""

#~ msgid "`menu.input` - input value, only available in input script context"
#~ msgstr ""

#~ msgid "The following actions are available in menu templates:"
#~ msgstr ""

#~ msgid ""
#~ "`menu.back(force, update)`: will execute menu back command, optional boolean"
#~ " parameters `<force>` and `<update>`."
#~ msgstr ""

#~ msgid ""
#~ "When `<force>` is set True then it will also stop editing. Default value is "
#~ "False."
#~ msgstr ""

#~ msgid ""
#~ "When `<update>` is set False then parent container items are not updated. "
#~ "Default value is True."
#~ msgstr ""

#~ msgid ""
#~ "`menu.exit(force)` - will execute menu exit command, optional boolean "
#~ "parameter `<force>` default value False."
#~ msgstr ""

#~ msgid "Save Variables to disk"
#~ msgstr ""

#~ msgid ""
#~ "If a [save_variables config section](Config_Reference.md#save_variables) has"
#~ " been enabled, `SAVE_VARIABLE VARIABLE=<name> VALUE=<value>` can be used to "
#~ "save the variable to disk so that it can be used across restarts. All stored"
#~ " variables are loaded into the `printer.save_variables.variables` dict at "
#~ "startup and can be used in gcode macros. to avoid overly long lines you can "
#~ "add the following at the top of the macro:"
#~ msgstr ""

#~ msgid "{% set svv = printer.save_variables.variables %}\n"
#~ msgstr ""

#~ msgid ""
#~ "As an example, it could be used to save the state of 2-in-1-out hotend and "
#~ "when starting a print ensure that the active extruder is used, instead of "
#~ "T0:"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro T1]\n"
#~ "gcode:\n"
#~ "  ACTIVATE_EXTRUDER extruder=extruder1\n"
#~ "  SAVE_VARIABLE VARIABLE=currentextruder VALUE='\"extruder1\"'\n"
#~ "\n"
#~ "[gcode_macro T0]\n"
#~ "gcode:\n"
#~ "  ACTIVATE_EXTRUDER extruder=extruder\n"
#~ "  SAVE_VARIABLE VARIABLE=currentextruder VALUE='\"extruder\"'\n"
#~ "\n"
#~ "[gcode_macro START_GCODE]\n"
#~ "gcode:\n"
#~ "  {% set svv = printer.save_variables.variables %}\n"
#~ "  ACTIVATE_EXTRUDER extruder={svv.currentextruder}\n"
#~ msgstr ""

#~ msgid "Code overview"
#~ msgstr ""

#~ msgid ""
#~ "This document describes the overall code layout and major code flow of "
#~ "Klipper."
#~ msgstr ""

#~ msgid "Directory Layout"
#~ msgstr ""

#~ msgid ""
#~ "The **src/** directory contains the C source for the micro-controller code. "
#~ "The **src/atsam/**, **src/atsamd/**, **src/avr/**, **src/linux/**, "
#~ "**src/lpc176x/**, **src/pru/**, and **src/stm32/** directories contain "
#~ "architecture specific micro-controller code. The **src/simulator/** contains"
#~ " code stubs that allow the micro-controller to be test compiled on other "
#~ "architectures. The **src/generic/** directory contains helper code that may "
#~ "be useful across different architectures. The build arranges for includes of"
#~ " \"board/somefile.h\" to first look in the current architecture directory "
#~ "(eg, src/avr/somefile.h) and then in the generic directory (eg, "
#~ "src/generic/somefile.h)."
#~ msgstr ""

#~ msgid ""
#~ "The **klippy/** directory contains the host software. Most of the host "
#~ "software is written in Python, however the **klippy/chelper/** directory "
#~ "contains some C code helpers. The **klippy/kinematics/** directory contains "
#~ "the robot kinematics code. The **klippy/extras/** directory contains the "
#~ "host code extensible \"modules\"."
#~ msgstr ""

#~ msgid ""
#~ "The **lib/** directory contains external 3rd-party library code that is "
#~ "necessary to build some targets."
#~ msgstr ""

#~ msgid ""
#~ "The **config/** directory contains example printer configuration files."
#~ msgstr ""

#~ msgid ""
#~ "The **scripts/** directory contains build-time scripts useful for compiling "
#~ "the micro-controller code."
#~ msgstr ""

#~ msgid "The **test/** directory contains automated test cases."
#~ msgstr ""

#~ msgid ""
#~ "During compilation, the build may create an **out/** directory. This "
#~ "contains temporary build time objects. The final micro-controller object "
#~ "that is built is **out/klipper.elf.hex** on AVR and **out/klipper.bin** on "
#~ "ARM."
#~ msgstr ""

#~ msgid "Micro-controller code flow"
#~ msgstr ""

#~ msgid ""
#~ "Execution of the micro-controller code starts in architecture specific code "
#~ "(eg, **src/avr/main.c**) which ultimately calls sched_main() located in "
#~ "**src/sched.c**. The sched_main() code starts by running all functions that "
#~ "have been tagged with the DECL_INIT() macro. It then goes on to repeatedly "
#~ "run all functions tagged with the DECL_TASK() macro."
#~ msgstr ""

#~ msgid ""
#~ "One of the main task functions is command_dispatch() located in "
#~ "**src/command.c**. This function is called from the board specific "
#~ "input/output code (eg, **src/avr/serial.c**, **src/generic/serial_irq.c**) "
#~ "and it runs the command functions associated with the commands found in the "
#~ "input stream. Command functions are declared using the DECL_COMMAND() macro "
#~ "(see the [protocol](Protocol.md) document for more information)."
#~ msgstr ""

#~ msgid ""
#~ "Task, init, and command functions always run with interrupts enabled "
#~ "(however, they can temporarily disable interrupts if needed). These "
#~ "functions should avoid long pauses, delays, or do work that lasts a "
#~ "significant time. (Long delays in these \"task\" functions result in "
#~ "scheduling jitter for other \"tasks\" - delays over 100us may become "
#~ "noticeable, delays over 500us may result in command retransmissions, delays "
#~ "over 100ms may result in watchdog reboots.) These functions schedule work at"
#~ " specific times by scheduling timers."
#~ msgstr ""

#~ msgid ""
#~ "Timer functions are scheduled by calling sched_add_timer() (located in "
#~ "**src/sched.c**). The scheduler code will arrange for the given function to "
#~ "be called at the requested clock time. Timer interrupts are initially "
#~ "handled in an architecture specific interrupt handler (eg, "
#~ "**src/avr/timer.c**) which calls sched_timer_dispatch() located in "
#~ "**src/sched.c**. The timer interrupt leads to execution of schedule timer "
#~ "functions. Timer functions always run with interrupts disabled. The timer "
#~ "functions should always complete within a few micro-seconds. At completion "
#~ "of the timer event, the function may choose to reschedule itself."
#~ msgstr ""

#~ msgid ""
#~ "In the event an error is detected the code can invoke shutdown() (a macro "
#~ "which calls sched_shutdown() located in **src/sched.c**). Invoking "
#~ "shutdown() causes all functions tagged with the DECL_SHUTDOWN() macro to be "
#~ "run. Shutdown functions always run with interrupts disabled."
#~ msgstr ""

#~ msgid ""
#~ "Much of the functionality of the micro-controller involves working with "
#~ "General-Purpose Input/Output pins (GPIO). In order to abstract the low-level"
#~ " architecture specific code from the high-level task code, all GPIO events "
#~ "are implemented in architecture specific wrappers (eg, **src/avr/gpio.c**). "
#~ "The code is compiled with gcc's \"-flto -fwhole-program\" optimization which"
#~ " does an excellent job of inlining functions across compilation units, so "
#~ "most of these tiny gpio functions are inlined into their callers, and there "
#~ "is no run-time cost to using them."
#~ msgstr ""

#~ msgid "Klippy code overview"
#~ msgstr ""

#~ msgid ""
#~ "The host code (Klippy) is intended to run on a low-cost computer (such as a "
#~ "Raspberry Pi) paired with the micro-controller. The code is primarily "
#~ "written in Python, however it does use CFFI to implement some functionality "
#~ "in C code."
#~ msgstr ""

#~ msgid ""
#~ "Initial execution starts in **klippy/klippy.py**. This reads the command-"
#~ "line arguments, opens the printer config file, instantiates the main printer"
#~ " objects, and starts the serial connection. The main execution of G-code "
#~ "commands is in the process_commands() method in **klippy/gcode.py**. This "
#~ "code translates the G-code commands into printer object calls, which "
#~ "frequently translate the actions to commands to be executed on the micro-"
#~ "controller (as declared via the DECL_COMMAND macro in the micro-controller "
#~ "code)."
#~ msgstr ""

#~ msgid ""
#~ "There are four threads in the Klippy host code. The main thread handles "
#~ "incoming gcode commands. A second thread (which resides entirely in the "
#~ "**klippy/chelper/serialqueue.c** C code) handles low-level IO with the "
#~ "serial port. The third thread is used to process response messages from the "
#~ "micro-controller in the Python code (see **klippy/serialhdl.py**). The "
#~ "fourth thread writes debug messages to the log (see "
#~ "**klippy/queuelogger.py**) so that the other threads never block on log "
#~ "writes."
#~ msgstr ""

#~ msgid "Code flow of a move command"
#~ msgstr ""

#~ msgid ""
#~ "A typical printer movement starts when a \"G1\" command is sent to the "
#~ "Klippy host and it completes when the corresponding step pulses are produced"
#~ " on the micro-controller. This section outlines the code flow of a typical "
#~ "move command. The [kinematics](Kinematics.md) document provides further "
#~ "information on the mechanics of moves."
#~ msgstr ""

#~ msgid ""
#~ "Processing for a move command starts in gcode.py. The goal of gcode.py is to"
#~ " translate G-code into internal calls. A G1 command will invoke cmd_G1() in "
#~ "klippy/extras/gcode_move.py. The gcode_move.py code handles changes in "
#~ "origin (eg, G92), changes in relative vs absolute positions (eg, G90), and "
#~ "unit changes (eg, F6000=100mm/s). The code path for a move is: "
#~ "`_process_data() -> _process_commands() -> cmd_G1()`. Ultimately the "
#~ "ToolHead class is invoked to execute the actual request: `cmd_G1() -> "
#~ "ToolHead.move()`"
#~ msgstr ""

#~ msgid ""
#~ "The ToolHead class (in toolhead.py) handles \"look-ahead\" and tracks the "
#~ "timing of printing actions. The main codepath for a move is: "
#~ "`ToolHead.move() -> MoveQueue.add_move() -> MoveQueue.flush() -> "
#~ "Move.set_junction() -> ToolHead._process_moves()`."
#~ msgstr ""

#~ msgid ""
#~ "ToolHead.move() creates a Move() object with the parameters of the move (in "
#~ "cartesian space and in units of seconds and millimeters)."
#~ msgstr ""

#~ msgid ""
#~ "The kinematics class is given the opportunity to audit each move "
#~ "(`ToolHead.move() -> kin.check_move()`). The kinematics classes are located "
#~ "in the klippy/kinematics/ directory. The check_move() code may raise an "
#~ "error if the move is not valid. If check_move() completes successfully then "
#~ "the underlying kinematics must be able to handle the move."
#~ msgstr ""

#~ msgid "MoveQueue.add_move() places the move object on the \"look-ahead\" queue."
#~ msgstr ""

#~ msgid ""
#~ "MoveQueue.flush() determines the start and end velocities of each move."
#~ msgstr ""

#~ msgid ""
#~ "Move.set_junction() implements the \"trapezoid generator\" on a move. The "
#~ "\"trapezoid generator\" breaks every move into three parts: a constant "
#~ "acceleration phase, followed by a constant velocity phase, followed by a "
#~ "constant deceleration phase. Every move contains these three phases in this "
#~ "order, but some phases may be of zero duration."
#~ msgstr ""

#~ msgid ""
#~ "When ToolHead._process_moves() is called, everything about the move is known"
#~ " - its start location, its end location, its acceleration, its "
#~ "start/cruising/end velocity, and distance traveled during "
#~ "acceleration/cruising/deceleration. All the information is stored in the "
#~ "Move() class and is in cartesian space in units of millimeters and seconds."
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
#~ "finding_algorithm) to generate the step times for each stepper. For "
#~ "efficiency reasons, the stepper pulse times are generated in C code. The "
#~ "moves are first placed on a \"trapezoid motion queue\": "
#~ "`ToolHead._process_moves() -> trapq_append()` (in klippy/chelper/trapq.c). "
#~ "The step times are then generated: `ToolHead._process_moves() -> "
#~ "ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> "
#~ "itersolve_generate_steps() -> itersolve_gen_steps_range()` (in "
#~ "klippy/chelper/itersolve.c). The goal of the iterative solver is to find "
#~ "step times given a function that calculates a stepper position from a time. "
#~ "This is done by repeatedly \"guessing\" various times until the stepper "
#~ "position formula returns the desired position of the next step on the "
#~ "stepper. The feedback produced from each guess is used to improve future "
#~ "guesses so that the process rapidly converges to the desired time. The "
#~ "kinematic stepper position formulas are located in the klippy/chelper/ "
#~ "directory (eg, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c)."
#~ msgstr ""

#~ msgid ""
#~ "Note that the extruder is handled in its own kinematic class: "
#~ "`ToolHead._process_moves() -> PrinterExtruder.move()`. Since the Move() "
#~ "class specifies the exact movement time and since step pulses are sent to "
#~ "the micro-controller with specific timing, stepper movements produced by the"
#~ " extruder class will be in sync with head movement even though the code is "
#~ "kept separate."
#~ msgstr ""

#~ msgid ""
#~ "After the iterative solver calculates the step times they are added to an "
#~ "array: `itersolve_gen_steps_range() -> stepcompress_append()` (in "
#~ "klippy/chelper/stepcompress.c). The array (struct stepcompress.queue) stores"
#~ " the corresponding micro-controller clock counter times for every step. Here"
#~ " the \"micro-controller clock counter\" value directly corresponds to the "
#~ "micro-controller's hardware counter - it is relative to when the micro-"
#~ "controller was last powered up."
#~ msgstr ""

#~ msgid ""
#~ "The next major step is to compress the steps: `stepcompress_flush() -> "
#~ "compress_bisect_add()` (in klippy/chelper/stepcompress.c). This code "
#~ "generates and encodes a series of micro-controller \"queue_step\" commands "
#~ "that correspond to the list of stepper step times built in the previous "
#~ "stage. These \"queue_step\" commands are then queued, prioritized, and sent "
#~ "to the micro-controller (via stepcompress.c:steppersync and "
#~ "serialqueue.c:serialqueue)."
#~ msgstr ""

#~ msgid ""
#~ "Processing of the queue_step commands on the micro-controller starts in "
#~ "src/command.c which parses the command and calls `command_queue_step()`. The"
#~ " command_queue_step() code (in src/stepper.c) just appends the parameters of"
#~ " each queue_step command to a per stepper queue. Under normal operation the "
#~ "queue_step command is parsed and queued at least 100ms before the time of "
#~ "its first step. Finally, the generation of stepper events is done in "
#~ "`stepper_event()`. It's called from the hardware timer interrupt at the "
#~ "scheduled time of the first step. The stepper_event() code generates a step "
#~ "pulse and then reschedules itself to run at the time of the next step pulse "
#~ "for the given queue_step parameters. The parameters for each queue_step "
#~ "command are \"interval\", \"count\", and \"add\". At a high-level, "
#~ "stepper_event() runs the following, 'count' times: `do_step(); "
#~ "next_wake_time = last_wake_time + interval; interval += add;`"
#~ msgstr ""

#~ msgid ""
#~ "The above may seem like a lot of complexity to execute a movement. However, "
#~ "the only really interesting parts are in the ToolHead and kinematic classes."
#~ " It's this part of the code which specifies the movements and their timings."
#~ " The remaining parts of the processing is mostly just communication and "
#~ "plumbing."
#~ msgstr ""

#~ msgid "Adding a host module"
#~ msgstr ""

#~ msgid ""
#~ "The Klippy host code has a dynamic module loading capability. If a config "
#~ "section named \"[my_module]\" is found in the printer config file then the "
#~ "software will automatically attempt to load the python module "
#~ "klippy/extras/my_module.py . This module system is the preferred method for "
#~ "adding new functionality to Klipper."
#~ msgstr ""

#~ msgid ""
#~ "The easiest way to add a new module is to use an existing module as a "
#~ "reference - see **klippy/extras/servo.py** as an example."
#~ msgstr ""

#~ msgid "The following may also be useful:"
#~ msgstr ""

#~ msgid ""
#~ "Execution of the module starts in the module level `load_config()` function "
#~ "(for config sections of the form [my_module]) or in `load_config_prefix()` "
#~ "(for config sections of the form [my_module my_name]). This function is "
#~ "passed a \"config\" object and it must return a new \"printer object\" "
#~ "associated with the given config section."
#~ msgstr ""

#~ msgid ""
#~ "During the process of instantiating a new printer object, the config object "
#~ "can be used to read parameters from the given config section. This is done "
#~ "using `config.get()`, `config.getfloat()`, `config.getint()`, etc. methods. "
#~ "Be sure to read all values from the config during the construction of the "
#~ "printer object - if the user specifies a config parameter that is not read "
#~ "during this phase then it will be assumed it is a typo in the config and an "
#~ "error will be raised."
#~ msgstr ""

#~ msgid ""
#~ "Use the `config.get_printer()` method to obtain a reference to the main "
#~ "\"printer\" class. This \"printer\" class stores references to all the "
#~ "\"printer objects\" that have been instantiated. Use the "
#~ "`printer.lookup_object()` method to find references to other printer "
#~ "objects. Almost all functionality (even core kinematic modules) are "
#~ "encapsulated in one of these printer objects. Note, though, that when a new "
#~ "module is instantiated, not all other printer objects will have been "
#~ "instantiated. The \"gcode\" and \"pins\" modules will always be available, "
#~ "but for other modules it is a good idea to defer the lookup."
#~ msgstr ""

#~ msgid ""
#~ "Register event handlers using the `printer.register_event_handler()` method "
#~ "if the code needs to be called during \"events\" raised by other printer "
#~ "objects. Each event name is a string, and by convention it is the name of "
#~ "the main source module that raises the event along with a short name for the"
#~ " action that is occurring (eg, \"klippy:connect\"). The parameters passed to"
#~ " each event handler are specific to the given event (as are exception "
#~ "handling and execution context). Two common startup events are:"
#~ msgstr ""

#~ msgid ""
#~ "klippy:connect - This event is generated after all printer objects are "
#~ "instantiated. It is commonly used to lookup other printer objects, to verify"
#~ " config settings, and to perform an initial \"handshake\" with printer "
#~ "hardware."
#~ msgstr ""

#~ msgid ""
#~ "klippy:ready - This event is generated after all connect handlers have "
#~ "completed successfully. It indicates the printer is transitioning to a state"
#~ " ready to handle normal operations. Do not raise an error in this callback."
#~ msgstr ""

#~ msgid ""
#~ "If there is an error in the user's config, be sure to raise it during the "
#~ "`load_config()` or \"connect event\" phases. Use either `raise "
#~ "config.error(\"my error\")` or `raise printer.config_error(\"my error\")` to"
#~ " report the error."
#~ msgstr ""

#~ msgid ""
#~ "Use the \"pins\" module to configure a pin on a micro-controller. This is "
#~ "typically done with something similar to "
#~ "`printer.lookup_object(\"pins\").setup_pin(\"pwm\", "
#~ "config.get(\"my_pin\"))`. The returned object can then be commanded at run-"
#~ "time."
#~ msgstr ""

#~ msgid ""
#~ "If the printer object defines a `get_status()` method then the module can "
#~ "export [status information](Status_Reference.md) via "
#~ "[macros](Command_Templates.md) and via the [API Server](API_Server.md). The "
#~ "`get_status()` method must return a Python dictionary with keys that are "
#~ "strings and values that are integers, floats, strings, lists, dictionaries, "
#~ "True, False, or None. Tuples (and named tuples) may also be used (these "
#~ "appear as lists when accessed via the API Server). Lists and dictionaries "
#~ "that are exported must be treated as \"immutable\" - if their contents "
#~ "change then a new object must be returned from `get_status()`, otherwise the"
#~ " API Server will not detect those changes."
#~ msgstr ""

#~ msgid ""
#~ "If the module needs access to system timing or external file descriptors "
#~ "then use `printer.get_reactor()` to obtain access to the global \"event "
#~ "reactor\" class. This reactor class allows one to schedule timers, wait for "
#~ "input on file descriptors, and to \"sleep\" the host code."
#~ msgstr ""

#~ msgid ""
#~ "Do not use global variables. All state should be stored in the printer "
#~ "object returned from the `load_config()` function. This is important as "
#~ "otherwise the RESTART command may not perform as expected. Also, for similar"
#~ " reasons, if any external files (or sockets) are opened then be sure to "
#~ "register a \"klippy:disconnect\" event handler and close them from that "
#~ "callback."
#~ msgstr ""

#~ msgid ""
#~ "Avoid accessing the internal member variables (or calling methods that start"
#~ " with an underscore) of other printer objects. Observing this convention "
#~ "makes it easier to manage future changes."
#~ msgstr ""

#~ msgid ""
#~ "It is recommended to assign a value to all member variables in the Python "
#~ "constructor of Python classes. (And therefore avoid utilizing Python's "
#~ "ability to dynamically create new member variables.)"
#~ msgstr ""

#~ msgid ""
#~ "If a Python variable is to store a floating point value then it is "
#~ "recommended to always assign and manipulate that variable with floating "
#~ "point constants (and never use integer constants). For example, prefer "
#~ "`self.speed = 1.` over `self.speed = 1`, and prefer `self.speed = 2. * x` "
#~ "over `self.speed = 2 * x`. Consistent use of floating point values can avoid"
#~ " hard to debug quirks in Python type conversions."
#~ msgstr ""

#~ msgid ""
#~ "If submitting the module for inclusion in the main Klipper code, be sure to "
#~ "place a copyright notice at the top of the module. See the existing modules "
#~ "for the preferred format."
#~ msgstr ""

#~ msgid "Adding new kinematics"
#~ msgstr ""

#~ msgid ""
#~ "This section provides some tips on adding support to Klipper for additional "
#~ "types of printer kinematics. This type of activity requires excellent "
#~ "understanding of the math formulas for the target kinematics. It also "
#~ "requires software development skills - though one should only need to update"
#~ " the host software."
#~ msgstr ""

#~ msgid "Useful steps:"
#~ msgstr ""

#~ msgid ""
#~ "Start by studying the \"[code flow of a move](#code-flow-of-a-move-"
#~ "command)\" section and the [Kinematics document](Kinematics.md)."
#~ msgstr ""

#~ msgid ""
#~ "Review the existing kinematic classes in the klippy/kinematics/ directory. "
#~ "The kinematic classes are tasked with converting a move in cartesian "
#~ "coordinates to the movement on each stepper. One should be able to copy one "
#~ "of these files as a starting point."
#~ msgstr ""

#~ msgid ""
#~ "Implement the C stepper kinematic position functions for each stepper if "
#~ "they are not already available (see kin_cart.c, kin_corexy.c, and "
#~ "kin_delta.c in klippy/chelper/). The function should call `move_get_coord()`"
#~ " to convert a given move time (in seconds) to a cartesian coordinate (in "
#~ "millimeters), and then calculate the desired stepper position (in "
#~ "millimeters) from that cartesian coordinate."
#~ msgstr ""

#~ msgid ""
#~ "Implement the `calc_position()` method in the new kinematics class. This "
#~ "method calculates the position of the toolhead in cartesian coordinates from"
#~ " the position of each stepper. It does not need to be efficient as it is "
#~ "typically only called during homing and probing operations."
#~ msgstr ""

#~ msgid ""
#~ "Other methods. Implement the `check_move()`, `get_status()`, "
#~ "`get_steppers()`, `home()`, and `set_position()` methods. These functions "
#~ "are typically used to provide kinematic specific checks. However, at the "
#~ "start of development one can use boiler-plate code here."
#~ msgstr ""

#~ msgid ""
#~ "Implement test cases. Create a g-code file with a series of moves that can "
#~ "test important cases for the given kinematics. Follow the [debugging "
#~ "documentation](Debugging.md) to convert this g-code file to micro-controller"
#~ " commands. This is useful to exercise corner cases and to check for "
#~ "regressions."
#~ msgstr ""

#~ msgid "Porting to a new micro-controller"
#~ msgstr ""

#~ msgid ""
#~ "This section provides some tips on porting Klipper's micro-controller code "
#~ "to a new architecture. This type of activity requires good knowledge of "
#~ "embedded development and hands-on access to the target micro-controller."
#~ msgstr ""

#~ msgid ""
#~ "Start by identifying any 3rd party libraries that will be used during the "
#~ "port. Common examples include \"CMSIS\" wrappers and manufacturer \"HAL\" "
#~ "libraries. All 3rd party code needs to be GNU GPLv3 compatible. The 3rd "
#~ "party code should be committed to the Klipper lib/ directory. Update the "
#~ "lib/README file with information on where and when the library was obtained."
#~ " It is preferable to copy the code into the Klipper repository unchanged, "
#~ "but if any changes are required then those changes should be listed "
#~ "explicitly in the lib/README file."
#~ msgstr ""

#~ msgid ""
#~ "Create a new architecture sub-directory in the src/ directory and add "
#~ "initial Kconfig and Makefile support. Use the existing architectures as a "
#~ "guide. The src/simulator provides a basic example of a minimum starting "
#~ "point."
#~ msgstr ""

#~ msgid ""
#~ "The first main coding task is to bring up communication support to the "
#~ "target board. This is the most difficult step in a new port. Once basic "
#~ "communication is working, the remaining steps tend to be much easier. It is "
#~ "typical to use a UART type serial device during initial development as these"
#~ " types of hardware devices are generally easier to enable and control. "
#~ "During this phase, make liberal use of helper code from the src/generic/ "
#~ "directory (check how src/simulator/Makefile includes the generic C code into"
#~ " the build). It is also necessary to define timer_read_time() (which returns"
#~ " the current system clock) in this phase, but it is not necessary to fully "
#~ "support timer irq handling."
#~ msgstr ""

#~ msgid ""
#~ "Get familiar with the the console.py tool (as described in the [debugging "
#~ "document](Debugging.md)) and verify connectivity to the micro-controller "
#~ "with it. This tool translates the low-level micro-controller communication "
#~ "protocol to a human readable form."
#~ msgstr ""

#~ msgid ""
#~ "Add support for timer dispatch from hardware interrupts. See Klipper [commit"
#~ " "
#~ "970831ee](https://github.com/Klipper3d/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)"
#~ " as an example of steps 1-5 done for the LPC176x architecture."
#~ msgstr ""

#~ msgid ""
#~ "Bring up basic GPIO input and output support. See Klipper [commit "
#~ "c78b9076](https://github.com/Klipper3d/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54)"
#~ " as an example of this."
#~ msgstr ""

#~ msgid ""
#~ "Bring up additional peripherals - for example see Klipper commit "
#~ "[65613aed](https://github.com/Klipper3d/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27),"
#~ " "
#~ "[c812a40a](https://github.com/Klipper3d/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5),"
#~ " and "
#~ "[c381d03a](https://github.com/Klipper3d/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)."
#~ msgstr ""

#~ msgid ""
#~ "Create a sample Klipper config file in the config/ directory. Test the "
#~ "micro-controller with the main klippy.py program."
#~ msgstr ""

#~ msgid "Consider adding build test cases in the test/ directory."
#~ msgstr ""

#~ msgid "Additional coding tips:"
#~ msgstr ""

#~ msgid ""
#~ "Avoid using \"C bitfields\" to access IO registers; prefer direct read and "
#~ "write operations of 32bit, 16bit, or 8bit integers. The C language "
#~ "specifications don't clearly specify how the compiler must implement C "
#~ "bitfields (eg, endianness, and bit layout), and it's difficult to determine "
#~ "what IO operations will occur on a C bitfield read or write."
#~ msgstr ""

#~ msgid ""
#~ "Prefer writing explicit values to IO registers instead of using read-modify-"
#~ "write operations. That is, if updating a field in an IO register where the "
#~ "other fields have known values, then it is preferable to explicitly write "
#~ "the full contents of the register. Explicit writes produce code that is "
#~ "smaller, faster, and easier to debug."
#~ msgstr ""

#~ msgid "Coordinate Systems"
#~ msgstr ""

#~ msgid ""
#~ "Internally, Klipper primarily tracks the position of the toolhead in "
#~ "cartesian coordinates that are relative to the coordinate system specified "
#~ "in the config file. That is, most of the Klipper code will never experience "
#~ "a change in coordinate systems. If the user makes a request to change the "
#~ "origin (eg, a `G92` command) then that effect is obtained by translating "
#~ "future commands to the primary coordinate system."
#~ msgstr ""

#~ msgid ""
#~ "However, in some cases it is useful to obtain the toolhead position in some "
#~ "other coordinate system and Klipper has several tools to facilitate that. "
#~ "This can be seen by running the GET_POSITION command. For example:"
#~ msgstr ""

#~ msgid ""
#~ "Send: GET_POSITION\n"
#~ "Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613\n"
#~ "Recv: // stepper: stepper_a:457.254159 stepper_b:466.085669 stepper_c:465.382132\n"
#~ "Recv: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121\n"
#~ "Recv: // toolhead: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
#~ "Recv: // gcode: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
#~ "Recv: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000\n"
#~ "Recv: // gcode homing: X:0.000000 Y:0.000000 Z:0.000000\n"
#~ msgstr ""

#~ msgid ""
#~ "The \"mcu\" position (`stepper.get_mcu_position()` in the code) is the total"
#~ " number of steps the micro-controller has issued in a positive direction "
#~ "minus the number of steps issued in a negative direction since the micro-"
#~ "controller was last reset. If the robot is in motion when the query is "
#~ "issued then the reported value includes moves buffered on the micro-"
#~ "controller, but does not include moves on the look-ahead queue."
#~ msgstr ""

#~ msgid ""
#~ "The \"stepper\" position (`stepper.get_commanded_position()`) is the "
#~ "position of the given stepper as tracked by the kinematics code. This "
#~ "generally corresponds to the position (in mm) of the carriage along its "
#~ "rail, relative to the position_endstop specified in the config file. (Some "
#~ "kinematics track stepper positions in radians instead of millimeters.) If "
#~ "the robot is in motion when the query is issued then the reported value "
#~ "includes moves buffered on the micro-controller, but does not include moves "
#~ "on the look-ahead queue. One may use the `toolhead.flush_step_generation()` "
#~ "or `toolhead.wait_moves()` calls to fully flush the look-ahead and step "
#~ "generation code."
#~ msgstr ""

#~ msgid ""
#~ "The \"kinematic\" position (`kin.calc_position()`) is the cartesian position"
#~ " of the toolhead as derived from \"stepper\" positions and is relative to "
#~ "the coordinate system specified in the config file. This may differ from the"
#~ " requested cartesian position due to the granularity of the stepper motors. "
#~ "If the robot is in motion when the \"stepper\" positions are taken then the "
#~ "reported value includes moves buffered on the micro-controller, but does not"
#~ " include moves on the look-ahead queue. One may use the "
#~ "`toolhead.flush_step_generation()` or `toolhead.wait_moves()` calls to fully"
#~ " flush the look-ahead and step generation code."
#~ msgstr ""

#~ msgid ""
#~ "The \"toolhead\" position (`toolhead.get_position()`) is the last requested "
#~ "position of the toolhead in cartesian coordinates relative to the coordinate"
#~ " system specified in the config file. If the robot is in motion when the "
#~ "query is issued then the reported value includes all requested moves (even "
#~ "those in buffers waiting to be issued to the stepper motor drivers)."
#~ msgstr ""

#~ msgid ""
#~ "The \"gcode\" position is the last requested position from a `G1` (or `G0`) "
#~ "command in cartesian coordinates relative to the coordinate system specified"
#~ " in the config file. This may differ from the \"toolhead\" position if a "
#~ "g-code transformation (eg, bed_mesh, bed_tilt, skew_correction) is in "
#~ "effect. This may differ from the actual coordinates specified in the last "
#~ "`G1` command if the g-code origin has been changed (eg, `G92`, "
#~ "`SET_GCODE_OFFSET`, `M221`). The `M114` command "
#~ "(`gcode_move.get_status()['gcode_position']`) will report the last g-code "
#~ "position relative to the current g-code coordinate system."
#~ msgstr ""

#~ msgid ""
#~ "The \"gcode base\" is the location of the g-code origin in cartesian "
#~ "coordinates relative to the coordinate system specified in the config file. "
#~ "Commands such as `G92`, `SET_GCODE_OFFSET`, and `M221` alter this value."
#~ msgstr ""

#~ msgid ""
#~ "The \"gcode homing\" is the location to use for the g-code origin (in "
#~ "cartesian coordinates relative to the coordinate system specified in the "
#~ "config file) after a `G28` home command. The `SET_GCODE_OFFSET` command can "
#~ "alter this value."
#~ msgstr ""

#~ msgid "Time"
#~ msgstr ""

#~ msgid ""
#~ "Fundamental to the operation of Klipper is the handling of clocks, times, "
#~ "and timestamps. Klipper executes actions on the printer by scheduling events"
#~ " to occur in the near future. For example, to turn on a fan, the code might "
#~ "schedule a change to a GPIO pin in a 100ms. It is rare for the code to "
#~ "attempt to take an instantaneous action. Thus, the handling of time within "
#~ "Klipper is critical to correct operation."
#~ msgstr ""

#~ msgid ""
#~ "There are three types of times tracked internally in the Klipper host "
#~ "software:"
#~ msgstr ""

#~ msgid ""
#~ "System time. The system time uses the system's monotonic clock - it is a "
#~ "floating point number stored as seconds and it is (generally) relative to "
#~ "when the host computer was last started. System times have limited use in "
#~ "the software - they are primarily used when interacting with the operating "
#~ "system. Within the host code, system times are frequently stored in "
#~ "variables named *eventtime* or *curtime*."
#~ msgstr ""

#~ msgid ""
#~ "Print time. The print time is synchronized to the main micro-controller "
#~ "clock (the micro-controller defined in the \"[mcu]\" config section). It is "
#~ "a floating point number stored as seconds and is relative to when the main "
#~ "mcu was last restarted. It is possible to convert from a \"print time\" to "
#~ "the main micro-controller's hardware clock by multiplying the print time by "
#~ "the mcu's statically configured frequency rate. The high-level host code "
#~ "uses print times to calculate almost all physical actions (eg, head "
#~ "movement, heater changes, etc.). Within the host code, print times are "
#~ "generally stored in variables named *print_time* or *move_time*."
#~ msgstr ""

#~ msgid ""
#~ "MCU clock. This is the hardware clock counter on each micro-controller. It "
#~ "is stored as an integer and its update rate is relative to the frequency of "
#~ "the given micro-controller. The host software translates its internal times "
#~ "to clocks before transmission to the mcu. The mcu code only ever tracks time"
#~ " in clock ticks. Within the host code, clock values are tracked as 64bit "
#~ "integers, while the mcu code uses 32bit integers. Within the host code, "
#~ "clocks are generally stored in variables with names containing *clock* or "
#~ "*ticks*."
#~ msgstr ""

#~ msgid ""
#~ "Conversion between the different time formats is primarily implemented in "
#~ "the **klippy/clocksync.py** code."
#~ msgstr ""

#~ msgid "Some things to be aware of when reviewing the code:"
#~ msgstr ""

#~ msgid ""
#~ "32bit and 64bit clocks: To reduce bandwidth and to improve micro-controller "
#~ "efficiency, clocks on the micro-controller are tracked as 32bit integers. "
#~ "When comparing two clocks in the mcu code, the `timer_is_before()` function "
#~ "must always be used to ensure integer rollovers are handled properly. The "
#~ "host software converts 32bit clocks to 64bit clocks by appending the high-"
#~ "order bits from the last mcu timestamp it has received - no message from the"
#~ " mcu is ever more than 2^31 clock ticks in the future or past so this "
#~ "conversion is never ambiguous. The host converts from 64bit clocks to 32bit "
#~ "clocks by simply truncating the high-order bits. To ensure there is no "
#~ "ambiguity in this conversion, the **klippy/chelper/serialqueue.c** code will"
#~ " buffer messages until they are within 2^31 clock ticks of their target "
#~ "time."
#~ msgstr ""

#~ msgid ""
#~ "Multiple micro-controllers: The host software supports using multiple micro-"
#~ "controllers on a single printer. In this case, the \"MCU clock\" of each "
#~ "micro-controller is tracked separately. The clocksync.py code handles clock "
#~ "drift between micro-controllers by modifying the way it converts from "
#~ "\"print time\" to \"MCU clock\". On secondary mcus, the mcu frequency that "
#~ "is used in this conversion is regularly updated to account for measured "
#~ "drift."
#~ msgstr ""

#~ msgid "Contributing to Klipper"
#~ msgstr ""

#~ msgid ""
#~ "Thank you for contributing to Klipper! This document describes the process "
#~ "for contributing changes to Klipper."
#~ msgstr ""

#~ msgid ""
#~ "Please see the [contact page](Contact.md) for information on reporting an "
#~ "issue or for details on contacting the developers."
#~ msgstr ""

#~ msgid "Overview of Contribution Process"
#~ msgstr ""

#~ msgid "Contributions to Klipper generally follow a high-level process:"
#~ msgstr ""

#~ msgid ""
#~ "A submitter starts by creating a [GitHub Pull "
#~ "Request](https://github.com/Klipper3d/klipper/pulls) when a submission is "
#~ "ready for widespread deployment."
#~ msgstr ""

#~ msgid ""
#~ "When a [reviewer](#reviewers) is available to [review](#what-to-expect-in-a-"
#~ "review) the submission, they will assign themselves to the Pull Request on "
#~ "GitHub. The goal of the review is to look for defects and to check that the "
#~ "submission follows documented guidelines."
#~ msgstr ""

#~ msgid ""
#~ "After a successful review, the reviewer will \"approve the review\" on "
#~ "GitHub and a [maintainer](#reviewers) will commit the change to the Klipper "
#~ "master branch."
#~ msgstr ""

#~ msgid ""
#~ "When working on enhancements, consider starting (or contributing to) a topic"
#~ " on [Klipper Discourse](Contact.md). An ongoing discussion on the forum can "
#~ "improve visibility of development work and may attract others interested in "
#~ "testing new work."
#~ msgstr ""

#~ msgid "What to expect in a review"
#~ msgstr ""

#~ msgid ""
#~ "Contributions to Klipper are reviewed before merging. The primary goal of "
#~ "the review process is to check for defects and to check that the submission "
#~ "follows guidelines specified in the Klipper documentation."
#~ msgstr ""

#~ msgid ""
#~ "It is understood that there are many ways to accomplish a task; it is not "
#~ "the intent of the review to discuss the \"best\" implementation. Where "
#~ "possible, review discussions focused on facts and measurements are "
#~ "preferable."
#~ msgstr ""

#~ msgid ""
#~ "The majority of submissions will result in feedback from a review. Be "
#~ "prepared to obtain feedback, provide further details, and to update the "
#~ "submission if needed."
#~ msgstr ""

#~ msgid "Common things a reviewer will look for:"
#~ msgstr ""

#~ msgid ""
#~ "Is the submission free of defects and is it ready to be widely deployed?"
#~ msgstr ""

#~ msgid ""
#~ "Submitters are expected to test their changes prior to submission. The "
#~ "reviewers look for errors, but they don't, in general, test submissions. An "
#~ "accepted submission is often deployed to thousands of printers within a few "
#~ "weeks of acceptance. Quality of submissions is therefore considered a "
#~ "priority."
#~ msgstr ""

#~ msgid ""
#~ "The main [Klipper3d/klipper](https://github.com/Klipper3d/klipper) GitHub "
#~ "repository does not accept experimental work. Submitters should perform "
#~ "experimentation, debugging, and testing in their own repositories. The "
#~ "[Klipper Discourse](Contact.md) server is a good place to raise awareness of"
#~ " new work and to find users interested in providing real-world feedback."
#~ msgstr ""

#~ msgid "Submissions must pass all [regression test cases](Debugging.md)."
#~ msgstr ""

#~ msgid ""
#~ "When fixing a defect in the code, submitters should have a general "
#~ "understanding of the root cause of that defect, and the fix should target "
#~ "that root cause."
#~ msgstr ""

#~ msgid ""
#~ "Code submissions should not contain excessive debugging code, debugging "
#~ "options, nor run-time debug logging."
#~ msgstr ""

#~ msgid ""
#~ "Comments in code submissions should focus on enhancing code maintenance. "
#~ "Submissions should not contain \"commented out code\" nor excessive comments"
#~ " describing past implementations. There should not be excessive \"todo\" "
#~ "comments."
#~ msgstr ""

#~ msgid ""
#~ "Updates to documentation should not declare that they are a \"work in "
#~ "progress\"."
#~ msgstr ""

#~ msgid ""
#~ "Does the submission provide a \"high impact\" benefit to real-world users "
#~ "performing real-world tasks?"
#~ msgstr ""

#~ msgid ""
#~ "Reviewers need to identify, at least in their own minds, roughly \"who the "
#~ "target audience is\", a rough scale of \"the size of that audience\", the "
#~ "\"benefit\" they will obtain, how the \"benefit is measured\", and the "
#~ "\"results of those measurement tests\". In most cases this will be obvious "
#~ "to both the submitter and the reviewer, and it is not explicitly stated "
#~ "during a review."
#~ msgstr ""

#~ msgid ""
#~ "Submissions to the master Klipper branch are expected to have a noteworthy "
#~ "target audience. As a general \"rule of thumb\", submissions should target a"
#~ " user base of at least a 100 real-world users."
#~ msgstr ""

#~ msgid ""
#~ "If a reviewer asks for details on the \"benefit\" of a submission, please "
#~ "don't consider it criticism. Being able to understand the real-world "
#~ "benefits of a change is a natural part of a review."
#~ msgstr ""

#~ msgid ""
#~ "When discussing benefits it is preferable to discuss \"facts and "
#~ "measurements\". In general, reviewers are not looking for responses of the "
#~ "form \"someone may find option X useful\", nor are they looking for "
#~ "responses of the form \"this submission adds a feature that firmware X "
#~ "implements\". Instead, it is generally preferable to discuss details on how "
#~ "the quality improvement was measured and what were the results of those "
#~ "measurements - for example, \"tests on Acme X1000 printers show improved "
#~ "corners as seen in picture ...\", or for example \"print time of real-world "
#~ "object X on a Foomatic X900 printer went from 4 hours to 3.5 hours\". It is "
#~ "understood that testing of this type can take significant time and effort. "
#~ "Some of Klipper's most notable features took months of discussion, rework, "
#~ "testing, and documentation prior to being merged into the master branch."
#~ msgstr ""

#~ msgid ""
#~ "All new modules, config options, commands, command parameters, and documents"
#~ " should have \"high impact\". We do not want to burden users with options "
#~ "that they can not reasonably configure nor do we want to burden them with "
#~ "options that don't provide a notable benefit."
#~ msgstr ""

#~ msgid ""
#~ "A reviewer may ask for clarification on how a user is to configure an option"
#~ " - an ideal response will contain details on the process - for example, "
#~ "\"users of the MegaX500 are expected to set option X to 99.3 while users of "
#~ "the Elite100Y are expected to calibrate option X using procedure ...\"."
#~ msgstr ""

#~ msgid ""
#~ "If the goal of an option is to make the code more modular then prefer using "
#~ "code constants instead of user facing config options."
#~ msgstr ""

#~ msgid ""
#~ "New modules, new options, and new parameters should not provide similar "
#~ "functionality to existing modules - if the differences are arbitrary than "
#~ "it's preferable to utilize the existing system or refactor the existing "
#~ "code."
#~ msgstr ""

#~ msgid ""
#~ "Is the copyright of the submission clear, non-gratuitous, and compatible?"
#~ msgstr ""

#~ msgid ""
#~ "New C files and Python files should have an unambiguous copyright statement."
#~ " See the existing files for the preferred format. Declaring a copyright on "
#~ "an existing file when making minor changes to that file is discouraged."
#~ msgstr ""

#~ msgid ""
#~ "Code taken from 3rd party sources must be compatible with the Klipper "
#~ "license (GNU GPLv3). Large 3rd party code additions should be added to the "
#~ "`lib/` directory (and follow the format described in "
#~ "[lib/README](../lib/README))."
#~ msgstr ""

#~ msgid ""
#~ "Submitters must provide a [Signed-off-by line](#format-of-commit-messages) "
#~ "using their full real name. It indicates the submitter agrees with the "
#~ "[developer certificate of origin](developer-certificate-of-origin)."
#~ msgstr ""

#~ msgid ""
#~ "Does the submission follow guidelines specified in the Klipper "
#~ "documentation?"
#~ msgstr ""

#~ msgid ""
#~ "In particular, code should follow the guidelines in <Code_Overview.md> and "
#~ "config files should follow the guidelines in <Example_Configs.md>."
#~ msgstr ""

#~ msgid "Is the Klipper documentation updated to reflect new changes?"
#~ msgstr ""

#~ msgid ""
#~ "At a minimum, the reference documentation must be updated with corresponding"
#~ " changes to the code:"
#~ msgstr ""

#~ msgid ""
#~ "All commands and command parameters must be documented in <G-Codes.md>."
#~ msgstr ""

#~ msgid ""
#~ "All user facing modules and their config parameters must be documented in "
#~ "<Config_Reference.md>."
#~ msgstr ""

#~ msgid ""
#~ "All exported \"status variables\" must be documented in "
#~ "<Status_Reference.md>."
#~ msgstr ""

#~ msgid ""
#~ "All new \"webhooks\" and their parameters must be documented in "
#~ "<API_Server.md>."
#~ msgstr ""

#~ msgid ""
#~ "Any change that makes a non-backwards compatible change to a command or "
#~ "config file setting must be documented in <Config_Changes.md>."
#~ msgstr ""

#~ msgid ""
#~ "New documents should be added to <Overview.md> and be added to the website "
#~ "index [docs/_klipper3d/mkdocs.yml](../docs/_klipper3d/mkdocs.yml)."
#~ msgstr ""

#~ msgid ""
#~ "Are commits well formed, address a single topic per commit, and independent?"
#~ msgstr ""

#~ msgid ""
#~ "Commit messages should follow the [preferred format](#format-of-commit-"
#~ "messages)."
#~ msgstr ""

#~ msgid ""
#~ "Commits must not have a merge conflict. New additions to the Klipper master "
#~ "branch are always done via a \"rebase\" or \"squash and rebase\". It is "
#~ "generally not necessary for submitters to re-merge their submission on every"
#~ " update to the Klipper master repository. However, if there is a merge "
#~ "conflict, then submitters are recommended to use `git rebase` to address the"
#~ " conflict."
#~ msgstr ""

#~ msgid ""
#~ "Each commit should address a single high-level change. Large changes should "
#~ "be broken up into multiple independent commits. Each commit should \"stand "
#~ "on its own\" so that tools like `git bisect` and `git revert` work reliably."
#~ msgstr ""

#~ msgid ""
#~ "Whitespace changes should not be mixed with functional changes. In general, "
#~ "gratuitous whitespace changes are not accepted unless they are from the "
#~ "established \"owner\" of the code being modified."
#~ msgstr ""

#~ msgid ""
#~ "Klipper does not implement a strict \"coding style guide\", but "
#~ "modifications to existing code should follow the high-level code flow, code "
#~ "indentation style, and format of that existing code. Submissions of new "
#~ "modules and systems have more flexibility in coding style, but it is "
#~ "preferable for that new code to follow an internally consistent style and to"
#~ " generally follow industry wide coding norms."
#~ msgstr ""

#~ msgid ""
#~ "It is not a goal of a review to discuss \"better implementations\". However,"
#~ " if a reviewer struggles to understand the implementation of a submission, "
#~ "then they may ask for changes to make the implementation more transparent. "
#~ "In particular, if reviewers can not convince themselves that a submission is"
#~ " free of defects then changes may be necessary."
#~ msgstr ""

#~ msgid ""
#~ "As part of a review, a reviewer may create an alternate Pull Request for a "
#~ "topic. This may be done to avoid excessive \"back and forth\" on minor "
#~ "procedural items and thus streamline the submission process. It may also be "
#~ "done because the discussion inspires a reviewer to build an alternative "
#~ "implementation. Both situations are a normal result of a review and should "
#~ "not be considered criticism of the original submission."
#~ msgstr ""

#~ msgid "Helping with reviews"
#~ msgstr ""

#~ msgid ""
#~ "We appreciate help with reviews! It is not necessary to be a [listed "
#~ "reviewer](#reviewers) to perform a review. Submitters of GitHub Pull "
#~ "Requests are also encouraged to review their own submissions."
#~ msgstr ""

#~ msgid ""
#~ "To help with a review, follow the steps outlined in [what to expect in a "
#~ "review](#what-to-expect-in-a-review) to verify the submission. After "
#~ "completing the review, add a comment to the GitHub Pull Request with your "
#~ "findings. If the submission passes the review then please state that "
#~ "explicitly in the comment - for example something like \"I reviewed this "
#~ "change according to the steps in the CONTRIBUTING document and everything "
#~ "looks good to me\". If unable to complete some steps in the review then "
#~ "please explicitly state which steps were reviewed and which steps were not "
#~ "reviewed - for example something like \"I didn't check the code for defects,"
#~ " but I reviewed everything else in the CONTRIBUTING document and it looks "
#~ "good\"."
#~ msgstr ""

#~ msgid ""
#~ "We also appreciate testing of submissions. If the code was tested then "
#~ "please add a comment to the GitHub Pull Request with the results of your "
#~ "test - success or failure. Please explicitly state that the code was tested "
#~ "and the results - for example something like \"I tested this code on my "
#~ "Acme900Z printer with a vase print and the results were good\"."
#~ msgstr ""

#~ msgid "Reviewers"
#~ msgstr ""

#~ msgid "The Klipper \"reviewers\" are:"
#~ msgstr ""

#~ msgid "Name"
#~ msgstr ""

#~ msgid "GitHub Id"
#~ msgstr ""

#~ msgid "Areas of interest"
#~ msgstr ""

#~ msgid "Dmitry Butyugin"
#~ msgstr ""

#~ msgid "@dmbutyugin"
#~ msgstr ""

#~ msgid "Input shaping, resonance testing, kinematics"
#~ msgstr ""

#~ msgid "@Arksine"
#~ msgstr ""

#~ msgid "Bed leveling, MCU flashing"
#~ msgstr ""

#~ msgid "@KevinOConnor"
#~ msgstr ""

#~ msgid "Core motion system, Micro-controller code"
#~ msgstr ""

#~ msgid "Paul McGowan"
#~ msgstr ""

#~ msgid "@mental405"
#~ msgstr ""

#~ msgid "Configuration files, documentation"
#~ msgstr ""

#~ msgid ""
#~ "Please do not \"ping\" any of the reviewers and please do not direct "
#~ "submissions at them. All of the reviewers monitor the forums and PRs, and "
#~ "will take on reviews when they have time to."
#~ msgstr ""

#~ msgid "The Klipper \"maintainers\" are:"
#~ msgstr ""

#~ msgid "GitHub name"
#~ msgstr ""

#~ msgid "Format of commit messages"
#~ msgstr ""

#~ msgid ""
#~ "Each commit should have a commit message formatted similar to the following:"
#~ msgstr ""

#~ msgid ""
#~ "module: Capitalized, short (50 chars or less) summary\n"
#~ "\n"
#~ "More detailed explanatory text, if necessary.  Wrap it to about 75\n"
#~ "characters or so.  In some contexts, the first line is treated as the\n"
#~ "subject of an email and the rest of the text as the body.  The blank\n"
#~ "line separating the summary from the body is critical (unless you omit\n"
#~ "the body entirely); tools like rebase can get confused if you run the\n"
#~ "two together.\n"
#~ "\n"
#~ "Further paragraphs come after blank lines..\n"
#~ "\n"
#~ "Signed-off-by: My Name <myemail@example.org>\n"
#~ msgstr ""

#~ msgid ""
#~ "In the above example, `module` should be the name of a file or directory in "
#~ "the repository (without a file extension). For example, `clocksync: Fix typo"
#~ " in pause() call at connect time`. The purpose of specifying a module name "
#~ "in the commit message is to help provide context for the commit comments."
#~ msgstr ""

#~ msgid ""
#~ "It is important to have a \"Signed-off-by\" line on each commit - it "
#~ "certifies that you agree to the [developer certificate of origin](developer-"
#~ "certificate-of-origin). It must contain your real name (sorry, no pseudonyms"
#~ " or anonymous contributions) and contain a current email address."
#~ msgstr ""

#~ msgid "Contributing to Klipper Translations"
#~ msgstr ""

#~ msgid ""
#~ "[Klipper-translations Project](https://github.com/Klipper3d/klipper-"
#~ "translations) is a project dedicated to translating Klipper to different "
#~ "languages. [Weblate](https://hosted.weblate.org/projects/klipper/) hosts all"
#~ " the Gettext strings for translating and reviewing. Locales can be displayed"
#~ " on [klipper3d.org](https://www.klipper3d.org) once they satisfy the "
#~ "following requirements:"
#~ msgstr ""

#~ msgid "75% Total coverage"
#~ msgstr ""

#~ msgid "All titles (H1) are translated"
#~ msgstr ""

#~ msgid "An updated navigation hierarchy PR in klipper-translations."
#~ msgstr ""

#~ msgid ""
#~ "To reduce the frustration of translating domain-specific terms and gain "
#~ "awareness of the ongoing translations, you can submit a PR modifying the "
#~ "[Klipper-translations Project](https://github.com/Klipper3d/klipper-"
#~ "translations) `readme.md`. Once a translation is ready, the corresponding "
#~ "modification to the Klipper project can be made."
#~ msgstr ""

#~ msgid ""
#~ "If a translation already exists in the Klipper repository and no longer "
#~ "meets the checklist above, it will be marked out-of-date after a month "
#~ "without updates."
#~ msgstr ""

#~ msgid "Once the requirements are met, you need to:"
#~ msgstr ""

#~ msgid ""
#~ "update klipper-tranlations repository "
#~ "[active_translations](https://github.com/Klipper3d/klipper-"
#~ "translations/blob/translations/active_translations)"
#~ msgstr ""

#~ msgid ""
#~ "Optional: add a manual-index.md file in klipper-translations repository's "
#~ "`docs\\locals\\<lang>` folder to replace the language specific index.md "
#~ "(generated index.md does not render correctly)."
#~ msgstr ""

#~ msgid "Known Issues:"
#~ msgstr ""

#~ msgid ""
#~ "Currently, there isn't a method for correctly translating pictures in the "
#~ "documentation"
#~ msgstr ""

#~ msgid "It is impossible to translate titles in mkdocs.yml."
#~ msgstr ""

#~ msgid "CANBUS protocol"
#~ msgstr ""

#~ msgid ""
#~ "This document describes the protocol Klipper uses to communicate over [CAN "
#~ "bus](https://en.wikipedia.org/wiki/CAN_bus). See <CANBUS.md> for information"
#~ " on configuring Klipper with CAN bus."
#~ msgstr ""

#~ msgid "Micro-controller id assignment"
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses only CAN 2.0A standard size CAN bus packets, which are limited "
#~ "to 8 data bytes and an 11-bit CAN bus identifier. In order to support "
#~ "efficient communication, each micro-controller is assigned at run-time a "
#~ "unique 1-byte CAN bus nodeid (`canbus_nodeid`) for general Klipper command "
#~ "and response traffic. Klipper command messages going from host to micro-"
#~ "controller use the CAN bus id of `canbus_nodeid * 2 + 256`, while Klipper "
#~ "response messages from micro-controller to host use `canbus_nodeid * 2 + 256"
#~ " + 1`."
#~ msgstr ""

#~ msgid ""
#~ "Each micro-controller has a factory assigned unique chip identifier that is "
#~ "used during id assignment. This identifier can exceed the length of one CAN "
#~ "packet, so a hash function is used to generate a unique 6-byte id "
#~ "(`canbus_uuid`) from the factory id."
#~ msgstr ""

#~ msgid "Admin messages"
#~ msgstr ""

#~ msgid ""
#~ "Admin messages are used for id assignment. Admin messages sent from host to "
#~ "micro-controller use the CAN bus id `0x3f0` and messages sent from micro-"
#~ "controller to host use the CAN bus id `0x3f1`. All micro-controllers listen "
#~ "to messages on id `0x3f0`; that id can be thought of as a \"broadcast "
#~ "address\"."
#~ msgstr ""

#~ msgid "CMD_QUERY_UNASSIGNED message"
#~ msgstr ""

#~ msgid ""
#~ "This command queries all micro-controllers that have not yet been assigned a"
#~ " `canbus_nodeid`. Unassigned micro-controllers will respond with a "
#~ "RESP_NEED_NODEID response message."
#~ msgstr ""

#~ msgid ""
#~ "The CMD_QUERY_UNASSIGNED message format is: `<1-byte message_id = 0x00>`"
#~ msgstr ""

#~ msgid "CMD_SET_KLIPPER_NODEID message"
#~ msgstr ""

#~ msgid ""
#~ "This command assigns a `canbus_nodeid` to the micro-controller with a given "
#~ "`canbus_uuid`."
#~ msgstr ""

#~ msgid ""
#~ "The CMD_SET_KLIPPER_NODEID message format is: `<1-byte message_id = "
#~ "0x01><6-byte canbus_uuid><1-byte canbus_nodeid>`"
#~ msgstr ""

#~ msgid "RESP_NEED_NODEID message"
#~ msgstr ""

#~ msgid ""
#~ "The RESP_NEED_NODEID message format is: `<1-byte message_id = 0x20><6-byte "
#~ "canbus_uuid><1-byte set_klipper_nodeid = 0x01>`"
#~ msgstr ""

#~ msgid "Data Packets"
#~ msgstr ""

#~ msgid ""
#~ "A micro-controller that has been assigned a nodeid via the "
#~ "CMD_SET_KLIPPER_NODEID command can send and receive data packets."
#~ msgstr ""

#~ msgid ""
#~ "The packet data in messages using the node's receive CAN bus id "
#~ "(`canbus_nodeid * 2 + 256`) are simply appended to a buffer, and when a "
#~ "complete [mcu protocol message](Protocol.md) is found its contents are "
#~ "parsed and processed. The data is treated as a byte stream - there is no "
#~ "requirement for the start of a Klipper message block to align with the start"
#~ " of a CAN bus packet."
#~ msgstr ""

#~ msgid ""
#~ "Similarly, mcu protocol message responses are sent from micro-controller to "
#~ "host by copying the message data into one or more packets with the node's "
#~ "transmit CAN bus id (`canbus_nodeid * 2 + 256 + 1`)."
#~ msgstr ""

#~ msgid "CANBUS"
#~ msgstr ""

#~ msgid "This document describes Klipper's CAN bus support."
#~ msgstr ""

#~ msgid "Device Hardware"
#~ msgstr ""

#~ msgid ""
#~ "Klipper currently supports CAN on stm32, same5x, and rp2040 chips. In "
#~ "addition, the micro-controller chip must be on a board that has a CAN "
#~ "transceiver."
#~ msgstr ""

#~ msgid ""
#~ "To compile for CAN, run `make menuconfig` and select \"CAN bus\" as the "
#~ "communication interface. Finally, compile the micro-controller code and "
#~ "flash it to the target board."
#~ msgstr ""

#~ msgid "Host Hardware"
#~ msgstr ""

#~ msgid ""
#~ "In order to use a CAN bus, it is necessary to have a host adapter. There are"
#~ " currently two common options:"
#~ msgstr ""

#~ msgid ""
#~ "Use a [Waveshare Raspberry Pi CAN hat](https://www.waveshare.com/rs485-can-"
#~ "hat.htm) or one of its many clones."
#~ msgstr ""

#~ msgid ""
#~ "Use a USB CAN adapter (for example <https://hacker-"
#~ "gadgets.com/product/cantact-usb-can-adapter/>). There are many different USB"
#~ " to CAN adapters available - when choosing one, we recommend verifying it "
#~ "can run the [candlelight firmware](https://github.com/candle-"
#~ "usb/candleLight_fw). (Unfortunately, we've found some USB adapters run "
#~ "defective firmware and are locked down, so verify before purchasing.)"
#~ msgstr ""

#~ msgid ""
#~ "It is also necessary to configure the host operating system to use the "
#~ "adapter. This is typically done by creating a new file named "
#~ "`/etc/network/interfaces.d/can0` with the following contents:"
#~ msgstr ""

#~ msgid ""
#~ "auto can0\n"
#~ "iface can0 can static\n"
#~ "    bitrate 500000\n"
#~ "    up ifconfig $IFACE txqueuelen 128\n"
#~ msgstr ""

#~ msgid ""
#~ "Note that the \"Raspberry Pi CAN hat\" also requires [changes to "
#~ "config.txt](https://www.waveshare.com/wiki/RS485_CAN_HAT)."
#~ msgstr ""

#~ msgid "Terminating Resistors"
#~ msgstr ""

#~ msgid ""
#~ "A CAN bus should have two 120 ohm resistors between the CANH and CANL wires."
#~ " Ideally, one resistor located at each the end of the bus."
#~ msgstr ""

#~ msgid ""
#~ "Note that some devices have a builtin 120 ohm resistor (for example, the "
#~ "\"Waveshare Raspberry Pi CAN hat\" has a soldered on resistor that can not "
#~ "be easily removed). Some devices do not include a resistor at all. Other "
#~ "devices have a mechanism to select the resistor (typically by connecting a "
#~ "\"pin jumper\"). Be sure to check the schematics of all devices on the CAN "
#~ "bus to verify that there are two and only two 120 Ohm resistors on the bus."
#~ msgstr ""

#~ msgid ""
#~ "To test that the resistors are correct, one can remove power to the printer "
#~ "and use a multi-meter to check the resistance between the CANH and CANL "
#~ "wires - it should report ~60 ohms on a correctly wired CAN bus."
#~ msgstr ""

#~ msgid "Finding the canbus_uuid for new micro-controllers"
#~ msgstr ""

#~ msgid ""
#~ "Each micro-controller on the CAN bus is assigned a unique id based on the "
#~ "factory chip identifier encoded into each micro-controller. To find each "
#~ "micro-controller device id, make sure the hardware is powered and wired "
#~ "correctly, and then run:"
#~ msgstr ""

#~ msgid "~/klippy-env/bin/python ~/klipper/scripts/canbus_query.py can0\n"
#~ msgstr ""

#~ msgid ""
#~ "If uninitialized CAN devices are detected the above command will report "
#~ "lines like the following:"
#~ msgstr ""

#~ msgid "Found canbus_uuid=11aa22bb33cc, Application: Klipper\n"
#~ msgstr ""

#~ msgid ""
#~ "Each device will have a unique identifier. In the above example, "
#~ "`11aa22bb33cc` is the micro-controller's \"canbus_uuid\"."
#~ msgstr ""

#~ msgid ""
#~ "Note that the `canbus_query.py` tool will only report uninitialized devices "
#~ "- if Klipper (or a similar tool) configures the device then it will no "
#~ "longer appear in the list."
#~ msgstr ""

#~ msgid ""
#~ "Update the Klipper [mcu configuration](Config_Reference.md#mcu) to use the "
#~ "CAN bus to communicate with the device - for example:"
#~ msgstr ""

#~ msgid ""
#~ "[mcu my_can_mcu]\n"
#~ "canbus_uuid: 11aa22bb33cc\n"
#~ msgstr ""

#~ msgid "USB to CAN bus bridge mode"
#~ msgstr ""

#~ msgid ""
#~ "Some micro-controllers support selecting \"USB to CAN bus bridge\" mode "
#~ "during \"make menuconfig\". This mode may allow one to use a micro-"
#~ "controller as both a \"USB to CAN bus adapter\" and as a Klipper node."
#~ msgstr ""

#~ msgid ""
#~ "When Klipper uses this mode the micro-controller appears as a \"USB CAN bus "
#~ "adapter\" under Linux. The \"Klipper bridge mcu\" itself will appear as if "
#~ "was on this CAN bus - it can be identified via `canbus_query.py` and "
#~ "configured like other CAN bus Klipper nodes. It will appear alongside other "
#~ "devices that are actually on the CAN bus."
#~ msgstr ""

#~ msgid "Some important notes when using this mode:"
#~ msgstr ""

#~ msgid ""
#~ "The \"bridge mcu\" is not actually on the CAN bus. Messages to and from it "
#~ "do not consume bandwidth on the CAN bus. The mcu can not be seen by other "
#~ "adapters that may be on the CAN bus."
#~ msgstr ""

#~ msgid ""
#~ "It is necessary to configure the `can0` (or similar) interface in Linux in "
#~ "order to communicate with the bus. However, Linux CAN bus speed and CAN bus "
#~ "bit-timing options are ignored by Klipper. Currently, the CAN bus frequency "
#~ "is specified during \"make menuconfig\" and the bus speed specified in Linux"
#~ " is ignored."
#~ msgstr ""

#~ msgid ""
#~ "Whenever the \"bridge mcu\" is reset, Linux will disable the corresponding "
#~ "`can0` interface. To ensure proper handling of FIRMWARE_RESTART and RESTART "
#~ "commands, it is recommended to replace `auto` with `allow-hotplug` in the "
#~ "`/etc/network/interfaces.d/can0` file. For example:"
#~ msgstr ""

#~ msgid ""
#~ "allow-hotplug can0\n"
#~ "iface can0 can static\n"
#~ "    bitrate 500000\n"
#~ "    up ifconfig $IFACE txqueuelen 128\n"
#~ msgstr ""

#~ msgid "Bootloaders"
#~ msgstr ""

#~ msgid ""
#~ "This document provides information on common bootloaders found on micro-"
#~ "controllers that Klipper supports."
#~ msgstr ""

#~ msgid ""
#~ "The bootloader is 3rd-party software that runs on the micro-controller when "
#~ "it is first powered on. It is typically used to flash a new application (eg,"
#~ " Klipper) to the micro-controller without requiring specialized hardware. "
#~ "Unfortunately, there is no industry wide standard for flashing a micro-"
#~ "controller, nor is there a standard bootloader that works across all micro-"
#~ "controllers. Worse, it is common for each bootloader to require a different "
#~ "set of steps to flash an application."
#~ msgstr ""

#~ msgid ""
#~ "If one can flash a bootloader to a micro-controller then one can generally "
#~ "also use that mechanism to flash an application, but care should be taken "
#~ "when doing this as one may inadvertently remove the bootloader. In contrast,"
#~ " a bootloader will generally only permit a user to flash an application. It "
#~ "is therefore recommended to use a bootloader to flash an application where "
#~ "possible."
#~ msgstr ""

#~ msgid ""
#~ "This document attempts to describe common bootloaders, the steps needed to "
#~ "flash a bootloader, and the steps needed to flash an application. This "
#~ "document is not an authoritative reference; it is intended as a collection "
#~ "of useful information that the Klipper developers have accumulated."
#~ msgstr ""

#~ msgid "AVR micro-controllers"
#~ msgstr ""

#~ msgid ""
#~ "In general, the Arduino project is a good reference for bootloaders and "
#~ "flashing procedures on the 8-bit Atmel Atmega micro-controllers. In "
#~ "particular, the \"boards.txt\" file: "
#~ "<https://github.com/arduino/Arduino/blob/1.8.5/hardware/arduino/avr/boards.txt>"
#~ " is a useful reference."
#~ msgstr ""

#~ msgid ""
#~ "To flash a bootloader itself, the AVR chips require an external hardware "
#~ "flashing tool (which communicates with the chip using SPI). This tool can be"
#~ " purchased (for example, do a web search for \"avr isp\", \"arduino isp\", "
#~ "or \"usb tiny isp\"). It is also possible to use another Arduino or "
#~ "Raspberry Pi to flash an AVR bootloader (for example, do a web search for "
#~ "\"program an avr using raspberry pi\"). The examples below are written "
#~ "assuming an \"AVR ISP Mk2\" type device is in use."
#~ msgstr ""

#~ msgid ""
#~ "The \"avrdude\" program is the most common tool used to flash atmega chips "
#~ "(both bootloader flashing and application flashing)."
#~ msgstr ""

#~ msgid "Atmega2560"
#~ msgstr ""

#~ msgid ""
#~ "This chip is typically found in the \"Arduino Mega\" and is very common in "
#~ "3d printer boards."
#~ msgstr ""

#~ msgid "To flash the bootloader itself use something like:"
#~ msgstr ""

#~ msgid ""
#~ "wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/stk500v2/stk500boot_v2_mega2560.hex'\n"
#~ "\n"
#~ "avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xD8:m -U lfuse:w:0xFF:m\n"
#~ "avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U flash:w:stk500boot_v2_mega2560.hex\n"
#~ "avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
#~ msgstr ""

#~ msgid "To flash an application use something like:"
#~ msgstr ""

#~ msgid ""
#~ "avrdude -cwiring -patmega2560 -P/dev/ttyACM0 -b115200 -D "
#~ "-Uflash:w:out/klipper.elf.hex:i\n"
#~ msgstr ""

#~ msgid "Atmega1280"
#~ msgstr ""

#~ msgid "This chip is typically found in earlier versions of the \"Arduino Mega\"."
#~ msgstr ""

#~ msgid ""
#~ "wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/atmega/ATmegaBOOT_168_atmega1280.hex'\n"
#~ "\n"
#~ "avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xF5:m -U hfuse:w:0xDA:m -U lfuse:w:0xFF:m\n"
#~ "avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U flash:w:ATmegaBOOT_168_atmega1280.hex\n"
#~ "avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
#~ msgstr ""

#~ msgid ""
#~ "avrdude -carduino -patmega1280 -P/dev/ttyACM0 -b57600 -D "
#~ "-Uflash:w:out/klipper.elf.hex:i\n"
#~ msgstr ""

#~ msgid "Atmega1284p"
#~ msgstr ""

#~ msgid "This chip is commonly found in \"Melzi\" style 3d printer boards."
#~ msgstr ""

#~ msgid ""
#~ "wget 'https://github.com/Lauszus/Sanguino/raw/1.0.2/bootloaders/optiboot/optiboot_atmega1284p.hex'\n"
#~ "\n"
#~ "avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xDE:m -U lfuse:w:0xFF:m\n"
#~ "avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega1284p.hex\n"
#~ "avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
#~ msgstr ""

#~ msgid ""
#~ "avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b115200 -D "
#~ "-Uflash:w:out/klipper.elf.hex:i\n"
#~ msgstr ""

#~ msgid ""
#~ "Note that a number of \"Melzi\" style boards come preloaded with a "
#~ "bootloader that uses a baud rate of 57600. In this case, to flash an "
#~ "application use something like this instead:"
#~ msgstr ""

#~ msgid ""
#~ "avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b57600 -D "
#~ "-Uflash:w:out/klipper.elf.hex:i\n"
#~ msgstr ""

#~ msgid "At90usb1286"
#~ msgstr ""

#~ msgid ""
#~ "This document does not cover the method to flash a bootloader to the "
#~ "At90usb1286 nor does it cover general application flashing to this device."
#~ msgstr ""

#~ msgid ""
#~ "The Teensy++ device from pjrc.com comes with a proprietary bootloader. It "
#~ "requires a custom flashing tool from "
#~ "<https://github.com/PaulStoffregen/teensy_loader_cli>. One can flash an "
#~ "application with it using something like:"
#~ msgstr ""

#~ msgid "teensy_loader_cli --mcu=at90usb1286 out/klipper.elf.hex -v\n"
#~ msgstr ""

#~ msgid "Atmega168"
#~ msgstr ""

#~ msgid ""
#~ "The atmega168 has limited flash space. If using a bootloader, it is "
#~ "recommended to use the Optiboot bootloader. To flash that bootloader use "
#~ "something like:"
#~ msgstr ""

#~ msgid ""
#~ "wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/optiboot/optiboot_atmega168.hex'\n"
#~ "\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0x04:m -U hfuse:w:0xDD:m -U lfuse:w:0xFF:m\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega168.hex\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
#~ msgstr ""

#~ msgid ""
#~ "To flash an application via the Optiboot bootloader use something like:"
#~ msgstr ""

#~ msgid ""
#~ "avrdude -carduino -patmega168 -P/dev/ttyACM0 -b115200 -D "
#~ "-Uflash:w:out/klipper.elf.hex:i\n"
#~ msgstr ""

#~ msgid "SAM3 micro-controllers (Arduino Due)"
#~ msgstr ""

#~ msgid ""
#~ "It is not common to use a bootloader with the SAM3 mcu. The chip itself has "
#~ "a ROM that allows the flash to be programmed from 3.3V serial port or from "
#~ "USB."
#~ msgstr ""

#~ msgid ""
#~ "To enable the ROM, the \"erase\" pin is held high during a reset, which "
#~ "erases the flash contents, and causes the ROM to run. On an Arduino Due, "
#~ "this sequence can be accomplished by setting a baud rate of 1200 on the "
#~ "\"programming usb port\" (the USB port closest to the power supply)."
#~ msgstr ""

#~ msgid ""
#~ "The code at <https://github.com/shumatech/BOSSA> can be used to program the "
#~ "SAM3. It is recommended to use version 1.9 or later."
#~ msgstr ""

#~ msgid ""
#~ "bossac -U -p /dev/ttyACM0 -a -e -w out/klipper.bin -v -b\n"
#~ "bossac -U -p /dev/ttyACM0 -R\n"
#~ msgstr ""

#~ msgid "SAM4 micro-controllers (Duet Wifi)"
#~ msgstr ""

#~ msgid ""
#~ "It is not common to use a bootloader with the SAM4 mcu. The chip itself has "
#~ "a ROM that allows the flash to be programmed from 3.3V serial port or from "
#~ "USB."
#~ msgstr ""

#~ msgid ""
#~ "To enable the ROM, the \"erase\" pin is held high during a reset, which "
#~ "erases the flash contents, and causes the ROM to run."
#~ msgstr ""

#~ msgid ""
#~ "The code at <https://github.com/shumatech/BOSSA> can be used to program the "
#~ "SAM4. It is necessary to use version `1.8.0` or higher."
#~ msgstr ""

#~ msgid "bossac --port=/dev/ttyACM0 -b -U -e -w -v -R out/klipper.bin\n"
#~ msgstr ""

#~ msgid "SAMD21 micro-controllers (Arduino Zero)"
#~ msgstr ""

#~ msgid ""
#~ "The SAMD21 bootloader is flashed via the ARM Serial Wire Debug (SWD) "
#~ "interface. This is commonly done with a dedicated SWD hardware dongle. "
#~ "Alternatively, one can use a [Raspberry Pi with OpenOCD](#running-openocd-"
#~ "on-the-raspberry-pi)."
#~ msgstr ""

#~ msgid "To flash a bootloader with OpenOCD use the following chip config:"
#~ msgstr ""

#~ msgid "source [find target/at91samdXX.cfg]\n"
#~ msgstr ""

#~ msgid "Obtain a bootloader - for example:"
#~ msgstr ""

#~ msgid ""
#~ "wget 'https://github.com/arduino/ArduinoCore-"
#~ "samd/raw/1.8.3/bootloaders/zero/samd21_sam_ba.bin'\n"
#~ msgstr ""

#~ msgid "Flash with OpenOCD commands similar to:"
#~ msgstr ""

#~ msgid ""
#~ "at91samd bootloader 0\n"
#~ "program samd21_sam_ba.bin verify\n"
#~ msgstr ""

#~ msgid ""
#~ "The most common bootloader on the SAMD21 is the one found on the \"Arduino "
#~ "Zero\". It uses an 8KiB bootloader (the application must be compiled with a "
#~ "start address of 8KiB). One can enter this bootloader by double clicking the"
#~ " reset button. To flash an application use something like:"
#~ msgstr ""

#~ msgid "bossac -U -p /dev/ttyACM0 --offset=0x2000 -w out/klipper.bin -v -b -R\n"
#~ msgstr ""

#~ msgid ""
#~ "In contrast, the \"Arduino M0\" uses a 16KiB bootloader (the application "
#~ "must be compiled with a start address of 16KiB). To flash an application on "
#~ "this bootloader, reset the micro-controller and run the flash command within"
#~ " the first few seconds of boot - something like:"
#~ msgstr ""

#~ msgid ""
#~ "avrdude -c stk500v2 -p atmega2560 -P /dev/ttyACM0 -u "
#~ "-Uflash:w:out/klipper.elf.hex:i\n"
#~ msgstr ""

#~ msgid "SAMD51 micro-controllers (Adafruit Metro-M4 and similar)"
#~ msgstr ""

#~ msgid ""
#~ "Like the SAMD21, the SAMD51 bootloader is flashed via the ARM Serial Wire "
#~ "Debug (SWD) interface. To flash a bootloader with [OpenOCD on a Raspberry "
#~ "Pi](#running-openocd-on-the-raspberry-pi) use the following chip config:"
#~ msgstr ""

#~ msgid "source [find target/atsame5x.cfg]\n"
#~ msgstr ""

#~ msgid ""
#~ "Obtain a bootloader - several bootloaders are available from "
#~ "<https://github.com/adafruit/uf2-samdx1/releases/latest>. For example:"
#~ msgstr ""

#~ msgid ""
#~ "wget "
#~ "'https://github.com/adafruit/uf2-samdx1/releases/download/v3.7.0/bootloader-"
#~ "itsybitsy_m4-v3.7.0.bin'\n"
#~ msgstr ""

#~ msgid ""
#~ "at91samd bootloader 0\n"
#~ "program bootloader-itsybitsy_m4-v3.7.0.bin verify\n"
#~ "at91samd bootloader 16384\n"
#~ msgstr ""

#~ msgid ""
#~ "The SAMD51 uses a 16KiB bootloader (the application must be compiled with a "
#~ "start address of 16KiB). To flash an application use something like:"
#~ msgstr ""

#~ msgid "bossac -U -p /dev/ttyACM0 --offset=0x4000 -w out/klipper.bin -v -b -R\n"
#~ msgstr ""

#~ msgid "STM32F103 micro-controllers (Blue Pill devices)"
#~ msgstr ""

#~ msgid ""
#~ "The STM32F103 devices have a ROM that can flash a bootloader or application "
#~ "via 3.3V serial. Typically one would wire the PA10 (MCU Rx) and PA9 (MCU Tx)"
#~ " pins to a 3.3V UART adapter. To access the ROM, one should connect the "
#~ "\"boot 0\" pin to high and \"boot 1\" pin to low, and then reset the device."
#~ " The \"stm32flash\" package can then be used to flash the device using "
#~ "something like:"
#~ msgstr ""

#~ msgid "stm32flash -w out/klipper.bin -v -g 0 /dev/ttyAMA0\n"
#~ msgstr ""

#~ msgid ""
#~ "Note that if one is using a Raspberry Pi for the 3.3V serial, the stm32flash"
#~ " protocol uses a serial parity mode which the Raspberry Pi's \"mini UART\" "
#~ "does not support. See "
#~ "<https://www.raspberrypi.com/documentation/computers/configuration.html#configuring-"
#~ "uarts> for details on enabling the full uart on the Raspberry Pi GPIO pins."
#~ msgstr ""

#~ msgid ""
#~ "After flashing, set both \"boot 0\" and \"boot 1\" back to low so that "
#~ "future resets boot from flash."
#~ msgstr ""

#~ msgid "STM32F103 with stm32duino bootloader"
#~ msgstr ""

#~ msgid ""
#~ "The \"stm32duino\" project has a USB capable bootloader - see: "
#~ "<https://github.com/rogerclarkmelbourne/STM32duino-bootloader>"
#~ msgstr ""

#~ msgid "This bootloader can be flashed via 3.3V serial with something like:"
#~ msgstr ""

#~ msgid ""
#~ "wget 'https://github.com/rogerclarkmelbourne/STM32duino-bootloader/raw/master/binaries/generic_boot20_pc13.bin'\n"
#~ "\n"
#~ "stm32flash -w generic_boot20_pc13.bin -v -g 0 /dev/ttyAMA0\n"
#~ msgstr ""

#~ msgid ""
#~ "This bootloader uses 8KiB of flash space (the application must be compiled "
#~ "with a start address of 8KiB). Flash an application with something like:"
#~ msgstr ""

#~ msgid "dfu-util -d 1eaf:0003 -a 2 -R -D out/klipper.bin\n"
#~ msgstr ""

#~ msgid ""
#~ "The bootloader typically runs for only a short period after boot. It may be "
#~ "necessary to time the above command so that it runs while the bootloader is "
#~ "still active (the bootloader will flash a board led while it is running). "
#~ "Alternatively, set the \"boot 0\" pin to low and \"boot 1\" pin to high to "
#~ "stay in the bootloader after a reset."
#~ msgstr ""

#~ msgid "STM32F103 with HID bootloader"
#~ msgstr ""

#~ msgid ""
#~ "The [HID bootloader](https://github.com/Serasidis/STM32_HID_Bootloader) is a"
#~ " compact, driverless bootloader capable of flashing over USB. Also available"
#~ " is a [fork with builds specific to the SKR Mini E3 "
#~ "1.2](https://github.com/Arksine/STM32_HID_Bootloader/releases/latest)."
#~ msgstr ""

#~ msgid ""
#~ "For generic STM32F103 boards such as the blue pill it is possible to flash "
#~ "the bootloader via 3.3v serial using stm32flash as noted in the stm32duino "
#~ "section above, substituting the file name for the desired hid bootloader "
#~ "binary (ie: hid_generic_pc13.bin for the blue pill)."
#~ msgstr ""

#~ msgid ""
#~ "It is not possible to use stm32flash for the SKR Mini E3 as the boot0 pin is"
#~ " tied directly to ground and not broken out via header pins. It is "
#~ "recommended to use a STLink V2 with STM32Cubeprogrammer to flash the "
#~ "bootloader. If you don't have access to a STLink it is also possible to use "
#~ "a [Raspberry Pi and OpenOCD](#running-openocd-on-the-raspberry-pi) with the "
#~ "following chip config:"
#~ msgstr ""

#~ msgid "source [find target/stm32f1x.cfg]\n"
#~ msgstr ""

#~ msgid ""
#~ "If you wish you can make a backup of the current flash with the following "
#~ "command. Note that it may take some time to complete:"
#~ msgstr ""

#~ msgid "flash read_bank 0 btt_skr_mini_e3_backup.bin\n"
#~ msgstr ""

#~ msgid "finally, you can flash with commands similar to:"
#~ msgstr ""

#~ msgid ""
#~ "stm32f1x mass_erase 0\n"
#~ "program hid_btt_skr_mini_e3.bin verify 0x08000000\n"
#~ msgstr ""

#~ msgid "NOTES:"
#~ msgstr ""

#~ msgid ""
#~ "The example above erases the chip then programs the bootloader. Regardless "
#~ "of the method chosen to flash it is recommended to erase the chip prior to "
#~ "flashing."
#~ msgstr ""

#~ msgid ""
#~ "Prior flashing the SKR Mini E3 with this bootloader you should be aware that"
#~ " you will no longer be able to update firmware via the sdcard."
#~ msgstr ""

#~ msgid ""
#~ "You may need to hold down the reset button on the board while launching OpenOCD. It should display something like:Open On-Chip Debugger 0.10.0+dev-01204-gc60252ac-dirty (2020-04-27-16:00)\n"
#~ "Licensed under GNU GPL v2\n"
#~ "For bug reports, read\n"
#~ "        http://openocd.org/doc/doxygen/bugs.html\n"
#~ "DEPRECATED! use 'adapter speed' not 'adapter_khz'\n"
#~ "Info : BCM2835 GPIO JTAG/SWD bitbang driver\n"
#~ "Info : JTAG and SWD modes enabled\n"
#~ "Info : clock speed 40 kHz\n"
#~ "Info : SWD DPIDR 0x1ba01477\n"
#~ "Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
#~ "Info : stm32f1x.cpu: external reset detected\n"
#~ "Info : starting gdb server for stm32f1x.cpu on 3333\n"
#~ "Info : Listening on port 3333 for gdb connections\n"
#~ msgstr ""

#~ msgid "After which you can release the reset button."
#~ msgstr ""

#~ msgid ""
#~ "This bootloader requires 2KiB of flash space (the application must be "
#~ "compiled with a start address of 2KiB)."
#~ msgstr ""

#~ msgid ""
#~ "The hid-flash program is used to upload a binary to the bootloader. You can "
#~ "install this software with the following commands:"
#~ msgstr ""

#~ msgid ""
#~ "sudo apt install libusb-1.0\n"
#~ "cd ~/klipper/lib/hidflash\n"
#~ "make\n"
#~ msgstr ""

#~ msgid "If the bootloader is running you can flash with something like:"
#~ msgstr ""

#~ msgid "~/klipper/lib/hidflash/hid-flash ~/klipper/out/klipper.bin\n"
#~ msgstr ""

#~ msgid "alternatively, you can use `make flash` to flash klipper directly:"
#~ msgstr ""

#~ msgid "make flash FLASH_DEVICE=1209:BEBA\n"
#~ msgstr ""

#~ msgid "OR if klipper has been previously flashed:"
#~ msgstr ""

#~ msgid "make flash FLASH_DEVICE=/dev/ttyACM0\n"
#~ msgstr ""

#~ msgid ""
#~ "It may be necessary to manually enter the bootloader, this can be done by "
#~ "setting \"boot 0\" low and \"boot 1\" high. On the SKR Mini E3 \"Boot 1\" is"
#~ " not available, so it may be done by setting pin PA2 low if you flashed "
#~ "\"hid_btt_skr_mini_e3.bin\". This pin is labeld \"TX0\" on the TFT header in"
#~ " the SKR Mini E3's \"PIN\" document. There is a ground pin next to PA2 which"
#~ " you can use to pull PA2 low."
#~ msgstr ""

#~ msgid "STM32F103/STM32F072 with MSC bootloader"
#~ msgstr ""

#~ msgid ""
#~ "The [MSC bootloader](https://github.com/Telekatz/MSC-stm32f103-bootloader) "
#~ "is a driverless bootloader capable of flashing over USB."
#~ msgstr ""

#~ msgid ""
#~ "It is possible to flash the bootloader via 3.3v serial using stm32flash as "
#~ "noted in the stm32duino section above, substituting the file name for the "
#~ "desired MSC bootloader binary (ie: MSCboot-Bluepill.bin for the blue pill)."
#~ msgstr ""

#~ msgid ""
#~ "For STM32F072 boards it is also possible to flash the bootloader over USB "
#~ "(via DFU) with something like:"
#~ msgstr ""

#~ msgid ""
#~ " dfu-util -d 0483:df11 -a 0 -R -D  MSCboot-STM32F072.bin "
#~ "-s0x08000000:leave\n"
#~ msgstr ""

#~ msgid ""
#~ "This bootloader uses 8KiB or 16KiB of flash space, see description of the "
#~ "bootloader (the application must be compiled with with the corresponding "
#~ "starting address)."
#~ msgstr ""

#~ msgid ""
#~ "The bootloader can be activated by pressing the reset button of the board "
#~ "twice. As soon as the bootloader is activated, the board appears as a USB "
#~ "flash drive onto which the klipper.bin file can be copied."
#~ msgstr ""

#~ msgid "STM32F103/STM32F0x2 with CanBoot bootloader"
#~ msgstr ""

#~ msgid ""
#~ "The [CanBoot](https://github.com/Arksine/CanBoot) bootloader provides an "
#~ "option for uploading Klipper firmware over the CANBUS. The bootloader itself"
#~ " is derived from Klipper's source code. Currently CanBoot supports the "
#~ "STM32F103, STM32F042, and STM32F072 models."
#~ msgstr ""

#~ msgid ""
#~ "It is recommended to use a ST-Link Programmer to flash CanBoot, however it "
#~ "should be possible to flash using `stm32flash` on STM32F103 devices, and "
#~ "`dfu-util` on STM32F042/STM32F072 devices. See the previous sections in this"
#~ " document for instructions on these flashing methods, substituting "
#~ "`canboot.bin` for the file name where appropriate. The CanBoot repo linked "
#~ "above provides instructions for building the bootloader."
#~ msgstr ""

#~ msgid ""
#~ "The first time CanBoot has been flashed it should detect that no application"
#~ " is present and enter the bootloader. If this doesn't occur it is possible "
#~ "to enter the bootloader by pressing the reset button twice in succession."
#~ msgstr ""

#~ msgid ""
#~ "The `flash_can.py` utility supplied in the `lib/canboot` folder may be used "
#~ "to upload Klipper firmware. The device UUID is necessary to flash. If you do"
#~ " not have a UUID it is possible to query nodes currently running the "
#~ "bootloader:"
#~ msgstr ""

#~ msgid "python3 flash_can.py -q\n"
#~ msgstr ""

#~ msgid ""
#~ "This will return UUIDs for all connected nodes not currently assigned a "
#~ "UUID. This should include all nodes currently in the bootloader."
#~ msgstr ""

#~ msgid "Once you have a UUID, you may upload firmware with following command:"
#~ msgstr ""

#~ msgid ""
#~ "python3 flash_can.py -i can0 -f ~/klipper/out/klipper.bin -u aabbccddeeff\n"
#~ msgstr ""

#~ msgid ""
#~ "Where `aabbccddeeff` is replaced by your UUID. Note that the `-i` and `-f` "
#~ "options may be omitted, they default to `can0` and "
#~ "`~/klipper/out/klipper.bin` respectively."
#~ msgstr ""

#~ msgid ""
#~ "When building Klipper for use with CanBoot, select the 8 KiB Bootloader "
#~ "option."
#~ msgstr ""

#~ msgid "STM32F4 micro-controllers (SKR Pro 1.1)"
#~ msgstr ""

#~ msgid ""
#~ "STM32F4 microcontrollers come equipped with a built-in system bootloader "
#~ "capable of flashing over USB (via DFU), 3.3v Serial, and various other "
#~ "methods (see STM Document AN2606 for more information). Some STM32F4 boards,"
#~ " such as the SKR Pro 1.1, are not able to enter the DFU bootloader. The HID "
#~ "bootloader is available for STM32F405/407 based boards should the user "
#~ "prefer flashing over USB over using the sdcard. Note that you may need to "
#~ "configure and build a version specific to your board, a [build for the SKR "
#~ "Pro 1.1 is available "
#~ "here](https://github.com/Arksine/STM32_HID_Bootloader/releases/latest)."
#~ msgstr ""

#~ msgid ""
#~ "Unless your board is DFU capable the most accessable flashing method is "
#~ "likely via 3.3v serial, which follows the same procedure as [flashing the "
#~ "STM32F103 using stm32flash](#stm32f103-micro-controllers-blue-pill-devices)."
#~ " For example:"
#~ msgstr ""

#~ msgid ""
#~ "wget https://github.com/Arksine/STM32_HID_Bootloader/releases/download/v0.5-beta/hid_bootloader_SKR_PRO.bin\n"
#~ "\n"
#~ "stm32flash -w hid_bootloader_SKR_PRO.bin -v -g 0 /dev/ttyAMA0\n"
#~ msgstr ""

#~ msgid ""
#~ "This bootloader requires 16Kib of flash space on the STM32F4 (the "
#~ "application must be compiled with a start address of 16KiB)."
#~ msgstr ""

#~ msgid ""
#~ "As with the STM32F1, the STM32F4 uses the hid-flash tool to upload binaries "
#~ "to the MCU. See the instructions above for details on how to build and use "
#~ "hid-flash."
#~ msgstr ""

#~ msgid ""
#~ "It may be necessary to manually enter the bootloader, this can be done by "
#~ "setting \"boot 0\" low, \"boot 1\" high and plugging in the device. After "
#~ "programming is complete unplug the device and set \"boot 1\" back to low so "
#~ "the application will be loaded."
#~ msgstr ""

#~ msgid "LPC176x micro-controllers (Smoothieboards)"
#~ msgstr ""

#~ msgid ""
#~ "This document does not describe the method to flash a bootloader itself - "
#~ "see: <http://smoothieware.org/flashing-the-bootloader> for further "
#~ "information on that topic."
#~ msgstr ""

#~ msgid ""
#~ "It is common for Smoothieboards to come with a bootloader from: "
#~ "<https://github.com/triffid/LPC17xx-DFU-Bootloader>. When using this "
#~ "bootloader the application must be compiled with a start address of 16KiB. "
#~ "The easiest way to flash an application with this bootloader is to copy the "
#~ "application file (eg, `out/klipper.bin`) to a file named `firmware.bin` on "
#~ "an SD card, and then to reboot the micro-controller with that SD card."
#~ msgstr ""

#~ msgid "Running OpenOCD on the Raspberry PI"
#~ msgstr ""

#~ msgid ""
#~ "OpenOCD is a software package that can perform low-level chip flashing and "
#~ "debugging. It can use the GPIO pins on a Raspberry Pi to communicate with a "
#~ "variety of ARM chips."
#~ msgstr ""

#~ msgid ""
#~ "This section describes how one can install and launch OpenOCD. It is derived"
#~ " from the instructions at: <https://learn.adafruit.com/programming-"
#~ "microcontrollers-using-openocd-on-raspberry-pi>"
#~ msgstr ""

#~ msgid ""
#~ "Begin by downloading and compiling the software (each step may take several "
#~ "minutes and the \"make\" step may take 30+ minutes):"
#~ msgstr ""

#~ msgid ""
#~ "sudo apt-get update\n"
#~ "sudo apt-get install autoconf libtool telnet\n"
#~ "mkdir ~/openocd\n"
#~ "cd ~/openocd/\n"
#~ "git clone http://openocd.zylin.com/openocd\n"
#~ "cd openocd\n"
#~ "./bootstrap\n"
#~ "./configure --enable-sysfsgpio --enable-bcm2835gpio --prefix=/home/pi/openocd/install\n"
#~ "make\n"
#~ "make install\n"
#~ msgstr ""

#~ msgid "Configure OpenOCD"
#~ msgstr ""

#~ msgid "Create an OpenOCD config file:"
#~ msgstr ""

#~ msgid "nano ~/openocd/openocd.cfg\n"
#~ msgstr ""

#~ msgid "Use a config similar to the following:"
#~ msgstr ""

#~ msgid ""
#~ "# Uses RPi pins: GPIO25 for SWDCLK, GPIO24 for SWDIO, GPIO18 for nRST\n"
#~ "source [find interface/raspberrypi2-native.cfg]\n"
#~ "bcm2835gpio_swd_nums 25 24\n"
#~ "bcm2835gpio_srst_num 18\n"
#~ "transport select swd\n"
#~ "\n"
#~ "# Use hardware reset wire for chip resets\n"
#~ "reset_config srst_only\n"
#~ "adapter_nsrst_delay 100\n"
#~ "adapter_nsrst_assert_width 100\n"
#~ "\n"
#~ "# Specify the chip type\n"
#~ "source [find target/atsame5x.cfg]\n"
#~ "\n"
#~ "# Set the adapter speed\n"
#~ "adapter_khz 40\n"
#~ "\n"
#~ "# Connect to chip\n"
#~ "init\n"
#~ "targets\n"
#~ "reset halt\n"
#~ msgstr ""

#~ msgid "Wire the Raspberry Pi to the target chip"
#~ msgstr ""

#~ msgid ""
#~ "Poweroff both the the Raspberry Pi and the target chip before wiring! Verify"
#~ " the target chip uses 3.3V prior to connecting to a Raspberry Pi!"
#~ msgstr ""

#~ msgid ""
#~ "Connect GND, SWDCLK, SWDIO, and RST on the target chip to GND, GPIO25, "
#~ "GPIO24, and GPIO18 respectively on the Raspberry Pi."
#~ msgstr ""

#~ msgid "Then power up the Raspberry Pi and provide power to the target chip."
#~ msgstr ""

#~ msgid "Run OpenOCD"
#~ msgstr ""

#~ msgid "Run OpenOCD:"
#~ msgstr ""

#~ msgid ""
#~ "cd ~/openocd/\n"
#~ "sudo ~/openocd/install/bin/openocd -f ~/openocd/openocd.cfg\n"
#~ msgstr ""

#~ msgid ""
#~ "The above should cause OpenOCD to emit some text messages and then wait (it "
#~ "should not immediately return to the Unix shell prompt). If OpenOCD exits on"
#~ " its own or if it continues to emit text messages then double check the "
#~ "wiring."
#~ msgstr ""

#~ msgid ""
#~ "Once OpenOCD is running and is stable, one can send it commands via telnet. "
#~ "Open another ssh session and run the following:"
#~ msgstr ""

#~ msgid "telnet 127.0.0.1 4444\n"
#~ msgstr ""

#~ msgid ""
#~ "(One can exit telnet by pressing ctrl+] and then running the \"quit\" "
#~ "command.)"
#~ msgstr ""

#~ msgid "OpenOCD and gdb"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to use OpenOCD with gdb to debug Klipper. The following "
#~ "commands assume one is running gdb on a desktop class machine."
#~ msgstr ""

#~ msgid "Add the following to the OpenOCD config file:"
#~ msgstr ""

#~ msgid ""
#~ "bindto 0.0.0.0\n"
#~ "gdb_port 44444\n"
#~ msgstr ""

#~ msgid ""
#~ "Restart OpenOCD on the Raspberry Pi and then run the following Unix command "
#~ "on the desktop machine:"
#~ msgstr ""

#~ msgid ""
#~ "cd /path/to/klipper/\n"
#~ "gdb out/klipper.elf\n"
#~ msgstr ""

#~ msgid "Within gdb run:"
#~ msgstr ""

#~ msgid "target remote octopi:44444\n"
#~ msgstr ""

#~ msgid ""
#~ "(Replace \"octopi\" with the host name of the Raspberry Pi.) Once gdb is "
#~ "running it is possible to set breakpoints and to inspect registers."
#~ msgstr ""

#~ msgid "Benchmarks"
#~ msgstr ""

#~ msgid "This document describes Klipper benchmarks."
#~ msgstr ""

#~ msgid "Micro-controller Benchmarks"
#~ msgstr ""

#~ msgid ""
#~ "This section describes the mechanism used to generate the Klipper micro-"
#~ "controller step rate benchmarks."
#~ msgstr ""

#~ msgid ""
#~ "The primary goal of the benchmarks is to provide a consistent mechanism for "
#~ "measuring the impact of coding changes within the software. A secondary goal"
#~ " is to provide high-level metrics for comparing the performance between "
#~ "chips and between software platforms."
#~ msgstr ""

#~ msgid ""
#~ "The step rate benchmark is designed to find the maximum stepping rate that "
#~ "the hardware and software can reach. This benchmark stepping rate is not "
#~ "achievable in day-to-day use as Klipper needs to perform other tasks (eg, "
#~ "mcu/host communication, temperature reading, endstop checking) in any real-"
#~ "world usage."
#~ msgstr ""

#~ msgid ""
#~ "In general, the pins for the benchmark tests are chosen to flash LEDs or "
#~ "other innocuous pins. **Always verify that it is safe to drive the "
#~ "configured pins prior to running a benchmark.** It is not recommended to "
#~ "drive an actual stepper during a benchmark."
#~ msgstr ""

#~ msgid "Step rate benchmark test"
#~ msgstr ""

#~ msgid ""
#~ "The test is performed using the console.py tool (described in "
#~ "<Debugging.md>). The micro-controller is configured for the particular "
#~ "hardware platform (see below) and then the following is cut-and-paste into "
#~ "the console.py terminal window:"
#~ msgstr ""

#~ msgid ""
#~ "SET start_clock {clock+freq}\n"
#~ "SET ticks 1000\n"
#~ "\n"
#~ "reset_step_clock oid=0 clock={start_clock}\n"
#~ "set_next_step_dir oid=0 dir=0\n"
#~ "queue_step oid=0 interval={ticks} count=60000 add=0\n"
#~ "set_next_step_dir oid=0 dir=1\n"
#~ "queue_step oid=0 interval=3000 count=1 add=0\n"
#~ "\n"
#~ "reset_step_clock oid=1 clock={start_clock}\n"
#~ "set_next_step_dir oid=1 dir=0\n"
#~ "queue_step oid=1 interval={ticks} count=60000 add=0\n"
#~ "set_next_step_dir oid=1 dir=1\n"
#~ "queue_step oid=1 interval=3000 count=1 add=0\n"
#~ "\n"
#~ "reset_step_clock oid=2 clock={start_clock}\n"
#~ "set_next_step_dir oid=2 dir=0\n"
#~ "queue_step oid=2 interval={ticks} count=60000 add=0\n"
#~ "set_next_step_dir oid=2 dir=1\n"
#~ "queue_step oid=2 interval=3000 count=1 add=0\n"
#~ msgstr ""

#~ msgid ""
#~ "The above tests three steppers simultaneously stepping. If running the above"
#~ " results in a \"Rescheduled timer in the past\" or \"Stepper too far in "
#~ "past\" error then it indicates the `ticks` parameter is too low (it results "
#~ "in a stepping rate that is too fast). The goal is to find the lowest setting"
#~ " of the ticks parameter that reliably results in a successful completion of "
#~ "the test. It should be possible to bisect the ticks parameter until a stable"
#~ " value is found."
#~ msgstr ""

#~ msgid ""
#~ "On a failure, one can copy-and-paste the following to clear the error in "
#~ "preparation for the next test:"
#~ msgstr ""

#~ msgid "clear_shutdown\n"
#~ msgstr ""

#~ msgid ""
#~ "To obtain the single stepper benchmarks, the same configuration sequence is "
#~ "used, but only the first block of the above test is cut-and-paste into the "
#~ "console.py window."
#~ msgstr ""

#~ msgid ""
#~ "To produce the benchmarks found in the [Features](Features.md) document, the"
#~ " total number of steps per second is calculated by multiplying the number of"
#~ " active steppers with the nominal mcu frequency and dividing by the final "
#~ "ticks parameter. The results are rounded to the nearest K. For example, with"
#~ " three active steppers:"
#~ msgstr ""

#~ msgid "ECHO Test result is: {\"%.0fK\" % (3. * freq / ticks / 1000.)}\n"
#~ msgstr ""

#~ msgid ""
#~ "The benchmarks are run with parameters suitable for TMC Drivers. For micro-"
#~ "controllers that support `STEPPER_BOTH_EDGE=1` (as reported in the `MCU "
#~ "config` line when console.py first starts) use `step_pulse_duration=0` and "
#~ "`invert_step=-1` to enable optimized stepping on both edges of the step "
#~ "pulse. For other micro-controllers use a `step_pulse_duration` corresponding"
#~ " to 100ns."
#~ msgstr ""

#~ msgid "AVR step rate benchmark"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on AVR chips:"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PA5 dir_pin=PA4 invert_step=0 step_pulse_ticks=32\n"
#~ "config_stepper oid=1 step_pin=PA3 dir_pin=PA2 invert_step=0 step_pulse_ticks=32\n"
#~ "config_stepper oid=2 step_pin=PC7 dir_pin=PC6 invert_step=0 step_pulse_ticks=32\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `59314d99` with gcc version `avr-gcc (GCC) "
#~ "5.4.0`. Both the 16Mhz and 20Mhz tests were run using simulavr configured "
#~ "for an atmega644p (previous tests have confirmed simulavr results match "
#~ "tests on both a 16Mhz at90usb and a 16Mhz atmega2560)."
#~ msgstr ""

#~ msgid "avr"
#~ msgstr ""

#~ msgid "ticks"
#~ msgstr ""

#~ msgid "1 stepper"
#~ msgstr ""

#~ msgid "102"
#~ msgstr ""

#~ msgid "3 stepper"
#~ msgstr ""

#~ msgid "486"
#~ msgstr ""

#~ msgid "Arduino Due step rate benchmark"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the Due:"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PB27 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=PB26 dir_pin=PC30 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=PA21 dir_pin=PC30 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `59314d99` with gcc version `arm-none-eabi-"
#~ "gcc (Fedora 10.2.0-4.fc34) 10.2.0`."
#~ msgstr ""

#~ msgid "sam3x8e"
#~ msgstr ""

#~ msgid "66"
#~ msgstr ""

#~ msgid "257"
#~ msgstr ""

#~ msgid "Duet Maestro step rate benchmark"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the Duet Maestro:"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PC26 dir_pin=PC18 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=PC26 dir_pin=PA8 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=PC26 dir_pin=PB4 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid "sam4s8c"
#~ msgstr ""

#~ msgid "71"
#~ msgstr ""

#~ msgid "260"
#~ msgstr ""

#~ msgid "Duet Wifi step rate benchmark"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the Duet Wifi:"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PD6 dir_pin=PD11 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=PD7 dir_pin=PD12 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=PD8 dir_pin=PD13 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `59314d99` with gcc version `gcc version "
#~ "10.3.1 20210621 (release) (GNU Arm Embedded Toolchain 10.3-2021.07)`."
#~ msgstr ""

#~ msgid "sam4e8e"
#~ msgstr ""

#~ msgid "48"
#~ msgstr ""

#~ msgid "215"
#~ msgstr ""

#~ msgid "Beaglebone PRU step rate benchmark"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the PRU:"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=gpio0_23 dir_pin=gpio1_12 invert_step=0 step_pulse_ticks=20\n"
#~ "config_stepper oid=1 step_pin=gpio1_15 dir_pin=gpio0_26 invert_step=0 step_pulse_ticks=20\n"
#~ "config_stepper oid=2 step_pin=gpio0_22 dir_pin=gpio2_1 invert_step=0 step_pulse_ticks=20\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `59314d99` with gcc version `pru-gcc (GCC) "
#~ "8.0.0 20170530 (experimental)`."
#~ msgstr ""

#~ msgid "pru"
#~ msgstr ""

#~ msgid "231"
#~ msgstr ""

#~ msgid "847"
#~ msgstr ""

#~ msgid "STM32F042 step rate benchmark"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the STM32F042:"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PA1 dir_pin=PA2 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=PA3 dir_pin=PA2 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=PB8 dir_pin=PA2 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid "stm32f042"
#~ msgstr ""

#~ msgid "59"
#~ msgstr ""

#~ msgid "249"
#~ msgstr ""

#~ msgid "STM32F103 step rate benchmark"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the STM32F103:"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PC13 dir_pin=PB5 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=PB3 dir_pin=PB6 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=PA4 dir_pin=PB7 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid "stm32f103"
#~ msgstr ""

#~ msgid "61"
#~ msgstr ""

#~ msgid "264"
#~ msgstr ""

#~ msgid "STM32F4 step rate benchmark"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the STM32F4:"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PA5 dir_pin=PB5 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=PB2 dir_pin=PB6 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=PB3 dir_pin=PB7 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `59314d99` with gcc version `arm-none-eabi-"
#~ "gcc (Fedora 10.2.0-4.fc34) 10.2.0`. The STM32F407 results were obtained by "
#~ "running an STM32F407 binary on an STM32F446 (and thus using a 168Mhz clock)."
#~ msgstr ""

#~ msgid "stm32f446"
#~ msgstr ""

#~ msgid "46"
#~ msgstr ""

#~ msgid "205"
#~ msgstr ""

#~ msgid "stm32f407"
#~ msgstr ""

#~ msgid "STM32H7 step rate benchmark"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on a STM32H743VIT6:"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PD4 dir_pin=PD3 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=PA15 dir_pin=PA8 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=PE2 dir_pin=PE3 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `00191b5c` with gcc version `arm-none-eabi-"
#~ "gcc (15:8-2019-q3-1+b1) 8.3.1 20190703 (release) [gcc-8-branch revision "
#~ "273027]`."
#~ msgstr ""

#~ msgid "stm32h7"
#~ msgstr ""

#~ msgid "44"
#~ msgstr ""

#~ msgid "198"
#~ msgstr ""

#~ msgid "STM32G0B1 step rate benchmark"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the STM32G0B1:"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PB13 dir_pin=PB12 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=PB10 dir_pin=PB2 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=PB0 dir_pin=PC5 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `247cd753` with gcc version `arm-none-eabi-"
#~ "gcc (Fedora 10.2.0-4.fc34) 10.2.0`."
#~ msgstr ""

#~ msgid "stm32g0b1"
#~ msgstr ""

#~ msgid "58"
#~ msgstr ""

#~ msgid "243"
#~ msgstr ""

#~ msgid "LPC176x step rate benchmark"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the LPC176x:"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=P1.20 dir_pin=P1.18 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=P1.21 dir_pin=P1.18 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=P1.23 dir_pin=P1.18 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `59314d99` with gcc version `arm-none-eabi-"
#~ "gcc (Fedora 10.2.0-4.fc34) 10.2.0`. The 120Mhz LPC1769 results were obtained"
#~ " by overclocking an LPC1768 to 120Mhz."
#~ msgstr ""

#~ msgid "lpc1768"
#~ msgstr ""

#~ msgid "52"
#~ msgstr ""

#~ msgid "222"
#~ msgstr ""

#~ msgid "lpc1769"
#~ msgstr ""

#~ msgid "51"
#~ msgstr ""

#~ msgid "SAMD21 step rate benchmark"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the SAMD21:"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PA27 dir_pin=PA20 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=PB3 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=PA17 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `59314d99` with gcc version `arm-none-eabi-"
#~ "gcc (Fedora 10.2.0-4.fc34) 10.2.0` on a SAMD21G18 micro-controller."
#~ msgstr ""

#~ msgid "samd21"
#~ msgstr ""

#~ msgid "70"
#~ msgstr ""

#~ msgid "306"
#~ msgstr ""

#~ msgid "SAMD51 step rate benchmark"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the SAMD51:"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PA22 dir_pin=PA20 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=PA22 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=PA22 dir_pin=PA19 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `59314d99` with gcc version `arm-none-eabi-"
#~ "gcc (Fedora 10.2.0-4.fc34) 10.2.0` on a SAMD51J19A micro-controller."
#~ msgstr ""

#~ msgid "samd51"
#~ msgstr ""

#~ msgid "191"
#~ msgstr ""

#~ msgid "1 stepper (200Mhz)"
#~ msgstr ""

#~ msgid "3 stepper (200Mhz)"
#~ msgstr ""

#~ msgid "181"
#~ msgstr ""

#~ msgid "RP2040 step rate benchmark"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the RP2040:"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=gpio25 dir_pin=gpio3 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=gpio26 dir_pin=gpio4 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=gpio27 dir_pin=gpio5 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `59314d99` with gcc version `arm-none-eabi-"
#~ "gcc (Fedora 10.2.0-4.fc34) 10.2.0` on a Raspberry Pi Pico board."
#~ msgstr ""

#~ msgid "rp2040"
#~ msgstr ""

#~ msgid "22"
#~ msgstr ""

#~ msgid "Linux MCU step rate benchmark"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on a Raspberry Pi:"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=gpio2 dir_pin=gpio3 invert_step=0 step_pulse_ticks=5\n"
#~ "config_stepper oid=1 step_pin=gpio4 dir_pin=gpio5 invert_step=0 step_pulse_ticks=5\n"
#~ "config_stepper oid=2 step_pin=gpio6 dir_pin=gpio17 invert_step=0 step_pulse_ticks=5\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `59314d99` with gcc version `gcc (Raspbian "
#~ "8.3.0-6+rpi1) 8.3.0` on a Raspberry Pi 3 (revision a02082). It was difficult"
#~ " to get stable results in this benchmark."
#~ msgstr ""

#~ msgid "Linux (RPi3)"
#~ msgstr ""

#~ msgid "160"
#~ msgstr ""

#~ msgid "380"
#~ msgstr ""

#~ msgid "Command dispatch benchmark"
#~ msgstr ""

#~ msgid ""
#~ "The command dispatch benchmark tests how many \"dummy\" commands the micro-"
#~ "controller can process. It is primarily a test of the hardware communication"
#~ " mechanism. The test is run using the console.py tool (described in "
#~ "<Debugging.md>). The following is cut-and-paste into the console.py terminal"
#~ " window:"
#~ msgstr ""

#~ msgid ""
#~ "DELAY {clock + 2*freq} get_uptime\n"
#~ "FLOOD 100000 0.0 debug_nop\n"
#~ "get_uptime\n"
#~ msgstr ""

#~ msgid ""
#~ "When the test completes, determine the difference between the clocks "
#~ "reported in the two \"uptime\" response messages. The total number of "
#~ "commands per second is then `100000 * mcu_frequency / clock_diff`."
#~ msgstr ""

#~ msgid ""
#~ "Note that this test may saturate the USB/CPU capacity of a Raspberry Pi. If "
#~ "running on a Raspberry Pi, Beaglebone, or similar host computer then "
#~ "increase the delay (eg, `DELAY {clock + 20*freq} get_uptime`). Where "
#~ "applicable, the benchmarks below are with console.py running on a desktop "
#~ "class machine with the device connected via a high-speed hub."
#~ msgstr ""

#~ msgid "MCU"
#~ msgstr ""

#~ msgid "Rate"
#~ msgstr ""

#~ msgid "Build"
#~ msgstr ""

#~ msgid "Build compiler"
#~ msgstr ""

#~ msgid "stm32f042 (CAN)"
#~ msgstr ""

#~ msgid "18K"
#~ msgstr ""

#~ msgid "c105adc8"
#~ msgstr ""

#~ msgid "arm-none-eabi-gcc (GNU Tools 7-2018-q3-update) 7.3.1"
#~ msgstr ""

#~ msgid "atmega2560 (serial)"
#~ msgstr ""

#~ msgid "23K"
#~ msgstr ""

#~ msgid "b161a69e"
#~ msgstr ""

#~ msgid "avr-gcc (GCC) 4.8.1"
#~ msgstr ""

#~ msgid "sam3x8e (serial)"
#~ msgstr ""

#~ msgid "arm-none-eabi-gcc (Fedora 7.1.0-5.fc27) 7.1.0"
#~ msgstr ""

#~ msgid "at90usb1286 (USB)"
#~ msgstr ""

#~ msgid "75K"
#~ msgstr ""

#~ msgid "01d2183f"
#~ msgstr ""

#~ msgid "avr-gcc (GCC) 5.4.0"
#~ msgstr ""

#~ msgid "samd21 (USB)"
#~ msgstr ""

#~ msgid "223K"
#~ msgstr ""

#~ msgid "arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0"
#~ msgstr ""

#~ msgid "pru (shared memory)"
#~ msgstr ""

#~ msgid "260K"
#~ msgstr ""

#~ msgid "c5968a08"
#~ msgstr ""

#~ msgid "pru-gcc (GCC) 8.0.0 20170530 (experimental)"
#~ msgstr ""

#~ msgid "stm32f103 (USB)"
#~ msgstr ""

#~ msgid "355K"
#~ msgstr ""

#~ msgid "sam3x8e (USB)"
#~ msgstr ""

#~ msgid "418K"
#~ msgstr ""

#~ msgid "lpc1768 (USB)"
#~ msgstr ""

#~ msgid "534K"
#~ msgstr ""

#~ msgid "lpc1769 (USB)"
#~ msgstr ""

#~ msgid "628K"
#~ msgstr ""

#~ msgid "sam4s8c (USB)"
#~ msgstr ""

#~ msgid "650K"
#~ msgstr ""

#~ msgid "8d4a5c16"
#~ msgstr ""

#~ msgid "samd51 (USB)"
#~ msgstr ""

#~ msgid "864K"
#~ msgstr ""

#~ msgid "stm32f446 (USB)"
#~ msgstr ""

#~ msgid "870K"
#~ msgstr ""

#~ msgid "rp2040 (USB)"
#~ msgstr ""

#~ msgid "873K"
#~ msgstr ""

#~ msgid "c5667193"
#~ msgstr ""

#~ msgid "arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0"
#~ msgstr ""

#~ msgid "Host Benchmarks"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to run timing tests on the host software using the \"batch "
#~ "mode\" processing mechanism (described in <Debugging.md>). This is typically"
#~ " done by choosing a large and complex G-Code file and timing how long it "
#~ "takes for the host software to process it. For example:"
#~ msgstr ""

#~ msgid ""
#~ "time ~/klippy-env/bin/python ./klippy/klippy.py config/example-cartesian.cfg"
#~ " -i something_complex.gcode -o /dev/null -d out/klipper.dict\n"
#~ msgstr ""

#~ msgid "Bed Mesh"
#~ msgstr ""

#~ msgid ""
#~ "The Bed Mesh module may be used to compensate for bed surface irregularties "
#~ "to achieve a better first layer across the entire bed. It should be noted "
#~ "that software based correction will not achieve perfect results, it can only"
#~ " approximate the shape of the bed. Bed Mesh also cannot compensate for "
#~ "mechanical and electrical issues. If an axis is skewed or a probe is not "
#~ "accurate then the bed_mesh module will not receive accurate results from the"
#~ " probing process."
#~ msgstr ""

#~ msgid ""
#~ "Prior to Mesh Calibration you will need to be sure that your Probe's "
#~ "Z-Offset is calibrated. If using an endstop for Z homing it will need to be "
#~ "calibrated as well. See [Probe Calibrate](Probe_Calibrate.md) and "
#~ "Z_ENDSTOP_CALIBRATE in [Manual Level](Manual_Level.md) for more information."
#~ msgstr ""

#~ msgid "Basic Configuration"
#~ msgstr ""

#~ msgid "Rectangular Beds"
#~ msgstr ""

#~ msgid ""
#~ "This example assumes a printer with a 250 mm x 220 mm rectangular bed and a "
#~ "probe with an x-offset of 24 mm and y-offset of 5 mm."
#~ msgstr ""

#~ msgid ""
#~ "[bed_mesh]\n"
#~ "speed: 120\n"
#~ "horizontal_move_z: 5\n"
#~ "mesh_min: 35, 6\n"
#~ "mesh_max: 240, 198\n"
#~ "probe_count: 5, 3\n"
#~ msgstr ""

#~ msgid ""
#~ "`speed: 120` *Default Value: 50* The speed in which the tool moves between "
#~ "points."
#~ msgstr ""

#~ msgid ""
#~ "`horizontal_move_z: 5` *Default Value: 5* The Z coordinate the probe rises "
#~ "to prior to traveling between points."
#~ msgstr ""

#~ msgid ""
#~ "`mesh_min: 35, 6` *Required* The first probed coordinate, nearest to the "
#~ "origin. This coordinate is relative to the probe's location."
#~ msgstr ""

#~ msgid ""
#~ "`mesh_max: 240, 198` *Required* The probed coordinate farthest farthest from"
#~ " the origin. This is not necessarily the last point probed, as the probing "
#~ "process occurs in a zig-zag fashion. As with `mesh_min`, this coordiante is "
#~ "relative to the probe's location."
#~ msgstr ""

#~ msgid ""
#~ "`probe_count: 5, 3` *Default Value: 3, 3* The number of points to probe on "
#~ "each axis, specified as X, Y integer values. In this example 5 points will "
#~ "be probed along the X axis, with 3 points along the Y axis, for a total of "
#~ "15 probed points. Note that if you wanted a square grid, for example 3x3, "
#~ "this could be specified as a single integer value that is used for both "
#~ "axes, ie `probe_count: 3`. Note that a mesh requires a minimum probe_count "
#~ "of 3 along each axis."
#~ msgstr ""

#~ msgid ""
#~ "The illustration below demonstrates how the `mesh_min`, `mesh_max`, and "
#~ "`probe_count` options are used to generate probe points. The arrows indicate"
#~ " the direction of the probing procedure, beginning at `mesh_min`. For "
#~ "reference, when the probe is at `mesh_min` the nozzle will be at (11, 1), "
#~ "and when the probe is at `mesh_max`, the nozzle will be at (206, 193)."
#~ msgstr ""

#~ msgid "![bedmesh_rect_basic](img/bedmesh_rect_basic.svg)"
#~ msgstr ""

#~ msgid "Round beds"
#~ msgstr ""

#~ msgid ""
#~ "This example assumes a printer equipped with a round bed radius of 100mm. We"
#~ " will use the same probe offsets as the rectangular example, 24 mm on X and "
#~ "5 mm on Y."
#~ msgstr ""

#~ msgid ""
#~ "[bed_mesh]\n"
#~ "speed: 120\n"
#~ "horizontal_move_z: 5\n"
#~ "mesh_radius: 75\n"
#~ "mesh_origin: 0, 0\n"
#~ "round_probe_count: 5\n"
#~ msgstr ""

#~ msgid ""
#~ "`mesh_radius: 75` *Required* The radius of the probed mesh in mm, relative "
#~ "to the `mesh_origin`. Note that the probe's offsets limit the size of the "
#~ "mesh radius. In this example, a radius larger than 76 would move the tool "
#~ "beyond the range of the printer."
#~ msgstr ""

#~ msgid ""
#~ "`mesh_origin: 0, 0` *Default Value: 0, 0* The center point of the mesh. This"
#~ " coordinate is relative to the probe's location. While the default is 0, 0, "
#~ "it may be useful to adjust the origin in an effort to probe a larger portion"
#~ " of the bed. See the illustration below."
#~ msgstr ""

#~ msgid ""
#~ "`round_probe_count: 5` *Default Value: 5* This is an integer value that "
#~ "defines the maximum number of probed points along the X and Y axes. By "
#~ "\"maximum\", we mean the number of points probed along the mesh origin. This"
#~ " value must be an odd number, as it is required that the center of the mesh "
#~ "is probed."
#~ msgstr ""

#~ msgid ""
#~ "The illustration below shows how the probed points are generated. As you can"
#~ " see, setting the `mesh_origin` to (-10, 0) allows us to specifiy a larger "
#~ "mesh radius of 85."
#~ msgstr ""

#~ msgid "![bedmesh_round_basic](img/bedmesh_round_basic.svg)"
#~ msgstr ""

#~ msgid "Advanced Configuration"
#~ msgstr ""

#~ msgid ""
#~ "Below the more advanced configuration options are explained in detail. Each "
#~ "example will build upon the basic rectangular bed configuration shown above."
#~ " Each of the advanced options apply to round beds in the same manner."
#~ msgstr ""

#~ msgid "Mesh Interpolation"
#~ msgstr ""

#~ msgid ""
#~ "While its possible to sample the probed matrix directly using simple "
#~ "bilinear interpolation to determine the Z-Values between probed points, it "
#~ "is often useful to interpolate extra points using more advanced "
#~ "interpolation algorithms to increase mesh density. These algorithms add "
#~ "curvature to the mesh, attempting to simulate the material properties of the"
#~ " bed. Bed Mesh offers lagrange and bicubic interpolation to accomplish this."
#~ msgstr ""

#~ msgid ""
#~ "[bed_mesh]\n"
#~ "speed: 120\n"
#~ "horizontal_move_z: 5\n"
#~ "mesh_min: 35, 6\n"
#~ "mesh_max: 240, 198\n"
#~ "probe_count: 5, 3\n"
#~ "mesh_pps: 2, 3\n"
#~ "algorithm: bicubic\n"
#~ "bicubic_tension: 0.2\n"
#~ msgstr ""

#~ msgid ""
#~ "`mesh_pps: 2, 3` *Default Value: 2, 2* The `mesh_pps` option is shorthand "
#~ "for Mesh Points Per Segment. This option specifies how many points to "
#~ "interpolate for each segment along the X and Y axes. Consider a 'segment' to"
#~ " be the space between each probed point. Like `probe_count`, `mesh_pps` is "
#~ "specified as an X, Y integer pair, and also may be specified a single "
#~ "integer that is applied to both axes. In this example there are 4 segments "
#~ "along the X axis and 2 segments along the Y axis. This evaluates to 8 "
#~ "interpolated points along X, 6 interpolated points along Y, which results in"
#~ " a 13x8 mesh. Note that if mesh_pps is set to 0 then mesh interpolation is "
#~ "disabled and the probed matrix will be sampled directly."
#~ msgstr ""

#~ msgid ""
#~ "`algorithm: lagrange` *Default Value: lagrange* The algorithm used to "
#~ "interpolate the mesh. May be `lagrange` or `bicubic`. Lagrange interpolation"
#~ " is capped at 6 probed points as oscillation tends to occur with a larger "
#~ "number of samples. Bicubic interpolation requires a minimum of 4 probed "
#~ "points along each axis, if less than 4 points are specified then lagrange "
#~ "sampling is forced. If `mesh_pps` is set to 0 then this value is ignored as "
#~ "no mesh interpolation is done."
#~ msgstr ""

#~ msgid ""
#~ "`bicubic_tension: 0.2` *Default Value: 0.2* If the `algorithm` option is set"
#~ " to bicubic it is possible to specify the tension value. The higher the "
#~ "tension the more slope is interpolated. Be careful when adjusting this, as "
#~ "higher values also create more overshoot, which will result in interpolated "
#~ "values higher or lower than your probed points."
#~ msgstr ""

#~ msgid ""
#~ "The illustration below shows how the options above are used to generate an "
#~ "interpolated mesh."
#~ msgstr ""

#~ msgid "![bedmesh_interpolated](img/bedmesh_interpolated.svg)"
#~ msgstr ""

#~ msgid "Move Splitting"
#~ msgstr ""

#~ msgid ""
#~ "Bed Mesh works by intercepting gcode move commands and applying a transform "
#~ "to their Z coordinate. Long moves must be split into smaller moves to "
#~ "correctly follow the shape of the bed. The options below control the "
#~ "splitting behavior."
#~ msgstr ""

#~ msgid ""
#~ "[bed_mesh]\n"
#~ "speed: 120\n"
#~ "horizontal_move_z: 5\n"
#~ "mesh_min: 35, 6\n"
#~ "mesh_max: 240, 198\n"
#~ "probe_count: 5, 3\n"
#~ "move_check_distance: 5\n"
#~ "split_delta_z: .025\n"
#~ msgstr ""

#~ msgid ""
#~ "`move_check_distance: 5` *Default Value: 5* The minimum distance to check "
#~ "for the desired change in Z before performing a split. In this example, a "
#~ "move longer than 5mm will be traversed by the algorithm. Each 5mm a mesh Z "
#~ "lookup will occur, comparing it with the Z value of the previous move. If "
#~ "the delta meets the threshold set by `split_delta_z`, the move will be split"
#~ " and traversal will continue. This process repeats until the end of the move"
#~ " is reached, where a final adjustment will be applied. Moves shorter than "
#~ "the `move_check_distance` have the correct Z adjustment applied directly to "
#~ "the move without traversal or splitting."
#~ msgstr ""

#~ msgid ""
#~ "`split_delta_z: .025` *Default Value: .025* As mentioned above, this is the "
#~ "minimum deviation required to trigger a move split. In this example, any Z "
#~ "value with a deviation +/- .025mm will trigger a split."
#~ msgstr ""

#~ msgid ""
#~ "Generally the default values for these options are sufficient, in fact the "
#~ "default value of 5mm for the `move_check_distance` may be overkill. However "
#~ "an advanced user may wish to experiment with these options in an effort to "
#~ "squeeze out the optimial first layer."
#~ msgstr ""

#~ msgid "Mesh Fade"
#~ msgstr ""

#~ msgid ""
#~ "When \"fade\" is enabled Z adjustment is phased out over a distance defined "
#~ "by the configuration. This is accomplished by applying small adjustments to "
#~ "the layer height, either increasing or decreasing depending on the shape of "
#~ "the bed. When fade has completed, Z adjustment is no longer applied, "
#~ "allowing the top of the print to be flat rather than mirror the shape of the"
#~ " bed. Fade also may have some undesirable traits, if you fade too quickly it"
#~ " can result in visible artifacts on the print. Also, if your bed is "
#~ "significantly warped, fade can shrink or stretch the Z height of the print. "
#~ "As such, fade is disabled by default."
#~ msgstr ""

#~ msgid ""
#~ "[bed_mesh]\n"
#~ "speed: 120\n"
#~ "horizontal_move_z: 5\n"
#~ "mesh_min: 35, 6\n"
#~ "mesh_max: 240, 198\n"
#~ "probe_count: 5, 3\n"
#~ "fade_start: 1\n"
#~ "fade_end: 10\n"
#~ "fade_target: 0\n"
#~ msgstr ""

#~ msgid ""
#~ "`fade_start: 1` *Default Value: 1* The Z height in which to start phasing "
#~ "out adjustment. It is a good idea to get a few layers down before starting "
#~ "the fade process."
#~ msgstr ""

#~ msgid ""
#~ "`fade_end: 10` *Default Value: 0* The Z height in which fade should "
#~ "complete. If this value is lower than `fade_start` then fade is disabled. "
#~ "This value may be adjusted depending on how warped the print surface is. A "
#~ "significantly warped surface should fade out over a longer distance. A near "
#~ "flat surface may be able to reduce this value to phase out more quickly. "
#~ "10mm is a sane value to begin with if using the default value of 1 for "
#~ "`fade_start`."
#~ msgstr ""

#~ msgid ""
#~ "`fade_target: 0` *Default Value: The average Z value of the mesh* The "
#~ "`fade_target` can be thought of as an additional Z offset applied to the "
#~ "entire bed after fade completes. Generally speaking we would like this value"
#~ " to be 0, however there are circumstances where it should not be. For "
#~ "example, lets assume your homing position on the bed is an outlier, its .2 "
#~ "mm lower than the average probed height of the bed. If the `fade_target` is "
#~ "0, fade will shrink the print by an average of .2 mm across the bed. By "
#~ "setting the `fade_target` to .2, the homed area will expand by .2 mm, "
#~ "however the rest of the bed will have an accurately sized. Generally its a "
#~ "good idea to leave `fade_target` out of the configuration so the average "
#~ "height of the mesh is used, however it may be desirable to manually adjust "
#~ "the fade target if one wants to print on a specific portion of the bed."
#~ msgstr ""

#~ msgid "The Relative Reference Index"
#~ msgstr ""

#~ msgid ""
#~ "Most probes are suceptible to drift, ie: inaccuracies in probing introduced "
#~ "by heat or interference. This can make calculating the probe's z-offset "
#~ "challenging, particuarly at different bed temperatures. As such, some "
#~ "printers use an endstop for homing the Z axis, and a probe for calibrating "
#~ "the mesh. These printers can benefit from configuring the relative reference"
#~ " index."
#~ msgstr ""

#~ msgid ""
#~ "[bed_mesh]\n"
#~ "speed: 120\n"
#~ "horizontal_move_z: 5\n"
#~ "mesh_min: 35, 6\n"
#~ "mesh_max: 240, 198\n"
#~ "probe_count: 5, 3\n"
#~ "relative_reference_index: 7\n"
#~ msgstr ""

#~ msgid ""
#~ "`relative_reference_index: 7` *Default Value: None (disabled)* When the "
#~ "probed points are generated they are each assigned an index. You can look up"
#~ " this index in klippy.log or by using BED_MESH_OUTPUT (see the section on "
#~ "Bed Mesh GCodes below for more information). If you assign an index to the "
#~ "`relative_reference_index` option, the value probed at this coordinate will "
#~ "replace the probe's z_offset. This effectively makes this coordinate the "
#~ "\"zero\" reference for the mesh."
#~ msgstr ""

#~ msgid ""
#~ "When using the relative reference index, you should choose the index nearest"
#~ " to the spot on the bed where Z endstop calibration was done. Note that when"
#~ " looking up the index using the log or BED_MESH_OUTPUT, you should use the "
#~ "coordinates listed under the \"Probe\" header to find the correct index."
#~ msgstr ""

#~ msgid "Faulty Regions"
#~ msgstr ""

#~ msgid ""
#~ "It is possible for some areas of a bed to report inaccurate results when "
#~ "probing due to a \"fault\" at specific locations. The best example of this "
#~ "are beds with series of integrated magnets used to retain removable steel "
#~ "sheets. The magnetic field at and around these magnets may cause an "
#~ "inductive probe to trigger at a distance higher or lower than it would "
#~ "otherwise, resulting in a mesh that does not accurately represent the "
#~ "surface at these locations. **Note: This should not be confused with probe "
#~ "location bias, which produces inaccurate results across the entire bed.**"
#~ msgstr ""

#~ msgid ""
#~ "The `faulty_region` options may be configured to compensate for this affect."
#~ " If a generated point lies within a faulty region bed mesh will attempt to "
#~ "probe up to 4 points at the boundaries of this region. These probed values "
#~ "will be averaged and inserted in the mesh as the Z value at the generated "
#~ "(X, Y) coordinate."
#~ msgstr ""

#~ msgid ""
#~ "[bed_mesh]\n"
#~ "speed: 120\n"
#~ "horizontal_move_z: 5\n"
#~ "mesh_min: 35, 6\n"
#~ "mesh_max: 240, 198\n"
#~ "probe_count: 5, 3\n"
#~ "faulty_region_1_min: 130.0, 0.0\n"
#~ "faulty_region_1_max: 145.0, 40.0\n"
#~ "faulty_region_2_min: 225.0, 0.0\n"
#~ "faulty_region_2_max: 250.0, 25.0\n"
#~ "faulty_region_3_min: 165.0, 95.0\n"
#~ "faulty_region_3_max: 205.0, 110.0\n"
#~ "faulty_region_4_min: 30.0, 170.0\n"
#~ "faulty_region_4_max: 45.0, 210.0\n"
#~ msgstr ""

#~ msgid ""
#~ "`faulty_region_{1...99}_min` `faulty_region_{1..99}_max` *Default Value: "
#~ "None (disabled)* Faulty Regions are defined in a way similar to that of mesh"
#~ " itself, where minimum and maximum (X, Y) coordinates must be specified for "
#~ "each region. A faulty region may extend outside of a mesh, however the "
#~ "alternate points generated will always be within the mesh boundary. No two "
#~ "regions may overlap."
#~ msgstr ""

#~ msgid ""
#~ "The image below illustrates how replacement points are generated when a "
#~ "generated point lies within a faulty region. The regions shown match those "
#~ "in the sample config above. The replacement points and their coordinates are"
#~ " identified in green."
#~ msgstr ""

#~ msgid "![bedmesh_interpolated](img/bedmesh_faulty_regions.svg)"
#~ msgstr ""

#~ msgid "Bed Mesh Gcodes"
#~ msgstr ""

#~ msgid "Calibration"
#~ msgstr ""

#~ msgid ""
#~ "`BED_MESH_CALIBRATE PROFILE=<name> METHOD=[manual | automatic] "
#~ "[<probe_parameter>=<value>] [<mesh_parameter>=<value>]` *Default Profile: "
#~ "default* *Default Method: automatic if a probe is detected, otherwise "
#~ "manual*"
#~ msgstr ""

#~ msgid "Initiates the probing procedure for Bed Mesh Calibration."
#~ msgstr ""

#~ msgid ""
#~ "The mesh will be saved into a profile specified by the `PROFILE` parameter, "
#~ "or `default` if unspecified. If `METHOD=manual` is selected then manual "
#~ "probing will occur. When switching between automatic and manual probing the "
#~ "generated mesh points will automatically be adjusted."
#~ msgstr ""

#~ msgid ""
#~ "It is possible to specify mesh parameters to modify the probed area. The "
#~ "following parameters are available:"
#~ msgstr ""

#~ msgid "Rectangular beds (cartesian):"
#~ msgstr ""

#~ msgid "`MESH_MIN`"
#~ msgstr ""

#~ msgid "`MESH_MAX`"
#~ msgstr ""

#~ msgid "`PROBE_COUNT`"
#~ msgstr ""

#~ msgid "Round beds (delta):"
#~ msgstr ""

#~ msgid "`MESH_RADIUS`"
#~ msgstr ""

#~ msgid "`MESH_ORIGIN`"
#~ msgstr ""

#~ msgid "`ROUND_PROBE_COUNT`"
#~ msgstr ""

#~ msgid "All beds:"
#~ msgstr ""

#~ msgid "`RELATIVE_REFERNCE_INDEX`"
#~ msgstr ""

#~ msgid "`ALGORITHM`"
#~ msgstr ""

#~ msgid ""
#~ "See the configuration documentation above for details on how each parameter "
#~ "applies to the mesh."
#~ msgstr ""

#~ msgid "Profiles"
#~ msgstr ""

#~ msgid "`BED_MESH_PROFILE SAVE=<name> LOAD=<name> REMOVE=<name>`"
#~ msgstr ""

#~ msgid ""
#~ "After a BED_MESH_CALIBRATE has been performed, it is possible to save the "
#~ "current mesh state into a named profile. This makes it possible to load a "
#~ "mesh without re-probing the bed. After a profile has been saved using "
#~ "`BED_MESH_PROFILE SAVE=<name>` the `SAVE_CONFIG` gcode may be executed to "
#~ "write the profile to printer.cfg."
#~ msgstr ""

#~ msgid "Profiles can be loaded by executing `BED_MESH_PROFILE LOAD=<name>`."
#~ msgstr ""

#~ msgid ""
#~ "It should be noted that each time a BED_MESH_CALIBRATE occurs, the current "
#~ "state is automatically saved to the *default* profile. If this profile "
#~ "exists it is automatically loaded when Klipper starts. If this behavior is "
#~ "not desirable the *default* profile can be removed as follows:"
#~ msgstr ""

#~ msgid "`BED_MESH_PROFILE REMOVE=default`"
#~ msgstr ""

#~ msgid ""
#~ "Any other saved profile can be removed in the same fashion, replacing "
#~ "*default* with the named profile you wish to remove."
#~ msgstr ""

#~ msgid "Output"
#~ msgstr ""

#~ msgid "`BED_MESH_OUTPUT PGP=[0 | 1]`"
#~ msgstr ""

#~ msgid ""
#~ "Outputs the current mesh state to the terminal. Note that the mesh itself is"
#~ " output"
#~ msgstr ""

#~ msgid ""
#~ "The PGP parameter is shorthand for \"Print Generated Points\". If `PGP=1` is"
#~ " set, the generated probed points will be output to the terminal:"
#~ msgstr ""

#~ msgid ""
#~ "// bed_mesh: generated points\n"
#~ "// Index | Tool Adjusted | Probe\n"
#~ "// 0 | (11.0, 1.0) | (35.0, 6.0)\n"
#~ "// 1 | (62.2, 1.0) | (86.2, 6.0)\n"
#~ "// 2 | (113.5, 1.0) | (137.5, 6.0)\n"
#~ "// 3 | (164.8, 1.0) | (188.8, 6.0)\n"
#~ "// 4 | (216.0, 1.0) | (240.0, 6.0)\n"
#~ "// 5 | (216.0, 97.0) | (240.0, 102.0)\n"
#~ "// 6 | (164.8, 97.0) | (188.8, 102.0)\n"
#~ "// 7 | (113.5, 97.0) | (137.5, 102.0)\n"
#~ "// 8 | (62.2, 97.0) | (86.2, 102.0)\n"
#~ "// 9 | (11.0, 97.0) | (35.0, 102.0)\n"
#~ "// 10 | (11.0, 193.0) | (35.0, 198.0)\n"
#~ "// 11 | (62.2, 193.0) | (86.2, 198.0)\n"
#~ "// 12 | (113.5, 193.0) | (137.5, 198.0)\n"
#~ "// 13 | (164.8, 193.0) | (188.8, 198.0)\n"
#~ "// 14 | (216.0, 193.0) | (240.0, 198.0)\n"
#~ msgstr ""

#~ msgid ""
#~ "The \"Tool Adjusted\" points refer to the nozzle location for each point, "
#~ "and the \"Probe\" points refer to the probe location. Note that when "
#~ "manually probing the \"Probe\" points will refer to both the tool and nozzle"
#~ " locations."
#~ msgstr ""

#~ msgid "Clear Mesh State"
#~ msgstr ""

#~ msgid "`BED_MESH_CLEAR`"
#~ msgstr ""

#~ msgid "This gcode may be used to clear the internal mesh state."
#~ msgstr ""

#~ msgid "Apply X/Y offsets"
#~ msgstr ""

#~ msgid "`BED_MESH_OFFSET [X=<value>] [Y=<value>]`"
#~ msgstr ""

#~ msgid ""
#~ "This is useful for printers with multiple independent extruders, as an "
#~ "offset is necessary to produce correct Z adjustment after a tool change. "
#~ "Offsets should be specified relative to the primary extruder. That is, a "
#~ "positive X offset should be specified if the secondary extruder is mounted "
#~ "to the right of the primary extruder, and a positive Y offset should be "
#~ "specified if the secondary extruder is mounted \"behind\" the primary "
#~ "extruder."
#~ msgstr ""

#~ msgid "Bed leveling"
#~ msgstr ""

#~ msgid ""
#~ "Bed leveling (sometimes also referred to as \"bed tramming\") is critical to"
#~ " getting high quality prints. If a bed is not properly \"leveled\" it can "
#~ "lead to poor bed adhesion, \"warping\", and subtle problems throughout the "
#~ "print. This document serves as a guide to performing bed leveling in "
#~ "Klipper."
#~ msgstr ""

#~ msgid ""
#~ "It's important to understand the goal of bed leveling. If the printer is "
#~ "commanded to a position `X0 Y0 Z10` during a print, then the goal is for the"
#~ " printer's nozzle to be exactly 10mm from the printer's bed. Further, should"
#~ " the printer then be commanded to a position of `X50 Z10` the goal is for "
#~ "the nozzle to maintain an exact distance of 10mm from the bed during that "
#~ "entire horizontal move."
#~ msgstr ""

#~ msgid ""
#~ "In order to get good quality prints the printer should be calibrated so that"
#~ " Z distances are accurate to within about 25 microns (.025mm). This is a "
#~ "small distance - significantly smaller than the width of a typical human "
#~ "hair. This scale can not be measured \"by eye\". Subtle effects (such as "
#~ "heat expansion) impact measurements at this scale. The secret to getting "
#~ "high accuracy is to use a repeatable process and to use a leveling method "
#~ "that leverages the high accuracy of the printer's own motion system."
#~ msgstr ""

#~ msgid "Choose the appropriate calibration mechanism"
#~ msgstr ""

#~ msgid ""
#~ "Different types of printers use different methods for performing bed "
#~ "leveling. All of them ultimately depend on the \"paper test\" (described "
#~ "below). However, the actual process for a particular type of printer is "
#~ "described in other documents."
#~ msgstr ""

#~ msgid ""
#~ "Prior to running any of these calibration tools, be sure to run the checks "
#~ "described in the [config check document](Config_checks.md). It is necessary "
#~ "to verify basic printer motion before performing bed leveling."
#~ msgstr ""

#~ msgid ""
#~ "For printers with an \"automatic Z probe\" be sure to calibrate the probe "
#~ "following the directions in the [Probe Calibrate](Probe_Calibrate.md) "
#~ "document. For delta printers, see the [Delta Calibrate](Delta_Calibrate.md) "
#~ "document. For printers with bed screws and traditional Z endstops, see the "
#~ "[Manual Level](Manual_Level.md) document."
#~ msgstr ""

#~ msgid ""
#~ "During calibration it may be necessary to set the printer's Z `position_min`"
#~ " to a negative number (eg, `position_min = -2`). The printer enforces "
#~ "boundary checks even during calibration routines. Setting a negative number "
#~ "allows the printer to move below the nominal position of the bed, which may "
#~ "help when trying to determine the actual bed position."
#~ msgstr ""

#~ msgid "The \"paper test\""
#~ msgstr ""

#~ msgid ""
#~ "The primary bed calibration mechanism is the \"paper test\". It involves "
#~ "placing a regular piece of \"copy machine paper\" between the printer's bed "
#~ "and nozzle, and then commanding the nozzle to different Z heights until one "
#~ "feels a small amount of friction when pushing the paper back and forth."
#~ msgstr ""

#~ msgid ""
#~ "It is important to understand the \"paper test\" even if one has an "
#~ "\"automatic Z probe\". The probe itself often needs to be calibrated to get "
#~ "good results. That probe calibration is done using this \"paper test\"."
#~ msgstr ""

#~ msgid ""
#~ "In order to perform the paper test, cut a small rectangular piece of paper "
#~ "using a pair of scissors (eg, 5x3 cm). The paper generally has a thickness "
#~ "of around 100 microns (0.100mm). (The exact thickness of the paper isn't "
#~ "crucial.)"
#~ msgstr ""

#~ msgid ""
#~ "The first step of the paper test is to inspect the printer's nozzle and bed."
#~ " Make sure there is no plastic (or other debris) on the nozzle or bed."
#~ msgstr ""

#~ msgid "**Inspect the nozzle and bed to ensure no plastic is present!**"
#~ msgstr ""

#~ msgid ""
#~ "If one always prints on a particular tape or printing surface then one may "
#~ "perform the paper test with that tape/surface in place. However, note that "
#~ "tape itself has a thickness and different tapes (or any other printing "
#~ "surface) will impact Z measurements. Be sure to rerun the paper test to "
#~ "measure each type of surface that is in use."
#~ msgstr ""

#~ msgid ""
#~ "If there is plastic on the nozzle then heat up the extruder and use a metal "
#~ "tweezers to remove that plastic. Wait for the extruder to fully cool to room"
#~ " temperature before continuing with the paper test. While the nozzle is "
#~ "cooling, use the metal tweezers to remove any plastic that may ooze out."
#~ msgstr ""

#~ msgid ""
#~ "**Always perform the paper test when both nozzle and bed are at room "
#~ "temperature!**"
#~ msgstr ""

#~ msgid ""
#~ "When the nozzle is heated, its position (relative to the bed) changes due to"
#~ " thermal expansion. This thermal expansion is typically around a 100 "
#~ "microns, which is about the same thickness as a typical piece of printer "
#~ "paper. The exact amount of thermal expansion isn't crucial, just as the "
#~ "exact thickness of the paper isn't crucial. Start with the assumption that "
#~ "the two are equal (see below for a method of determining the difference "
#~ "between the two distances)."
#~ msgstr ""

#~ msgid ""
#~ "It may seem odd to calibrate the distance at room temperature when the goal "
#~ "is to have a consistent distance when heated. However, if one calibrates "
#~ "when the nozzle is heated, it tends to impart small amounts of molten "
#~ "plastic on to the paper, which changes the amount of friction felt. That "
#~ "makes it harder to get a good calibration. Calibrating while the bed/nozzle "
#~ "is hot also greatly increases the risk of burning oneself. The amount of "
#~ "thermal expansion is stable, so it is easily accounted for later in the "
#~ "calibration process."
#~ msgstr ""

#~ msgid "**Use an automated tool to determine precise Z heights!**"
#~ msgstr ""

#~ msgid ""
#~ "Klipper has several helper scripts available (eg, MANUAL_PROBE, "
#~ "Z_ENDSTOP_CALIBRATE, PROBE_CALIBRATE, DELTA_CALIBRATE). See the documents "
#~ "[described above](#choose-the-appropriate-calibration-mechanism) to choose "
#~ "one of them."
#~ msgstr ""

#~ msgid ""
#~ "Run the appropriate command in the OctoPrint terminal window. The script "
#~ "will prompt for user interaction in the OctoPrint terminal output. It will "
#~ "look something like:"
#~ msgstr ""

#~ msgid ""
#~ "Recv: // Starting manual Z probe. Use TESTZ to adjust position.\n"
#~ "Recv: // Finish with ACCEPT or ABORT command.\n"
#~ "Recv: // Z position: ?????? --> 5.000 <-- ??????\n"
#~ msgstr ""

#~ msgid ""
#~ "The current height of the nozzle (as the printer currently understands it) "
#~ "is shown between the \"--> <--\". The number to the right is the height of "
#~ "the last probe attempt just greater than the current height, and to the left"
#~ " is the last probe attempt less than the current height (or ?????? if no "
#~ "attempt has been made)."
#~ msgstr ""

#~ msgid ""
#~ "Place the paper between the nozzle and bed. It can be useful to fold a "
#~ "corner of the paper so that it is easier to grab. (Try not to push down on "
#~ "the bed when moving the paper back and forth.)"
#~ msgstr ""

#~ msgid "![paper-test](img/paper-test.jpg)"
#~ msgstr ""

#~ msgid ""
#~ "Use the TESTZ command to request the nozzle to move closer to the paper. For"
#~ " example:"
#~ msgstr ""

#~ msgid "TESTZ Z=-.1\n"
#~ msgstr ""

#~ msgid ""
#~ "The TESTZ command will move the nozzle a relative distance from the nozzle's"
#~ " current position. (So, `Z=-.1` requests the nozzle to move closer to the "
#~ "bed by .1mm.) After the nozzle stops moving, push the paper back and forth "
#~ "to check if the nozzle is in contact with the paper and to feel the amount "
#~ "of friction. Continue issuing TESTZ commands until one feels a small amount "
#~ "of friction when testing with the paper."
#~ msgstr ""

#~ msgid ""
#~ "If too much friction is found then one can use a positive Z value to move "
#~ "the nozzle up. It is also possible to use `TESTZ Z=+` or `TESTZ Z=-` to "
#~ "\"bisect\" the last position - that is to move to a position half way "
#~ "between two positions. For example, if one received the following prompt "
#~ "from a TESTZ command:"
#~ msgstr ""

#~ msgid "Recv: // Z position: 0.130 --> 0.230 <-- 0.280\n"
#~ msgstr ""

#~ msgid ""
#~ "Then a `TESTZ Z=-` would move the nozzle to a Z position of 0.180 (half way "
#~ "between 0.130 and 0.230). One can use this feature to help rapidly narrow "
#~ "down to a consistent friction. It is also possible to use `Z=++` and `Z=--` "
#~ "to return directly to a past measurement - for example, after the above "
#~ "prompt a `TESTZ Z=--` command would move the nozzle to a Z position of "
#~ "0.130."
#~ msgstr ""

#~ msgid "After finding a small amount of friction run the ACCEPT command:"
#~ msgstr ""

#~ msgid "ACCEPT\n"
#~ msgstr ""

#~ msgid ""
#~ "This will accept the given Z height and proceed with the given calibration "
#~ "tool."
#~ msgstr ""

#~ msgid ""
#~ "The exact amount of friction felt isn't crucial, just as the amount of "
#~ "thermal expansion and exact width of the paper isn't crucial. Just try to "
#~ "obtain the same amount of friction each time one runs the test."
#~ msgstr ""

#~ msgid ""
#~ "If something goes wrong during the test, one can use the `ABORT` command to "
#~ "exit the calibration tool."
#~ msgstr ""

#~ msgid "Determining Thermal Expansion"
#~ msgstr ""

#~ msgid ""
#~ "After successfully performing bed leveling, one may go on to calculate a "
#~ "more precise value for the combined impact of \"thermal expansion\", "
#~ "\"thickness of the paper\", and \"amount of friction felt during the paper "
#~ "test\"."
#~ msgstr ""

#~ msgid ""
#~ "This type of calculation is generally not needed as most users find the "
#~ "simple \"paper test\" provides good results."
#~ msgstr ""

#~ msgid ""
#~ "The easiest way to make this calculation is to print a test object that has "
#~ "straight walls on all sides. The large hollow square found in "
#~ "[docs/prints/square.stl](prints/square.stl) can be used for this. When "
#~ "slicing the object, make sure the slicer uses the same layer height and "
#~ "extrusion widths for the first level that it does for all subsequent layers."
#~ " Use a coarse layer height (the layer height should be around 75% of the "
#~ "nozzle diameter) and do not use a brim or raft."
#~ msgstr ""

#~ msgid ""
#~ "Print the test object, wait for it to cool, and remove it from the bed. "
#~ "Inspect the lowest layer of the object. (It may also be useful to run a "
#~ "finger or nail along the bottom edge.) If one finds the bottom layer bulges "
#~ "out slightly along all sides of the object then it indicates the nozzle was "
#~ "slightly closer to the bed then it should be. One can issue a "
#~ "`SET_GCODE_OFFSET Z=+.010` command to increase the height. In subsequent "
#~ "prints one can inspect for this behavior and make further adjustment as "
#~ "needed. Adjustments of this type are typically in 10s of microns (.010mm)."
#~ msgstr ""

#~ msgid ""
#~ "If the bottom layer consistently appears narrower than subsequent layers "
#~ "then one can use the SET_GCODE_OFFSET command to make a negative Z "
#~ "adjustment. If one is unsure, then one can decrease the Z adjustment until "
#~ "the bottom layer of prints exhibit a small bulge, and then back-off until it"
#~ " disappears."
#~ msgstr ""

#~ msgid ""
#~ "The easiest way to apply the desired Z adjustment is to create a START_PRINT"
#~ " g-code macro, arrange for the slicer to call that macro during the start of"
#~ " each print, and add a SET_GCODE_OFFSET command to that macro. See the "
#~ "[slicers](Slicers.md) document for further details."
#~ msgstr ""

#~ msgid "Beaglebone"
#~ msgstr ""

#~ msgid ""
#~ "This document describes the process of running Klipper on a Beaglebone PRU."
#~ msgstr ""

#~ msgid "Building an OS image"
#~ msgstr ""

#~ msgid ""
#~ "Start by installing the [Debian 9.9 2019-08-03 4GB SD "
#~ "IoT](https://beagleboard.org/latest-images) image. One may run the image "
#~ "from either a micro-SD card or from builtin eMMC. If using the eMMC, install"
#~ " it to eMMC now by following the instructions from the above link."
#~ msgstr ""

#~ msgid ""
#~ "Then ssh into the Beaglebone machine (`ssh debian@beaglebone` -- password is"
#~ " `temppwd`) and install Klipper by running the following commands:"
#~ msgstr ""

#~ msgid ""
#~ "git clone https://github.com/Klipper3d/klipper\n"
#~ "./klipper/scripts/install-beaglebone.sh\n"
#~ msgstr ""

#~ msgid "Install Octoprint"
#~ msgstr ""

#~ msgid "One may then install Octoprint:"
#~ msgstr ""

#~ msgid ""
#~ "git clone https://github.com/foosel/OctoPrint.git\n"
#~ "cd OctoPrint/\n"
#~ "virtualenv venv\n"
#~ "./venv/bin/python setup.py install\n"
#~ msgstr ""

#~ msgid "And setup OctoPrint to start at bootup:"
#~ msgstr ""

#~ msgid ""
#~ "sudo cp ~/OctoPrint/scripts/octoprint.init /etc/init.d/octoprint\n"
#~ "sudo chmod +x /etc/init.d/octoprint\n"
#~ "sudo cp ~/OctoPrint/scripts/octoprint.default /etc/default/octoprint\n"
#~ "sudo update-rc.d octoprint defaults\n"
#~ msgstr ""

#~ msgid ""
#~ "It is necessary to modify OctoPrint's **/etc/default/octoprint** "
#~ "configuration file. One must change the `OCTOPRINT_USER` user to `debian`, "
#~ "change `NICELEVEL` to `0`, uncomment the `BASEDIR`, `CONFIGFILE`, and "
#~ "`DAEMON` settings and change the references from `/home/pi/` to "
#~ "`/home/debian/`:"
#~ msgstr ""

#~ msgid "sudo nano /etc/default/octoprint\n"
#~ msgstr ""

#~ msgid "Then start the Octoprint service:"
#~ msgstr ""

#~ msgid "sudo systemctl start octoprint\n"
#~ msgstr ""

#~ msgid ""
#~ "Make sure the OctoPrint web server is accessible - it should be at: "
#~ "<http://beaglebone:5000/>"
#~ msgstr ""

#~ msgid ""
#~ "To compile the Klipper micro-controller code, start by configuring it for "
#~ "the \"Beaglebone PRU\":"
#~ msgstr ""

#~ msgid ""
#~ "It is also necessary to compile and install the micro-controller code for a "
#~ "Linux host process. Configure it a second time for a \"Linux process\":"
#~ msgstr ""

#~ msgid "make menuconfig\n"
#~ msgstr ""

#~ msgid "Then install this micro-controller code as well:"
#~ msgstr ""

#~ msgid ""
#~ "Complete the installation by configuring Klipper and Octoprint following the"
#~ " instructions in the main [Installation](Installation.md#configuring-"
#~ "klipper) document."
#~ msgstr ""

#~ msgid "Printing on the Beaglebone"
#~ msgstr ""

#~ msgid ""
#~ "Unfortunately, the Beaglebone processor can sometimes struggle to run "
#~ "OctoPrint well. Print stalls have been known to occur on complex prints (the"
#~ " printer may move faster than OctoPrint can send movement commands). If this"
#~ " occurs, consider using the \"virtual_sdcard\" feature (see [Config "
#~ "Reference](Config_Reference.md#virtual_sdcard) for details) to print "
#~ "directly from Klipper."
#~ msgstr ""

#~ msgid "BL-Touch"
#~ msgstr ""

#~ msgid "Connecting BL-Touch"
#~ msgstr ""

#~ msgid ""
#~ "A **warning** before you start: Avoid touching the BL-Touch pin with your "
#~ "bare fingers, since it is quite sensitive to finger grease. And if you do "
#~ "touch it, be very gentle, in order to not bend or push anything."
#~ msgstr ""

#~ msgid ""
#~ "Hook up the BL-Touch \"servo\" connector to a `control_pin` according to the"
#~ " BL-Touch documentation or your MCU documentation. Using the original "
#~ "wiring, the yellow wire from the triple is the `control_pin` and the white "
#~ "wire from the pair is the `sensor_pin`. You need to configure these pins "
#~ "according to your wiring. Most BL-Touch devices require a pullup on the "
#~ "sensor pin (prefix the pin name with \"^\"). For example:"
#~ msgstr ""

#~ msgid ""
#~ "[bltouch]\n"
#~ "sensor_pin: ^P1.24\n"
#~ "control_pin: P1.26\n"
#~ msgstr ""

#~ msgid ""
#~ "If the BL-Touch will be used to home the Z axis then set `endstop_pin: "
#~ "probe:z_virtual_endstop` and remove `position_endstop` in the `[stepper_z]` "
#~ "config section, then add a `[safe_z_home]` config section to raise the z "
#~ "axis, home the xy axes, move to the center of the bed, and home the z axis. "
#~ "For example:"
#~ msgstr ""

#~ msgid ""
#~ "[safe_z_home]\n"
#~ "home_xy_position: 100, 100 # Change coordinates to the center of your print bed\n"
#~ "speed: 50\n"
#~ "z_hop: 10                 # Move up 10mm\n"
#~ "z_hop_speed: 5\n"
#~ msgstr ""

#~ msgid ""
#~ "It's important that the z_hop movement in safe_z_home is high enough that "
#~ "the probe doesn't hit anything even if the probe pin happens to be in its "
#~ "lowest state."
#~ msgstr ""

#~ msgid "Initial tests"
#~ msgstr ""

#~ msgid ""
#~ "Before moving on, verify that the BL-Touch is mounted at the correct height,"
#~ " the pin should be roughly 2 mm above the nozzle when retracted"
#~ msgstr ""

#~ msgid ""
#~ "When you turn on the printer, the BL-Touch probe should perform a self-test "
#~ "and move the pin up and down a couple of times. Once the self-test is "
#~ "completed, the pin should be retracted and the red LED on the probe should "
#~ "be lit. If there are any errors, for example the probe is flashing red or "
#~ "the pin is down instead of up, please turn off the printer and check the "
#~ "wiring and configuration."
#~ msgstr ""

#~ msgid ""
#~ "If the above is looking good, it's time to test that the control pin is "
#~ "working correctly. First run `BLTOUCH_DEBUG COMMAND=pin_down` in your "
#~ "printer terminal. Verify that the pin moves down and that the red LED on the"
#~ " probe turns off. If not, check your wiring and configuration again. Next "
#~ "issue a `BLTOUCH_DEBUG COMMAND=pin_up`, verify that the pin moves up, and "
#~ "that the red light turns on again. If it's flashing then there's some "
#~ "problem."
#~ msgstr ""

#~ msgid ""
#~ "The next step is to confirm that the sensor pin is working correctly. Run "
#~ "`BLTOUCH_DEBUG COMMAND=pin_down`, verify that the pin moves down, run "
#~ "`BLTOUCH_DEBUG COMMAND=touch_mode`, run `QUERY_PROBE`, and verify that "
#~ "command reports \"probe: open\". Then while gently pushing the pin up "
#~ "slightly with the nail of your finger run `QUERY_PROBE` again. Verify the "
#~ "command reports \"probe: TRIGGERED\". If either query does not report the "
#~ "correct message then it usually indicates an incorrect wiring or "
#~ "configuration (though some [clones](#bl-touch-clones) may require special "
#~ "handling). At the completion of this test run `BLTOUCH_DEBUG COMMAND=pin_up`"
#~ " and verify that the pin moves up."
#~ msgstr ""

#~ msgid ""
#~ "After completing the BL-Touch control pin and sensor pin tests, it is now "
#~ "time to test probing, but with a twist. Instead of letting the probe pin "
#~ "touch the print bed, let it touch the nail on your finger. Position the "
#~ "toolhead far from the bed, issue a `G28` (or `PROBE` if not using "
#~ "probe:z_virtual_endstop), wait until the toolhead starts to move down, and "
#~ "stop the movement by very gently touching the pin with your nail. You may "
#~ "have to do it twice, since the default homing configuration probes twice. Be"
#~ " prepared to turn off the printer if it doesn't stop when you touch the pin."
#~ msgstr ""

#~ msgid ""
#~ "If that was successful, do another `G28` (or `PROBE`) but this time let it "
#~ "touch the bed as it should."
#~ msgstr ""

#~ msgid "BL-Touch gone bad"
#~ msgstr ""

#~ msgid ""
#~ "Once the BL-Touch is in inconsistent state, it starts blinking red. You can "
#~ "force it to leave that state by issuing:"
#~ msgstr ""

#~ msgid "BLTOUCH_DEBUG COMMAND=reset"
#~ msgstr ""

#~ msgid ""
#~ "This may happen if its calibration is interrupted by the probe being blocked"
#~ " from being extracted."
#~ msgstr ""

#~ msgid ""
#~ "However, the BL-Touch may also not be able to calibrate itself anymore. This"
#~ " happens if the screw on its top is in the wrong position or the magnetic "
#~ "core inside the probe pin has moved. If it has moved up so that it sticks to"
#~ " the screw, it may not be able to lower its pin anymore. With this behavior "
#~ "you need to open the screw and use a ball-point pen to push it gently back "
#~ "into place. Re-Insert the pin into the BL-Touch so that it falls into the "
#~ "extracted position. Carefully readjust the headless screw into place. You "
#~ "need to find the right position so it is able to lower and raise the pin and"
#~ " the red light turns on and of. Use the `reset`, `pin_up` and `pin_down` "
#~ "commands to achieve this."
#~ msgstr ""

#~ msgid "BL-Touch \"clones\""
#~ msgstr ""

#~ msgid ""
#~ "Many BL-Touch \"clone\" devices work correctly with Klipper using the "
#~ "default configuration. However, some \"clone\" devices may not support the "
#~ "`QUERY_PROBE` command and some \"clone\" devices may require configuration "
#~ "of `pin_up_reports_not_triggered` or `pin_up_touch_mode_reports_triggered`."
#~ msgstr ""

#~ msgid ""
#~ "Important! Do not configure `pin_up_reports_not_triggered` or "
#~ "`pin_up_touch_mode_reports_triggered` to False without first following these"
#~ " directions. Do not configure either of these to False on a genuine BL-"
#~ "Touch. Incorrectly setting these to False can increase probing time and can "
#~ "increase the risk of damaging the printer."
#~ msgstr ""

#~ msgid ""
#~ "Some \"clone\" devices do not support `touch_mode` and as a result the "
#~ "`QUERY_PROBE` command does not work. Despite this, it may still be possible "
#~ "to perform probing and homing with these devices. On these devices the "
#~ "`QUERY_PROBE` command during the [initial tests](#initial-tests) will not "
#~ "succeed, however the subsequent `G28` (or `PROBE`) test does succeed. It may"
#~ " be possible to use these \"clone\" devices with Klipper if one does not "
#~ "utilize the `QUERY_PROBE` command and one does not enable the "
#~ "`probe_with_touch_mode` feature."
#~ msgstr ""

#~ msgid ""
#~ "Some \"clone\" devices are unable to perform Klipper's internal sensor "
#~ "verification test. On these devices, attempts to home or probe can result in"
#~ " Klipper reporting a \"BLTouch failed to verify sensor state\" error. If "
#~ "this occurs, then manually run the steps to confirm the sensor pin is "
#~ "working as described in the [initial tests section](#initial-tests). If the "
#~ "`QUERY_PROBE` commands in that test always produce the expected results and "
#~ "\"BLTouch failed to verify sensor state\" errors still occur, then it may be"
#~ " necessary to set `pin_up_touch_mode_reports_triggered` to False in the "
#~ "Klipper config file."
#~ msgstr ""

#~ msgid ""
#~ "A rare number of old \"clone\" devices are unable to report when they have "
#~ "successfully raised their probe. On these devices Klipper will report a "
#~ "\"BLTouch failed to raise probe\" error after every home or probe attempt. "
#~ "One can test for these devices - move the head far from the bed, run "
#~ "`BLTOUCH_DEBUG COMMAND=pin_down`, verify the pin has moved down, run "
#~ "`QUERY_PROBE`, verify that command reports \"probe: open\", run "
#~ "`BLTOUCH_DEBUG COMMAND=pin_up`, verify the pin has moved up, and run "
#~ "`QUERY_PROBE`. If the pin remains up, the device does not enter an error "
#~ "state, and the first query reports \"probe: open\" while the second query "
#~ "reports \"probe: TRIGGERED\" then it indicates that "
#~ "`pin_up_reports_not_triggered` should be set to False in the Klipper config "
#~ "file."
#~ msgstr ""

#~ msgid "BL-Touch v3"
#~ msgstr ""

#~ msgid ""
#~ "Some BL-Touch v3.0 and BL-Touch 3.1 devices may require configuring "
#~ "`probe_with_touch_mode` in the printer config file."
#~ msgstr ""

#~ msgid ""
#~ "If the BL-Touch v3.0 has its signal wire connected to an endstop pin (with a"
#~ " noise filtering capacitor), then the BL-Touch v3.0 may not be able to "
#~ "consistently send a signal during homing and probing. If the `QUERY_PROBE` "
#~ "commands in the [initial tests section](#initial-tests) always produce the "
#~ "expected results, but the toolhead does not always stop during G28/PROBE "
#~ "commands, then it is indicative of this issue. A workaround is to set "
#~ "`probe_with_touch_mode: True` in the config file."
#~ msgstr ""

#~ msgid ""
#~ "The BL-Touch v3.1 may incorrectly enter an error state after a successful "
#~ "probe attempt. The symptoms are an occasional flashing light on the BL-Touch"
#~ " v3.1 that lasts for a couple of seconds after it successfully contacts the "
#~ "bed. Klipper should clear this error automatically and it is generally "
#~ "harmless. However, one may set `probe_with_touch_mode` in the config file to"
#~ " avoid this issue."
#~ msgstr ""

#~ msgid ""
#~ "Important! Some \"clone\" devices and the BL-Touch v2.0 (and earlier) may "
#~ "have reduced accuracy when `probe_with_touch_mode` is set to True. Setting "
#~ "this to True also increases the time it takes to deploy the probe. If "
#~ "configuring this value on a \"clone\" or older BL-Touch device, be sure to "
#~ "test the probe accuracy before and after setting this value (use the "
#~ "`PROBE_ACCURACY` command to test)."
#~ msgstr ""

#~ msgid "Multi-probing without stowing"
#~ msgstr ""

#~ msgid ""
#~ "By default, Klipper will deploy the probe at the start of each probe attempt"
#~ " and then stow the probe afterwards. This repetitive deploying and stowing "
#~ "of the probe may increase the total time of calibration sequences that "
#~ "involve many probe measurements. Klipper supports leaving the probe deployed"
#~ " between consecutive probes, which can reduce the total time of probing. "
#~ "This mode is enabled by configuring `stow_on_each_sample` to False in the "
#~ "config file."
#~ msgstr ""

#~ msgid ""
#~ "Important! Setting `stow_on_each_sample` to False can lead to Klipper making"
#~ " horizontal toolhead movements while the probe is deployed. Be sure to "
#~ "verify all probing operations have sufficient Z clearance prior to setting "
#~ "this value to False. If there is insufficient clearance then a horizontal "
#~ "move may cause the pin to catch on an obstruction and result in damage to "
#~ "the printer."
#~ msgstr ""

#~ msgid ""
#~ "Important! It is recommended to use `probe_with_touch_mode` configured to "
#~ "True when using `stow_on_each_sample` configured to False. Some \"clone\" "
#~ "devices may not detect a subsequent bed contact if `probe_with_touch_mode` "
#~ "is not set. On all devices, using the combination of these two settings "
#~ "simplifies the device signaling, which can improve overall stability."
#~ msgstr ""

#~ msgid ""
#~ "Note, however, that some \"clone\" devices and the BL-Touch v2.0 (and "
#~ "earlier) may have reduced accuracy when `probe_with_touch_mode` is set to "
#~ "True. On these devices it is a good idea to test the probe accuracy before "
#~ "and after setting `probe_with_touch_mode` (use the `PROBE_ACCURACY` command "
#~ "to test)."
#~ msgstr ""

#~ msgid "Calibrating the BL-Touch offsets"
#~ msgstr ""

#~ msgid ""
#~ "Follow the directions in the [Probe Calibrate](Probe_Calibrate.md) guide to "
#~ "set the x_offset, y_offset, and z_offset config parameters."
#~ msgstr ""

#~ msgid ""
#~ "It's a good idea to verify that the Z offset is close to 1mm. If not, then "
#~ "you probably want to move the probe up or down to fix this. You want it to "
#~ "trigger well before the nozzle hits the bed, so that possible stuck filament"
#~ " or a warped bed doesn't affect any probing action. But at the same time, "
#~ "you want the retracted position to be as far above the nozzle as possible to"
#~ " avoid it touching printed parts. If an adjustment is made to the probe "
#~ "position, then rerun the probe calibration steps."
#~ msgstr ""

#~ msgid "BL-Touch output mode"
#~ msgstr ""

#~ msgid ""
#~ "A BL-Touch V3.0 supports setting a 5V or OPEN-DRAIN output mode, a BL-Touch "
#~ "V3.1 supports this too, but can also store this in its internal EEPROM. If "
#~ "your controller board needs the fixed 5V high logic level of the 5V mode you"
#~ " may set the 'set_output_mode' parameter in the [bltouch] section of the "
#~ "printer config file to \"5V\"."
#~ msgstr ""

#~ msgid ""
#~ "*** Only use the 5V mode if your controller boards input line is 5V "
#~ "tolerant. This is why the default configuration of these BL-Touch versions "
#~ "is OPEN-DRAIN mode. You could potentially damage your controller boards CPU "
#~ "***"
#~ msgstr ""

#~ msgid ""
#~ "So therefore: If a controller board NEEDs 5V mode AND it is 5V tolerant on "
#~ "its input signal line AND if"
#~ msgstr ""

#~ msgid ""
#~ "you have a BL-Touch Smart V3.0, you need the use 'set_output_mode: 5V' "
#~ "parameter to ensure this setting at each startup, since the probe cannot "
#~ "remember the needed setting."
#~ msgstr ""

#~ msgid ""
#~ "you have a BL-Touch Smart V3.1, you have the choice of using "
#~ "'set_output_mode: 5V' or storing the mode once by use of a 'BLTOUCH_STORE "
#~ "MODE=5V' command manually and NOT using the parameter 'set_output_mode:'."
#~ msgstr ""

#~ msgid ""
#~ "you have some other probe: Some probes have a trace on the circuit board to "
#~ "cut or a jumper to set in order to (permanently) set the output mode. In "
#~ "that case, omit the 'set_output_mode' parameter completely."
#~ msgstr ""

#~ msgid ""
#~ "If you have a V3.1, do not automate or repeat storing the output mode to "
#~ "avoid wearing out the EEPROM of the probe.The BLTouch EEPROM is good for "
#~ "about 100.000 updates. 100 stores per day would add up to about 3 years of "
#~ "operation prior to wearing it out. Thus, storing the output mode in a V3.1 "
#~ "is designed by the vendor to be a complicated operation (the factory default"
#~ " being a safe OPEN DRAIN mode) and is not suited to be repeatedly issued by "
#~ "any slicer, macro or anything else, it is preferably only to be used when "
#~ "first integrating the probe into a printers electronics."
#~ msgstr ""

#~ msgid "API server"
#~ msgstr ""

#~ msgid ""
#~ "This document describes Klipper's Application Programmer Interface (API). "
#~ "This interface enables external applications to query and control the "
#~ "Klipper host software."
#~ msgstr ""

#~ msgid "Enabling the API socket"
#~ msgstr ""

#~ msgid ""
#~ "In order to use the API server, the klippy.py host software must be started "
#~ "with the `-a` parameter. For example:"
#~ msgstr ""

#~ msgid ""
#~ "~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer.cfg -a "
#~ "/tmp/klippy_uds -l /tmp/klippy.log\n"
#~ msgstr ""

#~ msgid ""
#~ "This causes the host software to create a Unix Domain Socket. A client can "
#~ "then open a connection on that socket and send commands to Klipper."
#~ msgstr ""

#~ msgid ""
#~ "See the [Moonraker](https://github.com/Arksine/moonraker) project for a "
#~ "popular tool that can forward HTTP requests to Klipper's API Server Unix "
#~ "Domain Socket."
#~ msgstr ""

#~ msgid "Request format"
#~ msgstr ""

#~ msgid ""
#~ "Messages sent and received on the socket are JSON encoded strings terminated"
#~ " by an ASCII 0x03 character:"
#~ msgstr ""

#~ msgid "<json_object_1><0x03><json_object_2><0x03>...\n"
#~ msgstr ""

#~ msgid ""
#~ "Klipper contains a `scripts/whconsole.py` tool that can perform the above "
#~ "message framing. For example:"
#~ msgstr ""

#~ msgid "~/klipper/scripts/whconsole.py /tmp/klippy_uds\n"
#~ msgstr ""

#~ msgid ""
#~ "This tool can read a series of JSON commands from stdin, send them to "
#~ "Klipper, and report the results. The tool expects each JSON command to be on"
#~ " a single line, and it will automatically append the 0x03 terminator when "
#~ "transmitting a request. (The Klipper API server does not have a newline "
#~ "requirement.)"
#~ msgstr ""

#~ msgid "API Protocol"
#~ msgstr ""

#~ msgid ""
#~ "The command protocol used on the communication socket is inspired by [json-"
#~ "rpc](https://www.jsonrpc.org/)."
#~ msgstr ""

#~ msgid "A request might look like:"
#~ msgstr ""

#~ msgid "`{\"id\": 123, \"method\": \"info\", \"params\": {}}`"
#~ msgstr ""

#~ msgid "and a response might look like:"
#~ msgstr ""

#~ msgid ""
#~ "`{\"id\": 123, \"result\": {\"state_message\": \"Printer is ready\", "
#~ "\"klipper_path\": \"/home/pi/klipper\", \"config_file\": "
#~ "\"/home/pi/printer.cfg\", \"software_version\": \"v0.8.0-823-g883b1cb6\", "
#~ "\"hostname\": \"octopi\", \"cpu_info\": \"4 core ARMv7 Processor rev 4 "
#~ "(v7l)\", \"state\": \"ready\", \"python_path\": \"/home/pi/klippy-"
#~ "env/bin/python\", \"log_file\": \"/tmp/klippy.log\"}}`"
#~ msgstr ""

#~ msgid ""
#~ "Each request must be a JSON dictionary. (This document uses the Python term "
#~ "\"dictionary\" to describe a \"JSON object\" - a mapping of key/value pairs "
#~ "contained within `{}`.)"
#~ msgstr ""

#~ msgid ""
#~ "The request dictionary must contain a \"method\" parameter that is the "
#~ "string name of an available Klipper \"endpoint\"."
#~ msgstr ""

#~ msgid ""
#~ "The request dictionary may contain a \"params\" parameter which must be of a"
#~ " dictionary type. The \"params\" provide additional parameter information to"
#~ " the Klipper \"endpoint\" handling the request. Its content is specific to "
#~ "the \"endpoint\"."
#~ msgstr ""

#~ msgid ""
#~ "The request dictionary may contain an \"id\" parameter which may be of any "
#~ "JSON type. If \"id\" is present then Klipper will respond to the request "
#~ "with a response message containing that \"id\". If \"id\" is omitted (or set"
#~ " to a JSON \"null\" value) then Klipper will not provide any response to the"
#~ " request. A response message is a JSON dictionary containing \"id\" and "
#~ "\"result\". The \"result\" is always a dictionary - its contents are "
#~ "specific to the \"endpoint\" handling the request."
#~ msgstr ""

#~ msgid ""
#~ "If the processing of a request results in an error, then the response "
#~ "message will contain an \"error\" field instead of a \"result\" field. For "
#~ "example, the request: `{\"id\": 123, \"method\": \"gcode/script\", "
#~ "\"params\": {\"script\": \"G1 X200\"}}` might result in an error response "
#~ "such as: `{\"id\": 123, \"error\": {\"message\": \"Must home axis first: "
#~ "200.000 0.000 0.000 [0.000]\", \"error\": \"WebRequestError\"}}`"
#~ msgstr ""

#~ msgid ""
#~ "Klipper will always start processing requests in the order that they are "
#~ "received. However, some request may not complete immediately, which could "
#~ "cause the associated response to be sent out of order with respect to "
#~ "responses from other requests. A JSON request will never pause the "
#~ "processing of future JSON requests."
#~ msgstr ""

#~ msgid "Subscriptions"
#~ msgstr ""

#~ msgid ""
#~ "Some Klipper \"endpoint\" requests allow one to \"subscribe\" to future "
#~ "asynchronous update messages."
#~ msgstr ""

#~ msgid "For example:"
#~ msgstr ""

#~ msgid ""
#~ "`{\"id\": 123, \"method\": \"gcode/subscribe_output\", \"params\": "
#~ "{\"response_template\":{\"key\": 345}}}`"
#~ msgstr ""

#~ msgid "may initially respond with:"
#~ msgstr ""

#~ msgid "`{\"id\": 123, \"result\": {}}`"
#~ msgstr ""

#~ msgid "and cause Klipper to send future messages similar to:"
#~ msgstr ""

#~ msgid "`{\"params\": {\"response\": \"ok B:22.8 /0.0 T0:22.4 /0.0\"}, \"key\": 345}`"
#~ msgstr ""

#~ msgid ""
#~ "A subscription request accepts a \"response_template\" dictionary in the "
#~ "\"params\" field of the request. That \"response_template\" dictionary is "
#~ "used as a template for future asynchronous messages - it may contain "
#~ "arbitrary key/value pairs. When sending these future asynchronous messages, "
#~ "Klipper will add a \"params\" field containing a dictionary with "
#~ "\"endpoint\" specific contents to the response template and then send that "
#~ "template. If a \"response_template\" field is not provided then it defaults "
#~ "to an empty dictionary (`{}`)."
#~ msgstr ""

#~ msgid "Available \"endpoints\""
#~ msgstr ""

#~ msgid ""
#~ "By convention, Klipper \"endpoints\" are of the form "
#~ "`<module_name>/<some_name>`. When making a request to an \"endpoint\", the "
#~ "full name must be set in the \"method\" parameter of the request dictionary "
#~ "(eg, `{\"method\"=\"gcode/restart\"}`)."
#~ msgstr ""

#~ msgid "info"
#~ msgstr ""

#~ msgid ""
#~ "The \"info\" endpoint is used to obtain system and version information from "
#~ "Klipper. It is also used to provide the client's version information to "
#~ "Klipper. For example: `{\"id\": 123, \"method\": \"info\", \"params\": { "
#~ "\"client_info\": { \"version\": \"v1\"}}}`"
#~ msgstr ""

#~ msgid ""
#~ "If present, the \"client_info\" parameter must be a dictionary, but that "
#~ "dictionary may have arbitrary contents. Clients are encouraged to provide "
#~ "the name of the client and its software version when first connecting to the"
#~ " Klipper API server."
#~ msgstr ""

#~ msgid "emergency_stop"
#~ msgstr ""

#~ msgid ""
#~ "The \"emergency_stop\" endpoint is used to instruct Klipper to transition to"
#~ " a \"shutdown\" state. It behaves similarly to the G-Code `M112` command. "
#~ "For example: `{\"id\": 123, \"method\": \"emergency_stop\"}`"
#~ msgstr ""

#~ msgid "register_remote_method"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows clients to register methods that can be called from "
#~ "klipper. It will return an empty object upon success."
#~ msgstr ""

#~ msgid ""
#~ "For example: `{\"id\": 123, \"method\": \"register_remote_method\", "
#~ "\"params\": {\"response_template\": {\"action\": \"run_paneldue_beep\"}, "
#~ "\"remote_method\": \"paneldue_beep\"}}` will return: `{\"id\": 123, "
#~ "\"result\": {}}`"
#~ msgstr ""

#~ msgid ""
#~ "The remote method `paneldue_beep` may now be called from Klipper. Note that "
#~ "if the method takes parameters they should be provided as keyword arguments."
#~ " Below is an example of how it may called from a gcode_macro:"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro PANELDUE_BEEP]\n"
#~ "gcode:\n"
#~ "  {action_call_remote_method(\"paneldue_beep\", frequency=300, duration=1.0)}\n"
#~ msgstr ""

#~ msgid ""
#~ "When the PANELDUE_BEEP gcode macro is executed, Klipper would send something"
#~ " like the following over the socket: `{\"action\": \"run_paneldue_beep\", "
#~ "\"params\": {\"frequency\": 300, \"duration\": 1.0}}`"
#~ msgstr ""

#~ msgid "objects/list"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint queries the list of available printer \"objects\" that one may"
#~ " query (via the \"objects/query\" endpoint). For example: `{\"id\": 123, "
#~ "\"method\": \"objects/list\"}` might return: `{\"id\": 123, \"result\": "
#~ "{\"objects\": [\"webhooks\", \"configfile\", \"heaters\", \"gcode_move\", "
#~ "\"query_endstops\", \"idle_timeout\", \"toolhead\", \"extruder\"]}}`"
#~ msgstr ""

#~ msgid "objects/query"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows one to query information from printer objects. For "
#~ "example: `{\"id\": 123, \"method\": \"objects/query\", \"params\": "
#~ "{\"objects\": {\"toolhead\": [\"position\"], \"webhooks\": null}}}` might "
#~ "return: `{\"id\": 123, \"result\": {\"status\": {\"webhooks\": {\"state\": "
#~ "\"ready\", \"state_message\": \"Printer is ready\"}, \"toolhead\": "
#~ "{\"position\": [0.0, 0.0, 0.0, 0.0]}}, \"eventtime\": 3051555.377933684}}`"
#~ msgstr ""

#~ msgid ""
#~ "The \"objects\" parameter in the request must be a dictionary containing the"
#~ " printer objects that are to be queried - the key contains the printer "
#~ "object name and the value is either \"null\" (to query all fields) or a list"
#~ " of field names."
#~ msgstr ""

#~ msgid ""
#~ "The response message will contain a \"status\" field containing a dictionary"
#~ " with the queried information - the key contains the printer object name and"
#~ " the value is a dictionary containing its fields. The response message will "
#~ "also contain an \"eventtime\" field containing the timestamp from when the "
#~ "query was taken."
#~ msgstr ""

#~ msgid ""
#~ "Available fields are documented in the [Status "
#~ "Reference](Status_Reference.md) document."
#~ msgstr ""

#~ msgid "objects/subscribe"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows one to query and then subscribe to information from "
#~ "printer objects. The endpoint request and response is identical to the "
#~ "\"objects/query\" endpoint. For example: `{\"id\": 123, \"method\": "
#~ "\"objects/subscribe\", \"params\": {\"objects\":{\"toolhead\": "
#~ "[\"position\"], \"webhooks\": [\"state\"]}, \"response_template\":{}}}` "
#~ "might return: `{\"id\": 123, \"result\": {\"status\": {\"webhooks\": "
#~ "{\"state\": \"ready\"}, \"toolhead\": {\"position\": [0.0, 0.0, 0.0, 0.0]}},"
#~ " \"eventtime\": 3052153.382083195}}` and result in subsequent asynchronous "
#~ "messages such as: `{\"params\": {\"status\": {\"webhooks\": {\"state\": "
#~ "\"shutdown\"}}, \"eventtime\": 3052165.418815847}}`"
#~ msgstr ""

#~ msgid "gcode/help"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows one to query available G-Code commands that have a help"
#~ " string defined. For example: `{\"id\": 123, \"method\": \"gcode/help\"}` "
#~ "might return: `{\"id\": 123, \"result\": {\"RESTORE_GCODE_STATE\": \"Restore"
#~ " a previously saved G-Code state\", \"PID_CALIBRATE\": \"Run PID calibration"
#~ " test\", \"QUERY_ADC\": \"Report the last value of an analog pin\", ...}}`"
#~ msgstr ""

#~ msgid "gcode/script"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows one to run a series of G-Code commands. For example: "
#~ "`{\"id\": 123, \"method\": \"gcode/script\", \"params\": {\"script\": "
#~ "\"G90\"}}`"
#~ msgstr ""

#~ msgid ""
#~ "If the provided G-Code script raises an error, then an error response is "
#~ "generated. However, if the G-Code command produces terminal output, that "
#~ "terminal output is not provided in the response. (Use the "
#~ "\"gcode/subscribe_output\" endpoint to obtain G-Code terminal output.)"
#~ msgstr ""

#~ msgid ""
#~ "If there is a G-Code command being processed when this request is received, "
#~ "then the provided script will be queued. This delay could be significant "
#~ "(eg, if a G-Code wait for temperature command is running). The JSON response"
#~ " message is sent when the processing of the script fully completes."
#~ msgstr ""

#~ msgid "gcode/restart"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows one to request a restart - it is similar to running the"
#~ " G-Code \"RESTART\" command. For example: `{\"id\": 123, \"method\": "
#~ "\"gcode/restart\"}`"
#~ msgstr ""

#~ msgid ""
#~ "As with the \"gcode/script\" endpoint, this endpoint only completes after "
#~ "any pending G-Code commands complete."
#~ msgstr ""

#~ msgid "gcode/firmware_restart"
#~ msgstr ""

#~ msgid ""
#~ "This is similar to the \"gcode/restart\" endpoint - it implements the G-Code"
#~ " \"FIRMWARE_RESTART\" command. For example: `{\"id\": 123, \"method\": "
#~ "\"gcode/firmware_restart\"}`"
#~ msgstr ""

#~ msgid "gcode/subscribe_output"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint is used to subscribe to G-Code terminal messages that are "
#~ "generated by Klipper. For example: `{\"id\": 123, \"method\": "
#~ "\"gcode/subscribe_output\", \"params\": {\"response_template\":{}}}` might "
#~ "later produce asynchronous messages such as: `{\"params\": {\"response\": "
#~ "\"// Klipper state: Shutdown\"}}`"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint is intended to support human interaction via a \"terminal "
#~ "window\" interface. Parsing content from the G-Code terminal output is "
#~ "discouraged. Use the \"objects/subscribe\" endpoint to obtain updates on "
#~ "Klipper's state."
#~ msgstr ""

#~ msgid "motion_report/dump_stepper"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint is used to subscribe to Klipper's internal stepper queue_step "
#~ "command stream for a stepper. Obtaining these low-level motion updates may "
#~ "be useful for diagnostic and debugging purposes. Using this endpoint may "
#~ "increase Klipper's system load."
#~ msgstr ""

#~ msgid ""
#~ "A request may look like: `{\"id\": 123, "
#~ "\"method\":\"motion_report/dump_stepper\", \"params\": {\"name\": "
#~ "\"stepper_x\", \"response_template\": {}}}` and might return: `{\"id\": 123,"
#~ " \"result\": {\"header\": [\"interval\", \"count\", \"add\"]}}` and might "
#~ "later produce asynchronous messages such as: `{\"params\": {\"first_clock\":"
#~ " 179601081, \"first_time\": 8.98, \"first_position\": 0, \"last_clock\": "
#~ "219686097, \"last_time\": 10.984, \"data\": [[179601081, 1, 0], [29573, 2, "
#~ "-8685], [16230, 4, -1525], [10559, 6, -160], [10000, 976, 0], [10000, 1000, "
#~ "0], [10000, 1000, 0], [10000, 1000, 0], [9855, 5, 187], [11632, 4, 1534], "
#~ "[20756, 2, 9442]]}}`"
#~ msgstr ""

#~ msgid ""
#~ "The \"header\" field in the initial query response is used to describe the "
#~ "fields found in later \"data\" responses."
#~ msgstr ""

#~ msgid "motion_report/dump_trapq"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint is used to subscribe to Klipper's internal \"trapezoid motion "
#~ "queue\". Obtaining these low-level motion updates may be useful for "
#~ "diagnostic and debugging purposes. Using this endpoint may increase "
#~ "Klipper's system load."
#~ msgstr ""

#~ msgid ""
#~ "A request may look like: `{\"id\": 123, \"method\": "
#~ "\"motion_report/dump_trapq\", \"params\": {\"name\": \"toolhead\", "
#~ "\"response_template\":{}}}` and might return: `{\"id\": 1, \"result\": "
#~ "{\"header\": [\"time\", \"duration\", \"start_velocity\", \"acceleration\", "
#~ "\"start_position\", \"direction\"]}}` and might later produce asynchronous "
#~ "messages such as: `{\"params\": {\"data\": [[4.05, 1.0, 0.0, 0.0, [300.0, "
#~ "0.0, 0.0], [0.0, 0.0, 0.0]], [5.054, 0.001, 0.0, 3000.0, [300.0, 0.0, 0.0], "
#~ "[-1.0, 0.0, 0.0]]]}}`"
#~ msgstr ""

#~ msgid "adxl345/dump_adxl345"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint is used to subscribe to ADXL345 accelerometer data. Obtaining "
#~ "these low-level motion updates may be useful for diagnostic and debugging "
#~ "purposes. Using this endpoint may increase Klipper's system load."
#~ msgstr ""

#~ msgid ""
#~ "A request may look like: `{\"id\": 123, \"method\":\"adxl345/dump_adxl345\","
#~ " \"params\": {\"sensor\": \"adxl345\", \"response_template\": {}}}` and "
#~ "might return: `{\"id\": "
#~ "123,\"result\":{\"header\":[\"time\",\"x_acceleration\",\"y_acceleration\", "
#~ "\"z_acceleration\"]}}` and might later produce asynchronous messages such "
#~ "as: "
#~ "`{\"params\":{\"overflows\":0,\"data\":[[3292.432935,-535.44309,-1529.8374,9561.4],"
#~ " [3292.433256,-382.45935,-1606.32927,9561.48375]]}}`"
#~ msgstr ""

#~ msgid "angle/dump_angle"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint is used to subscribe to [angle sensor "
#~ "data](Config_Reference.md#angle). Obtaining these low-level motion updates "
#~ "may be useful for diagnostic and debugging purposes. Using this endpoint may"
#~ " increase Klipper's system load."
#~ msgstr ""

#~ msgid ""
#~ "A request may look like: `{\"id\": 123, \"method\":\"angle/dump_angle\", "
#~ "\"params\": {\"sensor\": \"my_angle_sensor\", \"response_template\": {}}}` "
#~ "and might return: `{\"id\": "
#~ "123,\"result\":{\"header\":[\"time\",\"angle\"]}}` and might later produce "
#~ "asynchronous messages such as: "
#~ "`{\"params\":{\"position_offset\":3.151562,\"errors\":0, "
#~ "\"data\":[[1290.951905,-5063],[1290.952321,-5065]]}}`"
#~ msgstr ""

#~ msgid "pause_resume/cancel"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint is similar to running the \"PRINT_CANCEL\" G-Code command. For"
#~ " example: `{\"id\": 123, \"method\": \"pause_resume/cancel\"}`"
#~ msgstr ""

#~ msgid "pause_resume/pause"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint is similar to running the \"PAUSE\" G-Code command. For "
#~ "example: `{\"id\": 123, \"method\": \"pause_resume/pause\"}`"
#~ msgstr ""

#~ msgid "pause_resume/resume"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint is similar to running the \"RESUME\" G-Code command. For "
#~ "example: `{\"id\": 123, \"method\": \"pause_resume/resume\"}`"
#~ msgstr ""

#~ msgid "query_endstops/status"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint will query the active endpoints and return their status. For "
#~ "example: `{\"id\": 123, \"method\": \"query_endstops/status\"}` might "
#~ "return: `{\"id\": 123, \"result\": {\"y\": \"open\", \"x\": \"open\", \"z\":"
#~ " \"TRIGGERED\"}}`"
#~ msgstr ""

#~ msgid "RESUME"
#~ msgstr ""

#~ msgid ""
#~ "Note that the [linux mcu](RPi_microcontroller.md) implementation does not "
#~ "currently support directly connected neopixels. The current design using the"
#~ " Linux kernel interface does not allow this scenario because the kernel GPIO"
#~ " interface is not fast enough to provide the required pulse rates."
#~ msgstr ""

#~ msgid ""
#~ "`last_query`: Returns True if the probe was reported as \"triggered\" during"
#~ " the last QUERY_PROBE command. Note, if this is used in a macro, due to the "
#~ "order of template expansion, the QUERY_PROBE command must be run prior to "
#~ "the macro containing this reference."
#~ msgstr ""

#~ msgid "Input <br> shaper"
#~ msgstr ""

#~ msgid "Support for AD595 sensors"
#~ msgstr ""

#~ msgid ""
#~ "Alternatively, follow [this](Resonance_Compensation.md#selecting-max_accel) "
#~ "part of the input shaper tuning guide and print the test model to choose "
#~ "`max_accel` parameter experimentally."
#~ msgstr ""

#~ msgid "SYNC_EXTRUDER_MOTION"
#~ msgstr ""

#~ msgid "RESUME"
#~ msgstr ""

#~ msgid ""
#~ "Support manually moving stepper motors for diagnostic purposes. Note, using "
#~ "this feature may place the printer in an invalid state - see the [command "
#~ "reference](G-Codes.md#force_move) for important details."
#~ msgstr ""

#~ msgid ""
#~ "Note that the [linux mcu](RPi_microcontroller.md) implementation does not "
#~ "currently support directly connected neopixels. The current design using the"
#~ " Linux kernel interface does not allow this scenario because the kernel GPIO"
#~ " interface is not fast enough to provide the required pulse rates."
#~ msgstr ""

#~ msgid ""
#~ "[palette2]\n"
#~ "serial:\n"
#~ "#   The serial port to connect to the Palette 2.\n"
#~ "#baud: 115200\n"
#~ "#   The baud rate to use. The default is 115200.\n"
#~ "#feedrate_splice: 0.8\n"
#~ "#   The feedrate to use when splicing, default is 0.8\n"
#~ "#feedrate_normal: 1.0\n"
#~ "#   The feedrate to use after splicing, default is 1.0\n"
#~ "#auto_load_speed: 2\n"
#~ "#   Extrude feedrate when autoloading, default is 2 (mm/s)\n"
#~ "#auto_cancel_variation: 0.1\n"
#~ "#   Auto cancel print when ping varation is above this threshold\n"
#~ msgstr ""

#~ msgid ""
#~ "It is common for Smoothieboards to come with a bootloader from: "
#~ "<https://github.com/triffid/LPC17xx-DFU-Bootloader>. When using this "
#~ "bootloader the application must be compiled with a start address of 16KiB. "
#~ "The easiest way to flash an application with this bootloader is to copy the "
#~ "application file (eg, `out/klipper.bin`) to a file named `firmware.bin` on "
#~ "an SD card, and then to reboot the micro-controller with that SD card."
#~ msgstr ""

#~ msgid ""
#~ "The command dispatch benchmark tests how many \"dummy\" commands the micro-"
#~ "controller can process. It is primarily a test of the hardware communication"
#~ " mechanism. The test is run using the console.py tool (described in "
#~ "<Debugging.md>). The following is cut-and-paste into the console.py terminal"
#~ " window:"
#~ msgstr ""

#~ msgid ""
#~ "When searching for maximum_sensitivity, it may be convenient to jump to "
#~ "different VALUE settings (so as to bisect the VALUE parameter). If doing "
#~ "this then be prepared to issue an `M112` command to halt the printer, as a "
#~ "setting with a very low sensitivity may cause the axis to repeatedly "
#~ "\"bang\" into the end of the rail."
#~ msgstr ""

#~ msgid ""
#~ "`position`: The last commanded position of the toolhead using the coordinate"
#~ " system specified in the config file. It is possible to access the x, y, z, "
#~ "and e components of this position (eg, `position.x`)."
#~ msgstr ""

#~ msgid ""
#~ "`last_query`: Returns True if the probe was reported as \"triggered\" during"
#~ " the last QUERY_PROBE command. Note, if this is used in a macro, due to the "
#~ "order of template expansion, the QUERY_PROBE command must be run prior to "
#~ "the macro containing this reference."
#~ msgstr ""

#~ msgid ""
#~ "`state`: Returns a string indicating the current Klipper state. Possible "
#~ "values are: \"ready\", \"startup\", \"shutdown\", \"error\"."
#~ msgstr ""

#~ msgid "GND (VSS)"
#~ msgstr ""

#~ msgid ""
#~ "In this picture, the acceleration increases left to right, and the gap "
#~ "starts to grow starting from 3500 mm/sec^2 (5-th band from the left). So the"
#~ " good value for max_accel = 3000 (mm/sec^2) in this case to avoid the "
#~ "excessive smoothing."
#~ msgstr ""

#~ msgid "Input <br> shaper"
#~ msgstr ""

#~ msgid "Klipper now has a logo."
#~ msgstr ""

#~ msgid "Support for AD595 sensors"
#~ msgstr ""

#~ msgid ""
#~ "[output_pin caselight]\n"
#~ "pin: host:pwmchip0/pwm0\n"
#~ "pwm: True\n"
#~ "hardware_pwm: True\n"
#~ "cycle_time: 0.000001\n"
#~ msgstr ""

#~ msgid ""
#~ "In order for meaningful communications to be established between micro-"
#~ "controller and host, both sides must agree on a \"data dictionary\". This "
#~ "data dictionary contains the integer identifiers for commands and responses "
#~ "along with their descriptions."
#~ msgstr ""

#~ msgid ""
#~ "sudo apt update\n"
#~ "sudo apt install python3-numpy python3-matplotlib libatlas-base-dev\n"
#~ msgstr ""

#~ msgid ""
#~ "Alternatively, follow [this](Resonance_Compensation.md#selecting-max_accel) "
#~ "part of the input shaper tuning guide and print the test model to choose "
#~ "`max_accel` parameter experimentally."
#~ msgstr ""

#~ msgid "![pressure-advance](img/pressure-velocity.png)"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [bed_screws config "
#~ "section](Config_Reference.md#bed_screws) is enabled (also see the [manual "
#~ "level guide](Manual_Level.md#adjusting-bed-leveling-screws))."
#~ msgstr ""

#~ msgid "SYNC_EXTRUDER_MOTION"
#~ msgstr ""

#~ msgid ""
#~ "`QUERY_RAW_FILAMENT_WIDTH`: Return the current ADC channel readings and RAW "
#~ "sensor value for calibration points."
#~ msgstr ""

#~ msgid "RESUME"
#~ msgstr ""

#~ msgid ""
#~ "`SET_SKEW [XY=<ac_length,bd_length,ad_length>] [XZ=<ac,bd,ad>] "
#~ "[YZ=<ac,bd,ad>] [CLEAR=<0|1>]`: Configures the [skew_correction] module with"
#~ " measurements (in mm) taken from a calibration print. One may enter "
#~ "measurements for any combination of planes, planes not entered will retain "
#~ "their current value. If `CLEAR=1` is entered then all skew correction will "
#~ "be disabled."
#~ msgstr ""

#~ msgid "981K"
#~ msgstr ""

#~ msgid ""
#~ "The workaround is to use a restart_method other than \"command\" or to flash"
#~ " an updated bootloader to the AVR device. Flashing a new bootloader is a one"
#~ " time step that typically requires an external programmer - see "
#~ "[Bootloaders](Bootloaders.md) for further details."
#~ msgstr ""

#~ msgid ""
#~ "cd /path/to/klipper\n"
#~ "make menuconfig\n"
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to cable winch printers are described here - see "
#~ "[common kinematic settings](#common-kinematic-settings) for available "
#~ "parameters."
#~ msgstr ""

#~ msgid ""
#~ "Support manually moving stepper motors for diagnostic purposes. Note, using "
#~ "this feature may place the printer in an invalid state - see the [command "
#~ "reference](G-Codes.md#force_move) for important details."
#~ msgstr ""

#~ msgid "[thermistor]"
#~ msgstr ""

#~ msgid ""
#~ "Note that the [linux mcu](RPi_microcontroller.md) implementation does not "
#~ "currently support directly connected neopixels. The current design using the"
#~ " Linux kernel interface does not allow this scenario because the kernel GPIO"
#~ " interface is not fast enough to provide the required pulse rates."
#~ msgstr ""

#~ msgid ""
#~ "Information on configuring st7920 displays (which is used in "
#~ "\"RepRapDiscount 12864 Full Graphic Smart Controller\" type displays)."
#~ msgstr ""

#~ msgid ""
#~ "[palette2]\n"
#~ "serial:\n"
#~ "#   The serial port to connect to the Palette 2.\n"
#~ "#baud: 115200\n"
#~ "#   The baud rate to use. The default is 115200.\n"
#~ "#feedrate_splice: 0.8\n"
#~ "#   The feedrate to use when splicing, default is 0.8\n"
#~ "#feedrate_normal: 1.0\n"
#~ "#   The feedrate to use after splicing, default is 1.0\n"
#~ "#auto_load_speed: 2\n"
#~ "#   Extrude feedrate when autoloading, default is 2 (mm/s)\n"
#~ "#auto_cancel_variation: 0.1\n"
#~ "#   Auto cancel print when ping varation is above this threshold\n"
#~ msgstr ""

#~ msgid ""
#~ "20191210: The builtin T0, T1, T2, ... commands have been removed. The "
#~ "extruder activate_gcode and deactivate_gcode config options have been "
#~ "removed. If these commands (and scripts) are needed then define individual "
#~ "[gcode_macro T0] style macros that call the ACTIVATE_EXTRUDER command. See "
#~ "the config/sample-idex.cfg and sample-multi-extruder.cfg files for examples."
#~ msgstr ""

#~ msgid "`menu.width` - element width (number of display columns)"
#~ msgstr ""

#~ msgid ""
#~ "Other methods. Implement the `check_move()`, `get_status()`, "
#~ "`get_steppers()`, `home()`, and `set_position()` methods. These functions "
#~ "are typically used to provide kinematic specific checks. However, at the "
#~ "start of development one can use boiler-plate code here."
#~ msgstr ""

#~ msgid "@dmbutyugin"
#~ msgstr ""

#~ msgid "bossac -U -p /dev/ttyACM0 --offset=0x4000 -w out/klipper.bin -v -b -R\n"
#~ msgstr ""

#~ msgid ""
#~ "It is common for Smoothieboards to come with a bootloader from: "
#~ "<https://github.com/triffid/LPC17xx-DFU-Bootloader>. When using this "
#~ "bootloader the application must be compiled with a start address of 16KiB. "
#~ "The easiest way to flash an application with this bootloader is to copy the "
#~ "application file (eg, `out/klipper.bin`) to a file named `firmware.bin` on "
#~ "an SD card, and then to reboot the micro-controller with that SD card."
#~ msgstr ""

#~ msgid "stm32f103"
#~ msgstr ""

#~ msgid ""
#~ "The command dispatch benchmark tests how many \"dummy\" commands the micro-"
#~ "controller can process. It is primarily a test of the hardware communication"
#~ " mechanism. The test is run using the console.py tool (described in "
#~ "<Debugging.md>). The following is cut-and-paste into the console.py terminal"
#~ " window:"
#~ msgstr ""

#~ msgid "`MESH_MIN`"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows one to request a restart - it is similar to running the"
#~ " G-Code \"RESTART\" command. For example: `{\"id\": 123, \"method\": "
#~ "\"gcode/restart\"}`"
#~ msgstr ""

#~ msgid ""
#~ "A stallGuard capable TMC stepper driver (tmc2130, tmc2209, tmc2660, or "
#~ "tmc5160)."
#~ msgstr ""

#~ msgid ""
#~ "When searching for maximum_sensitivity, it may be convenient to jump to "
#~ "different VALUE settings (so as to bisect the VALUE parameter). If doing "
#~ "this then be prepared to issue an `M112` command to halt the printer, as a "
#~ "setting with a very low sensitivity may cause the axis to repeatedly "
#~ "\"bang\" into the end of the rail."
#~ msgstr ""

#~ msgid ""
#~ "In addition, almost all fields can be modified at run-time using the "
#~ "[SET_TMC_FIELD command](G-Codes.md#set_tmc_field)."
#~ msgstr ""

#~ msgid ""
#~ "`last_home.<stepper name>.mcu_position`: The position (as tracked by the "
#~ "micro-controller) of the stepper motor at the end of the last home attempt. "
#~ "The position is the total number of steps taken in a forward direction minus"
#~ " the total number of steps taken in the reverse direction since the micro-"
#~ "controller was last restarted."
#~ msgstr ""

#~ msgid ""
#~ "`position`: The last commanded position of the toolhead using the coordinate"
#~ " system specified in the config file. It is possible to access the x, y, z, "
#~ "and e components of this position (eg, `position.x`)."
#~ msgstr ""

#~ msgid ""
#~ "`z_position`: The current height of the nozzle (as the printer currently "
#~ "understands it)."
#~ msgstr ""

#~ msgid ""
#~ "`last_query`: Returns True if the probe was reported as \"triggered\" during"
#~ " the last QUERY_PROBE command. Note, if this is used in a macro, due to the "
#~ "order of template expansion, the QUERY_PROBE command must be run prior to "
#~ "the macro containing this reference."
#~ msgstr ""

#~ msgid "temperature_sensor"
#~ msgstr ""

#~ msgid ""
#~ "`state`: Returns a string indicating the current Klipper state. Possible "
#~ "values are: \"ready\", \"startup\", \"shutdown\", \"error\"."
#~ msgstr ""

#~ msgid ""
#~ "If software SPI is required, the `spi_bus` field should be set to `swspi` "
#~ "and the following additional field should be specified:"
#~ msgstr ""

#~ msgid "GND (VSS)"
#~ msgstr ""

#~ msgid ""
#~ "For example, the common \"T8 leadscrew\" has a rotation distance of 8 (it "
#~ "has a pitch of 2mm and has 4 separate threads)."
#~ msgstr ""

#~ msgid ""
#~ "Note that the ringing frequencies can change if the changes are made to the "
#~ "printer that affect the moving mass or change the stiffness of the system, "
#~ "for example:"
#~ msgstr ""

#~ msgid ""
#~ "In this picture, the acceleration increases left to right, and the gap "
#~ "starts to grow starting from 3500 mm/sec^2 (5-th band from the left). So the"
#~ " good value for max_accel = 3000 (mm/sec^2) in this case to avoid the "
#~ "excessive smoothing."
#~ msgstr ""

#~ msgid ""
#~ "`SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=50 SHAPER_FREQ_Y=50`"
#~ msgstr ""

#~ msgid "Input <br> shaper"
#~ msgstr ""

#~ msgid ""
#~ "If one needs to reduce vibrations at several very different frequencies "
#~ "(say, 30 Hz and 100 Hz), they may see that the table above does not provide "
#~ "enough information. In this case one may have more luck with "
#~ "[scripts/graph_shaper.py](../scripts/graph_shaper.py) script, which is more "
#~ "flexible."
#~ msgstr ""

#~ msgid ""
#~ "New \"Smooth Pressure Advance\" system. This implements \"Pressure Advance\""
#~ " without introducing instantaneous velocity changes. It is also now possible"
#~ " to tune pressure advance using a \"Tuning Tower\" method."
#~ msgstr ""

#~ msgid "Klipper now has a logo."
#~ msgstr ""

#~ msgid "Initial support for \"safe homing\" and homing overrides"
#~ msgstr ""

#~ msgid "Support for AD595 sensors"
#~ msgstr ""

#~ msgid "To check available gpiochip run:"
#~ msgstr ""

#~ msgid ""
#~ "[output_pin caselight]\n"
#~ "pin: host:pwmchip0/pwm0\n"
#~ "pwm: True\n"
#~ "hardware_pwm: True\n"
#~ "cycle_time: 0.000001\n"
#~ msgstr ""

#~ msgid "DECL_CONSTANT(\"SERIAL_BAUD\", 250000);\n"
#~ msgstr ""

#~ msgid ""
#~ "In order for meaningful communications to be established between micro-"
#~ "controller and host, both sides must agree on a \"data dictionary\". This "
#~ "data dictionary contains the integer identifiers for commands and responses "
#~ "along with their descriptions."
#~ msgstr ""

#~ msgid ""
#~ "This is a common issue with probes on delta printers, however it can occur "
#~ "on all printers."
#~ msgstr ""

#~ msgid ""
#~ "[Exclude Object](Exclude_Object.md): The guide to the Exclude Objecs "
#~ "implementation."
#~ msgstr ""

#~ msgid "GPIO11 (SPI0_SCLK)"
#~ msgstr ""

#~ msgid ""
#~ "sudo apt update\n"
#~ "sudo apt install python3-numpy python3-matplotlib libatlas-base-dev\n"
#~ msgstr ""

#~ msgid "TEST_RESONANCES AXIS=Y\n"
#~ msgstr ""

#~ msgid ""
#~ "Alternatively, follow [this](Resonance_Compensation.md#selecting-max_accel) "
#~ "part of the input shaper tuning guide and print the test model to choose "
#~ "`max_accel` parameter experimentally."
#~ msgstr ""

#~ msgid ""
#~ "ignoring any errors for `SET_INPUT_SHAPER` command. For `TEST_RESONANCES` "
#~ "command, specify the desired test axis. The raw data will be written into "
#~ "`/tmp` directory on the RPi."
#~ msgstr ""

#~ msgid ""
#~ "[screws_tilt_adjust]\n"
#~ "screw1: -5, 30\n"
#~ "screw1_name: front left screw\n"
#~ "screw2: 155, 30\n"
#~ "screw2_name: front right screw\n"
#~ "screw3: 155, 190\n"
#~ "screw3_name: rear right screw\n"
#~ "screw4: -5, 190\n"
#~ "screw4_name: rear left screw\n"
#~ "horizontal_move_z: 10.\n"
#~ "speed: 50.\n"
#~ "screw_thread: CW-M3\n"
#~ msgstr ""

#~ msgid ""
#~ "`get_clock` : This command causes the micro-controller to generate a "
#~ "\"clock\" response message. The host sends this command once a second to "
#~ "obtain the value of the micro-controller clock and to estimate the drift "
#~ "between host and micro-controller clocks. It enables the host to accurately "
#~ "estimate the micro-controller clock."
#~ msgstr ""

#~ msgid "Generating steps"
#~ msgstr ""

#~ msgid "![pressure-advance](img/pressure-velocity.png)"
#~ msgstr ""

#~ msgid ""
#~ "The next step is to copy the [printer configuration file](#obtain-a-klipper-"
#~ "configuration-file) to the Raspberry Pi."
#~ msgstr ""

#~ msgid "Additional Commands"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [bed_screws config "
#~ "section](Config_Reference.md#bed_screws) is enabled (also see the [manual "
#~ "level guide](Manual_Level.md#adjusting-bed-leveling-screws))."
#~ msgstr ""

#~ msgid ""
#~ "`SET_DISPLAY_TEXT MSG=<message>`: Performs the equivalent of M117, setting "
#~ "the supplied `MSG` as the current display message. If `MSG` is omitted the "
#~ "display will be cleared."
#~ msgstr ""

#~ msgid "SYNC_EXTRUDER_MOTION"
#~ msgstr ""

#~ msgid "FIRMWARE_RESTART"
#~ msgstr ""

#~ msgid ""
#~ "`QUERY_RAW_FILAMENT_WIDTH`: Return the current ADC channel readings and RAW "
#~ "sensor value for calibration points."
#~ msgstr ""

#~ msgid ""
#~ "`MANUAL_STEPPER STEPPER=config_name [ENABLE=[0|1]] [SET_POSITION=<pos>] "
#~ "[SPEED=<speed>] [ACCEL=<accel>] [MOVE=<pos> [STOP_ON_ENDSTOP=[1|2|-1|-2]] "
#~ "[SYNC=0]]`: This command will alter the state of the stepper. Use the ENABLE"
#~ " parameter to enable/disable the stepper. Use the SET_POSITION parameter to "
#~ "force the stepper to think it is at the given position. Use the MOVE "
#~ "parameter to request a movement to the given position. If SPEED and/or ACCEL"
#~ " is specified then the given values will be used instead of the defaults "
#~ "specified in the config file. If an ACCEL of zero is specified then no "
#~ "acceleration will be performed. If STOP_ON_ENDSTOP=1 is specified then the "
#~ "move will end early should the endstop report as triggered (use "
#~ "STOP_ON_ENDSTOP=2 to complete the move without error even if the endstop "
#~ "does not trigger, use -1 or -2 to stop when the endstop reports not "
#~ "triggered). Normally future G-Code commands will be scheduled to run after "
#~ "the stepper move completes, however if a manual stepper move uses SYNC=0 "
#~ "then future G-Code movement commands may run in parallel with the stepper "
#~ "movement."
#~ msgstr ""

#~ msgid "RESUME"
#~ msgstr ""

#~ msgid ""
#~ "`MEASURE_AXES_NOISE`: Measures and outputs the noise for all axes of all "
#~ "enabled accelerometer chips."
#~ msgstr ""

#~ msgid ""
#~ "`SET_SKEW [XY=<ac_length,bd_length,ad_length>] [XZ=<ac,bd,ad>] "
#~ "[YZ=<ac,bd,ad>] [CLEAR=<0|1>]`: Configures the [skew_correction] module with"
#~ " measurements (in mm) taken from a calibration print. One may enter "
#~ "measurements for any combination of planes, planes not entered will retain "
#~ "their current value. If `CLEAR=1` is entered then all skew correction will "
#~ "be disabled."
#~ msgstr ""

#~ msgid ""
#~ "`SET_VELOCITY_LIMIT [VELOCITY=<value>] [ACCEL=<value>] "
#~ "[ACCEL_TO_DECEL=<value>] [SQUARE_CORNER_VELOCITY=<value>]`: Modify the "
#~ "printer's velocity limits."
#~ msgstr ""

#~ msgid ""
#~ "Support for measuring and recording acceleration using an adxl345, mpu9250, "
#~ "and mpu6050 accelerometers."
#~ msgstr ""

#~ msgid "981K"
#~ msgstr ""

#~ msgid "Can I run multiple instances of Klipper on the same host machine?"
#~ msgstr ""

#~ msgid ""
#~ "The workaround is to use a restart_method other than \"command\" or to flash"
#~ " an updated bootloader to the AVR device. Flashing a new bootloader is a one"
#~ " time step that typically requires an external programmer - see "
#~ "[Bootloaders](Bootloaders.md) for further details."
#~ msgstr ""

#~ msgid ""
#~ "cd ~/klipper\n"
#~ "git pull\n"
#~ "~/klipper/scripts/install-octopi.sh\n"
#~ msgstr ""

#~ msgid ""
#~ "Then measure the distance between the A pillar and the pillar across from "
#~ "the C label."
#~ msgstr ""

#~ msgid "Graphs can be generated with a command like the following:"
#~ msgstr ""

#~ msgid ""
#~ "cd /path/to/klipper\n"
#~ "make menuconfig\n"
#~ msgstr ""

#~ msgid ""
#~ "Problems should be reported in the [Klipper Community Forum](#community-"
#~ "forum)."
#~ msgstr ""

#~ msgid "Next steps"
#~ msgstr ""

#~ msgid "Deltesian Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to cable winch printers are described here - see "
#~ "[common kinematic settings](#common-kinematic-settings) for available "
#~ "parameters."
#~ msgstr ""

#~ msgid "Where x is the 0, 0 point on the bed"
#~ msgstr ""

#~ msgid ""
#~ "Support manually moving stepper motors for diagnostic purposes. Note, using "
#~ "this feature may place the printer in an invalid state - see the [command "
#~ "reference](G-Codes.md#force_move) for important details."
#~ msgstr ""

#~ msgid ""
#~ "[duplicate_pin_override]\n"
#~ "pins:\n"
#~ "#   A comma separated list of pins that may be used multiple times in\n"
#~ "#   a config file without normal error checks. This parameter must be\n"
#~ "#   provided.\n"
#~ msgstr ""

#~ msgid "[thermistor]"
#~ msgstr ""

#~ msgid "LM75 temperature sensor"
#~ msgstr ""

#~ msgid ""
#~ "Note that the [linux mcu](RPi_microcontroller.md) implementation does not "
#~ "currently support directly connected neopixels. The current design using the"
#~ " Linux kernel interface does not allow this scenario because the kernel GPIO"
#~ " interface is not fast enough to provide the required pulse rates."
#~ msgstr ""

#~ msgid ""
#~ "[tmc2208 stepper_x]\n"
#~ "uart_pin:\n"
#~ "#   The pin connected to the TMC2208 PDN_UART line. This parameter\n"
#~ "#   must be provided.\n"
#~ "#tx_pin:\n"
#~ "#   If using separate receive and transmit lines to communicate with\n"
#~ "#   the driver then set uart_pin to the receive pin and tx_pin to the\n"
#~ "#   transmit pin. The default is to use uart_pin for both reading and\n"
#~ "#   writing.\n"
#~ "#select_pins:\n"
#~ "#   A comma separated list of pins to set prior to accessing the\n"
#~ "#   tmc2208 UART. This may be useful for configuring an analog mux for\n"
#~ "#   UART communication. The default is to not configure any pins.\n"
#~ "#interpolate: True\n"
#~ "#   If true, enable step interpolation (the driver will internally\n"
#~ "#   step at a rate of 256 micro-steps). This interpolation does\n"
#~ "#   introduce a small systemic positional deviation - see\n"
#~ "#   TMC_Drivers.md for details. The default is True.\n"
#~ "run_current:\n"
#~ "#   The amount of current (in amps RMS) to configure the driver to use\n"
#~ "#   during stepper movement. This parameter must be provided.\n"
#~ "#hold_current:\n"
#~ "#   The amount of current (in amps RMS) to configure the driver to use\n"
#~ "#   when the stepper is not moving. Setting a hold_current is not\n"
#~ "#   recommended (see TMC_Drivers.md for details). The default is to\n"
#~ "#   not reduce the current.\n"
#~ "#sense_resistor: 0.110\n"
#~ "#   The resistance (in ohms) of the motor sense resistor. The default\n"
#~ "#   is 0.110 ohms.\n"
#~ "#stealthchop_threshold: 0\n"
#~ "#   The velocity (in mm/s) to set the \"stealthChop\" threshold to. When\n"
#~ "#   set, \"stealthChop\" mode will be enabled if the stepper motor\n"
#~ "#   velocity is below this value. The default is 0, which disables\n"
#~ "#   \"stealthChop\" mode.\n"
#~ "#driver_IHOLDDELAY: 8\n"
#~ "#driver_TPOWERDOWN: 20\n"
#~ "#driver_TBL: 2\n"
#~ "#driver_TOFF: 3\n"
#~ "#driver_HEND: 0\n"
#~ "#driver_HSTRT: 5\n"
#~ "#driver_PWM_AUTOGRAD: True\n"
#~ "#driver_PWM_AUTOSCALE: True\n"
#~ "#driver_PWM_LIM: 12\n"
#~ "#driver_PWM_REG: 8\n"
#~ "#driver_PWM_FREQ: 1\n"
#~ "#driver_PWM_GRAD: 14\n"
#~ "#driver_PWM_OFS: 36\n"
#~ "#   Set the given register during the configuration of the TMC2208\n"
#~ "#   chip. This may be used to set custom motor parameters. The\n"
#~ "#   defaults for each parameter are next to the parameter name in the\n"
#~ "#   above list.\n"
#~ msgstr ""

#~ msgid ""
#~ "Information on configuring st7920 displays (which is used in "
#~ "\"RepRapDiscount 12864 Full Graphic Smart Controller\" type displays)."
#~ msgstr ""

#~ msgid "Filament sensors"
#~ msgstr ""

#~ msgid ""
#~ "[palette2]\n"
#~ "serial:\n"
#~ "#   The serial port to connect to the Palette 2.\n"
#~ "#baud: 115200\n"
#~ "#   The baud rate to use. The default is 115200.\n"
#~ "#feedrate_splice: 0.8\n"
#~ "#   The feedrate to use when splicing, default is 0.8\n"
#~ "#feedrate_normal: 1.0\n"
#~ "#   The feedrate to use after splicing, default is 1.0\n"
#~ "#auto_load_speed: 2\n"
#~ "#   Extrude feedrate when autoloading, default is 2 (mm/s)\n"
#~ "#auto_cancel_variation: 0.1\n"
#~ "#   Auto cancel print when ping varation is above this threshold\n"
#~ msgstr ""

#~ msgid ""
#~ "20210313: Klipper's support for micro-controllers that communicate with CAN "
#~ "bus has changed. If using CAN bus then all micro-controllers must be "
#~ "reflashed and the [Klipper configuration must be updated](CANBUS.md)."
#~ msgstr ""

#~ msgid ""
#~ "20191210: The builtin T0, T1, T2, ... commands have been removed. The "
#~ "extruder activate_gcode and deactivate_gcode config options have been "
#~ "removed. If these commands (and scripts) are needed then define individual "
#~ "[gcode_macro T0] style macros that call the ACTIVATE_EXTRUDER command. See "
#~ "the config/sample-idex.cfg and sample-multi-extruder.cfg files for examples."
#~ msgstr ""

#~ msgid "The \"printer\" Variable"
#~ msgstr ""

#~ msgid "`menu.width` - element width (number of display columns)"
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
#~ "finding_algorithm) to generate the step times for each stepper. For "
#~ "efficiency reasons, the stepper pulse times are generated in C code. The "
#~ "moves are first placed on a \"trapezoid motion queue\": "
#~ "`ToolHead._process_moves() -> trapq_append()` (in klippy/chelper/trapq.c). "
#~ "The step times are then generated: `ToolHead._process_moves() -> "
#~ "ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> "
#~ "itersolve_generate_steps() -> itersolve_gen_steps_range()` (in "
#~ "klippy/chelper/itersolve.c). The goal of the iterative solver is to find "
#~ "step times given a function that calculates a stepper position from a time. "
#~ "This is done by repeatedly \"guessing\" various times until the stepper "
#~ "position formula returns the desired position of the next step on the "
#~ "stepper. The feedback produced from each guess is used to improve future "
#~ "guesses so that the process rapidly converges to the desired time. The "
#~ "kinematic stepper position formulas are located in the klippy/chelper/ "
#~ "directory (eg, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c)."
#~ msgstr ""

#~ msgid ""
#~ "Other methods. Implement the `check_move()`, `get_status()`, "
#~ "`get_steppers()`, `home()`, and `set_position()` methods. These functions "
#~ "are typically used to provide kinematic specific checks. However, at the "
#~ "start of development one can use boiler-plate code here."
#~ msgstr ""

#~ msgid ""
#~ "MCU clock. This is the hardware clock counter on each micro-controller. It "
#~ "is stored as an integer and its update rate is relative to the frequency of "
#~ "the given micro-controller. The host software translates its internal times "
#~ "to clocks before transmission to the mcu. The mcu code only ever tracks time"
#~ " in clock ticks. Within the host code, clock values are tracked as 64bit "
#~ "integers, while the mcu code uses 32bit integers. Within the host code, "
#~ "clocks are generally stored in variables with names containing *clock* or "
#~ "*ticks*."
#~ msgstr ""

#~ msgid ""
#~ "Is the copyright of the submission clear, non-gratuitous, and compatible?"
#~ msgstr ""

#~ msgid "@dmbutyugin"
#~ msgstr ""

#~ msgid ""
#~ "Whenever the \"bridge mcu\" is reset, Linux will disable the corresponding "
#~ "`can0` interface. To ensure proper handling of FIRMWARE_RESTART and RESTART "
#~ "commands, it is recommended to replace `auto` with `allow-hotplug` in the "
#~ "`/etc/network/interfaces.d/can0` file. For example:"
#~ msgstr ""

#~ msgid ""
#~ "wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/optiboot/optiboot_atmega168.hex'\n"
#~ "\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0x04:m -U hfuse:w:0xDD:m -U lfuse:w:0xFF:m\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega168.hex\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
#~ msgstr ""

#~ msgid "bossac -U -p /dev/ttyACM0 --offset=0x4000 -w out/klipper.bin -v -b -R\n"
#~ msgstr ""

#~ msgid "alternatively, you can use `make flash` to flash klipper directly:"
#~ msgstr ""

#~ msgid ""
#~ "It is common for Smoothieboards to come with a bootloader from: "
#~ "<https://github.com/triffid/LPC17xx-DFU-Bootloader>. When using this "
#~ "bootloader the application must be compiled with a start address of 16KiB. "
#~ "The easiest way to flash an application with this bootloader is to copy the "
#~ "application file (eg, `out/klipper.bin`) to a file named `firmware.bin` on "
#~ "an SD card, and then to reboot the micro-controller with that SD card."
#~ msgstr ""

#~ msgid "sam3x8e"
#~ msgstr ""

#~ msgid "stm32f103"
#~ msgstr ""

#~ msgid "lpc1769"
#~ msgstr ""

#~ msgid ""
#~ "The command dispatch benchmark tests how many \"dummy\" commands the micro-"
#~ "controller can process. It is primarily a test of the hardware communication"
#~ " mechanism. The test is run using the console.py tool (described in "
#~ "<Debugging.md>). The following is cut-and-paste into the console.py terminal"
#~ " window:"
#~ msgstr ""

#~ msgid "418K"
#~ msgstr ""

#~ msgid "![bedmesh_interpolated](img/bedmesh_interpolated.svg)"
#~ msgstr ""

#~ msgid "`MESH_MIN`"
#~ msgstr ""

#~ msgid "Recv: // Z position: 0.130 --> 0.230 <-- 0.280\n"
#~ msgstr ""

#~ msgid "Multi-probing without stowing"
#~ msgstr ""

#~ msgid "and cause Klipper to send future messages similar to:"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows one to request a restart - it is similar to running the"
#~ " G-Code \"RESTART\" command. For example: `{\"id\": 123, \"method\": "
#~ "\"gcode/restart\"}`"
#~ msgstr ""

#~ msgid ""
#~ "Tests comparing modes have shown an increased \"positional lag\" of around "
#~ "75% of a full-step during constant velocity moves when using stealthChop "
#~ "mode (for example, on a printer with 40mm rotation_distance and 200 "
#~ "steps_per_rotation, position deviation of constant speed moves increased by "
#~ "~0.150mm). However, this \"delay in obtaining the requested position\" may "
#~ "not manifest as a significant print defect and one may prefer the quieter "
#~ "behavior of stealthChop mode."
#~ msgstr ""

#~ msgid ""
#~ "A stallGuard capable TMC stepper driver (tmc2130, tmc2209, tmc2660, or "
#~ "tmc5160)."
#~ msgstr ""

#~ msgid ""
#~ "The `homing_retract_dist` setting must be set to zero in the `stepper_x` "
#~ "config section to disable the second homing move. The second homing attempt "
#~ "does not add value when using sensorless homing, it will not work reliably, "
#~ "and it will confuse the tuning process."
#~ msgstr ""

#~ msgid ""
#~ "When searching for maximum_sensitivity, it may be convenient to jump to "
#~ "different VALUE settings (so as to bisect the VALUE parameter). If doing "
#~ "this then be prepared to issue an `M112` command to halt the printer, as a "
#~ "setting with a very low sensitivity may cause the axis to repeatedly "
#~ "\"bang\" into the end of the rail."
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro SENSORLESS_HOME_X]\n"
#~ "gcode:\n"
#~ "    {% set HOME_CUR = 0.700 %}\n"
#~ "    {% set driver_config = printer.configfile.settings['tmc2209 stepper_x'] %}\n"
#~ "    {% set RUN_CUR = driver_config.run_current %}\n"
#~ "    # Set current for sensorless homing\n"
#~ "    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={HOME_CUR}\n"
#~ "    # Pause to ensure driver stall flag is clear\n"
#~ "    G4 P2000\n"
#~ "    # Home\n"
#~ "    G28 X0\n"
#~ "    # Move away\n"
#~ "    G90\n"
#~ "    G1 X5 F1200\n"
#~ "    # Set current during print\n"
#~ "    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={RUN_CUR}\n"
#~ msgstr ""

#~ msgid ""
#~ "In addition, almost all fields can be modified at run-time using the "
#~ "[SET_TMC_FIELD command](G-Codes.md#set_tmc_field)."
#~ msgstr ""

#~ msgid "Why did I get a \"TMC reports error: ...\" error?"
#~ msgstr ""

#~ msgid "`accepted_screws`: The number of accepted screws."
#~ msgstr ""

#~ msgid ""
#~ "`last_home.<stepper name>.mcu_position`: The position (as tracked by the "
#~ "micro-controller) of the stepper motor at the end of the last home attempt. "
#~ "The position is the total number of steps taken in a forward direction minus"
#~ " the total number of steps taken in the reverse direction since the micro-"
#~ "controller was last restarted."
#~ msgstr ""

#~ msgid "filament_switch_sensor"
#~ msgstr ""

#~ msgid ""
#~ "`position`: The last commanded position of the toolhead using the coordinate"
#~ " system specified in the config file. It is possible to access the x, y, z, "
#~ "and e components of this position (eg, `position.x`)."
#~ msgstr ""

#~ msgid ""
#~ "`power`: The last setting of the PWM pin (a value between 0.0 and 1.0) "
#~ "associated with the heater."
#~ msgstr ""

#~ msgid ""
#~ "`z_position`: The current height of the nozzle (as the printer currently "
#~ "understands it)."
#~ msgstr ""

#~ msgid "`value`: The \"value\" of the pin, as set by a `SET_PIN` command."
#~ msgstr ""

#~ msgid ""
#~ "`last_query`: Returns True if the probe was reported as \"triggered\" during"
#~ " the last QUERY_PROBE command. Note, if this is used in a macro, due to the "
#~ "order of template expansion, the QUERY_PROBE command must be run prior to "
#~ "the macro containing this reference."
#~ msgstr ""

#~ msgid ""
#~ "`sign`: A string specifying the direction to turn to screw for the necessary"
#~ " adjustment. Either \"CW\" for clockwise or \"CCW\" for counterclockwise. "
#~ "The base screw will not have a `sign` key."
#~ msgstr ""

#~ msgid "temperature_sensor"
#~ msgstr ""

#~ msgid ""
#~ "For Delta printers the `cone_start_z` is the max z height at maximum radius "
#~ "(`printer.toolhead.cone_start_z`)."
#~ msgstr ""

#~ msgid ""
#~ "`state`: Returns a string indicating the current Klipper state. Possible "
#~ "values are: \"ready\", \"startup\", \"shutdown\", \"error\"."
#~ msgstr ""

#~ msgid "Do not use \"extra restart distance\" on Simplify3d"
#~ msgstr ""

#~ msgid ""
#~ "The `[skew_correction]` module also supports profile management in a manner "
#~ "similar to `[bed_mesh]`. After setting skew using the `SET_SKEW` gcode, you "
#~ "may use the `SKEW_PROFILE` gcode to save it:"
#~ msgstr ""

#~ msgid ""
#~ "./scripts/flash-sdcard.sh -f ~/downloads/klipper.bin /dev/ttyAMA0 btt-"
#~ "skr-v1.3\n"
#~ msgstr ""

#~ msgid ""
#~ "If software SPI is required, the `spi_bus` field should be set to `swspi` "
#~ "and the following additional field should be specified:"
#~ msgstr ""

#~ msgid "SDIO to SPI Pin Mapping"
#~ msgstr ""

#~ msgid "GND (VSS)"
#~ msgstr ""

#~ msgid ""
#~ "Use a marker to place a mark on the filament around 70mm from the intake of "
#~ "the extruder body. Then use a digital calipers to measure the actual "
#~ "distance of that mark as precisely as one can. Note this as "
#~ "`<initial_mark_distance>`."
#~ msgstr ""

#~ msgid ""
#~ "For example, the common \"T8 leadscrew\" has a rotation distance of 8 (it "
#~ "has a pitch of 2mm and has 4 separate threads)."
#~ msgstr ""

#~ msgid ""
#~ "If `square_corner_velocity` parameter was changed, revert it back to 5.0. It"
#~ " is not advised to increase it when using input shaper because it can cause "
#~ "more smoothing in parts - it is better to use higher acceleration value "
#~ "instead."
#~ msgstr ""

#~ msgid ""
#~ "Note that the ringing frequencies can change if the changes are made to the "
#~ "printer that affect the moving mass or change the stiffness of the system, "
#~ "for example:"
#~ msgstr ""

#~ msgid "Execute: `SET_INPUT_SHAPER SHAPER_TYPE=MZV`"
#~ msgstr ""

#~ msgid ""
#~ "In this picture, the acceleration increases left to right, and the gap "
#~ "starts to grow starting from 3500 mm/sec^2 (5-th band from the left). So the"
#~ " good value for max_accel = 3000 (mm/sec^2) in this case to avoid the "
#~ "excessive smoothing."
#~ msgstr ""

#~ msgid ""
#~ "Find the band which shows ringing the least and count its number from the "
#~ "bottom starting at 1."
#~ msgstr ""

#~ msgid ""
#~ "`SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=50 SHAPER_FREQ_Y=50`"
#~ msgstr ""

#~ msgid "Troubleshooting and FAQ"
#~ msgstr ""

#~ msgid "Input <br> shaper"
#~ msgstr ""

#~ msgid " 20% shaper_freq"
#~ msgstr ""

#~ msgid ""
#~ "If one needs to reduce vibrations at several very different frequencies "
#~ "(say, 30 Hz and 100 Hz), they may see that the table above does not provide "
#~ "enough information. In this case one may have more luck with "
#~ "[scripts/graph_shaper.py](../scripts/graph_shaper.py) script, which is more "
#~ "flexible."
#~ msgstr ""

#~ msgid "Available on 20210929. Major changes in this release:"
#~ msgstr ""

#~ msgid ""
#~ "New \"Smooth Pressure Advance\" system. This implements \"Pressure Advance\""
#~ " without introducing instantaneous velocity changes. It is also now possible"
#~ " to tune pressure advance using a \"Tuning Tower\" method."
#~ msgstr ""

#~ msgid "New support for TMC2209 and TMC5160 drivers."
#~ msgstr ""

#~ msgid "Klipper now has a logo."
#~ msgstr ""

#~ msgid "Support for \"uc1701\" and \"ssd1306\" displays"
#~ msgstr ""

#~ msgid "Initial support for \"safe homing\" and homing overrides"
#~ msgstr ""

#~ msgid "Available on 20171025. Major changes in this release:"
#~ msgstr ""

#~ msgid "Support for AD595 sensors"
#~ msgstr ""

#~ msgid ""
#~ "Support for common g-code commands. Support for interfacing with OctoPrint."
#~ msgstr ""

#~ msgid ""
#~ "Complete the installation by configuring Klipper secondary MCU following the"
#~ " instructions in [RaspberryPi sample config](../config/sample-raspberry-"
#~ "pi.cfg) and [Multi MCU sample config](../config/sample-multi-mcu.cfg)."
#~ msgstr ""

#~ msgid "To check available gpiochip run:"
#~ msgstr ""

#~ msgid "Optional: Hardware PWM"
#~ msgstr ""

#~ msgid ""
#~ "[output_pin caselight]\n"
#~ "pin: host:pwmchip0/pwm0\n"
#~ "pwm: True\n"
#~ "hardware_pwm: True\n"
#~ "cycle_time: 0.000001\n"
#~ msgstr ""

#~ msgid "18"
#~ msgstr ""

#~ msgid ""
#~ "To send information from the micro-controller to the host a \"response\" is "
#~ "generated. These are both declared and transmitted using the sendf() C "
#~ "macro. For example:"
#~ msgstr ""

#~ msgid "DECL_CONSTANT(\"SERIAL_BAUD\", 250000);\n"
#~ msgstr ""

#~ msgid ""
#~ "In order to encode and parse the message contents, both the host and micro-"
#~ "controller must agree on the command ids and the number of parameters each "
#~ "command has. So, in the above example, both the host and micro-controller "
#~ "would know that \"id_update_digital_out\" is always followed by two "
#~ "parameters, and \"id_get_config\" and \"id_get_clock\" have zero parameters."
#~ " The host and micro-controller share a \"data dictionary\" that maps the "
#~ "command descriptions (eg, \"update_digital_out oid=%c value=%c\") to their "
#~ "integer command-ids. When processing the data, the parser will know to "
#~ "expect a specific number of VLQ encoded parameters following a given command"
#~ " id."
#~ msgstr ""

#~ msgid ""
#~ "In order for meaningful communications to be established between micro-"
#~ "controller and host, both sides must agree on a \"data dictionary\". This "
#~ "data dictionary contains the integer identifiers for commands and responses "
#~ "along with their descriptions."
#~ msgstr ""

#~ msgid ""
#~ "Providing an accurate probe z_offset is critical to obtaining high quality "
#~ "prints. The z_offset is the distance between the nozzle and bed when the "
#~ "probe triggers. The Klipper `PROBE_CALIBRATE` tool can be used to obtain "
#~ "this value - it will run an automatic probe to measure the probe's Z trigger"
#~ " position and then start a manual probe to obtain the nozzle Z height. The "
#~ "probe z_offset will then be calculated from these measurements."
#~ msgstr ""

#~ msgid ""
#~ "This is a common issue with probes on delta printers, however it can occur "
#~ "on all printers."
#~ msgstr ""

#~ msgid ""
#~ "Inspect the print and then use a digital calipers to find the height that "
#~ "has the best quality corners. When in doubt, prefer a lower height."
#~ msgstr ""

#~ msgid ""
#~ "[Probe calibrate](Probe_Calibrate.md): Calibration of automatic Z probes."
#~ msgstr ""

#~ msgid ""
#~ "[Exclude Object](Exclude_Object.md): The guide to the Exclude Objecs "
#~ "implementation."
#~ msgstr ""

#~ msgid "[CAN bus](CANBUS.md): Information on using CAN bus with Klipper."
#~ msgstr ""

#~ msgid "RPi pin"
#~ msgstr ""

#~ msgid "GPIO11 (SPI0_SCLK)"
#~ msgstr ""

#~ msgid "Recommended connection scheme for I2C(i2c0a) on the RP2040:"
#~ msgstr ""

#~ msgid ""
#~ "sudo apt update\n"
#~ "sudo apt install python3-numpy python3-matplotlib libatlas-base-dev\n"
#~ msgstr ""

#~ msgid "Measuring the resonances"
#~ msgstr ""

#~ msgid "TEST_RESONANCES AXIS=Y\n"
#~ msgstr ""

#~ msgid ""
#~ "Keep in mind that the input shaper can create some smoothing in parts. "
#~ "Automatic tuning of the input shaper performed by `calibrate_shaper.py` "
#~ "script or `SHAPER_CALIBRATE` command tries not to exacerbate the smoothing, "
#~ "but at the same time they try to minimize the resulting vibrations. "
#~ "Sometimes they can make a sub-optimal choice of the shaper frequency, or "
#~ "maybe you simply prefer to have less smoothing in parts at the expense of a "
#~ "larger remaining vibrations. In these cases, you can request to limit the "
#~ "maximum smoothing from the input shaper."
#~ msgstr ""

#~ msgid ""
#~ "Alternatively, follow [this](Resonance_Compensation.md#selecting-max_accel) "
#~ "part of the input shaper tuning guide and print the test model to choose "
#~ "`max_accel` parameter experimentally."
#~ msgstr ""

#~ msgid "SHAPER_CALIBRATE\n"
#~ msgstr ""

#~ msgid ""
#~ "ignoring any errors for `SET_INPUT_SHAPER` command. For `TEST_RESONANCES` "
#~ "command, specify the desired test axis. The raw data will be written into "
#~ "`/tmp` directory on the RPi."
#~ msgstr ""

#~ msgid ""
#~ "Combining the resonance data from 2 axis (e.g. on a bed slinger printer to "
#~ "configure X-axis input_shaper from both X and Y axes resonances to cancel "
#~ "vibrations of the *bed* in case the nozzle 'catches' a print when moving in "
#~ "X axis direction)."
#~ msgstr ""

#~ msgid ""
#~ "Once the config file is ready, run `RESTART` to load that config, and then "
#~ "one can start the tool by running:"
#~ msgstr ""

#~ msgid ""
#~ "[screws_tilt_adjust]\n"
#~ "screw1: -5, 30\n"
#~ "screw1_name: front left screw\n"
#~ "screw2: 155, 30\n"
#~ "screw2_name: front right screw\n"
#~ "screw3: 155, 190\n"
#~ "screw3_name: rear right screw\n"
#~ "screw4: -5, 190\n"
#~ "screw4_name: rear left screw\n"
#~ "horizontal_move_z: 10.\n"
#~ "speed: 50.\n"
#~ "screw_thread: CW-M3\n"
#~ msgstr ""

#~ msgid ""
#~ "`finalize_config crc=%u` : The finalize_config command transitions the "
#~ "micro-controller from an unconfigured state to a configured state. The crc "
#~ "parameter passed to the micro-controller is stored and provided back to the "
#~ "host in \"config\" response messages. By convention, the host takes a 32bit "
#~ "CRC of the configuration it will request and at the start of subsequent "
#~ "communication sessions it checks that the CRC stored in the micro-controller"
#~ " exactly matches its desired CRC. If the CRC does not match then the host "
#~ "knows the micro-controller has not been configured in the state desired by "
#~ "the host."
#~ msgstr ""

#~ msgid ""
#~ "`get_clock` : This command causes the micro-controller to generate a "
#~ "\"clock\" response message. The host sends this command once a second to "
#~ "obtain the value of the micro-controller clock and to estimate the drift "
#~ "between host and micro-controller clocks. It enables the host to accurately "
#~ "estimate the micro-controller clock."
#~ msgstr ""

#~ msgid "Consider the following two moves contained on an XY plane:"
#~ msgstr ""

#~ msgid "Generating steps"
#~ msgstr ""

#~ msgid "Delta Robots"
#~ msgstr ""

#~ msgid "![pressure-advance](img/pressure-velocity.png)"
#~ msgstr ""

#~ msgid "make\n"
#~ msgstr ""

#~ msgid ""
#~ "The next step is to copy the [printer configuration file](#obtain-a-klipper-"
#~ "configuration-file) to the Raspberry Pi."
#~ msgstr ""

#~ msgid "Logging"
#~ msgstr ""

#~ msgid ""
#~ "Note: If S is not specified and both P and T are specified, then the "
#~ "acceleration is set to the minimum of P and T. If only one of P or T is "
#~ "specified, the command has no effect."
#~ msgstr ""

#~ msgid "Additional Commands"
#~ msgstr ""

#~ msgid ""
#~ "`ANGLE_DEBUG_READ CHIP=<config_name> REG=<register>`: Queries sensor "
#~ "register \"register\" (e.g. 44 or 0x2C). Can be useful for debugging "
#~ "purposes. This is only available for tle5012b chips."
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [bed_screws config "
#~ "section](Config_Reference.md#bed_screws) is enabled (also see the [manual "
#~ "level guide](Manual_Level.md#adjusting-bed-leveling-screws))."
#~ msgstr ""

#~ msgid "UPDATE_DELAYED_GCODE"
#~ msgstr ""

#~ msgid ""
#~ "`SET_DISPLAY_TEXT MSG=<message>`: Performs the equivalent of M117, setting "
#~ "the supplied `MSG` as the current display message. If `MSG` is omitted the "
#~ "display will be cleared."
#~ msgstr ""

#~ msgid ""
#~ "When the `NAME` parameter is included, this defines an object to be "
#~ "excluded."
#~ msgstr ""

#~ msgid "SYNC_EXTRUDER_MOTION"
#~ msgstr ""

#~ msgid "The following additional commands are also available."
#~ msgstr ""

#~ msgid "FIRMWARE_RESTART"
#~ msgstr ""

#~ msgid "SET_GCODE_OFFSET"
#~ msgstr ""

#~ msgid ""
#~ "`QUERY_RAW_FILAMENT_WIDTH`: Return the current ADC channel readings and RAW "
#~ "sensor value for calibration points."
#~ msgstr ""

#~ msgid ""
#~ "The following command is enabled if an [input_shaper config "
#~ "section](Config_Reference.md#input_shaper) has been enabled (also see the "
#~ "[resonance compensation guide](Resonance_Compensation.md))."
#~ msgstr ""

#~ msgid ""
#~ "`MANUAL_STEPPER STEPPER=config_name [ENABLE=[0|1]] [SET_POSITION=<pos>] "
#~ "[SPEED=<speed>] [ACCEL=<accel>] [MOVE=<pos> [STOP_ON_ENDSTOP=[1|2|-1|-2]] "
#~ "[SYNC=0]]`: This command will alter the state of the stepper. Use the ENABLE"
#~ " parameter to enable/disable the stepper. Use the SET_POSITION parameter to "
#~ "force the stepper to think it is at the given position. Use the MOVE "
#~ "parameter to request a movement to the given position. If SPEED and/or ACCEL"
#~ " is specified then the given values will be used instead of the defaults "
#~ "specified in the config file. If an ACCEL of zero is specified then no "
#~ "acceleration will be performed. If STOP_ON_ENDSTOP=1 is specified then the "
#~ "move will end early should the endstop report as triggered (use "
#~ "STOP_ON_ENDSTOP=2 to complete the move without error even if the endstop "
#~ "does not trigger, use -1 or -2 to stop when the endstop reports not "
#~ "triggered). Normally future G-Code commands will be scheduled to run after "
#~ "the stepper move completes, however if a manual stepper move uses SYNC=0 "
#~ "then future G-Code movement commands may run in parallel with the stepper "
#~ "movement."
#~ msgstr ""

#~ msgid ""
#~ "`PALETTE_CONNECT`: This command initializes the connection with the Palette "
#~ "2."
#~ msgstr ""

#~ msgid "RESUME"
#~ msgstr ""

#~ msgid ""
#~ "`PROBE_ACCURACY [PROBE_SPEED=<mm/s>] [SAMPLES=<count>] "
#~ "[SAMPLE_RETRACT_DIST=<mm>]`: Calculate the maximum, minimum, average, "
#~ "median, and standard deviation of multiple probe samples. By default, 10 "
#~ "SAMPLES are taken. Otherwise the optional parameters default to their "
#~ "equivalent setting in the probe config section."
#~ msgstr ""

#~ msgid ""
#~ "`MEASURE_AXES_NOISE`: Measures and outputs the noise for all axes of all "
#~ "enabled accelerometer chips."
#~ msgstr ""

#~ msgid ""
#~ "`SAVE_VARIABLE VARIABLE=<name> VALUE=<value>`: Saves the variable to disk so"
#~ " that it can be used across restarts. All stored variables are loaded into "
#~ "the `printer.save_variables.variables` dict at startup and can be used in "
#~ "gcode macros. The provided VALUE is parsed as a Python literal."
#~ msgstr ""

#~ msgid ""
#~ "`SET_SKEW [XY=<ac_length,bd_length,ad_length>] [XZ=<ac,bd,ad>] "
#~ "[YZ=<ac,bd,ad>] [CLEAR=<0|1>]`: Configures the [skew_correction] module with"
#~ " measurements (in mm) taken from a calibration print. One may enter "
#~ "measurements for any combination of planes, planes not entered will retain "
#~ "their current value. If `CLEAR=1` is entered then all skew correction will "
#~ "be disabled."
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a [temperature_fan config "
#~ "section](Config_Reference.md#temperature_fan) is enabled."
#~ msgstr ""

#~ msgid ""
#~ "`SET_VELOCITY_LIMIT [VELOCITY=<value>] [ACCEL=<value>] "
#~ "[ACCEL_TO_DECEL=<value>] [SQUARE_CORNER_VELOCITY=<value>]`: Modify the "
#~ "printer's velocity limits."
#~ msgstr ""

#~ msgid ""
#~ "In addition, the following extended commands are available when the "
#~ "\"virtual_sdcard\" config section is enabled."
#~ msgstr ""

#~ msgid "Klipper supports many standard 3d printer features:"
#~ msgstr ""

#~ msgid ""
#~ "Support for measuring and recording acceleration using an adxl345, mpu9250, "
#~ "and mpu6050 accelerometers."
#~ msgstr ""

#~ msgid "686K"
#~ msgstr ""

#~ msgid "981K"
#~ msgstr ""

#~ msgid "SAMD51"
#~ msgstr ""

#~ msgid ""
#~ "If you're having an intermittent failure or you do have a standard setup, "
#~ "then double check that Klipper isn't running when flashing (sudo service "
#~ "klipper stop), make sure OctoPrint isn't trying to connect directly to the "
#~ "device (open the Connection tab in the web page and click Disconnect if the "
#~ "Serial Port is set to the device), and make sure FLASH_DEVICE is set "
#~ "correctly for your board (see the [question above](#wheres-my-serial-port))."
#~ msgstr ""

#~ msgid "Can I run multiple instances of Klipper on the same host machine?"
#~ msgstr ""

#~ msgid ""
#~ "I converted my config from Marlin and the X/Y axes work fine, but I just get"
#~ " a screeching noise when homing the Z axis"
#~ msgstr ""

#~ msgid ""
#~ "The workaround is to use a restart_method other than \"command\" or to flash"
#~ " an updated bootloader to the AVR device. Flashing a new bootloader is a one"
#~ " time step that typically requires an external programmer - see "
#~ "[Bootloaders](Bootloaders.md) for further details."
#~ msgstr ""

#~ msgid ""
#~ "SPI pins: When using hardware SPI it is necessary to wire the pins to the "
#~ "micro-controller's SPI capable pins. However, most devices can be configured"
#~ " to use \"software SPI\", in which case any general purpose IO pins may be "
#~ "used."
#~ msgstr ""

#~ msgid ""
#~ "cd ~/klipper\n"
#~ "git pull\n"
#~ "~/klipper/scripts/install-octopi.sh\n"
#~ msgstr ""

#~ msgid "Object Definitions"
#~ msgstr ""

#~ msgid ""
#~ "Do not specify `pressure_advance` in an example config, as that value is "
#~ "specific to the filament, not the printer hardware. Similarly, do not "
#~ "specify `max_extrude_only_velocity` nor `max_extrude_only_accel` settings."
#~ msgstr ""

#~ msgid ""
#~ "In order to use this system the endstop must be accurate enough to identify "
#~ "the stepper position within two \"full steps\". So, for example, if a "
#~ "stepper is using 16 micro-steps with a step distance of 0.005mm then the "
#~ "endstop must have an accuracy of at least 0.160mm. If one gets \"Endstop "
#~ "stepper_z incorrect phase\" type error messages than in may be due to an "
#~ "endstop that is not sufficiently accurate. If recalibration does not help "
#~ "then disable endstop phase adjustments by removing them from the config "
#~ "file."
#~ msgstr ""

#~ msgid ""
#~ "After probing the seven points new delta parameters will be calculated. Save"
#~ " and apply these parameters by running:"
#~ msgstr ""

#~ msgid ""
#~ "Then measure the distance between the A pillar and the pillar across from "
#~ "the C label."
#~ msgstr ""

#~ msgid "DELTA_ANALYZE OUTER_PILLAR_WIDTHS=<a>,<far_c>,<b>,<far_a>,<c>,<far_b>\n"
#~ msgstr ""

#~ msgid ""
#~ "To run Klippy in this batch mode, there is a one time step necessary to "
#~ "generate the micro-controller \"data dictionary\". This is done by compiling"
#~ " the micro-controller code to obtain the **out/klipper.dict** file:"
#~ msgstr ""

#~ msgid "Graphs can be generated with a command like the following:"
#~ msgstr ""

#~ msgid "One can then view the resulting **loadgraph.png** file."
#~ msgstr ""

#~ msgid ""
#~ "cd /path/to/klipper\n"
#~ "make menuconfig\n"
#~ msgstr ""

#~ msgid "I have a question about Klipper"
#~ msgstr ""

#~ msgid ""
#~ "Problems should be reported in the [Klipper Community Forum](#community-"
#~ "forum)."
#~ msgstr ""

#~ msgid ""
#~ "Klipper github may be used by contributors to share the status of their work"
#~ " to improve Klipper. It is expected that the person opening a github ticket "
#~ "is actively working on the given task and will be the one performing all the"
#~ " work necessary to accomplish it. The Klipper github is not used for "
#~ "requests, nor to report bugs, nor to ask questions. Use the [Klipper "
#~ "Community Forum](#community-forum) or the [Klipper Community "
#~ "Discord](#discord-chat) instead."
#~ msgstr ""

#~ msgid "Verify endstops"
#~ msgstr ""

#~ msgid "Next steps"
#~ msgstr ""

#~ msgid "Common kinematic settings"
#~ msgstr ""

#~ msgid "Deltesian Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: hybrid_corexy\n"
#~ "max_z_velocity:\n"
#~ "#   This sets the maximum velocity (in mm/s) of movement along the z\n"
#~ "#   axis. The default is to use max_velocity for max_z_velocity.\n"
#~ "max_z_accel:\n"
#~ "#   This sets the maximum acceleration (in mm/s^2) of movement along\n"
#~ "#   the z axis. The default is to use max_accel for max_z_accel.\n"
#~ "\n"
#~ "# The stepper_x section is used to describe the X axis as well as the\n"
#~ "# stepper controlling the X-Y movement.\n"
#~ "[stepper_x]\n"
#~ "\n"
#~ "# The stepper_y section is used to describe the stepper controlling\n"
#~ "# the Y axis.\n"
#~ "[stepper_y]\n"
#~ "\n"
#~ "# The stepper_z section is used to describe the stepper controlling\n"
#~ "# the Z axis.\n"
#~ "[stepper_z]\n"
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to cable winch printers are described here - see "
#~ "[common kinematic settings](#common-kinematic-settings) for available "
#~ "parameters."
#~ msgstr ""

#~ msgid ""
#~ " rectangular bed, probe_count = 3, 3:\n"
#~ "             x---x---x (max_point)\n"
#~ "             |\n"
#~ "             x---x---x\n"
#~ "                     |\n"
#~ " (min_point) x---x---x\n"
#~ "\n"
#~ " round bed, round_probe_count = 5, bed_radius = r:\n"
#~ "                 x (0, r) end\n"
#~ "               /\n"
#~ "             x---x---x\n"
#~ "                       \\\n"
#~ " (-r, 0) x---x---x---x---x (r, 0)\n"
#~ "           \\\n"
#~ "             x---x---x\n"
#~ "                   /\n"
#~ "                 x  (0, -r) start\n"
#~ msgstr ""

#~ msgid "Where x is the 0, 0 point on the bed"
#~ msgstr ""

#~ msgid ""
#~ "[endstop_phase stepper_z]\n"
#~ "#endstop_accuracy:\n"
#~ "#   Sets the expected accuracy (in mm) of the endstop. This represents\n"
#~ "#   the maximum error distance the endstop may trigger (eg, if an\n"
#~ "#   endstop may occasionally trigger 100um early or up to 100um late\n"
#~ "#   then set this to 0.200 for 200um). The default is\n"
#~ "#   4*rotation_distance/full_steps_per_rotation.\n"
#~ "#trigger_phase:\n"
#~ "#   This specifies the phase of the stepper motor driver to expect\n"
#~ "#   when hitting the endstop. It is composed of two numbers separated\n"
#~ "#   by a forward slash character - the phase and the total number of\n"
#~ "#   phases (eg, \"7/64\"). Only set this value if one is sure the\n"
#~ "#   stepper motor driver is reset every time the mcu is reset. If this\n"
#~ "#   is not set, then the stepper phase will be detected on the first\n"
#~ "#   home and that phase will be used on all subsequent homes.\n"
#~ "#endstop_align_zero: False\n"
#~ "#   If true then the position_endstop of the axis will effectively be\n"
#~ "#   modified so that the zero position for the axis occurs at a full\n"
#~ "#   step on the stepper motor. (If used on the Z axis and the print\n"
#~ "#   layer height is a multiple of a full step distance then every\n"
#~ "#   layer will occur on a full step.) The default is False.\n"
#~ msgstr ""

#~ msgid ""
#~ "Support manually moving stepper motors for diagnostic purposes. Note, using "
#~ "this feature may place the printer in an invalid state - see the [command "
#~ "reference](G-Codes.md#force_move) for important details."
#~ msgstr ""

#~ msgid ""
#~ "Support for ADXL345 accelerometers. This support allows one to query "
#~ "accelerometer measurements from the sensor. This enables an "
#~ "ACCELEROMETER_MEASURE command (see [G-Codes](G-Codes.md#adxl345) for more "
#~ "information). The default chip name is \"default\", but one may specify an "
#~ "explicit name (eg, [adxl345 my_chip_name])."
#~ msgstr ""

#~ msgid ""
#~ "[duplicate_pin_override]\n"
#~ "pins:\n"
#~ "#   A comma separated list of pins that may be used multiple times in\n"
#~ "#   a config file without normal error checks. This parameter must be\n"
#~ "#   provided.\n"
#~ msgstr ""

#~ msgid ""
#~ "Support for cartesian printers with dual carriages on a single axis. The "
#~ "active carriage is set via the SET_DUAL_CARRIAGE extended g-code command. "
#~ "The \"SET_DUAL_CARRIAGE CARRIAGE=1\" command will activate the carriage "
#~ "defined in this section (CARRIAGE=0 will return activation to the primary "
#~ "carriage). Dual carriage support is typically combined with extra extruders "
#~ "- the SET_DUAL_CARRIAGE command is often called at the same time as the "
#~ "ACTIVATE_EXTRUDER command. Be sure to park the carriages during "
#~ "deactivation."
#~ msgstr ""

#~ msgid "[thermistor]"
#~ msgstr ""

#~ msgid ""
#~ "sensor_type:\n"
#~ "#   One of \"EPCOS 100K B57560G104F\", \"ATC Semitec 104GT-2\",\n"
#~ "#   \"ATC Semitec 104NT-4-R025H42G\", \"Generic 3950\",\n"
#~ "#   \"Honeywell 100K 135-104LAG-J01\", \"NTC 100K MGB18-104F39050L32\",\n"
#~ "#   \"SliceEngineering 450\", or \"TDK NTCG104LH104JT1\"\n"
#~ "sensor_pin:\n"
#~ "#   Analog input pin connected to the thermistor. This parameter must\n"
#~ "#   be provided.\n"
#~ "#pullup_resistor: 4700\n"
#~ "#   The resistance (in ohms) of the pullup attached to the thermistor.\n"
#~ "#   The default is 4700 ohms.\n"
#~ "#inline_resistor: 0\n"
#~ "#   The resistance (in ohms) of an extra (not heat varying) resistor\n"
#~ "#   that is placed inline with the thermistor. It is rare to set this.\n"
#~ "#   The default is 0 ohms.\n"
#~ msgstr ""

#~ msgid "LM75 temperature sensor"
#~ msgstr ""

#~ msgid "[heater_fan]"
#~ msgstr ""

#~ msgid ""
#~ "Note that the [linux mcu](RPi_microcontroller.md) implementation does not "
#~ "currently support directly connected neopixels. The current design using the"
#~ " Linux kernel interface does not allow this scenario because the kernel GPIO"
#~ " interface is not fast enough to provide the required pulse rates."
#~ msgstr ""

#~ msgid ""
#~ "[gcode_button my_gcode_button]\n"
#~ "pin:\n"
#~ "#   The pin on which the button is connected. This parameter must be\n"
#~ "#   provided.\n"
#~ "#analog_range:\n"
#~ "#   Two comma separated resistances (in Ohms) specifying the minimum\n"
#~ "#   and maximum resistance range for the button. If analog_range is\n"
#~ "#   provided then the pin must be an analog capable pin. The default\n"
#~ "#   is to use digital gpio for the button.\n"
#~ "#analog_pullup_resistor:\n"
#~ "#   The pullup resistance (in Ohms) when analog_range is specified.\n"
#~ "#   The default is 4700 ohms.\n"
#~ "#press_gcode:\n"
#~ "#   A list of G-Code commands to execute when the button is pressed.\n"
#~ "#   G-Code templates are supported. This parameter must be provided.\n"
#~ "#release_gcode:\n"
#~ "#   A list of G-Code commands to execute when the button is released.\n"
#~ "#   G-Code templates are supported. The default is to not run any\n"
#~ "#   commands on a button release.\n"
#~ msgstr ""

#~ msgid ""
#~ "[tmc2208 stepper_x]\n"
#~ "uart_pin:\n"
#~ "#   The pin connected to the TMC2208 PDN_UART line. This parameter\n"
#~ "#   must be provided.\n"
#~ "#tx_pin:\n"
#~ "#   If using separate receive and transmit lines to communicate with\n"
#~ "#   the driver then set uart_pin to the receive pin and tx_pin to the\n"
#~ "#   transmit pin. The default is to use uart_pin for both reading and\n"
#~ "#   writing.\n"
#~ "#select_pins:\n"
#~ "#   A comma separated list of pins to set prior to accessing the\n"
#~ "#   tmc2208 UART. This may be useful for configuring an analog mux for\n"
#~ "#   UART communication. The default is to not configure any pins.\n"
#~ "#interpolate: True\n"
#~ "#   If true, enable step interpolation (the driver will internally\n"
#~ "#   step at a rate of 256 micro-steps). This interpolation does\n"
#~ "#   introduce a small systemic positional deviation - see\n"
#~ "#   TMC_Drivers.md for details. The default is True.\n"
#~ "run_current:\n"
#~ "#   The amount of current (in amps RMS) to configure the driver to use\n"
#~ "#   during stepper movement. This parameter must be provided.\n"
#~ "#hold_current:\n"
#~ "#   The amount of current (in amps RMS) to configure the driver to use\n"
#~ "#   when the stepper is not moving. Setting a hold_current is not\n"
#~ "#   recommended (see TMC_Drivers.md for details). The default is to\n"
#~ "#   not reduce the current.\n"
#~ "#sense_resistor: 0.110\n"
#~ "#   The resistance (in ohms) of the motor sense resistor. The default\n"
#~ "#   is 0.110 ohms.\n"
#~ "#stealthchop_threshold: 0\n"
#~ "#   The velocity (in mm/s) to set the \"stealthChop\" threshold to. When\n"
#~ "#   set, \"stealthChop\" mode will be enabled if the stepper motor\n"
#~ "#   velocity is below this value. The default is 0, which disables\n"
#~ "#   \"stealthChop\" mode.\n"
#~ "#driver_IHOLDDELAY: 8\n"
#~ "#driver_TPOWERDOWN: 20\n"
#~ "#driver_TBL: 2\n"
#~ "#driver_TOFF: 3\n"
#~ "#driver_HEND: 0\n"
#~ "#driver_HSTRT: 5\n"
#~ "#driver_PWM_AUTOGRAD: True\n"
#~ "#driver_PWM_AUTOSCALE: True\n"
#~ "#driver_PWM_LIM: 12\n"
#~ "#driver_PWM_REG: 8\n"
#~ "#driver_PWM_FREQ: 1\n"
#~ "#driver_PWM_GRAD: 14\n"
#~ "#driver_PWM_OFS: 36\n"
#~ "#   Set the given register during the configuration of the TMC2208\n"
#~ "#   chip. This may be used to set custom motor parameters. The\n"
#~ "#   defaults for each parameter are next to the parameter name in the\n"
#~ "#   above list.\n"
#~ msgstr ""

#~ msgid ""
#~ "[mcp4451 my_digipot]\n"
#~ "i2c_address:\n"
#~ "#   The i2c address that the chip is using on the i2c bus. This\n"
#~ "#   parameter must be provided.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#wiper_0:\n"
#~ "#wiper_1:\n"
#~ "#wiper_2:\n"
#~ "#wiper_3:\n"
#~ "#   The value to statically set the given MCP4451 \"wiper\" to. This is\n"
#~ "#   typically set to a number between 0.0 and 1.0 with 1.0 being the\n"
#~ "#   highest resistance and 0.0 being the lowest resistance. However,\n"
#~ "#   the range may be changed with the 'scale' parameter (see below).\n"
#~ "#   If a wiper is not specified then it is left unconfigured.\n"
#~ "#scale:\n"
#~ "#   This parameter can be used to alter how the 'wiper_x' parameters\n"
#~ "#   are interpreted. If provided, then the 'wiper_x' parameters should\n"
#~ "#   be between 0.0 and 'scale'. This may be useful when the MCP4451 is\n"
#~ "#   used to set stepper voltage references. The 'scale' can be set to\n"
#~ "#   the equivalent stepper amperage if the MCP4451 were at its highest\n"
#~ "#   resistance, and then the 'wiper_x' parameters can be specified\n"
#~ "#   using the desired amperage value for the stepper. The default is\n"
#~ "#   to not scale the 'wiper_x' parameters.\n"
#~ msgstr ""

#~ msgid ""
#~ "Information on configuring st7920 displays (which is used in "
#~ "\"RepRapDiscount 12864 Full Graphic Smart Controller\" type displays)."
#~ msgstr ""

#~ msgid ""
#~ "Display data text \"macros\" (one may define any number of sections with a "
#~ "display_template prefix). See the [command templates](Command_Templates.md) "
#~ "document for information on template evaluation."
#~ msgstr ""

#~ msgid "Filament sensors"
#~ msgstr ""

#~ msgid ""
#~ "[sx1509 my_sx1509]\n"
#~ "i2c_address:\n"
#~ "#   I2C address used by this expander. Depending on the hardware\n"
#~ "#   jumpers this is one out of the following addresses: 62 63 112\n"
#~ "#   113. This parameter must be provided.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#i2c_bus:\n"
#~ "#   If the I2C implementation of your micro-controller supports\n"
#~ "#   multiple I2C busses, you may specify the bus name here. The\n"
#~ "#   default is to use the default micro-controller i2c bus.\n"
#~ msgstr ""

#~ msgid ""
#~ "[palette2]\n"
#~ "serial:\n"
#~ "#   The serial port to connect to the Palette 2.\n"
#~ "#baud: 115200\n"
#~ "#   The baud rate to use. The default is 115200.\n"
#~ "#feedrate_splice: 0.8\n"
#~ "#   The feedrate to use when splicing, default is 0.8\n"
#~ "#feedrate_normal: 1.0\n"
#~ "#   The feedrate to use after splicing, default is 1.0\n"
#~ "#auto_load_speed: 2\n"
#~ "#   Extrude feedrate when autoloading, default is 2 (mm/s)\n"
#~ "#auto_cancel_variation: 0.1\n"
#~ "#   Auto cancel print when ping varation is above this threshold\n"
#~ msgstr ""

#~ msgid ""
#~ "20211110: The \"NTC 100K beta 3950\" temperature sensor is deprecated. This "
#~ "sensor will be removed in the near future. Most users will find the "
#~ "\"Generic 3950\" temperature sensor more accurate. To continue to use the "
#~ "older (typically less accurate) definition, define a custom "
#~ "[thermistor](Config_Reference.md#thermistor) with `temperature1: 25`, "
#~ "`resistance1: 100000`, and `beta: 3950`."
#~ msgstr ""

#~ msgid ""
#~ "20210313: Klipper's support for micro-controllers that communicate with CAN "
#~ "bus has changed. If using CAN bus then all micro-controllers must be "
#~ "reflashed and the [Klipper configuration must be updated](CANBUS.md)."
#~ msgstr ""

#~ msgid ""
#~ "20200816: The gcode macro `printer.gcode` object has been renamed to "
#~ "`printer.gcode_move`. Several undocumented variables in `printer.toolhead` "
#~ "and `printer.gcode` have been removed. See docs/Command_Templates.md for a "
#~ "list of available template variables."
#~ msgstr ""

#~ msgid ""
#~ "20191210: The builtin T0, T1, T2, ... commands have been removed. The "
#~ "extruder activate_gcode and deactivate_gcode config options have been "
#~ "removed. If these commands (and scripts) are needed then define individual "
#~ "[gcode_macro T0] style macros that call the ACTIVATE_EXTRUDER command. See "
#~ "the config/sample-idex.cfg and sample-multi-extruder.cfg files for examples."
#~ msgstr ""

#~ msgid ""
#~ "20190606: The \"samples\", \"samples_result\", and \"sample_retract_dist\" "
#~ "config options have been moved to the \"probe\" config section. These "
#~ "options are no longer supported in the \"delta_calibrate\", \"bed_tilt\", "
#~ "\"bed_mesh\", \"screws_tilt_adjust\", \"z_tilt\", or \"quad_gantry_level\" "
#~ "config sections."
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro MOVE_UP]\n"
#~ "gcode:\n"
#~ "  SAVE_GCODE_STATE NAME=my_move_up_state\n"
#~ "  G91\n"
#~ "  G1 Z10 F300\n"
#~ "  RESTORE_GCODE_STATE NAME=my_move_up_state\n"
#~ msgstr ""

#~ msgid "The \"printer\" Variable"
#~ msgstr ""

#~ msgid ""
#~ "The SET_GCODE_VARIABLE command may be useful for saving state between macro "
#~ "calls. Variable names may not contain any upper case characters. For "
#~ "example:"
#~ msgstr ""

#~ msgid "`menu.width` - element width (number of display columns)"
#~ msgstr ""

#~ msgid ""
#~ "In the event an error is detected the code can invoke shutdown() (a macro "
#~ "which calls sched_shutdown() located in **src/sched.c**). Invoking "
#~ "shutdown() causes all functions tagged with the DECL_SHUTDOWN() macro to be "
#~ "run. Shutdown functions always run with interrupts disabled."
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
#~ "finding_algorithm) to generate the step times for each stepper. For "
#~ "efficiency reasons, the stepper pulse times are generated in C code. The "
#~ "moves are first placed on a \"trapezoid motion queue\": "
#~ "`ToolHead._process_moves() -> trapq_append()` (in klippy/chelper/trapq.c). "
#~ "The step times are then generated: `ToolHead._process_moves() -> "
#~ "ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> "
#~ "itersolve_generate_steps() -> itersolve_gen_steps_range()` (in "
#~ "klippy/chelper/itersolve.c). The goal of the iterative solver is to find "
#~ "step times given a function that calculates a stepper position from a time. "
#~ "This is done by repeatedly \"guessing\" various times until the stepper "
#~ "position formula returns the desired position of the next step on the "
#~ "stepper. The feedback produced from each guess is used to improve future "
#~ "guesses so that the process rapidly converges to the desired time. The "
#~ "kinematic stepper position formulas are located in the klippy/chelper/ "
#~ "directory (eg, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c)."
#~ msgstr ""

#~ msgid ""
#~ "If there is an error in the user's config, be sure to raise it during the "
#~ "`load_config()` or \"connect event\" phases. Use either `raise "
#~ "config.error(\"my error\")` or `raise printer.config_error(\"my error\")` to"
#~ " report the error."
#~ msgstr ""

#~ msgid ""
#~ "Other methods. Implement the `check_move()`, `get_status()`, "
#~ "`get_steppers()`, `home()`, and `set_position()` methods. These functions "
#~ "are typically used to provide kinematic specific checks. However, at the "
#~ "start of development one can use boiler-plate code here."
#~ msgstr ""

#~ msgid "Coordinate Systems"
#~ msgstr ""

#~ msgid ""
#~ "MCU clock. This is the hardware clock counter on each micro-controller. It "
#~ "is stored as an integer and its update rate is relative to the frequency of "
#~ "the given micro-controller. The host software translates its internal times "
#~ "to clocks before transmission to the mcu. The mcu code only ever tracks time"
#~ " in clock ticks. Within the host code, clock values are tracked as 64bit "
#~ "integers, while the mcu code uses 32bit integers. Within the host code, "
#~ "clocks are generally stored in variables with names containing *clock* or "
#~ "*ticks*."
#~ msgstr ""

#~ msgid ""
#~ "Submitters are expected to test their changes prior to submission. The "
#~ "reviewers look for errors, but they don't, in general, test submissions. An "
#~ "accepted submission is often deployed to thousands of printers within a few "
#~ "weeks of acceptance. Quality of submissions is therefore considered a "
#~ "priority."
#~ msgstr ""

#~ msgid ""
#~ "Is the copyright of the submission clear, non-gratuitous, and compatible?"
#~ msgstr ""

#~ msgid ""
#~ "Commits must not have a merge conflict. New additions to the Klipper master "
#~ "branch are always done via a \"rebase\" or \"squash and rebase\". It is "
#~ "generally not necessary for submitters to re-merge their submission on every"
#~ " update to the Klipper master repository. However, if there is a merge "
#~ "conflict, then submitters are recommended to use `git rebase` to address the"
#~ " conflict."
#~ msgstr ""

#~ msgid "@dmbutyugin"
#~ msgstr ""

#~ msgid ""
#~ "It is important to have a \"Signed-off-by\" line on each commit - it "
#~ "certifies that you agree to the [developer certificate of origin](developer-"
#~ "certificate-of-origin). It must contain your real name (sorry, no pseudonyms"
#~ " or anonymous contributions) and contain a current email address."
#~ msgstr ""

#~ msgid "Data Packets"
#~ msgstr ""

#~ msgid ""
#~ "To test that the resistors are correct, one can remove power to the printer "
#~ "and use a multi-meter to check the resistance between the CANH and CANL "
#~ "wires - it should report ~60 ohms on a correctly wired CAN bus."
#~ msgstr ""

#~ msgid ""
#~ "Whenever the \"bridge mcu\" is reset, Linux will disable the corresponding "
#~ "`can0` interface. To ensure proper handling of FIRMWARE_RESTART and RESTART "
#~ "commands, it is recommended to replace `auto` with `allow-hotplug` in the "
#~ "`/etc/network/interfaces.d/can0` file. For example:"
#~ msgstr ""

#~ msgid "Atmega1280"
#~ msgstr ""

#~ msgid ""
#~ "wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/optiboot/optiboot_atmega168.hex'\n"
#~ "\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0x04:m -U hfuse:w:0xDD:m -U lfuse:w:0xFF:m\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega168.hex\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
#~ msgstr ""

#~ msgid "source [find target/at91samdXX.cfg]\n"
#~ msgstr ""

#~ msgid "bossac -U -p /dev/ttyACM0 --offset=0x4000 -w out/klipper.bin -v -b -R\n"
#~ msgstr ""

#~ msgid ""
#~ "It is not possible to use stm32flash for the SKR Mini E3 as the boot0 pin is"
#~ " tied directly to ground and not broken out via header pins. It is "
#~ "recommended to use a STLink V2 with STM32Cubeprogrammer to flash the "
#~ "bootloader. If you don't have access to a STLink it is also possible to use "
#~ "a [Raspberry Pi and OpenOCD](#running-openocd-on-the-raspberry-pi) with the "
#~ "following chip config:"
#~ msgstr ""

#~ msgid "alternatively, you can use `make flash` to flash klipper directly:"
#~ msgstr ""

#~ msgid ""
#~ "The `flash_can.py` utility supplied in the `lib/canboot` folder may be used "
#~ "to upload Klipper firmware. The device UUID is necessary to flash. If you do"
#~ " not have a UUID it is possible to query nodes currently running the "
#~ "bootloader:"
#~ msgstr ""

#~ msgid ""
#~ "It is common for Smoothieboards to come with a bootloader from: "
#~ "<https://github.com/triffid/LPC17xx-DFU-Bootloader>. When using this "
#~ "bootloader the application must be compiled with a start address of 16KiB. "
#~ "The easiest way to flash an application with this bootloader is to copy the "
#~ "application file (eg, `out/klipper.bin`) to a file named `firmware.bin` on "
#~ "an SD card, and then to reboot the micro-controller with that SD card."
#~ msgstr ""

#~ msgid "Run OpenOCD:"
#~ msgstr ""

#~ msgid "ECHO Test result is: {\"%.0fK\" % (3. * freq / ticks / 1000.)}\n"
#~ msgstr ""

#~ msgid "sam3x8e"
#~ msgstr ""

#~ msgid "Beaglebone PRU step rate benchmark"
#~ msgstr ""

#~ msgid "stm32f103"
#~ msgstr ""

#~ msgid "44"
#~ msgstr ""

#~ msgid "lpc1769"
#~ msgstr ""

#~ msgid "3 stepper (200Mhz)"
#~ msgstr ""

#~ msgid ""
#~ "The command dispatch benchmark tests how many \"dummy\" commands the micro-"
#~ "controller can process. It is primarily a test of the hardware communication"
#~ " mechanism. The test is run using the console.py tool (described in "
#~ "<Debugging.md>). The following is cut-and-paste into the console.py terminal"
#~ " window:"
#~ msgstr ""

#~ msgid "sam3x8e (serial)"
#~ msgstr ""

#~ msgid "418K"
#~ msgstr ""

#~ msgid "Host Benchmarks"
#~ msgstr ""

#~ msgid ""
#~ "This example assumes a printer equipped with a round bed radius of 100mm. We"
#~ " will use the same probe offsets as the rectangular example, 24 mm on X and "
#~ "5 mm on Y."
#~ msgstr ""

#~ msgid "![bedmesh_interpolated](img/bedmesh_interpolated.svg)"
#~ msgstr ""

#~ msgid ""
#~ "`relative_reference_index: 7` *Default Value: None (disabled)* When the "
#~ "probed points are generated they are each assigned an index. You can look up"
#~ " this index in klippy.log or by using BED_MESH_OUTPUT (see the section on "
#~ "Bed Mesh GCodes below for more information). If you assign an index to the "
#~ "`relative_reference_index` option, the value probed at this coordinate will "
#~ "replace the probe's z_offset. This effectively makes this coordinate the "
#~ "\"zero\" reference for the mesh."
#~ msgstr ""

#~ msgid "`MESH_MIN`"
#~ msgstr ""

#~ msgid "`BED_MESH_PROFILE REMOVE=default`"
#~ msgstr ""

#~ msgid ""
#~ "If one always prints on a particular tape or printing surface then one may "
#~ "perform the paper test with that tape/surface in place. However, note that "
#~ "tape itself has a thickness and different tapes (or any other printing "
#~ "surface) will impact Z measurements. Be sure to rerun the paper test to "
#~ "measure each type of surface that is in use."
#~ msgstr ""

#~ msgid "Recv: // Z position: 0.130 --> 0.230 <-- 0.280\n"
#~ msgstr ""

#~ msgid ""
#~ "Make sure the OctoPrint web server is accessible - it should be at: "
#~ "<http://beaglebone:5000/>"
#~ msgstr ""

#~ msgid "BL-Touch gone bad"
#~ msgstr ""

#~ msgid "Multi-probing without stowing"
#~ msgstr ""

#~ msgid "A request might look like:"
#~ msgstr ""

#~ msgid "and cause Klipper to send future messages similar to:"
#~ msgstr ""

#~ msgid "objects/list"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows one to request a restart - it is similar to running the"
#~ " G-Code \"RESTART\" command. For example: `{\"id\": 123, \"method\": "
#~ "\"gcode/restart\"}`"
#~ msgstr ""

#~ msgid ""
#~ "A request may look like: `{\"id\": 123, \"method\":\"adxl345/dump_adxl345\","
#~ " \"params\": {\"sensor\": \"adxl345\", \"response_template\": {}}}` and "
#~ "might return: `{\"id\": "
#~ "123,\"result\":{\"header\":[\"time\",\"x_acceleration\",\"y_acceleration\", "
#~ "\"z_acceleration\"]}}` and might later produce asynchronous messages such "
#~ "as: "
#~ "`{\"params\":{\"overflows\":0,\"data\":[[3292.432935,-535.44309,-1529.8374,9561.4],"
#~ " [3292.433256,-382.45935,-1606.32927,9561.48375]]}}`"
#~ msgstr ""

#~ msgid "Commands"
#~ msgstr ""

#~ msgid "Prefer to not specify a hold_current"
#~ msgstr ""

#~ msgid ""
#~ "Tests comparing modes have shown an increased \"positional lag\" of around "
#~ "75% of a full-step during constant velocity moves when using stealthChop "
#~ "mode (for example, on a printer with 40mm rotation_distance and 200 "
#~ "steps_per_rotation, position deviation of constant speed moves increased by "
#~ "~0.150mm). However, this \"delay in obtaining the requested position\" may "
#~ "not manifest as a significant print defect and one may prefer the quieter "
#~ "behavior of stealthChop mode."
#~ msgstr ""

#~ msgid ""
#~ "This guide covers the setup of sensorless homing for the X axis of your "
#~ "(cartesian) printer. However, it works the same with all other axes (that "
#~ "require an end stop). You should configure and tune it for one axis at a "
#~ "time."
#~ msgstr ""

#~ msgid ""
#~ "A stallGuard capable TMC stepper driver (tmc2130, tmc2209, tmc2660, or "
#~ "tmc5160)."
#~ msgstr ""

#~ msgid ""
#~ "Find the stallguard setting with lowest sensitivity that successfully homes "
#~ "with a single touch."
#~ msgstr ""

#~ msgid ""
#~ "The `homing_retract_dist` setting must be set to zero in the `stepper_x` "
#~ "config section to disable the second homing move. The second homing attempt "
#~ "does not add value when using sensorless homing, it will not work reliably, "
#~ "and it will confuse the tuning process."
#~ msgstr ""

#~ msgid ""
#~ "The examples above only show settings specific to sensorless homing. See the"
#~ " [config reference](Config_Reference.md#tmc-stepper-driver-configuration) "
#~ "for all the available options."
#~ msgstr ""

#~ msgid ""
#~ "When searching for maximum_sensitivity, it may be convenient to jump to "
#~ "different VALUE settings (so as to bisect the VALUE parameter). If doing "
#~ "this then be prepared to issue an `M112` command to halt the printer, as a "
#~ "setting with a very low sensitivity may cause the axis to repeatedly "
#~ "\"bang\" into the end of the rail."
#~ msgstr ""

#~ msgid ""
#~ "For tmc2209 set this in the config as `driver_SGTHRS`, for other TMC drivers"
#~ " set this in the config as `driver_SGT`."
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro SENSORLESS_HOME_X]\n"
#~ "gcode:\n"
#~ "    {% set HOME_CUR = 0.700 %}\n"
#~ "    {% set driver_config = printer.configfile.settings['tmc2209 stepper_x'] %}\n"
#~ "    {% set RUN_CUR = driver_config.run_current %}\n"
#~ "    # Set current for sensorless homing\n"
#~ "    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={HOME_CUR}\n"
#~ "    # Pause to ensure driver stall flag is clear\n"
#~ "    G4 P2000\n"
#~ "    # Home\n"
#~ "    G28 X0\n"
#~ "    # Move away\n"
#~ "    G90\n"
#~ "    G1 X5 F1200\n"
#~ "    # Set current during print\n"
#~ "    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={RUN_CUR}\n"
#~ msgstr ""

#~ msgid ""
#~ "After tuning is complete, when homing both X and Y, use macros to ensure "
#~ "that one axis is homed first, then move that carriage away from the axis "
#~ "limit, pause for at least 2 seconds, and then start the homing of the other "
#~ "carriage. The move away from the axis avoids homing one axis while the other"
#~ " is pressed against the axis limit (which may skew the stall detection). The"
#~ " pause is necessary to ensure the driver's stall flag is cleared prior to "
#~ "homing again."
#~ msgstr ""

#~ msgid ""
#~ "In addition, almost all fields can be modified at run-time using the "
#~ "[SET_TMC_FIELD command](G-Codes.md#set_tmc_field)."
#~ msgstr ""

#~ msgid ""
#~ "This occurs when Klipper is unable to communicate with a tmc2208 or tmc2209 "
#~ "driver."
#~ msgstr ""

#~ msgid "Why did I get a \"TMC reports error: ...\" error?"
#~ msgstr ""

#~ msgid ""
#~ "This error may also occur if using stealthChop mode and the TMC driver is "
#~ "not able to accurately predict the mechanical load of the motor. (If the "
#~ "driver makes a poor prediction then it may send too much current through the"
#~ " motor and trigger its own over-current detection.) To test this, disable "
#~ "stealthChop mode and check if the errors continue to occur."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[bed_mesh](Config_Reference.md#bed_mesh) object:"
#~ msgstr ""

#~ msgid "`accepted_screws`: The number of accepted screws."
#~ msgstr ""

#~ msgid "display_status"
#~ msgstr ""

#~ msgid ""
#~ "`last_home.<stepper name>.mcu_position`: The position (as tracked by the "
#~ "micro-controller) of the stepper motor at the end of the last home attempt. "
#~ "The position is the total number of steps taken in a forward direction minus"
#~ " the total number of steps taken in the reverse direction since the micro-"
#~ "controller was last restarted."
#~ msgstr ""

#~ msgid "extruder_stepper"
#~ msgstr ""

#~ msgid "filament_switch_sensor"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[firmware_retraction](Config_Reference.md#firmware_retraction) object:"
#~ msgstr ""

#~ msgid ""
#~ "`position`: The last commanded position of the toolhead using the coordinate"
#~ " system specified in the config file. It is possible to access the x, y, z, "
#~ "and e components of this position (eg, `position.x`)."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[hall_filament_width_sensor](Config_Reference.md#hall_filament_width_sensor)"
#~ " object:"
#~ msgstr ""

#~ msgid ""
#~ "`power`: The last setting of the PWM pin (a value between 0.0 and 1.0) "
#~ "associated with the heater."
#~ msgstr ""

#~ msgid ""
#~ "`state`: The current state of the printer as tracked by the idle_timeout "
#~ "module. It is one of the following strings: \"Idle\", \"Printing\", "
#~ "\"Ready\"."
#~ msgstr ""

#~ msgid ""
#~ "`z_position`: The current height of the nozzle (as the printer currently "
#~ "understands it)."
#~ msgstr ""

#~ msgid ""
#~ "`last_stats.<statistics_name>`: Statistics information on the micro-"
#~ "controller connection."
#~ msgstr ""

#~ msgid "`value`: The \"value\" of the pin, as set by a `SET_PIN` command."
#~ msgstr ""

#~ msgid ""
#~ "`is_paused`: Returns true if a PAUSE command has been executed without a "
#~ "corresponding RESUME."
#~ msgstr ""

#~ msgid ""
#~ "`last_query`: Returns True if the probe was reported as \"triggered\" during"
#~ " the last QUERY_PROBE command. Note, if this is used in a macro, due to the "
#~ "order of template expansion, the QUERY_PROBE command must be run prior to "
#~ "the macro containing this reference."
#~ msgstr ""

#~ msgid "screws_tilt_adjust"
#~ msgstr ""

#~ msgid ""
#~ "`sign`: A string specifying the direction to turn to screw for the necessary"
#~ " adjustment. Either \"CW\" for clockwise or \"CCW\" for counterclockwise. "
#~ "The base screw will not have a `sign` key."
#~ msgstr ""

#~ msgid "temperature sensors"
#~ msgstr ""

#~ msgid "temperature_sensor"
#~ msgstr ""

#~ msgid "`run_current`: The currently set run current."
#~ msgstr ""

#~ msgid ""
#~ "For Delta printers the `cone_start_z` is the max z height at maximum radius "
#~ "(`printer.toolhead.cone_start_z`)."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[virtual_sdcard](Config_Reference.md#virtual_sdcard) object:"
#~ msgstr ""

#~ msgid ""
#~ "`state`: Returns a string indicating the current Klipper state. Possible "
#~ "values are: \"ready\", \"startup\", \"shutdown\", \"error\"."
#~ msgstr ""

#~ msgid "`current_z_adjust`: Last computed Z adjustment [mm]."
#~ msgstr ""

#~ msgid ""
#~ "Eric is the author of bed_mesh, spi_flash, and several other Klipper "
#~ "modules. Eric has a donations page at: <https://ko-fi.com/arksine>"
#~ msgstr ""

#~ msgid ""
#~ "See the [config reference](Config_Reference.md#gcode_macro) for details on "
#~ "defining a gcode_macro."
#~ msgstr ""

#~ msgid "Do not use \"extra restart distance\" on Simplify3d"
#~ msgstr ""

#~ msgid "![skew_lengths](img/skew_lengths.png)"
#~ msgstr ""

#~ msgid ""
#~ "The `[skew_correction]` module also supports profile management in a manner "
#~ "similar to `[bed_mesh]`. After setting skew using the `SET_SKEW` gcode, you "
#~ "may use the `SKEW_PROFILE` gcode to save it:"
#~ msgstr ""

#~ msgid "Verifying your correction"
#~ msgstr ""

#~ msgid "./scripts/flash-sdcard.sh -l\n"
#~ msgstr ""

#~ msgid ""
#~ "./scripts/flash-sdcard.sh -f ~/downloads/klipper.bin /dev/ttyAMA0 btt-"
#~ "skr-v1.3\n"
#~ msgstr ""

#~ msgid ""
#~ "BOARD_DEFS = {\n"
#~ "    'generic-lpc1768': {\n"
#~ "        'mcu': \"lpc1768\",\n"
#~ "        'spi_bus': \"ssp1\",\n"
#~ "        \"cs_pin\": \"P0.6\"\n"
#~ "    },\n"
#~ "    ...<further definitions>\n"
#~ "}\n"
#~ msgstr ""

#~ msgid ""
#~ "If software SPI is required, the `spi_bus` field should be set to `swspi` "
#~ "and the following additional field should be specified:"
#~ msgstr ""

#~ msgid ""
#~ "There are two scenarios -- one with the RPi Host running on a separate power"
#~ " supply and the other when the RPi Host is running on the same power supply "
#~ "as the main board being flashed. The difference is whether or not it's "
#~ "necessary to also shutdown the RPi and then `ssh` again after the flashing "
#~ "is complete in order to do the verification step, or if the verification can"
#~ " be done immediately. Here's examples of the two scenarios:"
#~ msgstr ""

#~ msgid "SDIO to SPI Pin Mapping"
#~ msgstr ""

#~ msgid "None (PU)*"
#~ msgstr ""

#~ msgid "GND (VSS)"
#~ msgstr ""

#~ msgid "\\* None (PU) indicates an unused pin with a pull-up resistor"
#~ msgstr ""

#~ msgid ""
#~ "The `<full_steps_per_rotation>` setting is determined from the type of "
#~ "stepper motor. Most stepper motors are \"1.8 degree steppers\" and therefore"
#~ " have 200 full steps per rotation (360 divided by 1.8 is 200). Some stepper "
#~ "motors are \"0.9 degree steppers\" and thus have 400 full steps per "
#~ "rotation. Other stepper motors are rare. If unsure, do not set "
#~ "full_steps_per_rotation in the config file and use 200 in the formula above."
#~ msgstr ""

#~ msgid ""
#~ "Use a marker to place a mark on the filament around 70mm from the intake of "
#~ "the extruder body. Then use a digital calipers to measure the actual "
#~ "distance of that mark as precisely as one can. Note this as "
#~ "`<initial_mark_distance>`."
#~ msgstr ""

#~ msgid "Belt driven axes"
#~ msgstr ""

#~ msgid ""
#~ "For example, the common \"T8 leadscrew\" has a rotation distance of 8 (it "
#~ "has a pitch of 2mm and has 4 separate threads)."
#~ msgstr ""

#~ msgid ""
#~ "When `gear_ratio` is set, the `rotation_distance` represents the distance "
#~ "the axis moves with one full rotation of the final gear on the gear box. If,"
#~ " for example, one is using a gearbox with a \"5:1\" ratio, then one could "
#~ "calculate the rotation_distance with [knowledge of the hardware](#obtaining-"
#~ "rotation_distance-by-inspecting-the-hardware) and then add `gear_ratio: 5:1`"
#~ " to the config."
#~ msgstr ""

#~ msgid "Infill and top layers can be set to 0."
#~ msgstr ""

#~ msgid ""
#~ "If `square_corner_velocity` parameter was changed, revert it back to 5.0. It"
#~ " is not advised to increase it when using input shaper because it can cause "
#~ "more smoothing in parts - it is better to use higher acceleration value "
#~ "instead."
#~ msgstr ""

#~ msgid ""
#~ "|![Mark ringing](img/ringing-mark.jpg)|![Measure ringing](img/ringing-"
#~ "measure.jpg)|"
#~ msgstr ""

#~ msgid ""
#~ "Note that the ringing frequencies can change if the changes are made to the "
#~ "printer that affect the moving mass or change the stiffness of the system, "
#~ "for example:"
#~ msgstr ""

#~ msgid ""
#~ "[input_shaper]\n"
#~ "shaper_freq_x: ...  # frequency for the X mark of the test model\n"
#~ "shaper_freq_y: ...  # frequency for the Y mark of the test model\n"
#~ msgstr ""

#~ msgid "Execute: `SET_INPUT_SHAPER SHAPER_TYPE=MZV`"
#~ msgstr ""

#~ msgid ""
#~ "EI shaper may be more suited for bed slinger printers (if the resonance "
#~ "frequency and resulting smoothing allows): as more filament is deposited on "
#~ "the moving bed, the mass of the bed increases and the resonance frequency "
#~ "will decrease. Since EI shaper is more robust to resonance frequency "
#~ "changes, it may work better when printing large parts."
#~ msgstr ""

#~ msgid ""
#~ "In this picture, the acceleration increases left to right, and the gap "
#~ "starts to grow starting from 3500 mm/sec^2 (5-th band from the left). So the"
#~ " good value for max_accel = 3000 (mm/sec^2) in this case to avoid the "
#~ "excessive smoothing."
#~ msgstr ""

#~ msgid ""
#~ "Assuming that you have sliced the ringing model with suggested parameters, "
#~ "complete the following steps for each of the axes X and Y:"
#~ msgstr ""

#~ msgid ""
#~ "Find the band which shows ringing the least and count its number from the "
#~ "bottom starting at 1."
#~ msgstr ""

#~ msgid ""
#~ "If you are unable to measure the ringing frequencies, e.g. if the distance "
#~ "between the oscillations is not stable, you may still be able to take "
#~ "advantage of input shaping techniques, but the results may not be as good as"
#~ " with proper measurements of the frequencies, and will require a bit more "
#~ "tuning and printing the test model. Note that another possibility is to "
#~ "purchase and install an accelerometer and measure the resonances with it "
#~ "(refer to the [docs](Measuring_Resonances.md) describing the required "
#~ "hardware and the setup process) - but this option requires some crimping and"
#~ " soldering."
#~ msgstr ""

#~ msgid ""
#~ "`SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=50 SHAPER_FREQ_Y=50`"
#~ msgstr ""

#~ msgid "For 2HUMP_EI 50 Hz shaper, use EI shaper with shaper_freq = 40 Hz."
#~ msgstr ""

#~ msgid "Troubleshooting and FAQ"
#~ msgstr ""

#~ msgid ""
#~ "There is no dedicated support for dual carriages with input shapers, but it "
#~ "does not mean this setup will not work. One should run the tuning twice for "
#~ "each of the carriages, and calculate the ringing frequencies for X and Y "
#~ "axes for each of the carriages independently. Then put the values for "
#~ "carriage 0 into [input_shaper] section, and change the values on the fly "
#~ "when changing carriages, e.g. as a part of some macro:"
#~ msgstr ""

#~ msgid "Input <br> shaper"
#~ msgstr ""

#~ msgid "0.75 / shaper_freq"
#~ msgstr ""

#~ msgid " 20% shaper_freq"
#~ msgstr ""

#~ msgid "-45...+50% shaper_freq"
#~ msgstr ""

#~ msgid ""
#~ "If one needs to reduce vibrations at several very different frequencies "
#~ "(say, 30 Hz and 100 Hz), they may see that the table above does not provide "
#~ "enough information. In this case one may have more luck with "
#~ "[scripts/graph_shaper.py](../scripts/graph_shaper.py) script, which is more "
#~ "flexible."
#~ msgstr ""

#~ msgid "Support for CanBoot bootloader."
#~ msgstr ""

#~ msgid "Available on 20210929. Major changes in this release:"
#~ msgstr ""

#~ msgid ""
#~ "New \"motion analysis\" system. Klipper's internal motion updates and sensor"
#~ " results can be tracked and logged for analysis."
#~ msgstr ""

#~ msgid ""
#~ "New \"Smooth Pressure Advance\" system. This implements \"Pressure Advance\""
#~ " without introducing instantaneous velocity changes. It is also now possible"
#~ " to tune pressure advance using a \"Tuning Tower\" method."
#~ msgstr ""

#~ msgid "Improved handling of Python \"garbage collection\" events."
#~ msgstr ""

#~ msgid "New support for TMC2209 and TMC5160 drivers."
#~ msgstr ""

#~ msgid "Many Klipper micro-controller improvements:"
#~ msgstr ""

#~ msgid "Klipper now has a logo."
#~ msgstr ""

#~ msgid ""
#~ "New support for \"enhanced\" delta calibration (calibrates print x/y "
#~ "dimensions on delta printers)"
#~ msgstr ""

#~ msgid "Support for \"uc1701\" and \"ssd1306\" displays"
#~ msgstr ""

#~ msgid ""
#~ "Documentation updates for bootloaders, benchmarking, micro-controller "
#~ "porting, config checks, pin mapping, slicer settings, packaging, and more"
#~ msgstr ""

#~ msgid "Initial support for \"safe homing\" and homing overrides"
#~ msgstr ""

#~ msgid "Support for setting different arm lengths on each tower of a delta"
#~ msgstr ""

#~ msgid "Available on 20171025. Major changes in this release:"
#~ msgstr ""

#~ msgid "Available on 20170503. Major changes in this release:"
#~ msgstr ""

#~ msgid "Support for AD595 sensors"
#~ msgstr ""

#~ msgid ""
#~ "New \"stepper phased based endstop\" feature - enables higher precision on "
#~ "endstop homing."
#~ msgstr ""

#~ msgid ""
#~ "Support for common g-code commands. Support for interfacing with OctoPrint."
#~ msgstr ""

#~ msgid "After installing Klipper, install the script. run:"
#~ msgstr ""

#~ msgid ""
#~ "Complete the installation by configuring Klipper secondary MCU following the"
#~ " instructions in [RaspberryPi sample config](../config/sample-raspberry-"
#~ "pi.cfg) and [Multi MCU sample config](../config/sample-multi-mcu.cfg)."
#~ msgstr ""

#~ msgid "Optional: Identify the correct gpiochip"
#~ msgstr ""

#~ msgid "To check available gpiochip run:"
#~ msgstr ""

#~ msgid ""
#~ "The chosen pin can thus be used within the configuration as "
#~ "`gpiochip<n>/gpio<o>` where **n** is the chip number as seen by the "
#~ "`gpiodetect` command and **o** is the line number seen by the`gpioinfo` "
#~ "command."
#~ msgstr ""

#~ msgid "Optional: Hardware PWM"
#~ msgstr ""

#~ msgid ""
#~ "The overlay does not expose the pwm line on sysfs on boot and needs to be "
#~ "exported by echo'ing the number of the pwm channel to "
#~ "`/sys/class/pwm/pwmchip0/export`:"
#~ msgstr ""

#~ msgid ""
#~ "[output_pin caselight]\n"
#~ "pin: host:pwmchip0/pwm0\n"
#~ "pwm: True\n"
#~ "hardware_pwm: True\n"
#~ "cycle_time: 0.000001\n"
#~ msgstr ""

#~ msgid "gpio PIN"
#~ msgstr ""

#~ msgid "18"
#~ msgstr ""

#~ msgid ""
#~ "The Klipper transmission protocol can be thought of as a "
#~ "[RPC](https://en.wikipedia.org/wiki/Remote_procedure_call) mechanism between"
#~ " micro-controller and host. The micro-controller software declares the "
#~ "commands that the host may invoke along with the response messages that it "
#~ "can generate. The host uses that information to command the micro-controller"
#~ " to perform actions and to interpret the results."
#~ msgstr ""

#~ msgid ""
#~ "To send information from the micro-controller to the host a \"response\" is "
#~ "generated. These are both declared and transmitted using the sendf() C "
#~ "macro. For example:"
#~ msgstr ""

#~ msgid ""
#~ "The output() function is similar in usage to printf() - it is intended to "
#~ "generate and format arbitrary messages for human consumption."
#~ msgstr ""

#~ msgid "DECL_CONSTANT(\"SERIAL_BAUD\", 250000);\n"
#~ msgstr ""

#~ msgid ""
#~ "The length byte contains the number of bytes in the message block including "
#~ "the header and trailer bytes (thus the minimum message length is 5 bytes). "
#~ "The maximum message block length is currently 64 bytes. The sequence byte "
#~ "contains a 4 bit sequence number in the low-order bits and the high-order "
#~ "bits always contain 0x10 (the high-order bits are reserved for future use). "
#~ "The content bytes contain arbitrary data and its format is described in the "
#~ "following section. The crc bytes contain a 16bit CCITT "
#~ "[CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) of the message "
#~ "block including the header bytes but excluding the trailer bytes. The sync "
#~ "byte is 0x7e."
#~ msgstr ""

#~ msgid ""
#~ "In order to encode and parse the message contents, both the host and micro-"
#~ "controller must agree on the command ids and the number of parameters each "
#~ "command has. So, in the above example, both the host and micro-controller "
#~ "would know that \"id_update_digital_out\" is always followed by two "
#~ "parameters, and \"id_get_config\" and \"id_get_clock\" have zero parameters."
#~ " The host and micro-controller share a \"data dictionary\" that maps the "
#~ "command descriptions (eg, \"update_digital_out oid=%c value=%c\") to their "
#~ "integer command-ids. When processing the data, the parser will know to "
#~ "expect a specific number of VLQ encoded parameters following a given command"
#~ " id."
#~ msgstr ""

#~ msgid "-524288 .. 1572863"
#~ msgstr ""

#~ msgid ""
#~ "In order for meaningful communications to be established between micro-"
#~ "controller and host, both sides must agree on a \"data dictionary\". This "
#~ "data dictionary contains the integer identifiers for commands and responses "
#~ "along with their descriptions."
#~ msgstr ""

#~ msgid ""
#~ "The low-level host code implements an automatic retransmission system for "
#~ "lost and corrupt message blocks sent to the micro-controller. To facilitate "
#~ "this, the micro-controller transmits an \"ack message block\" after each "
#~ "successfully received message block. The host schedules a timeout after "
#~ "sending each block and it will retransmit should the timeout expire without "
#~ "receiving a corresponding \"ack\". In addition, if the micro-controller "
#~ "detects a corrupt or out-of-order block it may transmit a \"nak message "
#~ "block\" to facilitate fast retransmission."
#~ msgstr ""

#~ msgid ""
#~ "Issue a `GET_POSITION` command and record the toolhead XY location reported "
#~ "by that command. For example if one sees:"
#~ msgstr ""

#~ msgid ""
#~ "Providing an accurate probe z_offset is critical to obtaining high quality "
#~ "prints. The z_offset is the distance between the nozzle and bed when the "
#~ "probe triggers. The Klipper `PROBE_CALIBRATE` tool can be used to obtain "
#~ "this value - it will run an automatic probe to measure the probe's Z trigger"
#~ " position and then start a manual probe to obtain the nozzle Z height. The "
#~ "probe z_offset will then be calculated from these measurements."
#~ msgstr ""

#~ msgid ""
#~ "After calibrating the probe X, Y, and Z offsets it is a good idea to verify "
#~ "that the probe provides repeatable results. Start by homing the printer and "
#~ "then move the head to a position near the center of the bed. Navigate to the"
#~ " OctoPrint terminal tab and run the `PROBE_ACCURACY` command."
#~ msgstr ""

#~ msgid ""
#~ "This is a common issue with probes on delta printers, however it can occur "
#~ "on all printers."
#~ msgstr ""

#~ msgid ""
#~ "To check for a temperature bias, start with the printer at room temperature "
#~ "and then home the printer, move the head to a position near the center of "
#~ "the bed, and run the `PROBE_ACCURACY` command. Note the results. Then, "
#~ "without homing or disabling the stepper motors, heat the printer nozzle and "
#~ "bed to printing temperature, and run the `PROBE_ACCURACY` command again. "
#~ "Ideally, the command will report identical results. As above, if the probe "
#~ "does have a temperature bias then be careful to always use the probe at a "
#~ "consistent temperature."
#~ msgstr ""

#~ msgid ""
#~ "This command makes the nozzle travel slower through corners to emphasize the"
#~ " effects of extruder pressure. Then for printers with a direct drive "
#~ "extruder run the command:"
#~ msgstr ""

#~ msgid ""
#~ "Inspect the print and then use a digital calipers to find the height that "
#~ "has the best quality corners. When in doubt, prefer a lower height."
#~ msgstr ""

#~ msgid ""
#~ "The pressure advance value is dependent on the extruder, the nozzle, and the"
#~ " filament. It is common for filament from different manufactures or with "
#~ "different pigments to require significantly different pressure advance "
#~ "values. Therefore, one should calibrate pressure advance on each printer and"
#~ " with each spool of filament."
#~ msgstr ""

#~ msgid ""
#~ "If you are building a package of Klipper from git, it is usual practice not "
#~ "to ship a .git directory, so the versioning must be handled without git. To "
#~ "do this, use the script shipped in `scripts/make_version.py` which should be"
#~ " run as follows: `python2 scripts/make_version.py YOURDISTRONAME > "
#~ "klippy/.version`."
#~ msgstr ""

#~ msgid ""
#~ "[Config changes](Config_Changes.md): Recent software changes that may "
#~ "require users to update their printer config file."
#~ msgstr ""

#~ msgid ""
#~ "[Probe calibrate](Probe_Calibrate.md): Calibration of automatic Z probes."
#~ msgstr ""

#~ msgid "[G-Codes](G-Codes.md): Information on commands supported by Klipper."
#~ msgstr ""

#~ msgid ""
#~ "[Exclude Object](Exclude_Object.md): The guide to the Exclude Objecs "
#~ "implementation."
#~ msgstr ""

#~ msgid ""
#~ "[Benchmarks](Benchmarks.md): Information on the Klipper benchmark method."
#~ msgstr ""

#~ msgid "[CAN bus](CANBUS.md): Information on using CAN bus with Klipper."
#~ msgstr ""

#~ msgid ""
#~ "Note that an axis with multiple steppers (eg, `stepper_z` and `stepper_z1`) "
#~ "need to be on the same micro-controller in order to use multi-mcu homing. "
#~ "For example, if an endstop is on a separate micro-controller from "
#~ "`stepper_z` then `stepper_z1` must be on the same micro-controller as "
#~ "`stepper_z`."
#~ msgstr ""

#~ msgid ""
#~ "***Double-check your wiring before powering up to prevent damaging your "
#~ "MCU/Raspberry Pi or the accelerometer.***"
#~ msgstr ""

#~ msgid "RPi pin"
#~ msgstr ""

#~ msgid "GPIO08 (SPI0_CE0_N)"
#~ msgstr ""

#~ msgid "GPIO11 (SPI0_SCLK)"
#~ msgstr ""

#~ msgid "MPU-9250 pin"
#~ msgstr ""

#~ msgid "Recommended connection scheme for I2C(i2c0a) on the RP2040:"
#~ msgstr ""

#~ msgid "Mounting the accelerometer"
#~ msgstr ""

#~ msgid ""
#~ "sudo apt update\n"
#~ "sudo apt install python3-numpy python3-matplotlib libatlas-base-dev\n"
#~ msgstr ""

#~ msgid ""
#~ "It is advised to start with 1 probe point, in the middle of the print bed, "
#~ "slightly above it."
#~ msgstr ""

#~ msgid "Measuring the resonances"
#~ msgstr ""

#~ msgid ""
#~ "**If you are using MPU-6000/9000 series accelerometer and it show up as "
#~ "`mpu-unknown`, use with caution! They are probably refurbished chips!**"
#~ msgstr ""

#~ msgid "TEST_RESONANCES AXIS=Y\n"
#~ msgstr ""

#~ msgid ""
#~ "or you can choose some other configuration yourself based on the generated "
#~ "charts: peaks in the power spectral density on the charts correspond to the "
#~ "resonance frequencies of the printer."
#~ msgstr ""

#~ msgid ""
#~ "Keep in mind that the input shaper can create some smoothing in parts. "
#~ "Automatic tuning of the input shaper performed by `calibrate_shaper.py` "
#~ "script or `SHAPER_CALIBRATE` command tries not to exacerbate the smoothing, "
#~ "but at the same time they try to minimize the resulting vibrations. "
#~ "Sometimes they can make a sub-optimal choice of the shaper frequency, or "
#~ "maybe you simply prefer to have less smoothing in parts at the expense of a "
#~ "larger remaining vibrations. In these cases, you can request to limit the "
#~ "maximum smoothing from the input shaper."
#~ msgstr ""

#~ msgid "![Resonances](img/calibrate-x-max-smoothing.png)"
#~ msgstr ""

#~ msgid ""
#~ "Alternatively, follow [this](Resonance_Compensation.md#selecting-max_accel) "
#~ "part of the input shaper tuning guide and print the test model to choose "
#~ "`max_accel` parameter experimentally."
#~ msgstr ""

#~ msgid ""
#~ "~/klipper/scripts/graph_accelerometer.py -c /tmp/raw_data_axis*.csv -o "
#~ "/tmp/resonances.png\n"
#~ msgstr ""

#~ msgid "SHAPER_CALIBRATE\n"
#~ msgstr ""

#~ msgid "Input Shaper re-calibration"
#~ msgstr ""

#~ msgid ""
#~ "ignoring any errors for `SET_INPUT_SHAPER` command. For `TEST_RESONANCES` "
#~ "command, specify the desired test axis. The raw data will be written into "
#~ "`/tmp` directory on the RPi."
#~ msgstr ""

#~ msgid "For example,"
#~ msgstr ""

#~ msgid ""
#~ "Combining the resonance data from 2 axis (e.g. on a bed slinger printer to "
#~ "configure X-axis input_shaper from both X and Y axes resonances to cancel "
#~ "vibrations of the *bed* in case the nozzle 'catches' a print when moving in "
#~ "X axis direction)."
#~ msgstr ""

#~ msgid ""
#~ "Then follow the steps described at [\"the paper test\"](Bed_Level.md#the-"
#~ "paper-test) to determine the actual distance between the nozzle and bed at "
#~ "the given location. Once those steps are complete one can `ACCEPT` the "
#~ "position and save the results to the config file with:"
#~ msgstr ""

#~ msgid ""
#~ "Once the config file is ready, run `RESTART` to load that config, and then "
#~ "one can start the tool by running:"
#~ msgstr ""

#~ msgid "![bed_screws](img/bed_screws.svg.png)"
#~ msgstr ""

#~ msgid ""
#~ "[screws_tilt_adjust]\n"
#~ "screw1: -5, 30\n"
#~ "screw1_name: front left screw\n"
#~ "screw2: 155, 30\n"
#~ "screw2_name: front right screw\n"
#~ "screw3: 155, 190\n"
#~ "screw3_name: rear right screw\n"
#~ "screw4: -5, 190\n"
#~ "screw4_name: rear left screw\n"
#~ "horizontal_move_z: 10.\n"
#~ "speed: 50.\n"
#~ "screw_thread: CW-M3\n"
#~ msgstr ""

#~ msgid ""
#~ "Note that \"minutes\" refers to \"minutes of a clock face\". So, for "
#~ "example, 15 minutes is a quarter of a full turn."
#~ msgstr ""

#~ msgid ""
#~ "`set_digital_out pin=%u value=%c` : This command immediately configures the "
#~ "given pin as a digital out GPIO and it sets it to either a low level "
#~ "(value=0) or a high level (value=1). This command may be useful for "
#~ "configuring the initial value of LEDs and for configuring the initial value "
#~ "of stepper driver micro-stepping pins."
#~ msgstr ""

#~ msgid ""
#~ "`finalize_config crc=%u` : The finalize_config command transitions the "
#~ "micro-controller from an unconfigured state to a configured state. The crc "
#~ "parameter passed to the micro-controller is stored and provided back to the "
#~ "host in \"config\" response messages. By convention, the host takes a 32bit "
#~ "CRC of the configuration it will request and at the start of subsequent "
#~ "communication sessions it checks that the CRC stored in the micro-controller"
#~ " exactly matches its desired CRC. If the CRC does not match then the host "
#~ "knows the micro-controller has not been configured in the state desired by "
#~ "the host."
#~ msgstr ""

#~ msgid ""
#~ "`config_spi oid=%c bus=%u pin=%u mode=%u rate=%u shutdown_msg=%*s` : This "
#~ "command creates an internal SPI object. It is used with spi_transfer and "
#~ "spi_send commands (see below). The \"bus\" identifies the SPI bus to use (if"
#~ " the micro-controller has more than one SPI bus available). The \"pin\" "
#~ "specifies the chip select (CS) pin for the device. The \"mode\" is the SPI "
#~ "mode (should be between 0 and 3). The \"rate\" parameter specifies the SPI "
#~ "bus rate (in cycles per second). Finally, the \"shutdown_msg\" is an SPI "
#~ "command to send to the given device should the micro-controller go into a "
#~ "shutdown state."
#~ msgstr ""

#~ msgid ""
#~ "`get_clock` : This command causes the micro-controller to generate a "
#~ "\"clock\" response message. The host sends this command once a second to "
#~ "obtain the value of the micro-controller clock and to estimate the drift "
#~ "between host and micro-controller clocks. It enables the host to accurately "
#~ "estimate the micro-controller clock."
#~ msgstr ""

#~ msgid ""
#~ "Each queue_step command utilizes an entry in the micro-controller \"move "
#~ "queue\". This queue is allocated when it receives the \"finalize_config\" "
#~ "command, and it reports the number of available queue entries in \"config\" "
#~ "response messages."
#~ msgstr ""

#~ msgid "Trapezoid generator"
#~ msgstr ""

#~ msgid "Consider the following two moves contained on an XY plane:"
#~ msgstr ""

#~ msgid "Key formula for look-ahead:"
#~ msgstr ""

#~ msgid "Generating steps"
#~ msgstr ""

#~ msgid ""
#~ "cartesian_x_position = start_x + move_distance * total_x_movement / total_movement\n"
#~ "cartesian_y_position = start_y + move_distance * total_y_movement / total_movement\n"
#~ "cartesian_z_position = start_z + move_distance * total_z_movement / total_movement\n"
#~ msgstr ""

#~ msgid "Delta Robots"
#~ msgstr ""

#~ msgid ""
#~ "Basic extruder movement is simple to calculate. The step time generation "
#~ "uses the same formulas that cartesian robots use:"
#~ msgstr ""

#~ msgid "![pressure-advance](img/pressure-velocity.png)"
#~ msgstr ""

#~ msgid "Prepping an OS image"
#~ msgstr ""

#~ msgid "make\n"
#~ msgstr ""

#~ msgid ""
#~ "When flashing for the first time, make sure that OctoPrint is not connected "
#~ "directly to the printer (from the OctoPrint web page, under the "
#~ "\"Connection\" section, click \"Disconnect\")."
#~ msgstr ""

#~ msgid ""
#~ "The next step is to copy the [printer configuration file](#obtain-a-klipper-"
#~ "configuration-file) to the Raspberry Pi."
#~ msgstr ""

#~ msgid ""
#~ "Klipper reports error messages via the OctoPrint terminal tab. The "
#~ "\"status\" command can be used to re-report error messages. The default "
#~ "Klipper startup script also places a log in **/tmp/klippy.log** which "
#~ "provides more detailed information."
#~ msgstr ""

#~ msgid "Calibration procedure"
#~ msgstr ""

#~ msgid "Logging"
#~ msgstr ""

#~ msgid "Turn off motors: `M18` or `M84`"
#~ msgstr ""

#~ msgid ""
#~ "Note: If S is not specified and both P and T are specified, then the "
#~ "acceleration is set to the minimum of P and T. If only one of P or T is "
#~ "specified, the command has no effect."
#~ msgstr ""

#~ msgid "Set fan speed: `M106 S<value>`"
#~ msgstr ""

#~ msgid "Additional Commands"
#~ msgstr ""

#~ msgid "ACCELEROMETER_DEBUG_READ"
#~ msgstr ""

#~ msgid ""
#~ "`ANGLE_DEBUG_READ CHIP=<config_name> REG=<register>`: Queries sensor "
#~ "register \"register\" (e.g. 44 or 0x2C). Can be useful for debugging "
#~ "purposes. This is only available for tle5012b chips."
#~ msgstr ""

#~ msgid "BED_MESH_MAP"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [bed_screws config "
#~ "section](Config_Reference.md#bed_screws) is enabled (also see the [manual "
#~ "level guide](Manual_Level.md#adjusting-bed-leveling-screws))."
#~ msgstr ""

#~ msgid ""
#~ "`BLTOUCH_DEBUG COMMAND=<command>`: This sends a command to the BLTouch. It "
#~ "may be useful for debugging. Available commands are: `pin_down`, "
#~ "`touch_mode`, `pin_up`, `self_test`, `reset`. A BL-Touch V3.0 or V3.1 may "
#~ "also support `set_5V_output_mode`, `set_OD_output_mode`, `output_mode_store`"
#~ " commands."
#~ msgstr ""

#~ msgid "UPDATE_DELAYED_GCODE"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a [display config "
#~ "section](Config_Reference.md#gcode_macro) is enabled."
#~ msgstr ""

#~ msgid ""
#~ "`SET_DISPLAY_TEXT MSG=<message>`: Performs the equivalent of M117, setting "
#~ "the supplied `MSG` as the current display message. If `MSG` is omitted the "
#~ "display will be cleared."
#~ msgstr ""

#~ msgid "`EXCLUDE_OBJECT`"
#~ msgstr ""

#~ msgid ""
#~ "When the `NAME` parameter is included, this defines an object to be "
#~ "excluded."
#~ msgstr ""

#~ msgid ""
#~ "`EXCLUDE_OBJECT_END [NAME=object_name]`: Denotes the end of the object's "
#~ "gcode for the layer. It is paired with `EXCLUDE_OBJECT_START`. A `NAME` "
#~ "parameter is optional, and will only warn when the provided name does not "
#~ "match the current object."
#~ msgstr ""

#~ msgid "SYNC_EXTRUDER_MOTION"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a "
#~ "[filament_switch_sensor](Config_Reference.md#filament_switch_sensor) or "
#~ "[filament_motion_sensor](Config_Reference.md#filament_motion_sensor) config "
#~ "section is enabled."
#~ msgstr ""

#~ msgid "The following additional commands are also available."
#~ msgstr ""

#~ msgid "FORCE_MOVE"
#~ msgstr ""

#~ msgid "FIRMWARE_RESTART"
#~ msgstr ""

#~ msgid "Arc Plane Select: G17 (XY plane), G18 (XZ plane), G19 (YZ plane)"
#~ msgstr ""

#~ msgid "SET_GCODE_OFFSET"
#~ msgstr ""

#~ msgid "`QUERY_FILAMENT_WIDTH`: Return the current measured filament width."
#~ msgstr ""

#~ msgid ""
#~ "`QUERY_RAW_FILAMENT_WIDTH`: Return the current ADC channel readings and RAW "
#~ "sensor value for calibration points."
#~ msgstr ""

#~ msgid "`TURN_OFF_HEATERS`: Turn off all heaters."
#~ msgstr ""

#~ msgid ""
#~ "The following command is enabled if an [input_shaper config "
#~ "section](Config_Reference.md#input_shaper) has been enabled (also see the "
#~ "[resonance compensation guide](Resonance_Compensation.md))."
#~ msgstr ""

#~ msgid "`ABORT`: This command terminates the manual probing tool."
#~ msgstr ""

#~ msgid ""
#~ "`MANUAL_STEPPER STEPPER=config_name [ENABLE=[0|1]] [SET_POSITION=<pos>] "
#~ "[SPEED=<speed>] [ACCEL=<accel>] [MOVE=<pos> [STOP_ON_ENDSTOP=[1|2|-1|-2]] "
#~ "[SYNC=0]]`: This command will alter the state of the stepper. Use the ENABLE"
#~ " parameter to enable/disable the stepper. Use the SET_POSITION parameter to "
#~ "force the stepper to think it is at the given position. Use the MOVE "
#~ "parameter to request a movement to the given position. If SPEED and/or ACCEL"
#~ " is specified then the given values will be used instead of the defaults "
#~ "specified in the config file. If an ACCEL of zero is specified then no "
#~ "acceleration will be performed. If STOP_ON_ENDSTOP=1 is specified then the "
#~ "move will end early should the endstop report as triggered (use "
#~ "STOP_ON_ENDSTOP=2 to complete the move without error even if the endstop "
#~ "does not trigger, use -1 or -2 to stop when the endstop reports not "
#~ "triggered). Normally future G-Code commands will be scheduled to run after "
#~ "the stepper move completes, however if a manual stepper move uses SYNC=0 "
#~ "then future G-Code movement commands may run in parallel with the stepper "
#~ "movement."
#~ msgstr ""

#~ msgid ""
#~ "`SET_LED_TEMPLATE LED=<led_name> TEMPLATE=<template_name> "
#~ "[<param_x>=<literal>] [INDEX=<index>]`: Assign a "
#~ "[display_template](Config_Reference.md#display_template) to a given "
#~ "[LED](Config_Reference.md#leds). For example, if one defined a "
#~ "`[display_template my_led_template]` config section then one could assign "
#~ "`TEMPLATE=my_led_template` here. The display_template should produce a comma"
#~ " separated string containing four floating point numbers corresponding to "
#~ "red, green, blue, and white color settings. The template will be "
#~ "continuously evaluated and the LED will be automatically set to the "
#~ "resulting colors. One may set display_template parameters to use during "
#~ "template evaluation (parameters will be parsed as Python literals). If INDEX"
#~ " is not specified then all chips in the LED's daisy-chain will be set to the"
#~ " template, otherwise only the chip with the given index will be updated. If "
#~ "TEMPLATE is an empty string then this command will clear any previous "
#~ "template assigned to the LED (one can then use `SET_LED` commands to manage "
#~ "the LED's color settings)."
#~ msgstr ""

#~ msgid ""
#~ "`PALETTE_CONNECT`: This command initializes the connection with the Palette "
#~ "2."
#~ msgstr ""

#~ msgid ""
#~ "`PALETTE_SMART_LOAD`: This command start the smart load sequence on the "
#~ "Palette 2. Filament is loaded automatically by extruding it the distance "
#~ "calibrated on the device for the printer, and instructs the Palette 2 once "
#~ "the loading has been completed. This command is the same as pressing **Smart"
#~ " Load** directly on the Palette 2 screen after the filament load is "
#~ "complete."
#~ msgstr ""

#~ msgid "RESUME"
#~ msgstr ""

#~ msgid "SET_PRINT_STATS_INFO"
#~ msgstr ""

#~ msgid ""
#~ "`PROBE_ACCURACY [PROBE_SPEED=<mm/s>] [SAMPLES=<count>] "
#~ "[SAMPLE_RETRACT_DIST=<mm>]`: Calculate the maximum, minimum, average, "
#~ "median, and standard deviation of multiple probe samples. By default, 10 "
#~ "SAMPLES are taken. Otherwise the optional parameters default to their "
#~ "equivalent setting in the probe config section."
#~ msgstr ""

#~ msgid ""
#~ "`QUERY_ADC [NAME=<config_name>] [PULLUP=<value>]`: Report the last analog "
#~ "value received for a configured analog pin. If NAME is not provided, the "
#~ "list of available adc names are reported. If PULLUP is provided (as a value "
#~ "in Ohms), the raw analog value along with the equivalent resistance given "
#~ "that pullup is reported."
#~ msgstr ""

#~ msgid ""
#~ "`MEASURE_AXES_NOISE`: Measures and outputs the noise for all axes of all "
#~ "enabled accelerometer chips."
#~ msgstr ""

#~ msgid ""
#~ "`RESPOND MSG=\"<message>\"`: echo the message prepended with the configured "
#~ "default prefix (or `echo: ` if no prefix is configured)."
#~ msgstr ""

#~ msgid ""
#~ "`SAVE_VARIABLE VARIABLE=<name> VALUE=<value>`: Saves the variable to disk so"
#~ " that it can be used across restarts. All stored variables are loaded into "
#~ "the `printer.save_variables.variables` dict at startup and can be used in "
#~ "gcode macros. The provided VALUE is parsed as a Python literal."
#~ msgstr ""

#~ msgid "`SDCARD_LOOP_END`: End a looped section in the SD print."
#~ msgstr ""

#~ msgid ""
#~ "`SET_SKEW [XY=<ac_length,bd_length,ad_length>] [XZ=<ac,bd,ad>] "
#~ "[YZ=<ac,bd,ad>] [CLEAR=<0|1>]`: Configures the [skew_correction] module with"
#~ " measurements (in mm) taken from a calibration print. One may enter "
#~ "measurements for any combination of planes, planes not entered will retain "
#~ "their current value. If `CLEAR=1` is entered then all skew correction will "
#~ "be disabled."
#~ msgstr ""

#~ msgid "SET_SMART_EFFECTOR"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a [temperature_fan config "
#~ "section](Config_Reference.md#temperature_fan) is enabled."
#~ msgstr ""

#~ msgid ""
#~ "`INIT_TMC STEPPER=<name>`: This command will initialize the TMC registers. "
#~ "Needed to re-enable the driver if power to the chip is turned off then back "
#~ "on."
#~ msgstr ""

#~ msgid ""
#~ "`SET_VELOCITY_LIMIT [VELOCITY=<value>] [ACCEL=<value>] "
#~ "[ACCEL_TO_DECEL=<value>] [SQUARE_CORNER_VELOCITY=<value>]`: Modify the "
#~ "printer's velocity limits."
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports the following standard G-Code commands if the "
#~ "[virtual_sdcard config section](Config_Reference.md#virtual_sdcard) is "
#~ "enabled:"
#~ msgstr ""

#~ msgid ""
#~ "In addition, the following extended commands are available when the "
#~ "\"virtual_sdcard\" config section is enabled."
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [z_tilt config "
#~ "section](Config_Reference.md#z_tilt) is enabled."
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports \"Input Shaping\" to reduce the impact of vibrations on "
#~ "print quality. This can reduce or eliminate \"ringing\" (also known as "
#~ "\"ghosting\", \"echoing\", or \"rippling\") in prints. It may also allow one"
#~ " to obtain faster printing speeds while still maintaining high print "
#~ "quality."
#~ msgstr ""

#~ msgid "Klipper supports many standard 3d printer features:"
#~ msgstr ""

#~ msgid ""
#~ "Support for common temperature sensors (eg, common thermistors, AD595, "
#~ "AD597, AD849x, PT100, PT1000, MAX6675, MAX31855, MAX31856, MAX31865, BME280,"
#~ " HTU21D, DS18B20, and LM75). Custom thermistors and custom analog "
#~ "temperature sensors can also be configured. One can monitor the internal "
#~ "micro-controller temperature sensor and the internal temperature sensor of a"
#~ " Raspberry Pi."
#~ msgstr ""

#~ msgid ""
#~ "Support for measuring and recording acceleration using an adxl345, mpu9250, "
#~ "and mpu6050 accelerometers."
#~ msgstr ""

#~ msgid "3 steppers active"
#~ msgstr ""

#~ msgid "686K"
#~ msgstr ""

#~ msgid "STM32G0B1"
#~ msgstr ""

#~ msgid "981K"
#~ msgstr ""

#~ msgid "2353K"
#~ msgstr ""

#~ msgid "SAMD51"
#~ msgstr ""

#~ msgid "2634K"
#~ msgstr ""

#~ msgid ""
#~ "The name found in the above command is stable and it is possible to use it "
#~ "in the config file and while flashing the micro-controller code. For "
#~ "example, a flash command might look similar to:"
#~ msgstr ""

#~ msgid ""
#~ "If you're having an intermittent failure or you do have a standard setup, "
#~ "then double check that Klipper isn't running when flashing (sudo service "
#~ "klipper stop), make sure OctoPrint isn't trying to connect directly to the "
#~ "device (open the Connection tab in the web page and click Disconnect if the "
#~ "Serial Port is set to the device), and make sure FLASH_DEVICE is set "
#~ "correctly for your board (see the [question above](#wheres-my-serial-port))."
#~ msgstr ""

#~ msgid "Can I run Klipper on something other than a Raspberry Pi 3?"
#~ msgstr ""

#~ msgid "Can I run multiple instances of Klipper on the same host machine?"
#~ msgstr ""

#~ msgid ""
#~ "Klipper creates a \"virtual serial port\" via the \"/tmp/printer\" file, and"
#~ " it emulates a classic 3d-printer serial interface via that file. In "
#~ "general, alternative software may work with Klipper as long as it can be "
#~ "configured to use \"/tmp/printer\" for the printer serial port."
#~ msgstr ""

#~ msgid ""
#~ "I converted my config from Marlin and the X/Y axes work fine, but I just get"
#~ " a screeching noise when homing the Z axis"
#~ msgstr ""

#~ msgid ""
#~ "If using a Raspberry Pi, use a [good quality power "
#~ "supply](https://www.raspberrypi.com/documentation/computers/raspberry-"
#~ "pi.html#power-supply) for the Raspberry Pi and use a [good quality USB "
#~ "cable](https://forums.raspberrypi.com/viewtopic.php?p=589877#p589877) to "
#~ "connect that power supply to the Pi. If you get \"under voltage\" warnings "
#~ "from OctoPrint, this is related to the power supply and it must be fixed."
#~ msgstr ""

#~ msgid ""
#~ "The workaround is to use a restart_method other than \"command\" or to flash"
#~ " an updated bootloader to the AVR device. Flashing a new bootloader is a one"
#~ " time step that typically requires an external programmer - see "
#~ "[Bootloaders](Bootloaders.md) for further details."
#~ msgstr ""

#~ msgid ""
#~ "Long answer: Klipper uses the standard pin names defined by the micro-"
#~ "controller. On the Atmega chips these hardware pins have names like `PA4`, "
#~ "`PC7`, or `PD2`."
#~ msgstr ""

#~ msgid ""
#~ "SPI pins: When using hardware SPI it is necessary to wire the pins to the "
#~ "micro-controller's SPI capable pins. However, most devices can be configured"
#~ " to use \"software SPI\", in which case any general purpose IO pins may be "
#~ "used."
#~ msgstr ""

#~ msgid ""
#~ "Note that endstop switches themselves tend to trigger at slightly different "
#~ "positions, so a difference of a couple of microsteps is likely the result of"
#~ " endstop inaccuracies. A stepper motor itself can only lose steps in "
#~ "increments of 4 full steps. (So, if one is using 16 microsteps, then a lost "
#~ "step on the stepper would result in the \"mcu:\" step counter being off by a"
#~ " multiple of 64 microsteps.)"
#~ msgstr ""

#~ msgid ""
#~ "cd ~/klipper\n"
#~ "git pull\n"
#~ "~/klipper/scripts/install-octopi.sh\n"
#~ msgstr ""

#~ msgid "How do I uninstall Klipper?"
#~ msgstr ""

#~ msgid ""
#~ "When Klipper processes the `EXCLUDE_OBJECT_DEFINE` block, it will update the"
#~ " status with the known objects and pass it on to clients."
#~ msgstr ""

#~ msgid "Object Definitions"
#~ msgstr ""

#~ msgid "The Klipper firmware is restarted."
#~ msgstr ""

#~ msgid ""
#~ "The `kit` prefix is for 3d printers that are assembled according to a widely"
#~ " used specification. These \"kit\" printers are generally distinct from "
#~ "normal \"printers\" in that they are not sold by a manufacturer."
#~ msgstr ""

#~ msgid ""
#~ "Do not specify `pressure_advance` in an example config, as that value is "
#~ "specific to the filament, not the printer hardware. Similarly, do not "
#~ "specify `max_extrude_only_velocity` nor `max_extrude_only_accel` settings."
#~ msgstr ""

#~ msgid ""
#~ "Avoid defining field values that are set to their default value. For "
#~ "example, one should not specify `min_extrude_temp: 170` as that is already "
#~ "the default value."
#~ msgstr ""

#~ msgid "[endstop_phase]\n"
#~ msgstr ""

#~ msgid ""
#~ "In order to use this system the endstop must be accurate enough to identify "
#~ "the stepper position within two \"full steps\". So, for example, if a "
#~ "stepper is using 16 micro-steps with a step distance of 0.005mm then the "
#~ "endstop must have an accuracy of at least 0.160mm. If one gets \"Endstop "
#~ "stepper_z incorrect phase\" type error messages than in may be due to an "
#~ "endstop that is not sufficiently accurate. If recalibration does not help "
#~ "then disable endstop phase adjustments by removing them from the config "
#~ "file."
#~ msgstr ""

#~ msgid ""
#~ "If using a probe that is mounted on the side of the hotend (that is, it has "
#~ "an X or Y offset) then note that performing delta calibration will "
#~ "invalidate the results of probe calibration. These types of probes are "
#~ "rarely suitable for use on a delta (because minor effector tilt will result "
#~ "in a probe location bias). If using the probe anyway, then be sure to rerun "
#~ "probe calibration after any delta calibration."
#~ msgstr ""

#~ msgid ""
#~ "After probing the seven points new delta parameters will be calculated. Save"
#~ " and apply these parameters by running:"
#~ msgstr ""

#~ msgid ""
#~ "If possible, perform the measurements described below while the object is "
#~ "still attached to the print bed, but don't worry if the part detaches from "
#~ "the bed - just try to avoid bending the object when performing the "
#~ "measurements."
#~ msgstr ""

#~ msgid ""
#~ "Then measure the distance between the A pillar and the pillar across from "
#~ "the C label."
#~ msgstr ""

#~ msgid "![delta_cal_e_step3](img/delta_cal_e_step3.png)"
#~ msgstr ""

#~ msgid "DELTA_ANALYZE OUTER_PILLAR_WIDTHS=<a>,<far_c>,<b>,<far_a>,<c>,<far_b>\n"
#~ msgstr ""

#~ msgid ""
#~ "If the delta printer has good dimensional accuracy then the distance between"
#~ " any two pillars should be around 74mm and the width of every pillar should "
#~ "be around 9mm. (Specifically, the goal is for the distance between any two "
#~ "pillars minus the width of one of the pillars to be exactly 65mm.) Should "
#~ "there be a dimensional inaccuracy in the part then the DELTA_ANALYZE routine"
#~ " will calculate new delta parameters using both the distance measurements "
#~ "and the previous height measurements from the last DELTA_CALIBRATE command."
#~ msgstr ""

#~ msgid ""
#~ "tar xfz klipper-dict-20??????.tar.gz\n"
#~ "~/klippy-env/bin/python ~/klipper/scripts/test_klippy.py -d dict/ ~/klipper/test/klippy/*.test\n"
#~ msgstr ""

#~ msgid ""
#~ "To run Klippy in this batch mode, there is a one time step necessary to "
#~ "generate the micro-controller \"data dictionary\". This is done by compiling"
#~ " the micro-controller code to obtain the **out/klipper.dict** file:"
#~ msgstr ""

#~ msgid "Motion analysis and data logging"
#~ msgstr ""

#~ msgid "Graphs can be generated with a command like the following:"
#~ msgstr ""

#~ msgid ""
#~ "Many matplotlib options are available; some examples are \"color\", "
#~ "\"label\", \"alpha\", and \"linestyle\"."
#~ msgstr ""

#~ msgid "One can then view the resulting **loadgraph.png** file."
#~ msgstr ""

#~ msgid ""
#~ "To use simulavr, download the simulavr package and compile with python "
#~ "support. Note that the build system may need to have some packages (such as "
#~ "swig) installed in order to build the python module."
#~ msgstr ""

#~ msgid ""
#~ "cd /path/to/klipper\n"
#~ "make menuconfig\n"
#~ msgstr ""

#~ msgid ""
#~ "One useful feature of simulavr is its ability to create signal wave "
#~ "generation files with the exact timing of events. To do this, follow the "
#~ "directions above, but run avrsim.py with a command-line like the following:"
#~ msgstr ""

#~ msgid ""
#~ "[I found a bug in the Klipper software](#i-found-a-bug-in-the-klipper-"
#~ "software)"
#~ msgstr ""

#~ msgid "I have a question about Klipper"
#~ msgstr ""

#~ msgid ""
#~ "Unfortunately, we receive many more requests for help than we could possibly"
#~ " answer. Most problem reports we see are eventually tracked down to:"
#~ msgstr ""

#~ msgid ""
#~ "Problems should be reported in the [Klipper Community Forum](#community-"
#~ "forum)."
#~ msgstr ""

#~ msgid ""
#~ "Do not modify the log file in any way; do not provide a snippet of the log. "
#~ "Only the full unmodified log file provides the necessary information."
#~ msgstr ""

#~ msgid ""
#~ "Klipper github may be used by contributors to share the status of their work"
#~ " to improve Klipper. It is expected that the person opening a github ticket "
#~ "is actively working on the given task and will be the one performing all the"
#~ " work necessary to accomplish it. The Klipper github is not used for "
#~ "requests, nor to report bugs, nor to ask questions. Use the [Klipper "
#~ "Community Forum](#community-forum) or the [Klipper Community "
#~ "Discord](#discord-chat) instead."
#~ msgstr ""

#~ msgid "Verify M112"
#~ msgstr ""

#~ msgid "Verify endstops"
#~ msgstr ""

#~ msgid ""
#~ "After verifying all endstops and verifying all stepper motors the homing "
#~ "mechanism should be tested. Issue a G28 command to home all axes. Remove "
#~ "power from the printer if it does not home properly. Rerun the endstop and "
#~ "stepper motor verification steps if necessary."
#~ msgstr ""

#~ msgid "Next steps"
#~ msgstr ""

#~ msgid ""
#~ "Input pins may be preceded by `^` to indicate that a hardware pull-up "
#~ "resistor should be enabled for the pin. If the micro-controller supports "
#~ "pull-down resistors then an input pin may alternatively be preceded by `~`."
#~ msgstr ""

#~ msgid "Common kinematic settings"
#~ msgstr ""

#~ msgid "Cartesian Kinematics"
#~ msgstr ""

#~ msgid "Deltesian Kinematics"
#~ msgstr ""

#~ msgid "CoreXZ Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: hybrid_corexy\n"
#~ "max_z_velocity:\n"
#~ "#   This sets the maximum velocity (in mm/s) of movement along the z\n"
#~ "#   axis. The default is to use max_velocity for max_z_velocity.\n"
#~ "max_z_accel:\n"
#~ "#   This sets the maximum acceleration (in mm/s^2) of movement along\n"
#~ "#   the z axis. The default is to use max_accel for max_z_accel.\n"
#~ "\n"
#~ "# The stepper_x section is used to describe the X axis as well as the\n"
#~ "# stepper controlling the X-Y movement.\n"
#~ "[stepper_x]\n"
#~ "\n"
#~ "# The stepper_y section is used to describe the stepper controlling\n"
#~ "# the Y axis.\n"
#~ "[stepper_y]\n"
#~ "\n"
#~ "# The stepper_z section is used to describe the stepper controlling\n"
#~ "# the Z axis.\n"
#~ "[stepper_z]\n"
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: polar\n"
#~ "max_z_velocity:\n"
#~ "#   This sets the maximum velocity (in mm/s) of movement along the z\n"
#~ "#   axis. This setting can be used to restrict the maximum speed of\n"
#~ "#   the z stepper motor. The default is to use max_velocity for\n"
#~ "#   max_z_velocity.\n"
#~ "max_z_accel:\n"
#~ "#   This sets the maximum acceleration (in mm/s^2) of movement along\n"
#~ "#   the z axis. It limits the acceleration of the z stepper motor. The\n"
#~ "#   default is to use max_accel for max_z_accel.\n"
#~ "\n"
#~ "# The stepper_bed section is used to describe the stepper controlling\n"
#~ "# the bed.\n"
#~ "[stepper_bed]\n"
#~ "gear_ratio:\n"
#~ "#   A gear_ratio must be specified and rotation_distance may not be\n"
#~ "#   specified. For example, if the bed has an 80 toothed pulley driven\n"
#~ "#   by a stepper with a 16 toothed pulley then one would specify a\n"
#~ "#   gear ratio of \"80:16\". This parameter must be provided.\n"
#~ "\n"
#~ "# The stepper_arm section is used to describe the stepper controlling\n"
#~ "# the carriage on the arm.\n"
#~ "[stepper_arm]\n"
#~ "\n"
#~ "# The stepper_z section is used to describe the stepper controlling\n"
#~ "# the Z axis.\n"
#~ "[stepper_z]\n"
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to cable winch printers are described here - see "
#~ "[common kinematic settings](#common-kinematic-settings) for available "
#~ "parameters."
#~ msgstr ""

#~ msgid ""
#~ "[extruder]\n"
#~ "step_pin:\n"
#~ "dir_pin:\n"
#~ "enable_pin:\n"
#~ "microsteps:\n"
#~ "rotation_distance:\n"
#~ "#full_steps_per_rotation:\n"
#~ "#gear_ratio:\n"
#~ "#   See the \"stepper\" section for a description of the above\n"
#~ "#   parameters. If none of the above parameters are specified then no\n"
#~ "#   stepper will be associated with the nozzle hotend (though a\n"
#~ "#   SYNC_EXTRUDER_MOTION command may associate one at run-time).\n"
#~ "nozzle_diameter:\n"
#~ "#   Diameter of the nozzle orifice (in mm). This parameter must be\n"
#~ "#   provided.\n"
#~ "filament_diameter:\n"
#~ "#   The nominal diameter of the raw filament (in mm) as it enters the\n"
#~ "#   extruder. This parameter must be provided.\n"
#~ "#max_extrude_cross_section:\n"
#~ "#   Maximum area (in mm^2) of an extrusion cross section (eg,\n"
#~ "#   extrusion width multiplied by layer height). This setting prevents\n"
#~ "#   excessive amounts of extrusion during relatively small XY moves.\n"
#~ "#   If a move requests an extrusion rate that would exceed this value\n"
#~ "#   it will cause an error to be returned. The default is: 4.0 *\n"
#~ "#   nozzle_diameter^2\n"
#~ "#instantaneous_corner_velocity: 1.000\n"
#~ "#   The maximum instantaneous velocity change (in mm/s) of the\n"
#~ "#   extruder during the junction of two moves. The default is 1mm/s.\n"
#~ "#max_extrude_only_distance: 50.0\n"
#~ "#   Maximum length (in mm of raw filament) that a retraction or\n"
#~ "#   extrude-only move may have. If a retraction or extrude-only move\n"
#~ "#   requests a distance greater than this value it will cause an error\n"
#~ "#   to be returned. The default is 50mm.\n"
#~ "#max_extrude_only_velocity:\n"
#~ "#max_extrude_only_accel:\n"
#~ "#   Maximum velocity (in mm/s) and acceleration (in mm/s^2) of the\n"
#~ "#   extruder motor for retractions and extrude-only moves. These\n"
#~ "#   settings do not have any impact on normal printing moves. If not\n"
#~ "#   specified then they are calculated to match the limit an XY\n"
#~ "#   printing move with a cross section of 4.0*nozzle_diameter^2 would\n"
#~ "#   have.\n"
#~ "#pressure_advance: 0.0\n"
#~ "#   The amount of raw filament to push into the extruder during\n"
#~ "#   extruder acceleration. An equal amount of filament is retracted\n"
#~ "#   during deceleration. It is measured in millimeters per\n"
#~ "#   millimeter/second. The default is 0, which disables pressure\n"
#~ "#   advance.\n"
#~ "#pressure_advance_smooth_time: 0.040\n"
#~ "#   A time range (in seconds) to use when calculating the average\n"
#~ "#   extruder velocity for pressure advance. A larger value results in\n"
#~ "#   smoother extruder movements. This parameter may not exceed 200ms.\n"
#~ "#   This setting only applies if pressure_advance is non-zero. The\n"
#~ "#   default is 0.040 (40 milliseconds).\n"
#~ "#\n"
#~ "# The remaining variables describe the extruder heater.\n"
#~ "heater_pin:\n"
#~ "#   PWM output pin controlling the heater. This parameter must be\n"
#~ "#   provided.\n"
#~ "#max_power: 1.0\n"
#~ "#   The maximum power (expressed as a value from 0.0 to 1.0) that the\n"
#~ "#   heater_pin may be set to. The value 1.0 allows the pin to be set\n"
#~ "#   fully enabled for extended periods, while a value of 0.5 would\n"
#~ "#   allow the pin to be enabled for no more than half the time. This\n"
#~ "#   setting may be used to limit the total power output (over extended\n"
#~ "#   periods) to the heater. The default is 1.0.\n"
#~ "sensor_type:\n"
#~ "#   Type of sensor - common thermistors are \"EPCOS 100K B57560G104F\",\n"
#~ "#   \"ATC Semitec 104GT-2\", \"ATC Semitec 104NT-4-R025H42G\", \"Generic\n"
#~ "#   3950\",\"Honeywell 100K 135-104LAG-J01\", \"NTC 100K MGB18-104F39050L32\",\n"
#~ "#   \"SliceEngineering 450\", and \"TDK NTCG104LH104JT1\". See the\n"
#~ "#   \"Temperature sensors\" section for other sensors. This parameter\n"
#~ "#   must be provided.\n"
#~ "sensor_pin:\n"
#~ "#   Analog input pin connected to the sensor. This parameter must be\n"
#~ "#   provided.\n"
#~ "#pullup_resistor: 4700\n"
#~ "#   The resistance (in ohms) of the pullup attached to the thermistor.\n"
#~ "#   This parameter is only valid when the sensor is a thermistor. The\n"
#~ "#   default is 4700 ohms.\n"
#~ "#smooth_time: 1.0\n"
#~ "#   A time value (in seconds) over which temperature measurements will\n"
#~ "#   be smoothed to reduce the impact of measurement noise. The default\n"
#~ "#   is 1 seconds.\n"
#~ "control:\n"
#~ "#   Control algorithm (either pid or watermark). This parameter must\n"
#~ "#   be provided.\n"
#~ "pid_Kp:\n"
#~ "pid_Ki:\n"
#~ "pid_Kd:\n"
#~ "#   The proportional (pid_Kp), integral (pid_Ki), and derivative\n"
#~ "#   (pid_Kd) settings for the PID feedback control system. Klipper\n"
#~ "#   evaluates the PID settings with the following general formula:\n"
#~ "#     heater_pwm = (Kp*error + Ki*integral(error) - Kd*derivative(error)) / 255\n"
#~ "#   Where \"error\" is \"requested_temperature - measured_temperature\"\n"
#~ "#   and \"heater_pwm\" is the requested heating rate with 0.0 being full\n"
#~ "#   off and 1.0 being full on. Consider using the PID_CALIBRATE\n"
#~ "#   command to obtain these parameters. The pid_Kp, pid_Ki, and pid_Kd\n"
#~ "#   parameters must be provided for PID heaters.\n"
#~ "#max_delta: 2.0\n"
#~ "#   On 'watermark' controlled heaters this is the number of degrees in\n"
#~ "#   Celsius above the target temperature before disabling the heater\n"
#~ "#   as well as the number of degrees below the target before\n"
#~ "#   re-enabling the heater. The default is 2 degrees Celsius.\n"
#~ "#pwm_cycle_time: 0.100\n"
#~ "#   Time in seconds for each software PWM cycle of the heater. It is\n"
#~ "#   not recommended to set this unless there is an electrical\n"
#~ "#   requirement to switch the heater faster than 10 times a second.\n"
#~ "#   The default is 0.100 seconds.\n"
#~ "#min_extrude_temp: 170\n"
#~ "#   The minimum temperature (in Celsius) at which extruder move\n"
#~ "#   commands may be issued. The default is 170 Celsius.\n"
#~ "min_temp:\n"
#~ "max_temp:\n"
#~ "#   The maximum range of valid temperatures (in Celsius) that the\n"
#~ "#   heater must remain within. This controls a safety feature\n"
#~ "#   implemented in the micro-controller code - should the measured\n"
#~ "#   temperature ever fall outside this range then the micro-controller\n"
#~ "#   will go into a shutdown state. This check can help detect some\n"
#~ "#   heater and sensor hardware failures. Set this range just wide\n"
#~ "#   enough so that reasonable temperatures do not result in an error.\n"
#~ "#   These parameters must be provided.\n"
#~ msgstr ""

#~ msgid ""
#~ " rectangular bed, probe_count = 3, 3:\n"
#~ "             x---x---x (max_point)\n"
#~ "             |\n"
#~ "             x---x---x\n"
#~ "                     |\n"
#~ " (min_point) x---x---x\n"
#~ "\n"
#~ " round bed, round_probe_count = 5, bed_radius = r:\n"
#~ "                 x (0, r) end\n"
#~ "               /\n"
#~ "             x---x---x\n"
#~ "                       \\\n"
#~ " (-r, 0) x---x---x---x---x (r, 0)\n"
#~ "           \\\n"
#~ "             x---x---x\n"
#~ "                   /\n"
#~ "                 x  (0, -r) start\n"
#~ msgstr ""

#~ msgid ""
#~ "Tool to help adjust bed screws tilt using Z probe. One may define a "
#~ "screws_tilt_adjust config section to enable a SCREWS_TILT_CALCULATE g-code "
#~ "command."
#~ msgstr ""

#~ msgid "Where x is the 0, 0 point on the bed"
#~ msgstr ""

#~ msgid "[safe_z_home]"
#~ msgstr ""

#~ msgid ""
#~ "[endstop_phase stepper_z]\n"
#~ "#endstop_accuracy:\n"
#~ "#   Sets the expected accuracy (in mm) of the endstop. This represents\n"
#~ "#   the maximum error distance the endstop may trigger (eg, if an\n"
#~ "#   endstop may occasionally trigger 100um early or up to 100um late\n"
#~ "#   then set this to 0.200 for 200um). The default is\n"
#~ "#   4*rotation_distance/full_steps_per_rotation.\n"
#~ "#trigger_phase:\n"
#~ "#   This specifies the phase of the stepper motor driver to expect\n"
#~ "#   when hitting the endstop. It is composed of two numbers separated\n"
#~ "#   by a forward slash character - the phase and the total number of\n"
#~ "#   phases (eg, \"7/64\"). Only set this value if one is sure the\n"
#~ "#   stepper motor driver is reset every time the mcu is reset. If this\n"
#~ "#   is not set, then the stepper phase will be detected on the first\n"
#~ "#   home and that phase will be used on all subsequent homes.\n"
#~ "#endstop_align_zero: False\n"
#~ "#   If true then the position_endstop of the axis will effectively be\n"
#~ "#   modified so that the zero position for the axis occurs at a full\n"
#~ "#   step on the stepper motor. (If used on the Z axis and the print\n"
#~ "#   layer height is a multiple of a full step distance then every\n"
#~ "#   layer will occur on a full step.) The default is False.\n"
#~ msgstr ""

#~ msgid ""
#~ "Idle timeout. An idle timeout is automatically enabled - add an explicit "
#~ "idle_timeout config section to change the default settings."
#~ msgstr ""

#~ msgid ""
#~ "Support manually moving stepper motors for diagnostic purposes. Note, using "
#~ "this feature may place the printer in an invalid state - see the [command "
#~ "reference](G-Codes.md#force_move) for important details."
#~ msgstr ""

#~ msgid "Enable the \"M118\" and \"RESPOND\" extended [commands](G-Codes.md#respond)."
#~ msgstr ""

#~ msgid ""
#~ "Support for ADXL345 accelerometers. This support allows one to query "
#~ "accelerometer measurements from the sensor. This enables an "
#~ "ACCELEROMETER_MEASURE command (see [G-Codes](G-Codes.md#adxl345) for more "
#~ "information). The default chip name is \"default\", but one may specify an "
#~ "explicit name (eg, [adxl345 my_chip_name])."
#~ msgstr ""

#~ msgid "[board_pins]"
#~ msgstr ""

#~ msgid ""
#~ "[duplicate_pin_override]\n"
#~ "pins:\n"
#~ "#   A comma separated list of pins that may be used multiple times in\n"
#~ "#   a config file without normal error checks. This parameter must be\n"
#~ "#   provided.\n"
#~ msgstr ""

#~ msgid "Additional stepper motors and extruders"
#~ msgstr ""

#~ msgid ""
#~ "Support for cartesian printers with dual carriages on a single axis. The "
#~ "active carriage is set via the SET_DUAL_CARRIAGE extended g-code command. "
#~ "The \"SET_DUAL_CARRIAGE CARRIAGE=1\" command will activate the carriage "
#~ "defined in this section (CARRIAGE=0 will return activation to the primary "
#~ "carriage). Dual carriage support is typically combined with extra extruders "
#~ "- the SET_DUAL_CARRIAGE command is often called at the same time as the "
#~ "ACTIVATE_EXTRUDER command. Be sure to park the carriages during "
#~ "deactivation."
#~ msgstr ""

#~ msgid ""
#~ "[manual_stepper my_stepper]\n"
#~ "#step_pin:\n"
#~ "#dir_pin:\n"
#~ "#enable_pin:\n"
#~ "#microsteps:\n"
#~ "#rotation_distance:\n"
#~ "#   See the \"stepper\" section for a description of these parameters.\n"
#~ "#velocity:\n"
#~ "#   Set the default velocity (in mm/s) for the stepper. This value\n"
#~ "#   will be used if a MANUAL_STEPPER command does not specify a SPEED\n"
#~ "#   parameter. The default is 5mm/s.\n"
#~ "#accel:\n"
#~ "#   Set the default acceleration (in mm/s^2) for the stepper. An\n"
#~ "#   acceleration of zero will result in no acceleration. This value\n"
#~ "#   will be used if a MANUAL_STEPPER command does not specify an ACCEL\n"
#~ "#   parameter. The default is zero.\n"
#~ "#endstop_pin:\n"
#~ "#   Endstop switch detection pin. If specified, then one may perform\n"
#~ "#   \"homing moves\" by adding a STOP_ON_ENDSTOP parameter to\n"
#~ "#   MANUAL_STEPPER movement commands.\n"
#~ msgstr ""

#~ msgid "[thermistor]"
#~ msgstr ""

#~ msgid ""
#~ "[heater_generic my_generic_heater]\n"
#~ "#gcode_id:\n"
#~ "#   The id to use when reporting the temperature in the M105 command.\n"
#~ "#   This parameter must be provided.\n"
#~ "#heater_pin:\n"
#~ "#max_power:\n"
#~ "#sensor_type:\n"
#~ "#sensor_pin:\n"
#~ "#smooth_time:\n"
#~ "#control:\n"
#~ "#pid_Kp:\n"
#~ "#pid_Ki:\n"
#~ "#pid_Kd:\n"
#~ "#pwm_cycle_time:\n"
#~ "#min_temp:\n"
#~ "#max_temp:\n"
#~ "#   See the \"extruder\" section for the definition of the above\n"
#~ "#   parameters.\n"
#~ msgstr ""

#~ msgid ""
#~ "sensor_type:\n"
#~ "#   One of \"EPCOS 100K B57560G104F\", \"ATC Semitec 104GT-2\",\n"
#~ "#   \"ATC Semitec 104NT-4-R025H42G\", \"Generic 3950\",\n"
#~ "#   \"Honeywell 100K 135-104LAG-J01\", \"NTC 100K MGB18-104F39050L32\",\n"
#~ "#   \"SliceEngineering 450\", or \"TDK NTCG104LH104JT1\"\n"
#~ "sensor_pin:\n"
#~ "#   Analog input pin connected to the thermistor. This parameter must\n"
#~ "#   be provided.\n"
#~ "#pullup_resistor: 4700\n"
#~ "#   The resistance (in ohms) of the pullup attached to the thermistor.\n"
#~ "#   The default is 4700 ohms.\n"
#~ "#inline_resistor: 0\n"
#~ "#   The resistance (in ohms) of an extra (not heat varying) resistor\n"
#~ "#   that is placed inline with the thermistor. It is rare to set this.\n"
#~ "#   The default is 0 ohms.\n"
#~ msgstr ""

#~ msgid ""
#~ "MAXxxxxx serial peripheral interface (SPI) temperature based sensors. The "
#~ "following parameters are available in heater sections that use one of these "
#~ "sensor types."
#~ msgstr ""

#~ msgid "LM75 temperature sensor"
#~ msgstr ""

#~ msgid ""
#~ "sensor_type: temperature_host\n"
#~ "#sensor_path:\n"
#~ "#   The path to temperature system file. The default is\n"
#~ "#   \"/sys/class/thermal/thermal_zone0/temp\" which is the temperature\n"
#~ "#   system file on a Raspberry Pi computer.\n"
#~ msgstr ""

#~ msgid "[heater_fan]"
#~ msgstr ""

#~ msgid ""
#~ "[temperature_fan my_temp_fan]\n"
#~ "#pin:\n"
#~ "#max_power:\n"
#~ "#shutdown_speed:\n"
#~ "#cycle_time:\n"
#~ "#hardware_pwm:\n"
#~ "#kick_start_time:\n"
#~ "#off_below:\n"
#~ "#tachometer_pin:\n"
#~ "#tachometer_ppr:\n"
#~ "#tachometer_poll_interval:\n"
#~ "#enable_pin:\n"
#~ "#   See the \"fan\" section for a description of the above parameters.\n"
#~ "#sensor_type:\n"
#~ "#sensor_pin:\n"
#~ "#control:\n"
#~ "#max_delta:\n"
#~ "#min_temp:\n"
#~ "#max_temp:\n"
#~ "#   See the \"extruder\" section for a description of the above parameters.\n"
#~ "#pid_Kp:\n"
#~ "#pid_Ki:\n"
#~ "#pid_Kd:\n"
#~ "#   The proportional (pid_Kp), integral (pid_Ki), and derivative\n"
#~ "#   (pid_Kd) settings for the PID feedback control system. Klipper\n"
#~ "#   evaluates the PID settings with the following general formula:\n"
#~ "#     fan_pwm = max_power - (Kp*e + Ki*integral(e) - Kd*derivative(e)) / 255\n"
#~ "#   Where \"e\" is \"target_temperature - measured_temperature\" and\n"
#~ "#   \"fan_pwm\" is the requested fan rate with 0.0 being full off and\n"
#~ "#   1.0 being full on. The pid_Kp, pid_Ki, and pid_Kd parameters must\n"
#~ "#   be provided when the PID control algorithm is enabled.\n"
#~ "#pid_deriv_time: 2.0\n"
#~ "#   A time value (in seconds) over which temperature measurements will\n"
#~ "#   be smoothed when using the PID control algorithm. This may reduce\n"
#~ "#   the impact of measurement noise. The default is 2 seconds.\n"
#~ "#target_temp: 40.0\n"
#~ "#   A temperature (in Celsius) that will be the target temperature.\n"
#~ "#   The default is 40 degrees.\n"
#~ "#max_speed: 1.0\n"
#~ "#   The fan speed (expressed as a value from 0.0 to 1.0) that the fan\n"
#~ "#   will be set to when the sensor temperature exceeds the set value.\n"
#~ "#   The default is 1.0.\n"
#~ "#min_speed: 0.3\n"
#~ "#   The minimum fan speed (expressed as a value from 0.0 to 1.0) that\n"
#~ "#   the fan will be set to for PID temperature fans.\n"
#~ "#   The default is 0.3.\n"
#~ "#gcode_id:\n"
#~ "#   If set, the temperature will be reported in M105 queries using the\n"
#~ "#   given id. The default is to not report the temperature via M105.\n"
#~ msgstr ""

#~ msgid ""
#~ "Note that the [linux mcu](RPi_microcontroller.md) implementation does not "
#~ "currently support directly connected neopixels. The current design using the"
#~ " Linux kernel interface does not allow this scenario because the kernel GPIO"
#~ " interface is not fast enough to provide the required pulse rates."
#~ msgstr ""

#~ msgid "[pca9632]"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_button my_gcode_button]\n"
#~ "pin:\n"
#~ "#   The pin on which the button is connected. This parameter must be\n"
#~ "#   provided.\n"
#~ "#analog_range:\n"
#~ "#   Two comma separated resistances (in Ohms) specifying the minimum\n"
#~ "#   and maximum resistance range for the button. If analog_range is\n"
#~ "#   provided then the pin must be an analog capable pin. The default\n"
#~ "#   is to use digital gpio for the button.\n"
#~ "#analog_pullup_resistor:\n"
#~ "#   The pullup resistance (in Ohms) when analog_range is specified.\n"
#~ "#   The default is 4700 ohms.\n"
#~ "#press_gcode:\n"
#~ "#   A list of G-Code commands to execute when the button is pressed.\n"
#~ "#   G-Code templates are supported. This parameter must be provided.\n"
#~ "#release_gcode:\n"
#~ "#   A list of G-Code commands to execute when the button is released.\n"
#~ "#   G-Code templates are supported. The default is to not run any\n"
#~ "#   commands on a button release.\n"
#~ msgstr ""

#~ msgid ""
#~ "[multi_pin my_multi_pin]\n"
#~ "pins:\n"
#~ "#   A comma separated list of pins associated with this alias. This\n"
#~ "#   parameter must be provided.\n"
#~ msgstr ""

#~ msgid ""
#~ "[tmc2208 stepper_x]\n"
#~ "uart_pin:\n"
#~ "#   The pin connected to the TMC2208 PDN_UART line. This parameter\n"
#~ "#   must be provided.\n"
#~ "#tx_pin:\n"
#~ "#   If using separate receive and transmit lines to communicate with\n"
#~ "#   the driver then set uart_pin to the receive pin and tx_pin to the\n"
#~ "#   transmit pin. The default is to use uart_pin for both reading and\n"
#~ "#   writing.\n"
#~ "#select_pins:\n"
#~ "#   A comma separated list of pins to set prior to accessing the\n"
#~ "#   tmc2208 UART. This may be useful for configuring an analog mux for\n"
#~ "#   UART communication. The default is to not configure any pins.\n"
#~ "#interpolate: True\n"
#~ "#   If true, enable step interpolation (the driver will internally\n"
#~ "#   step at a rate of 256 micro-steps). This interpolation does\n"
#~ "#   introduce a small systemic positional deviation - see\n"
#~ "#   TMC_Drivers.md for details. The default is True.\n"
#~ "run_current:\n"
#~ "#   The amount of current (in amps RMS) to configure the driver to use\n"
#~ "#   during stepper movement. This parameter must be provided.\n"
#~ "#hold_current:\n"
#~ "#   The amount of current (in amps RMS) to configure the driver to use\n"
#~ "#   when the stepper is not moving. Setting a hold_current is not\n"
#~ "#   recommended (see TMC_Drivers.md for details). The default is to\n"
#~ "#   not reduce the current.\n"
#~ "#sense_resistor: 0.110\n"
#~ "#   The resistance (in ohms) of the motor sense resistor. The default\n"
#~ "#   is 0.110 ohms.\n"
#~ "#stealthchop_threshold: 0\n"
#~ "#   The velocity (in mm/s) to set the \"stealthChop\" threshold to. When\n"
#~ "#   set, \"stealthChop\" mode will be enabled if the stepper motor\n"
#~ "#   velocity is below this value. The default is 0, which disables\n"
#~ "#   \"stealthChop\" mode.\n"
#~ "#driver_IHOLDDELAY: 8\n"
#~ "#driver_TPOWERDOWN: 20\n"
#~ "#driver_TBL: 2\n"
#~ "#driver_TOFF: 3\n"
#~ "#driver_HEND: 0\n"
#~ "#driver_HSTRT: 5\n"
#~ "#driver_PWM_AUTOGRAD: True\n"
#~ "#driver_PWM_AUTOSCALE: True\n"
#~ "#driver_PWM_LIM: 12\n"
#~ "#driver_PWM_REG: 8\n"
#~ "#driver_PWM_FREQ: 1\n"
#~ "#driver_PWM_GRAD: 14\n"
#~ "#driver_PWM_OFS: 36\n"
#~ "#   Set the given register during the configuration of the TMC2208\n"
#~ "#   chip. This may be used to set custom motor parameters. The\n"
#~ "#   defaults for each parameter are next to the parameter name in the\n"
#~ "#   above list.\n"
#~ msgstr ""

#~ msgid ""
#~ "Configure a TMC5160 stepper motor driver via SPI bus. To use this feature, "
#~ "define a config section with a \"tmc5160\" prefix followed by the name of "
#~ "the corresponding stepper config section (for example, \"[tmc5160 "
#~ "stepper_x]\")."
#~ msgstr ""

#~ msgid ""
#~ "[mcp4451 my_digipot]\n"
#~ "i2c_address:\n"
#~ "#   The i2c address that the chip is using on the i2c bus. This\n"
#~ "#   parameter must be provided.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#wiper_0:\n"
#~ "#wiper_1:\n"
#~ "#wiper_2:\n"
#~ "#wiper_3:\n"
#~ "#   The value to statically set the given MCP4451 \"wiper\" to. This is\n"
#~ "#   typically set to a number between 0.0 and 1.0 with 1.0 being the\n"
#~ "#   highest resistance and 0.0 being the lowest resistance. However,\n"
#~ "#   the range may be changed with the 'scale' parameter (see below).\n"
#~ "#   If a wiper is not specified then it is left unconfigured.\n"
#~ "#scale:\n"
#~ "#   This parameter can be used to alter how the 'wiper_x' parameters\n"
#~ "#   are interpreted. If provided, then the 'wiper_x' parameters should\n"
#~ "#   be between 0.0 and 'scale'. This may be useful when the MCP4451 is\n"
#~ "#   used to set stepper voltage references. The 'scale' can be set to\n"
#~ "#   the equivalent stepper amperage if the MCP4451 were at its highest\n"
#~ "#   resistance, and then the 'wiper_x' parameters can be specified\n"
#~ "#   using the desired amperage value for the stepper. The default is\n"
#~ "#   to not scale the 'wiper_x' parameters.\n"
#~ msgstr ""

#~ msgid ""
#~ "[display]\n"
#~ "lcd_type:\n"
#~ "#   The type of LCD chip in use. This may be \"hd44780\", \"hd44780_spi\",\n"
#~ "#   \"st7920\", \"emulated_st7920\", \"uc1701\", \"ssd1306\", or \"sh1106\".\n"
#~ "#   See the display sections below for information on each type and\n"
#~ "#   additional parameters they provide. This parameter must be\n"
#~ "#   provided.\n"
#~ "#display_group:\n"
#~ "#   The name of the display_data group to show on the display. This\n"
#~ "#   controls the content of the screen (see the \"display_data\" section\n"
#~ "#   for more information). The default is _default_20x4 for hd44780\n"
#~ "#   displays and _default_16x4 for other displays.\n"
#~ "#menu_timeout:\n"
#~ "#   Timeout for menu. Being inactive this amount of seconds will\n"
#~ "#   trigger menu exit or return to root menu when having autorun\n"
#~ "#   enabled. The default is 0 seconds (disabled)\n"
#~ "#menu_root:\n"
#~ "#   Name of the main menu section to show when clicking the encoder\n"
#~ "#   on the home screen. The defaults is __main, and this shows the\n"
#~ "#   the default menus as defined in klippy/extras/display/menu.cfg\n"
#~ "#menu_reverse_navigation:\n"
#~ "#   When enabled it will reverse up and down directions for list\n"
#~ "#   navigation. The default is False. This parameter is optional.\n"
#~ "#encoder_pins:\n"
#~ "#   The pins connected to encoder. 2 pins must be provided when using\n"
#~ "#   encoder. This parameter must be provided when using menu.\n"
#~ "#encoder_steps_per_detent:\n"
#~ "#   How many steps the encoder emits per detent (\"click\"). If the\n"
#~ "#   encoder takes two detents to move between entries or moves two\n"
#~ "#   entries from one detent, try changing this. Allowed values are 2\n"
#~ "#   (half-stepping) or 4 (full-stepping). The default is 4.\n"
#~ "#click_pin:\n"
#~ "#   The pin connected to 'enter' button or encoder 'click'. This\n"
#~ "#   parameter must be provided when using menu. The presence of an\n"
#~ "#   'analog_range_click_pin' config parameter turns this parameter\n"
#~ "#   from digital to analog.\n"
#~ "#back_pin:\n"
#~ "#   The pin connected to 'back' button. This parameter is optional,\n"
#~ "#   menu can be used without it. The presence of an\n"
#~ "#   'analog_range_back_pin' config parameter turns this parameter from\n"
#~ "#   digital to analog.\n"
#~ "#up_pin:\n"
#~ "#   The pin connected to 'up' button. This parameter must be provided\n"
#~ "#   when using menu without encoder. The presence of an\n"
#~ "#   'analog_range_up_pin' config parameter turns this parameter from\n"
#~ "#   digital to analog.\n"
#~ "#down_pin:\n"
#~ "#   The pin connected to 'down' button. This parameter must be\n"
#~ "#   provided when using menu without encoder. The presence of an\n"
#~ "#   'analog_range_down_pin' config parameter turns this parameter from\n"
#~ "#   digital to analog.\n"
#~ "#kill_pin:\n"
#~ "#   The pin connected to 'kill' button. This button will call\n"
#~ "#   emergency stop. The presence of an 'analog_range_kill_pin' config\n"
#~ "#   parameter turns this parameter from digital to analog.\n"
#~ "#analog_pullup_resistor: 4700\n"
#~ "#   The resistance (in ohms) of the pullup attached to the analog\n"
#~ "#   button. The default is 4700 ohms.\n"
#~ "#analog_range_click_pin:\n"
#~ "#   The resistance range for a 'enter' button. Range minimum and\n"
#~ "#   maximum comma-separated values must be provided when using analog\n"
#~ "#   button.\n"
#~ "#analog_range_back_pin:\n"
#~ "#   The resistance range for a 'back' button. Range minimum and\n"
#~ "#   maximum comma-separated values must be provided when using analog\n"
#~ "#   button.\n"
#~ "#analog_range_up_pin:\n"
#~ "#   The resistance range for a 'up' button. Range minimum and maximum\n"
#~ "#   comma-separated values must be provided when using analog button.\n"
#~ "#analog_range_down_pin:\n"
#~ "#   The resistance range for a 'down' button. Range minimum and\n"
#~ "#   maximum comma-separated values must be provided when using analog\n"
#~ "#   button.\n"
#~ "#analog_range_kill_pin:\n"
#~ "#   The resistance range for a 'kill' button. Range minimum and\n"
#~ "#   maximum comma-separated values must be provided when using analog\n"
#~ "#   button.\n"
#~ msgstr ""

#~ msgid ""
#~ "Information on configuring st7920 displays (which is used in "
#~ "\"RepRapDiscount 12864 Full Graphic Smart Controller\" type displays)."
#~ msgstr ""

#~ msgid "ssd1306 and sh1106 displays"
#~ msgstr ""

#~ msgid ""
#~ "Display data text \"macros\" (one may define any number of sections with a "
#~ "display_template prefix). See the [command templates](Command_Templates.md) "
#~ "document for information on template evaluation."
#~ msgstr ""

#~ msgid "[display my_extra_display]"
#~ msgstr ""

#~ msgid "Filament sensors"
#~ msgstr ""

#~ msgid ""
#~ "TSLl401CL Based Filament Width Sensor. See the "
#~ "[guide](TSL1401CL_Filament_Width_Sensor.md) for more information."
#~ msgstr ""

#~ msgid ""
#~ "[sx1509 my_sx1509]\n"
#~ "i2c_address:\n"
#~ "#   I2C address used by this expander. Depending on the hardware\n"
#~ "#   jumpers this is one out of the following addresses: 62 63 112\n"
#~ "#   113. This parameter must be provided.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#i2c_bus:\n"
#~ "#   If the I2C implementation of your micro-controller supports\n"
#~ "#   multiple I2C busses, you may specify the bus name here. The\n"
#~ "#   default is to use the default micro-controller i2c bus.\n"
#~ msgstr ""

#~ msgid "[replicape]"
#~ msgstr ""

#~ msgid ""
#~ "[palette2]\n"
#~ "serial:\n"
#~ "#   The serial port to connect to the Palette 2.\n"
#~ "#baud: 115200\n"
#~ "#   The baud rate to use. The default is 115200.\n"
#~ "#feedrate_splice: 0.8\n"
#~ "#   The feedrate to use when splicing, default is 0.8\n"
#~ "#feedrate_normal: 1.0\n"
#~ "#   The feedrate to use after splicing, default is 1.0\n"
#~ "#auto_load_speed: 2\n"
#~ "#   Extrude feedrate when autoloading, default is 2 (mm/s)\n"
#~ "#auto_cancel_variation: 0.1\n"
#~ "#   Auto cancel print when ping varation is above this threshold\n"
#~ msgstr ""

#~ msgid ""
#~ "The following parameters are generally available for devices using an I2C "
#~ "bus."
#~ msgstr ""

#~ msgid ""
#~ "20220407: The temperature_fan `pid_integral_max` config option has been "
#~ "removed (it was deprecated on 20210612)."
#~ msgstr ""

#~ msgid ""
#~ "20211110: The \"NTC 100K beta 3950\" temperature sensor is deprecated. This "
#~ "sensor will be removed in the near future. Most users will find the "
#~ "\"Generic 3950\" temperature sensor more accurate. To continue to use the "
#~ "older (typically less accurate) definition, define a custom "
#~ "[thermistor](Config_Reference.md#thermistor) with `temperature1: 25`, "
#~ "`resistance1: 100000`, and `beta: 3950`."
#~ msgstr ""

#~ msgid ""
#~ "20210819: In some cases, a `G28` homing move may end in a position that is "
#~ "nominally outside the valid movement range. In rare situations this may "
#~ "result in confusing \"Move out of range\" errors after homing. If this "
#~ "occurs, change your start scripts to move the toolhead to a valid position "
#~ "immediately after homing."
#~ msgstr ""

#~ msgid ""
#~ "20210313: Klipper's support for micro-controllers that communicate with CAN "
#~ "bus has changed. If using CAN bus then all micro-controllers must be "
#~ "reflashed and the [Klipper configuration must be updated](CANBUS.md)."
#~ msgstr ""

#~ msgid ""
#~ "20201218: Rotary delta and polar printers must now specify a `gear_ratio` "
#~ "for their rotary steppers, and they may no longer specify a `step_distance` "
#~ "parameter. See the [config reference](Config_Reference.md#stepper) for the "
#~ "format of the new gear_ratio paramter."
#~ msgstr ""

#~ msgid ""
#~ "20200816: The gcode macro `printer.gcode` object has been renamed to "
#~ "`printer.gcode_move`. Several undocumented variables in `printer.toolhead` "
#~ "and `printer.gcode` have been removed. See docs/Command_Templates.md for a "
#~ "list of available template variables."
#~ msgstr ""

#~ msgid ""
#~ "20200531: The default USB vendor/product id is now 0x1d50/0x614e. These new "
#~ "ids are reserved for Klipper (thanks to the openmoko project). This change "
#~ "should not require any config changes, but the new ids may appear in system "
#~ "logs."
#~ msgstr ""

#~ msgid ""
#~ "20191210: The builtin T0, T1, T2, ... commands have been removed. The "
#~ "extruder activate_gcode and deactivate_gcode config options have been "
#~ "removed. If these commands (and scripts) are needed then define individual "
#~ "[gcode_macro T0] style macros that call the ACTIVATE_EXTRUDER command. See "
#~ "the config/sample-idex.cfg and sample-multi-extruder.cfg files for examples."
#~ msgstr ""

#~ msgid ""
#~ "20191003: The move_to_previous option in [safe_z_homing] now defaults to "
#~ "False. (It was effectively False prior to 20190918.)"
#~ msgstr ""

#~ msgid ""
#~ "20190606: The \"samples\", \"samples_result\", and \"sample_retract_dist\" "
#~ "config options have been moved to the \"probe\" config section. These "
#~ "options are no longer supported in the \"delta_calibrate\", \"bed_tilt\", "
#~ "\"bed_mesh\", \"screws_tilt_adjust\", \"z_tilt\", or \"quad_gantry_level\" "
#~ "config sections."
#~ msgstr ""

#~ msgid ""
#~ "20190310: The [controller_fan] config section now always takes a name (such "
#~ "as [controller_fan my_controller_fan])."
#~ msgstr ""

#~ msgid ""
#~ "Note how the `gcode:` config option always starts at the beginning of the "
#~ "line and subsequent lines in the G-Code macro never start at the beginning."
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro MOVE_UP]\n"
#~ "gcode:\n"
#~ "  SAVE_GCODE_STATE NAME=my_move_up_state\n"
#~ "  G91\n"
#~ "  G1 Z10 F300\n"
#~ "  RESTORE_GCODE_STATE NAME=my_move_up_state\n"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro SET_PERCENT]\n"
#~ "gcode:\n"
#~ "  M117 Now at { params.VALUE|float * 100 }%\n"
#~ msgstr ""

#~ msgid "The \"printer\" Variable"
#~ msgstr ""

#~ msgid "Actions"
#~ msgstr ""

#~ msgid ""
#~ "The SET_GCODE_VARIABLE command may be useful for saving state between macro "
#~ "calls. Variable names may not contain any upper case characters. For "
#~ "example:"
#~ msgstr ""

#~ msgid ""
#~ "[delayed_gcode welcome]\n"
#~ "initial_duration: 5.\n"
#~ "gcode:\n"
#~ "  M117 Welcome!\n"
#~ msgstr ""

#~ msgid "`menu.width` - element width (number of display columns)"
#~ msgstr ""

#~ msgid ""
#~ "`menu.exit(force)` - will execute menu exit command, optional boolean "
#~ "parameter `<force>` default value False."
#~ msgstr ""

#~ msgid ""
#~ "The **scripts/** directory contains build-time scripts useful for compiling "
#~ "the micro-controller code."
#~ msgstr ""

#~ msgid ""
#~ "In the event an error is detected the code can invoke shutdown() (a macro "
#~ "which calls sched_shutdown() located in **src/sched.c**). Invoking "
#~ "shutdown() causes all functions tagged with the DECL_SHUTDOWN() macro to be "
#~ "run. Shutdown functions always run with interrupts disabled."
#~ msgstr ""

#~ msgid ""
#~ "Processing for a move command starts in gcode.py. The goal of gcode.py is to"
#~ " translate G-code into internal calls. A G1 command will invoke cmd_G1() in "
#~ "klippy/extras/gcode_move.py. The gcode_move.py code handles changes in "
#~ "origin (eg, G92), changes in relative vs absolute positions (eg, G90), and "
#~ "unit changes (eg, F6000=100mm/s). The code path for a move is: "
#~ "`_process_data() -> _process_commands() -> cmd_G1()`. Ultimately the "
#~ "ToolHead class is invoked to execute the actual request: `cmd_G1() -> "
#~ "ToolHead.move()`"
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
#~ "finding_algorithm) to generate the step times for each stepper. For "
#~ "efficiency reasons, the stepper pulse times are generated in C code. The "
#~ "moves are first placed on a \"trapezoid motion queue\": "
#~ "`ToolHead._process_moves() -> trapq_append()` (in klippy/chelper/trapq.c). "
#~ "The step times are then generated: `ToolHead._process_moves() -> "
#~ "ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> "
#~ "itersolve_generate_steps() -> itersolve_gen_steps_range()` (in "
#~ "klippy/chelper/itersolve.c). The goal of the iterative solver is to find "
#~ "step times given a function that calculates a stepper position from a time. "
#~ "This is done by repeatedly \"guessing\" various times until the stepper "
#~ "position formula returns the desired position of the next step on the "
#~ "stepper. The feedback produced from each guess is used to improve future "
#~ "guesses so that the process rapidly converges to the desired time. The "
#~ "kinematic stepper position formulas are located in the klippy/chelper/ "
#~ "directory (eg, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c)."
#~ msgstr ""

#~ msgid ""
#~ "The easiest way to add a new module is to use an existing module as a "
#~ "reference - see **klippy/extras/servo.py** as an example."
#~ msgstr ""

#~ msgid ""
#~ "If there is an error in the user's config, be sure to raise it during the "
#~ "`load_config()` or \"connect event\" phases. Use either `raise "
#~ "config.error(\"my error\")` or `raise printer.config_error(\"my error\")` to"
#~ " report the error."
#~ msgstr ""

#~ msgid ""
#~ "If submitting the module for inclusion in the main Klipper code, be sure to "
#~ "place a copyright notice at the top of the module. See the existing modules "
#~ "for the preferred format."
#~ msgstr ""

#~ msgid ""
#~ "Other methods. Implement the `check_move()`, `get_status()`, "
#~ "`get_steppers()`, `home()`, and `set_position()` methods. These functions "
#~ "are typically used to provide kinematic specific checks. However, at the "
#~ "start of development one can use boiler-plate code here."
#~ msgstr ""

#~ msgid ""
#~ "Add support for timer dispatch from hardware interrupts. See Klipper [commit"
#~ " "
#~ "970831ee](https://github.com/Klipper3d/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)"
#~ " as an example of steps 1-5 done for the LPC176x architecture."
#~ msgstr ""

#~ msgid "Coordinate Systems"
#~ msgstr ""

#~ msgid ""
#~ "The \"gcode\" position is the last requested position from a `G1` (or `G0`) "
#~ "command in cartesian coordinates relative to the coordinate system specified"
#~ " in the config file. This may differ from the \"toolhead\" position if a "
#~ "g-code transformation (eg, bed_mesh, bed_tilt, skew_correction) is in "
#~ "effect. This may differ from the actual coordinates specified in the last "
#~ "`G1` command if the g-code origin has been changed (eg, `G92`, "
#~ "`SET_GCODE_OFFSET`, `M221`). The `M114` command "
#~ "(`gcode_move.get_status()['gcode_position']`) will report the last g-code "
#~ "position relative to the current g-code coordinate system."
#~ msgstr ""

#~ msgid ""
#~ "MCU clock. This is the hardware clock counter on each micro-controller. It "
#~ "is stored as an integer and its update rate is relative to the frequency of "
#~ "the given micro-controller. The host software translates its internal times "
#~ "to clocks before transmission to the mcu. The mcu code only ever tracks time"
#~ " in clock ticks. Within the host code, clock values are tracked as 64bit "
#~ "integers, while the mcu code uses 32bit integers. Within the host code, "
#~ "clocks are generally stored in variables with names containing *clock* or "
#~ "*ticks*."
#~ msgstr ""

#~ msgid ""
#~ "After a successful review, the reviewer will \"approve the review\" on "
#~ "GitHub and a [maintainer](#reviewers) will commit the change to the Klipper "
#~ "master branch."
#~ msgstr ""

#~ msgid ""
#~ "Submitters are expected to test their changes prior to submission. The "
#~ "reviewers look for errors, but they don't, in general, test submissions. An "
#~ "accepted submission is often deployed to thousands of printers within a few "
#~ "weeks of acceptance. Quality of submissions is therefore considered a "
#~ "priority."
#~ msgstr ""

#~ msgid ""
#~ "Reviewers need to identify, at least in their own minds, roughly \"who the "
#~ "target audience is\", a rough scale of \"the size of that audience\", the "
#~ "\"benefit\" they will obtain, how the \"benefit is measured\", and the "
#~ "\"results of those measurement tests\". In most cases this will be obvious "
#~ "to both the submitter and the reviewer, and it is not explicitly stated "
#~ "during a review."
#~ msgstr ""

#~ msgid ""
#~ "Is the copyright of the submission clear, non-gratuitous, and compatible?"
#~ msgstr ""

#~ msgid ""
#~ "All commands and command parameters must be documented in <G-Codes.md>."
#~ msgstr ""

#~ msgid ""
#~ "Commits must not have a merge conflict. New additions to the Klipper master "
#~ "branch are always done via a \"rebase\" or \"squash and rebase\". It is "
#~ "generally not necessary for submitters to re-merge their submission on every"
#~ " update to the Klipper master repository. However, if there is a merge "
#~ "conflict, then submitters are recommended to use `git rebase` to address the"
#~ " conflict."
#~ msgstr ""

#~ msgid ""
#~ "To help with a review, follow the steps outlined in [what to expect in a "
#~ "review](#what-to-expect-in-a-review) to verify the submission. After "
#~ "completing the review, add a comment to the GitHub Pull Request with your "
#~ "findings. If the submission passes the review then please state that "
#~ "explicitly in the comment - for example something like \"I reviewed this "
#~ "change according to the steps in the CONTRIBUTING document and everything "
#~ "looks good to me\". If unable to complete some steps in the review then "
#~ "please explicitly state which steps were reviewed and which steps were not "
#~ "reviewed - for example something like \"I didn't check the code for defects,"
#~ " but I reviewed everything else in the CONTRIBUTING document and it looks "
#~ "good\"."
#~ msgstr ""

#~ msgid "@dmbutyugin"
#~ msgstr ""

#~ msgid "Configuration files, documentation"
#~ msgstr ""

#~ msgid ""
#~ "It is important to have a \"Signed-off-by\" line on each commit - it "
#~ "certifies that you agree to the [developer certificate of origin](developer-"
#~ "certificate-of-origin). It must contain your real name (sorry, no pseudonyms"
#~ " or anonymous contributions) and contain a current email address."
#~ msgstr ""

#~ msgid "Once the requirements are met, you need to:"
#~ msgstr ""

#~ msgid "CMD_QUERY_UNASSIGNED message"
#~ msgstr ""

#~ msgid "Data Packets"
#~ msgstr ""

#~ msgid ""
#~ "Use a [Waveshare Raspberry Pi CAN hat](https://www.waveshare.com/rs485-can-"
#~ "hat.htm) or one of its many clones."
#~ msgstr ""

#~ msgid ""
#~ "To test that the resistors are correct, one can remove power to the printer "
#~ "and use a multi-meter to check the resistance between the CANH and CANL "
#~ "wires - it should report ~60 ohms on a correctly wired CAN bus."
#~ msgstr ""

#~ msgid ""
#~ "Update the Klipper [mcu configuration](Config_Reference.md#mcu) to use the "
#~ "CAN bus to communicate with the device - for example:"
#~ msgstr ""

#~ msgid ""
#~ "Whenever the \"bridge mcu\" is reset, Linux will disable the corresponding "
#~ "`can0` interface. To ensure proper handling of FIRMWARE_RESTART and RESTART "
#~ "commands, it is recommended to replace `auto` with `allow-hotplug` in the "
#~ "`/etc/network/interfaces.d/can0` file. For example:"
#~ msgstr ""

#~ msgid ""
#~ "To flash a bootloader itself, the AVR chips require an external hardware "
#~ "flashing tool (which communicates with the chip using SPI). This tool can be"
#~ " purchased (for example, do a web search for \"avr isp\", \"arduino isp\", "
#~ "or \"usb tiny isp\"). It is also possible to use another Arduino or "
#~ "Raspberry Pi to flash an AVR bootloader (for example, do a web search for "
#~ "\"program an avr using raspberry pi\"). The examples below are written "
#~ "assuming an \"AVR ISP Mk2\" type device is in use."
#~ msgstr ""

#~ msgid "Atmega1280"
#~ msgstr ""

#~ msgid ""
#~ "Note that a number of \"Melzi\" style boards come preloaded with a "
#~ "bootloader that uses a baud rate of 57600. In this case, to flash an "
#~ "application use something like this instead:"
#~ msgstr ""

#~ msgid ""
#~ "wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/optiboot/optiboot_atmega168.hex'\n"
#~ "\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0x04:m -U hfuse:w:0xDD:m -U lfuse:w:0xFF:m\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega168.hex\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
#~ msgstr ""

#~ msgid "SAM4 micro-controllers (Duet Wifi)"
#~ msgstr ""

#~ msgid "source [find target/at91samdXX.cfg]\n"
#~ msgstr ""

#~ msgid ""
#~ "avrdude -c stk500v2 -p atmega2560 -P /dev/ttyACM0 -u "
#~ "-Uflash:w:out/klipper.elf.hex:i\n"
#~ msgstr ""

#~ msgid "bossac -U -p /dev/ttyACM0 --offset=0x4000 -w out/klipper.bin -v -b -R\n"
#~ msgstr ""

#~ msgid "This bootloader can be flashed via 3.3V serial with something like:"
#~ msgstr ""

#~ msgid ""
#~ "It is not possible to use stm32flash for the SKR Mini E3 as the boot0 pin is"
#~ " tied directly to ground and not broken out via header pins. It is "
#~ "recommended to use a STLink V2 with STM32Cubeprogrammer to flash the "
#~ "bootloader. If you don't have access to a STLink it is also possible to use "
#~ "a [Raspberry Pi and OpenOCD](#running-openocd-on-the-raspberry-pi) with the "
#~ "following chip config:"
#~ msgstr ""

#~ msgid ""
#~ "Prior flashing the SKR Mini E3 with this bootloader you should be aware that"
#~ " you will no longer be able to update firmware via the sdcard."
#~ msgstr ""

#~ msgid "alternatively, you can use `make flash` to flash klipper directly:"
#~ msgstr ""

#~ msgid ""
#~ "For STM32F072 boards it is also possible to flash the bootloader over USB "
#~ "(via DFU) with something like:"
#~ msgstr ""

#~ msgid ""
#~ "The `flash_can.py` utility supplied in the `lib/canboot` folder may be used "
#~ "to upload Klipper firmware. The device UUID is necessary to flash. If you do"
#~ " not have a UUID it is possible to query nodes currently running the "
#~ "bootloader:"
#~ msgstr ""

#~ msgid ""
#~ "STM32F4 microcontrollers come equipped with a built-in system bootloader "
#~ "capable of flashing over USB (via DFU), 3.3v Serial, and various other "
#~ "methods (see STM Document AN2606 for more information). Some STM32F4 boards,"
#~ " such as the SKR Pro 1.1, are not able to enter the DFU bootloader. The HID "
#~ "bootloader is available for STM32F405/407 based boards should the user "
#~ "prefer flashing over USB over using the sdcard. Note that you may need to "
#~ "configure and build a version specific to your board, a [build for the SKR "
#~ "Pro 1.1 is available "
#~ "here](https://github.com/Arksine/STM32_HID_Bootloader/releases/latest)."
#~ msgstr ""

#~ msgid ""
#~ "It is common for Smoothieboards to come with a bootloader from: "
#~ "<https://github.com/triffid/LPC17xx-DFU-Bootloader>. When using this "
#~ "bootloader the application must be compiled with a start address of 16KiB. "
#~ "The easiest way to flash an application with this bootloader is to copy the "
#~ "application file (eg, `out/klipper.bin`) to a file named `firmware.bin` on "
#~ "an SD card, and then to reboot the micro-controller with that SD card."
#~ msgstr ""

#~ msgid "nano ~/openocd/openocd.cfg\n"
#~ msgstr ""

#~ msgid "Run OpenOCD:"
#~ msgstr ""

#~ msgid "Add the following to the OpenOCD config file:"
#~ msgstr ""

#~ msgid "Step rate benchmark test"
#~ msgstr ""

#~ msgid "ECHO Test result is: {\"%.0fK\" % (3. * freq / ticks / 1000.)}\n"
#~ msgstr ""

#~ msgid "1 stepper"
#~ msgstr ""

#~ msgid "sam3x8e"
#~ msgstr ""

#~ msgid "260"
#~ msgstr ""

#~ msgid "Beaglebone PRU step rate benchmark"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the STM32F042:"
#~ msgstr ""

#~ msgid "stm32f103"
#~ msgstr ""

#~ msgid "46"
#~ msgstr ""

#~ msgid "44"
#~ msgstr ""

#~ msgid "243"
#~ msgstr ""

#~ msgid "lpc1769"
#~ msgstr ""

#~ msgid "306"
#~ msgstr ""

#~ msgid "3 stepper (200Mhz)"
#~ msgstr ""

#~ msgid "Linux MCU step rate benchmark"
#~ msgstr ""

#~ msgid ""
#~ "The command dispatch benchmark tests how many \"dummy\" commands the micro-"
#~ "controller can process. It is primarily a test of the hardware communication"
#~ " mechanism. The test is run using the console.py tool (described in "
#~ "<Debugging.md>). The following is cut-and-paste into the console.py terminal"
#~ " window:"
#~ msgstr ""

#~ msgid "stm32f042 (CAN)"
#~ msgstr ""

#~ msgid "sam3x8e (serial)"
#~ msgstr ""

#~ msgid "arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0"
#~ msgstr ""

#~ msgid "418K"
#~ msgstr ""

#~ msgid "samd51 (USB)"
#~ msgstr ""

#~ msgid "Host Benchmarks"
#~ msgstr ""

#~ msgid ""
#~ "`speed: 120` *Default Value: 50* The speed in which the tool moves between "
#~ "points."
#~ msgstr ""

#~ msgid ""
#~ "This example assumes a printer equipped with a round bed radius of 100mm. We"
#~ " will use the same probe offsets as the rectangular example, 24 mm on X and "
#~ "5 mm on Y."
#~ msgstr ""

#~ msgid ""
#~ "Below the more advanced configuration options are explained in detail. Each "
#~ "example will build upon the basic rectangular bed configuration shown above."
#~ " Each of the advanced options apply to round beds in the same manner."
#~ msgstr ""

#~ msgid "![bedmesh_interpolated](img/bedmesh_interpolated.svg)"
#~ msgstr ""

#~ msgid ""
#~ "When \"fade\" is enabled Z adjustment is phased out over a distance defined "
#~ "by the configuration. This is accomplished by applying small adjustments to "
#~ "the layer height, either increasing or decreasing depending on the shape of "
#~ "the bed. When fade has completed, Z adjustment is no longer applied, "
#~ "allowing the top of the print to be flat rather than mirror the shape of the"
#~ " bed. Fade also may have some undesirable traits, if you fade too quickly it"
#~ " can result in visible artifacts on the print. Also, if your bed is "
#~ "significantly warped, fade can shrink or stretch the Z height of the print. "
#~ "As such, fade is disabled by default."
#~ msgstr ""

#~ msgid ""
#~ "`relative_reference_index: 7` *Default Value: None (disabled)* When the "
#~ "probed points are generated they are each assigned an index. You can look up"
#~ " this index in klippy.log or by using BED_MESH_OUTPUT (see the section on "
#~ "Bed Mesh GCodes below for more information). If you assign an index to the "
#~ "`relative_reference_index` option, the value probed at this coordinate will "
#~ "replace the probe's z_offset. This effectively makes this coordinate the "
#~ "\"zero\" reference for the mesh."
#~ msgstr ""

#~ msgid "![bedmesh_interpolated](img/bedmesh_faulty_regions.svg)"
#~ msgstr ""

#~ msgid "`MESH_MIN`"
#~ msgstr ""

#~ msgid "`RELATIVE_REFERNCE_INDEX`"
#~ msgstr ""

#~ msgid "`BED_MESH_PROFILE REMOVE=default`"
#~ msgstr ""

#~ msgid "Clear Mesh State"
#~ msgstr ""

#~ msgid ""
#~ "For printers with an \"automatic Z probe\" be sure to calibrate the probe "
#~ "following the directions in the [Probe Calibrate](Probe_Calibrate.md) "
#~ "document. For delta printers, see the [Delta Calibrate](Delta_Calibrate.md) "
#~ "document. For printers with bed screws and traditional Z endstops, see the "
#~ "[Manual Level](Manual_Level.md) document."
#~ msgstr ""

#~ msgid ""
#~ "If one always prints on a particular tape or printing surface then one may "
#~ "perform the paper test with that tape/surface in place. However, note that "
#~ "tape itself has a thickness and different tapes (or any other printing "
#~ "surface) will impact Z measurements. Be sure to rerun the paper test to "
#~ "measure each type of surface that is in use."
#~ msgstr ""

#~ msgid ""
#~ "Recv: // Starting manual Z probe. Use TESTZ to adjust position.\n"
#~ "Recv: // Finish with ACCEPT or ABORT command.\n"
#~ "Recv: // Z position: ?????? --> 5.000 <-- ??????\n"
#~ msgstr ""

#~ msgid "Recv: // Z position: 0.130 --> 0.230 <-- 0.280\n"
#~ msgstr ""

#~ msgid ""
#~ "After successfully performing bed leveling, one may go on to calculate a "
#~ "more precise value for the combined impact of \"thermal expansion\", "
#~ "\"thickness of the paper\", and \"amount of friction felt during the paper "
#~ "test\"."
#~ msgstr ""

#~ msgid "One may then install Octoprint:"
#~ msgstr ""

#~ msgid ""
#~ "Make sure the OctoPrint web server is accessible - it should be at: "
#~ "<http://beaglebone:5000/>"
#~ msgstr ""

#~ msgid "Then install this micro-controller code as well:"
#~ msgstr ""

#~ msgid ""
#~ "It's important that the z_hop movement in safe_z_home is high enough that "
#~ "the probe doesn't hit anything even if the probe pin happens to be in its "
#~ "lowest state."
#~ msgstr ""

#~ msgid "BL-Touch gone bad"
#~ msgstr ""

#~ msgid ""
#~ "Some \"clone\" devices do not support `touch_mode` and as a result the "
#~ "`QUERY_PROBE` command does not work. Despite this, it may still be possible "
#~ "to perform probing and homing with these devices. On these devices the "
#~ "`QUERY_PROBE` command during the [initial tests](#initial-tests) will not "
#~ "succeed, however the subsequent `G28` (or `PROBE`) test does succeed. It may"
#~ " be possible to use these \"clone\" devices with Klipper if one does not "
#~ "utilize the `QUERY_PROBE` command and one does not enable the "
#~ "`probe_with_touch_mode` feature."
#~ msgstr ""

#~ msgid "Multi-probing without stowing"
#~ msgstr ""

#~ msgid "BL-Touch output mode"
#~ msgstr ""

#~ msgid "Request format"
#~ msgstr ""

#~ msgid "A request might look like:"
#~ msgstr ""

#~ msgid ""
#~ "If the processing of a request results in an error, then the response "
#~ "message will contain an \"error\" field instead of a \"result\" field. For "
#~ "example, the request: `{\"id\": 123, \"method\": \"gcode/script\", "
#~ "\"params\": {\"script\": \"G1 X200\"}}` might result in an error response "
#~ "such as: `{\"id\": 123, \"error\": {\"message\": \"Must home axis first: "
#~ "200.000 0.000 0.000 [0.000]\", \"error\": \"WebRequestError\"}}`"
#~ msgstr ""

#~ msgid "and cause Klipper to send future messages similar to:"
#~ msgstr ""

#~ msgid "emergency_stop"
#~ msgstr ""

#~ msgid "objects/list"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows one to query and then subscribe to information from "
#~ "printer objects. The endpoint request and response is identical to the "
#~ "\"objects/query\" endpoint. For example: `{\"id\": 123, \"method\": "
#~ "\"objects/subscribe\", \"params\": {\"objects\":{\"toolhead\": "
#~ "[\"position\"], \"webhooks\": [\"state\"]}, \"response_template\":{}}}` "
#~ "might return: `{\"id\": 123, \"result\": {\"status\": {\"webhooks\": "
#~ "{\"state\": \"ready\"}, \"toolhead\": {\"position\": [0.0, 0.0, 0.0, 0.0]}},"
#~ " \"eventtime\": 3052153.382083195}}` and result in subsequent asynchronous "
#~ "messages such as: `{\"params\": {\"status\": {\"webhooks\": {\"state\": "
#~ "\"shutdown\"}}, \"eventtime\": 3052165.418815847}}`"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows one to request a restart - it is similar to running the"
#~ " G-Code \"RESTART\" command. For example: `{\"id\": 123, \"method\": "
#~ "\"gcode/restart\"}`"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint is used to subscribe to Klipper's internal stepper queue_step "
#~ "command stream for a stepper. Obtaining these low-level motion updates may "
#~ "be useful for diagnostic and debugging purposes. Using this endpoint may "
#~ "increase Klipper's system load."
#~ msgstr ""

#~ msgid ""
#~ "A request may look like: `{\"id\": 123, \"method\":\"adxl345/dump_adxl345\","
#~ " \"params\": {\"sensor\": \"adxl345\", \"response_template\": {}}}` and "
#~ "might return: `{\"id\": "
#~ "123,\"result\":{\"header\":[\"time\",\"x_acceleration\",\"y_acceleration\", "
#~ "\"z_acceleration\"]}}` and might later produce asynchronous messages such "
#~ "as: "
#~ "`{\"params\":{\"overflows\":0,\"data\":[[3292.432935,-535.44309,-1529.8374,9561.4],"
#~ " [3292.433256,-382.45935,-1606.32927,9561.48375]]}}`"
#~ msgstr ""

#~ msgid "pause_resume/resume"
#~ msgstr ""

#~ msgid ""
#~ "Klipper is a 3d-Printer firmware. It combines the power of a general purpose"
#~ " computer with one or more micro-controllers. See the "
#~ "[features](Features.md) document for more information on why you should use "
#~ "Klipper."
#~ msgstr ""

#~ msgid ""
#~ "**Warning:** When driving a laser, keep all security precautions that you "
#~ "can think of! Diode lasers are usually inverted. This means, that when the "
#~ "MCU restarts, the laser will be *fully on* for the time it takes the MCU to "
#~ "start up again. For good measure, it is recommended to *always* wear "
#~ "appropriate laser-goggles of the right wavelength if the laser is powered; "
#~ "and to disconnect the laser when it is not needed. Also, you should "
#~ "configure a safety timeout, so that when your host or MCU encounters an "
#~ "error, the tool will stop."
#~ msgstr ""

#~ msgid "Commands"
#~ msgstr ""

#~ msgid ""
#~ "GCODE START:\n"
#~ "    M5            ; Disable Laser\n"
#~ "    G21           ; Set units to mm\n"
#~ "    G90           ; Absolute positioning\n"
#~ "    G0 Z0 F7000   ; Set Non-Cutting speed\n"
#~ "\n"
#~ "GCODE END:\n"
#~ "    M5            ; Disable Laser\n"
#~ "    G91           ; relative\n"
#~ "    G0 Z+20 F4000 ;\n"
#~ "    G90           ; absolute\n"
#~ "\n"
#~ "GCODE HOMING:\n"
#~ "    M5            ; Disable Laser\n"
#~ "    G28           ; Home all axis\n"
#~ "\n"
#~ "TOOL ON:\n"
#~ "    M3 $INTENSITY\n"
#~ "\n"
#~ "TOOL OFF:\n"
#~ "    M5            ; Disable Laser\n"
#~ "\n"
#~ "LASER INTENSITY:\n"
#~ "    S\n"
#~ msgstr ""

#~ msgid ""
#~ "Sensor generates analog output based on calculated filament width. Output "
#~ "voltage always equals to detected filament width (Ex. 1.65v, 1.70v, 3.0v). "
#~ "Host module monitors voltage changes and adjusts extrusion multiplier."
#~ msgstr ""

#~ msgid ""
#~ "In addition to this document, be sure to review the [TMC driver config "
#~ "reference](Config_Reference.md#tmc-stepper-driver-configuration)."
#~ msgstr ""

#~ msgid "Prefer to not specify a hold_current"
#~ msgstr ""

#~ msgid ""
#~ "Some printers with dedicated Z motors that are idle during normal printing "
#~ "moves (no bed_mesh, no bed_tilt, no Z skew_correction, no \"vase mode\" "
#~ "prints, etc.) may find that Z motors do run cooler with a `hold_current`. If"
#~ " implementing this then be sure to take into account this type of "
#~ "uncommanded Z axis movement during bed leveling, bed probing, probe "
#~ "calibration, and similar. The `driver_TPOWERDOWN` and `driver_IHOLDDELAY` "
#~ "should also be calibrated accordingly. If unsure, prefer to not specify a "
#~ "`hold_current`."
#~ msgstr ""

#~ msgid ""
#~ "Tests comparing modes have shown an increased \"positional lag\" of around "
#~ "75% of a full-step during constant velocity moves when using stealthChop "
#~ "mode (for example, on a printer with 40mm rotation_distance and 200 "
#~ "steps_per_rotation, position deviation of constant speed moves increased by "
#~ "~0.150mm). However, this \"delay in obtaining the requested position\" may "
#~ "not manifest as a significant print defect and one may prefer the quieter "
#~ "behavior of stealthChop mode."
#~ msgstr ""

#~ msgid ""
#~ "For best positional accuracy consider using spreadCycle mode and disable "
#~ "interpolation (set `interpolate: False` in the TMC driver config). When "
#~ "configured this way, one may increase the `microstep` setting to reduce "
#~ "audible noise during stepper movement. Typically, a microstep setting of "
#~ "`64` or `128` will have similar audible noise as interpolation, and do so "
#~ "without introducing a systemic positional error."
#~ msgstr ""

#~ msgid ""
#~ "This guide covers the setup of sensorless homing for the X axis of your "
#~ "(cartesian) printer. However, it works the same with all other axes (that "
#~ "require an end stop). You should configure and tune it for one axis at a "
#~ "time."
#~ msgstr ""

#~ msgid ""
#~ "Further, the stall detection of the stepper driver is dependent on the "
#~ "mechanical load on the motor, the motor current and the motor temperature "
#~ "(coil resistance)."
#~ msgstr ""

#~ msgid ""
#~ "A stallGuard capable TMC stepper driver (tmc2130, tmc2209, tmc2660, or "
#~ "tmc5160)."
#~ msgstr ""

#~ msgid "The procedure described here has six major steps:"
#~ msgstr ""

#~ msgid ""
#~ "Find the stallguard setting with lowest sensitivity that successfully homes "
#~ "with a single touch."
#~ msgstr ""

#~ msgid ""
#~ "The homing speed is an important choice when performing sensorless homing. "
#~ "It's desirable to use a slow homing speed so that the carriage does not "
#~ "exert excessive force on the frame when making contact with the end of the "
#~ "rail. However, the TMC drivers can't reliably detect a stall at very slow "
#~ "speeds."
#~ msgstr ""

#~ msgid ""
#~ "The `homing_retract_dist` setting must be set to zero in the `stepper_x` "
#~ "config section to disable the second homing move. The second homing attempt "
#~ "does not add value when using sensorless homing, it will not work reliably, "
#~ "and it will confuse the tuning process."
#~ msgstr ""

#~ msgid "An example tmc2130 or tmc5160 config might look like:"
#~ msgstr ""

#~ msgid ""
#~ "The examples above only show settings specific to sensorless homing. See the"
#~ " [config reference](Config_Reference.md#tmc-stepper-driver-configuration) "
#~ "for all the available options."
#~ msgstr ""

#~ msgid "For tmc2130, tmc5160, and tmc2660:"
#~ msgstr ""

#~ msgid ""
#~ "When searching for maximum_sensitivity, it may be convenient to jump to "
#~ "different VALUE settings (so as to bisect the VALUE parameter). If doing "
#~ "this then be prepared to issue an `M112` command to halt the printer, as a "
#~ "setting with a very low sensitivity may cause the axis to repeatedly "
#~ "\"bang\" into the end of the rail."
#~ msgstr ""

#~ msgid ""
#~ "When homing with the found *maximum_sensitivity* value, the axis should move"
#~ " to the end of the rail and stop with a \"single touch\" - that is, there "
#~ "should not be a \"clicking\" or \"banging\" sound. (If there is a banging or"
#~ " clicking sound at maximum_sensitivity then the homing_speed may be too low,"
#~ " the driver current may be too low, or sensorless homing may not be a good "
#~ "choice for the axis.)"
#~ msgstr ""

#~ msgid ""
#~ "For tmc2209 set this in the config as `driver_SGTHRS`, for other TMC drivers"
#~ " set this in the config as `driver_SGT`."
#~ msgstr ""

#~ msgid ""
#~ "After sensorless homing completes the carriage will be pressed against the "
#~ "end of the rail and the stepper will exert a force on the frame until the "
#~ "carriage is moved away. It is a good idea to create a macro to home the axis"
#~ " and immediately move the carriage away from the end of the rail."
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro SENSORLESS_HOME_X]\n"
#~ "gcode:\n"
#~ "    {% set HOME_CUR = 0.700 %}\n"
#~ "    {% set driver_config = printer.configfile.settings['tmc2209 stepper_x'] %}\n"
#~ "    {% set RUN_CUR = driver_config.run_current %}\n"
#~ "    # Set current for sensorless homing\n"
#~ "    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={HOME_CUR}\n"
#~ "    # Pause to ensure driver stall flag is clear\n"
#~ "    G4 P2000\n"
#~ "    # Home\n"
#~ "    G28 X0\n"
#~ "    # Move away\n"
#~ "    G90\n"
#~ "    G1 X5 F1200\n"
#~ "    # Set current during print\n"
#~ "    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={RUN_CUR}\n"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to use sensorless homing on the X and Y carriages of a CoreXY"
#~ " printer. Klipper uses the `[stepper_x]` stepper to detect stalls when "
#~ "homing the X carriage and uses the `[stepper_y]` stepper to detect stalls "
#~ "when homing the Y carriage."
#~ msgstr ""

#~ msgid ""
#~ "After tuning is complete, when homing both X and Y, use macros to ensure "
#~ "that one axis is homed first, then move that carriage away from the axis "
#~ "limit, pause for at least 2 seconds, and then start the homing of the other "
#~ "carriage. The move away from the axis avoids homing one axis while the other"
#~ " is pressed against the axis limit (which may skew the stall detection). The"
#~ " pause is necessary to ensure the driver's stall flag is cleared prior to "
#~ "homing again."
#~ msgstr ""

#~ msgid ""
#~ "The `[DUMP_TMC command](G-Codes.md#dump_tmc) is a useful tool when "
#~ "configuring and diagnosing the drivers. It will report all fields configured"
#~ " by Klipper as well as all fields that can be queried from the driver."
#~ msgstr ""

#~ msgid ""
#~ "In addition, almost all fields can be modified at run-time using the "
#~ "[SET_TMC_FIELD command](G-Codes.md#set_tmc_field)."
#~ msgstr ""

#~ msgid "Can I use stealthChop mode on an extruder with pressure advance?"
#~ msgstr ""

#~ msgid ""
#~ "This occurs when Klipper is unable to communicate with a tmc2208 or tmc2209 "
#~ "driver."
#~ msgstr ""

#~ msgid ""
#~ "I keep getting \"Unable to write tmc spi 'stepper_x' register ...\" errors?"
#~ msgstr ""

#~ msgid "Why did I get a \"TMC reports error: ...\" error?"
#~ msgstr ""

#~ msgid "TMC reports error: `... ot=1(OvertempError!)`"
#~ msgstr ""

#~ msgid ""
#~ "This error may also occur if using stealthChop mode and the TMC driver is "
#~ "not able to accurately predict the mechanical load of the motor. (If the "
#~ "driver makes a poor prediction then it may send too much current through the"
#~ " motor and trigger its own over-current detection.) To test this, disable "
#~ "stealthChop mode and check if the errors continue to occur."
#~ msgstr ""

#~ msgid ""
#~ "This indicates the driver has detected a low-voltage event and has disabled "
#~ "itself. This may be due to wiring or power supply issues."
#~ msgstr ""

#~ msgid "angle"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[bed_mesh](Config_Reference.md#bed_mesh) object:"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "`Config_Reference.md#bed_screws` object:"
#~ msgstr ""

#~ msgid "`accepted_screws`: The number of accepted screws."
#~ msgstr ""

#~ msgid ""
#~ "`config.<section>.<option>`: Returns the given raw config file setting as "
#~ "read by Klipper during the last software start or restart. (Any settings "
#~ "changed at run-time will not be reflected here.) All values are returned as "
#~ "strings."
#~ msgstr ""

#~ msgid "display_status"
#~ msgstr ""

#~ msgid "endstop_phase"
#~ msgstr ""

#~ msgid ""
#~ "`last_home.<stepper name>.mcu_position`: The position (as tracked by the "
#~ "micro-controller) of the stepper motor at the end of the last home attempt. "
#~ "The position is the total number of steps taken in a forward direction minus"
#~ " the total number of steps taken in the reverse direction since the micro-"
#~ "controller was last restarted."
#~ msgstr ""

#~ msgid "Here is a JSON sample:"
#~ msgstr ""

#~ msgid "extruder_stepper"
#~ msgstr ""

#~ msgid "fan"
#~ msgstr ""

#~ msgid "filament_switch_sensor"
#~ msgstr ""

#~ msgid "filament_motion_sensor"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[firmware_retraction](Config_Reference.md#firmware_retraction) object:"
#~ msgstr ""

#~ msgid ""
#~ "`<variable>`: The current value of a [gcode_macro "
#~ "variable](Command_Templates.md#variables)."
#~ msgstr ""

#~ msgid ""
#~ "`position`: The last commanded position of the toolhead using the coordinate"
#~ " system specified in the config file. It is possible to access the x, y, z, "
#~ "and e components of this position (eg, `position.x`)."
#~ msgstr ""

#~ msgid ""
#~ "`extrude_factor`: The \"extrude factor override\" as set by an `M221` "
#~ "command. This is a floating point value such that 1.0 means no override and,"
#~ " for example, 2.0 would double requested extrusions."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[hall_filament_width_sensor](Config_Reference.md#hall_filament_width_sensor)"
#~ " object:"
#~ msgstr ""

#~ msgid "heater"
#~ msgstr ""

#~ msgid ""
#~ "`power`: The last setting of the PWM pin (a value between 0.0 and 1.0) "
#~ "associated with the heater."
#~ msgstr ""

#~ msgid ""
#~ "`available_heaters`: Returns a list of all currently available heaters by "
#~ "their full config section names, e.g. `[\"extruder\", \"heater_bed\", "
#~ "\"heater_generic my_custom_heater\"]`."
#~ msgstr ""

#~ msgid ""
#~ "`state`: The current state of the printer as tracked by the idle_timeout "
#~ "module. It is one of the following strings: \"Idle\", \"Printing\", "
#~ "\"Ready\"."
#~ msgstr ""

#~ msgid ""
#~ "`color_data`: A list of color lists containing the RGBW values for a led in "
#~ "the chain. Each value is represented as a float from 0.0 to 1.0. Each color "
#~ "list contains 4 items (red, green, blue, white) even if the underyling LED "
#~ "supports fewer color channels. For example, the blue value (3rd item in "
#~ "color list) of the second neopixel in a chain could be accessed at "
#~ "`printer[\"neopixel <config_name>\"].color_data[1][2]`."
#~ msgstr ""

#~ msgid ""
#~ "`z_position`: The current height of the nozzle (as the printer currently "
#~ "understands it)."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in [mcu](Config_Reference.md#mcu) and"
#~ " [mcu some_name](Config_Reference.md#mcu-my_extra_mcu) objects:"
#~ msgstr ""

#~ msgid ""
#~ "`last_stats.<statistics_name>`: Statistics information on the micro-"
#~ "controller connection."
#~ msgstr ""

#~ msgid ""
#~ "`live_velocity`: The requested toolhead velocity (in mm/s) at the current "
#~ "time."
#~ msgstr ""

#~ msgid "`value`: The \"value\" of the pin, as set by a `SET_PIN` command."
#~ msgstr ""

#~ msgid ""
#~ "`remaining_load_length`: When starting a Palette 2 print, this will be the "
#~ "amount of filament to load into the extruder."
#~ msgstr ""

#~ msgid ""
#~ "`is_paused`: Returns true if a PAUSE command has been executed without a "
#~ "corresponding RESUME."
#~ msgstr ""

#~ msgid ""
#~ "`info.total_layer`: The total layer value of the last `SET_PRINT_STATS_INFO "
#~ "TOTAL_LAYER=<value>` G-Code command."
#~ msgstr ""

#~ msgid ""
#~ "`last_query`: Returns True if the probe was reported as \"triggered\" during"
#~ " the last QUERY_PROBE command. Note, if this is used in a macro, due to the "
#~ "order of template expansion, the QUERY_PROBE command must be run prior to "
#~ "the macro containing this reference."
#~ msgstr ""

#~ msgid ""
#~ "`applied`: True if the gantry leveling process has been run and completed "
#~ "successfully."
#~ msgstr ""

#~ msgid "screws_tilt_adjust"
#~ msgstr ""

#~ msgid "`name`: The name of the screw as specified in the config file."
#~ msgstr ""

#~ msgid ""
#~ "`sign`: A string specifying the direction to turn to screw for the necessary"
#~ " adjustment. Either \"CW\" for clockwise or \"CCW\" for counterclockwise. "
#~ "The base screw will not have a `sign` key."
#~ msgstr ""

#~ msgid ""
#~ "`printer[\"servo <config_name>\"].value`: The last setting of the PWM pin (a"
#~ " value between 0.0 and 1.0) associated with the servo."
#~ msgstr ""

#~ msgid "temperature sensors"
#~ msgstr ""

#~ msgid ""
#~ "`humidity`, `pressure`, `gas`: The last read values from the sensor (only on"
#~ " bme280, htu21d, and lm75 sensors)."
#~ msgstr ""

#~ msgid "temperature_sensor"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in [TMC stepper "
#~ "driver](Config_Reference.md#tmc-stepper-driver-configuration) objects (eg, "
#~ "`[tmc2208 stepper_x]`):"
#~ msgstr ""

#~ msgid "`run_current`: The currently set run current."
#~ msgstr ""

#~ msgid ""
#~ "`position`: The last commanded position of the toolhead relative to the "
#~ "coordinate system specified in the config file. It is possible to access the"
#~ " x, y, z, and e components of this position (eg, `position.x`)."
#~ msgstr ""

#~ msgid ""
#~ "For Delta printers the `cone_start_z` is the max z height at maximum radius "
#~ "(`printer.toolhead.cone_start_z`)."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in "
#~ "[dual_carriage](Config_Reference.md#dual_carriage) on a hybrid_corexy or "
#~ "hybrid_corexz robot"
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[virtual_sdcard](Config_Reference.md#virtual_sdcard) object:"
#~ msgstr ""

#~ msgid "`file_position`: The current position (in bytes) of an active print."
#~ msgstr ""

#~ msgid ""
#~ "`state`: Returns a string indicating the current Klipper state. Possible "
#~ "values are: \"ready\", \"startup\", \"shutdown\", \"error\"."
#~ msgstr ""

#~ msgid "`enabled`: Returns True if adjustment is enabled."
#~ msgstr ""

#~ msgid "`current_z_adjust`: Last computed Z adjustment [mm]."
#~ msgstr ""

#~ msgid ""
#~ "`applied`: True if the z-tilt leveling process has been run and completed "
#~ "successfully."
#~ msgstr ""

#~ msgid ""
#~ "[<img src=\"./img/sponsors/BTT_BTT.png\" width=\"200\" />](https://bigtree-"
#~ "tech.com/collections/all-products)"
#~ msgstr ""

#~ msgid ""
#~ "Eric is the author of bed_mesh, spi_flash, and several other Klipper "
#~ "modules. Eric has a donations page at: <https://ko-fi.com/arksine>"
#~ msgstr ""

#~ msgid "[Mainsail](https://github.com/mainsail-crew/mainsail)"
#~ msgstr ""

#~ msgid ""
#~ "Many slicers have an option to configure the \"G-Code flavor\". The default "
#~ "is frequently \"Marlin\" and that works well with Klipper. The "
#~ "\"Smoothieware\" setting also works well with Klipper."
#~ msgstr ""

#~ msgid ""
#~ "See the [config reference](Config_Reference.md#gcode_macro) for details on "
#~ "defining a gcode_macro."
#~ msgstr ""

#~ msgid "Do not enable \"coasting\""
#~ msgstr ""

#~ msgid "Do not use \"extra restart distance\" on Simplify3d"
#~ msgstr ""

#~ msgid "Disable any \"advanced extruder pressure\" settings"
#~ msgstr ""

#~ msgid ""
#~ "The first step in correcting skew is to print a [calibration "
#~ "object](https://www.thingiverse.com/thing:2563185/files) along the plane you"
#~ " want to correct. There is also a [calibration "
#~ "object](https://www.thingiverse.com/thing:2972743) that includes all planes "
#~ "in one model. You want the object oriented so that corner A is toward the "
#~ "origin of the plane."
#~ msgstr ""

#~ msgid "![skew_lengths](img/skew_lengths.png)"
#~ msgstr ""

#~ msgid "`SET_SKEW` can be used to configure skew correction for the XY plane."
#~ msgstr ""

#~ msgid ""
#~ "The `[skew_correction]` module also supports profile management in a manner "
#~ "similar to `[bed_mesh]`. After setting skew using the `SET_SKEW` gcode, you "
#~ "may use the `SKEW_PROFILE` gcode to save it:"
#~ msgstr ""

#~ msgid "SKEW_PROFILE LOAD=my_skew_profile\n"
#~ msgstr ""

#~ msgid "Verifying your correction"
#~ msgstr ""

#~ msgid ""
#~ "Keep in mind that it is possible for `[skew_correction]` to generate a "
#~ "correction that moves the tool beyond the printer's boundaries on the X "
#~ "and/or Y axes. It is recommended to arrange parts away from the edges when "
#~ "using `[skew_correction]`."
#~ msgstr ""

#~ msgid ""
#~ "The procedure for updating MCU firmware using the SD Card is similar to that"
#~ " of other methods. Instead of using `make flash` it is necessary to run a "
#~ "helper script, `flash-sdcard.sh`. Updating a BigTreeTech SKR 1.3 might look "
#~ "like the following:"
#~ msgstr ""

#~ msgid "./scripts/flash-sdcard.sh -l\n"
#~ msgstr ""

#~ msgid ""
#~ "./scripts/flash-sdcard.sh -h\n"
#~ "SD Card upload utility for Klipper\n"
#~ "\n"
#~ "usage: flash_sdcard.sh [-h] [-l] [-c] [-b <baud>] [-f <firmware>]\n"
#~ "                       <device> <board>\n"
#~ "\n"
#~ "positional arguments:\n"
#~ "  <device>        device serial port\n"
#~ "  <board>         board type\n"
#~ "\n"
#~ "optional arguments:\n"
#~ "  -h              show this message\n"
#~ "  -l              list available boards\n"
#~ "  -c              run flash check/verify only (skip upload)\n"
#~ "  -b <baud>       serial baud rate (default is 250000)\n"
#~ "  -f <firmware>   path to klipper.bin\n"
#~ msgstr ""

#~ msgid ""
#~ "./scripts/flash-sdcard.sh -f ~/downloads/klipper.bin /dev/ttyAMA0 btt-"
#~ "skr-v1.3\n"
#~ msgstr ""

#~ msgid ""
#~ "While it is possible to flash a build that changes the Serial Baud or "
#~ "connection interface (ie: from USB to UART), verification will always fail "
#~ "as the script will be unable to reconnect to the MCU to verify the current "
#~ "version."
#~ msgstr ""

#~ msgid ""
#~ "BOARD_DEFS = {\n"
#~ "    'generic-lpc1768': {\n"
#~ "        'mcu': \"lpc1768\",\n"
#~ "        'spi_bus': \"ssp1\",\n"
#~ "        \"cs_pin\": \"P0.6\"\n"
#~ "    },\n"
#~ "    ...<further definitions>\n"
#~ "}\n"
#~ msgstr ""

#~ msgid ""
#~ "`cs_pin`: The Chip Select Pin connected to the SD Card. This should be "
#~ "retreived from the board schematic. This field is required."
#~ msgstr ""

#~ msgid ""
#~ "If software SPI is required, the `spi_bus` field should be set to `swspi` "
#~ "and the following additional field should be specified:"
#~ msgstr ""

#~ msgid ""
#~ "BOARD_ALIASES = {\n"
#~ "    ...<previous aliases>,\n"
#~ "    'my-new-board': BOARD_DEFS['generic-lpc1768'],\n"
#~ "}\n"
#~ msgstr ""

#~ msgid ""
#~ "There are two scenarios -- one with the RPi Host running on a separate power"
#~ " supply and the other when the RPi Host is running on the same power supply "
#~ "as the main board being flashed. The difference is whether or not it's "
#~ "necessary to also shutdown the RPi and then `ssh` again after the flashing "
#~ "is complete in order to do the verification step, or if the verification can"
#~ " be done immediately. Here's examples of the two scenarios:"
#~ msgstr ""

#~ msgid "SDIO Programming with RPi on the Same Power Supply"
#~ msgstr ""

#~ msgid "SDIO to SPI Pin Mapping"
#~ msgstr ""

#~ msgid "SDIO Pin Name"
#~ msgstr ""

#~ msgid "None (PU)*"
#~ msgstr ""

#~ msgid "+3.3V (VDD)"
#~ msgstr ""

#~ msgid "GND (VSS)"
#~ msgstr ""

#~ msgid "8"
#~ msgstr ""

#~ msgid "\\* None (PU) indicates an unused pin with a pull-up resistor"
#~ msgstr ""

#~ msgid ""
#~ "The designers of your 3d printer originally calculated `steps_per_mm` from a"
#~ " rotation distance. If you know the steps_per_mm then it is possible to use "
#~ "this general formula to obtain that original rotation distance:"
#~ msgstr ""

#~ msgid ""
#~ "The `<full_steps_per_rotation>` setting is determined from the type of "
#~ "stepper motor. Most stepper motors are \"1.8 degree steppers\" and therefore"
#~ " have 200 full steps per rotation (360 divided by 1.8 is 200). Some stepper "
#~ "motors are \"0.9 degree steppers\" and thus have 400 full steps per "
#~ "rotation. Other stepper motors are rare. If unsure, do not set "
#~ "full_steps_per_rotation in the config file and use 200 in the formula above."
#~ msgstr ""

#~ msgid ""
#~ "On an extruder, the `rotation_distance` is the amount of distance the "
#~ "filament travels for one full rotation of the stepper motor. The best way to"
#~ " get an accurate value for this setting is to use a \"measure and trim\" "
#~ "procedure."
#~ msgstr ""

#~ msgid ""
#~ "Use a marker to place a mark on the filament around 70mm from the intake of "
#~ "the extruder body. Then use a digital calipers to measure the actual "
#~ "distance of that mark as precisely as one can. Note this as "
#~ "`<initial_mark_distance>`."
#~ msgstr ""

#~ msgid ""
#~ "If the actual_extrude_distance differs from requested_extrude_distance by "
#~ "more than about 2mm then it is a good idea to perform the steps above a "
#~ "second time."
#~ msgstr ""

#~ msgid "Belt driven axes"
#~ msgstr ""

#~ msgid ""
#~ "For example, if a printer has a 2mm belt and uses a pulley with 20 teeth, "
#~ "then the rotation distance is 40."
#~ msgstr ""

#~ msgid ""
#~ "For example, the common \"T8 leadscrew\" has a rotation distance of 8 (it "
#~ "has a pitch of 2mm and has 4 separate threads)."
#~ msgstr ""

#~ msgid ""
#~ "If the extruder uses gears then it will also be necessary to [determine and "
#~ "set the gear_ratio](#using-a-gear_ratio) for the extruder."
#~ msgstr ""

#~ msgid ""
#~ "When `gear_ratio` is set, the `rotation_distance` represents the distance "
#~ "the axis moves with one full rotation of the final gear on the gear box. If,"
#~ " for example, one is using a gearbox with a \"5:1\" ratio, then one could "
#~ "calculate the rotation_distance with [knowledge of the hardware](#obtaining-"
#~ "rotation_distance-by-inspecting-the-hardware) and then add `gear_ratio: 5:1`"
#~ " to the config."
#~ msgstr ""

#~ msgid ""
#~ "In most cases, gear_ratio should be defined with whole numbers as common "
#~ "gears and pulleys have a whole number of teeth on them. However, in cases "
#~ "where a belt drives a pulley using friction instead of teeth, it may make "
#~ "sense to use a floating point number in the gear ratio (eg, `gear_ratio: "
#~ "107.237:16`)."
#~ msgstr ""

#~ msgid ""
#~ "[Input shaping](https://en.wikipedia.org/wiki/Input_shaping) is an open-loop"
#~ " control technique which creates a commanding signal that cancels its own "
#~ "vibrations. Input shaping requires some tuning and measurements before it "
#~ "can be enabled. Besides ringing, Input Shaping typically reduces the "
#~ "vibrations and shaking of the printer in general, and may also improve the "
#~ "reliability of the stealthChop mode of Trinamic stepper drivers."
#~ msgstr ""

#~ msgid "Infill and top layers can be set to 0."
#~ msgstr ""

#~ msgid "Make sure any \"dynamic acceleration control\" is disabled in the slicer."
#~ msgstr ""

#~ msgid ""
#~ "If `square_corner_velocity` parameter was changed, revert it back to 5.0. It"
#~ " is not advised to increase it when using input shaper because it can cause "
#~ "more smoothing in parts - it is better to use higher acceleration value "
#~ "instead."
#~ msgstr ""

#~ msgid ""
#~ "Execute the command: `TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT "
#~ "PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5` Basically, we try "
#~ "to make ringing more pronounced by setting different large values for "
#~ "acceleration. This command will increase the acceleration every 5 mm "
#~ "starting from 1500 mm/sec^2: 1500 mm/sec^2, 2000 mm/sec^2, 2500 mm/sec^2 and"
#~ " so forth up until 7000 mm/sec^2 at the last band."
#~ msgstr ""

#~ msgid ""
#~ "|![Mark ringing](img/ringing-mark.jpg)|![Measure ringing](img/ringing-"
#~ "measure.jpg)|"
#~ msgstr ""

#~ msgid ""
#~ "Note that ringing on the test print should follow the pattern of the curved "
#~ "notches, as in the picture above. If it doesn't, then this defect is not "
#~ "really a ringing and has a different origin - either mechanical, or an "
#~ "extruder issue. It should be fixed first before enabling and tuning input "
#~ "shapers."
#~ msgstr ""

#~ msgid ""
#~ "Note that the ringing frequencies can change if the changes are made to the "
#~ "printer that affect the moving mass or change the stiffness of the system, "
#~ "for example:"
#~ msgstr ""

#~ msgid ""
#~ "Different bed is installed on a bed-slinger printer, or glass added, etc."
#~ msgstr ""

#~ msgid ""
#~ "[input_shaper]\n"
#~ "shaper_freq_x: ...  # frequency for the X mark of the test model\n"
#~ "shaper_freq_y: ...  # frequency for the Y mark of the test model\n"
#~ msgstr ""

#~ msgid ""
#~ "For most of the printers, either MZV or EI shapers can be recommended. This "
#~ "section describes a testing process to choose between them, and figure out a"
#~ " few other related parameters."
#~ msgstr ""

#~ msgid "Execute: `SET_INPUT_SHAPER SHAPER_TYPE=MZV`"
#~ msgstr ""

#~ msgid ""
#~ "Now try EI input shaper. To try it, repeat steps (1)-(6) from above, but "
#~ "executing at step 4 the following command instead: `SET_INPUT_SHAPER "
#~ "SHAPER_TYPE=EI`."
#~ msgstr ""

#~ msgid ""
#~ "EI shaper may be more suited for bed slinger printers (if the resonance "
#~ "frequency and resulting smoothing allows): as more filament is deposited on "
#~ "the moving bed, the mass of the bed increases and the resonance frequency "
#~ "will decrease. Since EI shaper is more robust to resonance frequency "
#~ "changes, it may work better when printing large parts."
#~ msgstr ""

#~ msgid ""
#~ "Next, check the smoothing. To help with that, the test model has a small gap"
#~ " in the wall (0.15 mm):"
#~ msgstr ""

#~ msgid ""
#~ "In this picture, the acceleration increases left to right, and the gap "
#~ "starts to grow starting from 3500 mm/sec^2 (5-th band from the left). So the"
#~ " good value for max_accel = 3000 (mm/sec^2) in this case to avoid the "
#~ "excessive smoothing."
#~ msgstr ""

#~ msgid ""
#~ "At very low ringing frequencies (~25 Hz and below) even MZV shaper may "
#~ "create too much smoothing. If that is the case, you can also try to repeat "
#~ "the steps in [Choosing input shaper](#choosing-input-shaper) section with ZV"
#~ " shaper, by using `SET_INPUT_SHAPER SHAPER_TYPE=ZV` command instead. ZV "
#~ "shaper should show even less smoothing than MZV, but is more sensitive to "
#~ "errors in measuring the ringing frequencies."
#~ msgstr ""

#~ msgid ""
#~ "Assuming that you have sliced the ringing model with suggested parameters, "
#~ "complete the following steps for each of the axes X and Y:"
#~ msgstr ""

#~ msgid ""
#~ "Calculate the necessary parameters for the `TUNING_TOWER` command to tune "
#~ "`shaper_freq_x` parameter as follows: start = shaper_freq_x * 83 / 132 and "
#~ "factor = shaper_freq_x / 66, where `shaper_freq_x` here is the current value"
#~ " in `printer.cfg`."
#~ msgstr ""

#~ msgid ""
#~ "Find the band which shows ringing the least and count its number from the "
#~ "bottom starting at 1."
#~ msgstr ""

#~ msgid ""
#~ "After both new `shaper_freq_x` and `shaper_freq_y` parameters have been "
#~ "calculated, you can update `[input_shaper]` section in `printer.cfg` with "
#~ "the new `shaper_freq_x` and `shaper_freq_y` values."
#~ msgstr ""

#~ msgid ""
#~ "If you are unable to measure the ringing frequencies, e.g. if the distance "
#~ "between the oscillations is not stable, you may still be able to take "
#~ "advantage of input shaping techniques, but the results may not be as good as"
#~ " with proper measurements of the frequencies, and will require a bit more "
#~ "tuning and printing the test model. Note that another possibility is to "
#~ "purchase and install an accelerometer and measure the resonances with it "
#~ "(refer to the [docs](Measuring_Resonances.md) describing the required "
#~ "hardware and the setup process) - but this option requires some crimping and"
#~ " soldering."
#~ msgstr ""

#~ msgid "`SET_PRESSURE_ADVANCE ADVANCE=0`"
#~ msgstr ""

#~ msgid ""
#~ "`SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=50 SHAPER_FREQ_Y=50`"
#~ msgstr ""

#~ msgid ""
#~ "If none of the models demonstrate improvements in ringing, then, "
#~ "unfortunately, it does not look like the input shaping techniques can help "
#~ "with your case."
#~ msgstr ""

#~ msgid "For 2HUMP_EI 50 Hz shaper, use EI shaper with shaper_freq = 40 Hz."
#~ msgstr ""

#~ msgid ""
#~ "providing the shaper_freq_x=... and shaper_freq_y=... as determined "
#~ "previously."
#~ msgstr ""

#~ msgid "Troubleshooting and FAQ"
#~ msgstr ""

#~ msgid ""
#~ "Check the considerations in [Selecting max_accel](#selecting-max_accel) "
#~ "section. If the resonance frequency is low, one should not set too high "
#~ "max_accel or increase square_corner_velocity parameters. It might also be "
#~ "better to choose MZV or even ZV input shapers over EI (or 2HUMP_EI and "
#~ "3HUMP_EI shapers)."
#~ msgstr ""

#~ msgid ""
#~ "There is no dedicated support for dual carriages with input shapers, but it "
#~ "does not mean this setup will not work. One should run the tuning twice for "
#~ "each of the carriages, and calculate the ringing frequencies for X and Y "
#~ "axes for each of the carriages independently. Then put the values for "
#~ "carriage 0 into [input_shaper] section, and change the values on the fly "
#~ "when changing carriages, e.g. as a part of some macro:"
#~ msgstr ""

#~ msgid ""
#~ "No, `input_shaper` feature has pretty much no impact on the print times by "
#~ "itself. However, the value of `max_accel` certainly does (tuning of this "
#~ "parameter described in [this section](#selecting-max_accel))."
#~ msgstr ""

#~ msgid "Input <br> shaper"
#~ msgstr ""

#~ msgid "ZV"
#~ msgstr ""

#~ msgid "0.75 / shaper_freq"
#~ msgstr ""

#~ msgid "1 / shaper_freq"
#~ msgstr ""

#~ msgid " 20% shaper_freq"
#~ msgstr ""

#~ msgid " 35% shaper_freq"
#~ msgstr ""

#~ msgid "-45...+50% shaper_freq"
#~ msgstr ""

#~ msgid "**How to use this table:**"
#~ msgstr ""

#~ msgid ""
#~ "If one needs to reduce vibrations at several very different frequencies "
#~ "(say, 30 Hz and 100 Hz), they may see that the table above does not provide "
#~ "enough information. In this case one may have more luck with "
#~ "[scripts/graph_shaper.py](../scripts/graph_shaper.py) script, which is more "
#~ "flexible."
#~ msgstr ""

#~ msgid "Available on 20221128. Major changes in this release:"
#~ msgstr ""

#~ msgid "Support for CanBoot bootloader."
#~ msgstr ""

#~ msgid ""
#~ "Several micro-controller improvements. New support for stm32h743, stm32h750,"
#~ " stm32l412, stm32g0b1, same70, same51, and same54 chips. Support for i2c "
#~ "reads on atsamd and stm32f0. Hardware pwm support on stm32. Linux mcu signal"
#~ " based event dispatch. New rp2040 support for \"make flash\", i2c, and "
#~ "rp2040-e5 USB errata."
#~ msgstr ""

#~ msgid "Available on 20210929. Major changes in this release:"
#~ msgstr ""

#~ msgid "Automated support for flashing firmware via sdcard on many boards."
#~ msgstr ""

#~ msgid ""
#~ "New \"motion analysis\" system. Klipper's internal motion updates and sensor"
#~ " results can be tracked and logged for analysis."
#~ msgstr ""

#~ msgid ""
#~ "Many additional modules added: ds18b20, duplicate_pin_override, "
#~ "filament_motion_sensor, palette2, motion_report, pca9533, pulse_counter, "
#~ "save_variables, sdcard_loop, temperature_host, temperature_mcu"
#~ msgstr ""

#~ msgid ""
#~ "New \"Smooth Pressure Advance\" system. This implements \"Pressure Advance\""
#~ " without introducing instantaneous velocity changes. It is also now possible"
#~ " to tune pressure advance using a \"Tuning Tower\" method."
#~ msgstr ""

#~ msgid "Improved BL-Touch v3 support."
#~ msgstr ""

#~ msgid "Improved handling of Python \"garbage collection\" events."
#~ msgstr ""

#~ msgid "Klipper 0.8.0"
#~ msgstr ""

#~ msgid "New support for TMC2209 and TMC5160 drivers."
#~ msgstr ""

#~ msgid ""
#~ "New manual_probe, bed_screws, screws_tilt_adjust, skew_correction, "
#~ "safe_z_home modules added."
#~ msgstr ""

#~ msgid "Many Klipper micro-controller improvements:"
#~ msgstr ""

#~ msgid "Software SPI support."
#~ msgstr ""

#~ msgid "Klipper now has a logo."
#~ msgstr ""

#~ msgid ""
#~ "Many additional commands added: RESTORE_GCODE_STATE, SAVE_GCODE_STATE, "
#~ "SET_GCODE_VARIABLE, SET_HEATER_TEMPERATURE, SET_IDLE_TIMEOUT, "
#~ "SET_TEMPERATURE_FAN_TARGET"
#~ msgstr ""

#~ msgid ""
#~ "New support for \"enhanced\" delta calibration (calibrates print x/y "
#~ "dimensions on delta printers)"
#~ msgstr ""

#~ msgid ""
#~ "Several new commands added: SAVE_CONFIG, SET_PRESSURE_ADVANCE, "
#~ "SET_GCODE_OFFSET, SET_VELOCITY_LIMIT, STEPPER_BUZZ, TURN_OFF_HEATERS, M204, "
#~ "custom g-code macros"
#~ msgstr ""

#~ msgid "Support for \"uc1701\" and \"ssd1306\" displays"
#~ msgstr ""

#~ msgid "Performance improvements on ARM processors"
#~ msgstr ""

#~ msgid ""
#~ "Documentation updates for bootloaders, benchmarking, micro-controller "
#~ "porting, config checks, pin mapping, slicer settings, packaging, and more"
#~ msgstr ""

#~ msgid "Enhanced heater and thermistor hardware failure checks"
#~ msgstr ""

#~ msgid "Initial support for \"safe homing\" and homing overrides"
#~ msgstr ""

#~ msgid "Initial support for dual carriages"
#~ msgstr ""

#~ msgid "Support for setting different arm lengths on each tower of a delta"
#~ msgstr ""

#~ msgid "New bltouch sensor config example"
#~ msgstr ""

#~ msgid "Available on 20171025. Major changes in this release:"
#~ msgstr ""

#~ msgid ""
#~ "Support for multiple micro-controllers. (For example, one could control an "
#~ "extruder with one micro-controller and the rest of the printer with "
#~ "another.) Software clock synchronization is implemented to coordinate "
#~ "actions between micro-controllers."
#~ msgstr ""

#~ msgid "Available on 20170503. Major changes in this release:"
#~ msgstr ""

#~ msgid ""
#~ "Stepper performance improvements (20Mhz AVRs over 175K steps per second, "
#~ "Arduino Due over 460K)"
#~ msgstr ""

#~ msgid "Support for AD595 sensors"
#~ msgstr ""

#~ msgid "Support for robots with delta kinematics"
#~ msgstr ""

#~ msgid ""
#~ "New \"stepper phased based endstop\" feature - enables higher precision on "
#~ "endstop homing."
#~ msgstr ""

#~ msgid ""
#~ "Improved error reporting. Most errors now shown via the terminal along with "
#~ "help on how to resolve."
#~ msgstr ""

#~ msgid ""
#~ "Support for common g-code commands. Support for interfacing with OctoPrint."
#~ msgstr ""

#~ msgid ""
#~ "Often the MCUs dedicated to controlling 3D printers have a limited and pre-"
#~ "configured number of exposed pins to manage the main printing functions "
#~ "(thermal resistors, extruders, steppers ...). Using the RPi where Klipper is"
#~ " installed as a secondary MCU gives the possibility to directly use the "
#~ "GPIOs and the buses (i2c, spi) of the RPi inside klipper without using "
#~ "Octoprint plugins (if used) or external programs giving the ability to "
#~ "control everything within the print GCODE."
#~ msgstr ""

#~ msgid "After installing Klipper, install the script. run:"
#~ msgstr ""

#~ msgid ""
#~ "If klippy.log reports a \"Permission denied\" error when attempting to "
#~ "connect to `/tmp/klipper_host_mcu` then you need to add your user to the tty"
#~ " group. The following command will add the \"pi\" user to the tty group:"
#~ msgstr ""

#~ msgid ""
#~ "Complete the installation by configuring Klipper secondary MCU following the"
#~ " instructions in [RaspberryPi sample config](../config/sample-raspberry-"
#~ "pi.cfg) and [Multi MCU sample config](../config/sample-multi-mcu.cfg)."
#~ msgstr ""

#~ msgid "Optional: Enabling I2C"
#~ msgstr ""

#~ msgid "Optional: Identify the correct gpiochip"
#~ msgstr ""

#~ msgid ""
#~ "To install the *Linux GPIO character device - binary* on a debian based "
#~ "distro like octopi run:"
#~ msgstr ""

#~ msgid "To check available gpiochip run:"
#~ msgstr ""

#~ msgid "To check the pin number and the pin availability tun:"
#~ msgstr ""

#~ msgid ""
#~ "The chosen pin can thus be used within the configuration as "
#~ "`gpiochip<n>/gpio<o>` where **n** is the chip number as seen by the "
#~ "`gpiodetect` command and **o** is the line number seen by the`gpioinfo` "
#~ "command."
#~ msgstr ""

#~ msgid "For example on a RPi 3B+ where klipper use the GPIO20 for a switch:"
#~ msgstr ""

#~ msgid "Optional: Hardware PWM"
#~ msgstr ""

#~ msgid ""
#~ "# Enable pwmchip sysfs interface\n"
#~ "dtoverlay=pwm,pin=12,func=4\n"
#~ msgstr ""

#~ msgid ""
#~ "The overlay does not expose the pwm line on sysfs on boot and needs to be "
#~ "exported by echo'ing the number of the pwm channel to "
#~ "`/sys/class/pwm/pwmchip0/export`:"
#~ msgstr ""

#~ msgid ""
#~ "This will create device `/sys/class/pwm/pwmchip0/pwm0` in the filesystem. "
#~ "The easiest way to do this is by adding this to `/etc/rc.local` before the "
#~ "`exit 0` line."
#~ msgstr ""

#~ msgid ""
#~ "[output_pin caselight]\n"
#~ "pin: host:pwmchip0/pwm0\n"
#~ "pwm: True\n"
#~ "hardware_pwm: True\n"
#~ "cycle_time: 0.000001\n"
#~ msgstr ""

#~ msgid ""
#~ "PWM0 can be routed to gpio12 and gpio18, PWM1 can be routed to gpio13 and "
#~ "gpio19:"
#~ msgstr ""

#~ msgid "gpio PIN"
#~ msgstr ""

#~ msgid "0"
#~ msgstr ""

#~ msgid "18"
#~ msgstr ""

#~ msgid ""
#~ "See the [mcu commands](MCU_Commands.md) document for information on "
#~ "available commands. See the [debugging](Debugging.md) document for "
#~ "information on how to translate a G-Code file into its corresponding human-"
#~ "readable micro-controller commands."
#~ msgstr ""

#~ msgid ""
#~ "The Klipper transmission protocol can be thought of as a "
#~ "[RPC](https://en.wikipedia.org/wiki/Remote_procedure_call) mechanism between"
#~ " micro-controller and host. The micro-controller software declares the "
#~ "commands that the host may invoke along with the response messages that it "
#~ "can generate. The host uses that information to command the micro-controller"
#~ " to perform actions and to interpret the results."
#~ msgstr ""

#~ msgid ""
#~ "The above declares a command named \"update_digital_out\". This allows the "
#~ "host to \"invoke\" this command which would cause the "
#~ "command_update_digital_out() C function to be executed in the micro-"
#~ "controller. The above also indicates that the command takes two integer "
#~ "parameters. When the command_update_digital_out() C code is executed, it "
#~ "will be passed an array containing these two integers - the first "
#~ "corresponding to the 'oid' and the second corresponding to the 'value'."
#~ msgstr ""

#~ msgid ""
#~ "To send information from the micro-controller to the host a \"response\" is "
#~ "generated. These are both declared and transmitted using the sendf() C "
#~ "macro. For example:"
#~ msgstr ""

#~ msgid ""
#~ "The sendf() macro should only be invoked from command or task handlers, and "
#~ "it should not be invoked from interrupts or timers. The code does not need "
#~ "to issue a sendf() in response to a received command, it is not limited in "
#~ "the number of times sendf() may be invoked, and it may invoke sendf() at any"
#~ " time from a task handler."
#~ msgstr ""

#~ msgid ""
#~ "The output() function is similar in usage to printf() - it is intended to "
#~ "generate and format arbitrary messages for human consumption."
#~ msgstr ""

#~ msgid ""
#~ "If the first example, the DECL_ENUMERATION() macro defines an enumeration "
#~ "for any command/response message with a parameter name of \"spi_bus\" or "
#~ "parameter name with a suffix of \"_spi_bus\". For those parameters the "
#~ "string \"spi\" is a valid value and it will be transmitted with an integer "
#~ "value of zero."
#~ msgstr ""

#~ msgid "DECL_CONSTANT(\"SERIAL_BAUD\", 250000);\n"
#~ msgstr ""

#~ msgid ""
#~ "To accomplish the above RPC mechanism, each command and response is encoded "
#~ "into a binary format for transmission. This section describes the "
#~ "transmission system."
#~ msgstr ""

#~ msgid ""
#~ "The length byte contains the number of bytes in the message block including "
#~ "the header and trailer bytes (thus the minimum message length is 5 bytes). "
#~ "The maximum message block length is currently 64 bytes. The sequence byte "
#~ "contains a 4 bit sequence number in the low-order bits and the high-order "
#~ "bits always contain 0x10 (the high-order bits are reserved for future use). "
#~ "The content bytes contain arbitrary data and its format is described in the "
#~ "following section. The crc bytes contain a 16bit CCITT "
#~ "[CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) of the message "
#~ "block including the header bytes but excluding the trailer bytes. The sync "
#~ "byte is 0x7e."
#~ msgstr ""

#~ msgid ""
#~ "As an example, the following four commands might be placed in a single "
#~ "message block:"
#~ msgstr ""

#~ msgid ""
#~ "In order to encode and parse the message contents, both the host and micro-"
#~ "controller must agree on the command ids and the number of parameters each "
#~ "command has. So, in the above example, both the host and micro-controller "
#~ "would know that \"id_update_digital_out\" is always followed by two "
#~ "parameters, and \"id_get_config\" and \"id_get_clock\" have zero parameters."
#~ " The host and micro-controller share a \"data dictionary\" that maps the "
#~ "command descriptions (eg, \"update_digital_out oid=%c value=%c\") to their "
#~ "integer command-ids. When processing the data, the parser will know to "
#~ "expect a specific number of VLQ encoded parameters following a given command"
#~ " id."
#~ msgstr ""

#~ msgid "Integer"
#~ msgstr ""

#~ msgid "-524288 .. 1572863"
#~ msgstr ""

#~ msgid ""
#~ "As an exception to the above encoding rules, if a parameter to a command or "
#~ "response is a dynamic string then the parameter is not encoded as a simple "
#~ "VLQ integer. Instead it is encoded by transmitting the length as a VLQ "
#~ "encoded integer followed by the contents itself:"
#~ msgstr ""

#~ msgid ""
#~ "In order for meaningful communications to be established between micro-"
#~ "controller and host, both sides must agree on a \"data dictionary\". This "
#~ "data dictionary contains the integer identifiers for commands and responses "
#~ "along with their descriptions."
#~ msgstr ""

#~ msgid ""
#~ "The format of the transmitted data dictionary itself is a zlib compressed "
#~ "JSON string. The micro-controller build process generates the string, "
#~ "compresses it, and stores it in the text section of the micro-controller "
#~ "flash. The data dictionary can be much larger than the maximum message block"
#~ " size - the host downloads it by sending multiple identify commands "
#~ "requesting progressive chunks of the data dictionary. Once all chunks are "
#~ "obtained the host will assemble the chunks, uncompress the data, and parse "
#~ "the contents."
#~ msgstr ""

#~ msgid ""
#~ "The low-level host code implements an automatic retransmission system for "
#~ "lost and corrupt message blocks sent to the micro-controller. To facilitate "
#~ "this, the micro-controller transmits an \"ack message block\" after each "
#~ "successfully received message block. The host schedules a timeout after "
#~ "sending each block and it will retransmit should the timeout expire without "
#~ "receiving a corresponding \"ack\". In addition, if the micro-controller "
#~ "detects a corrupt or out-of-order block it may transmit a \"nak message "
#~ "block\" to facilitate fast retransmission."
#~ msgstr ""

#~ msgid ""
#~ "To calibrate the X and Y offset, navigate to the OctoPrint \"Control\" tab, "
#~ "home the printer, and then use the OctoPrint jogging buttons to move the "
#~ "head to a position near the center of the bed."
#~ msgstr ""

#~ msgid ""
#~ "Issue a `GET_POSITION` command and record the toolhead XY location reported "
#~ "by that command. For example if one sees:"
#~ msgstr ""

#~ msgid "G1 F300 X57 Y30 Z15\n"
#~ msgstr ""

#~ msgid ""
#~ "Providing an accurate probe z_offset is critical to obtaining high quality "
#~ "prints. The z_offset is the distance between the nozzle and bed when the "
#~ "probe triggers. The Klipper `PROBE_CALIBRATE` tool can be used to obtain "
#~ "this value - it will run an automatic probe to measure the probe's Z trigger"
#~ " position and then start a manual probe to obtain the nozzle Z height. The "
#~ "probe z_offset will then be calculated from these measurements."
#~ msgstr ""

#~ msgid ""
#~ "Note that if a change is made to the printer's motion system, hotend "
#~ "position, or probe location then it will invalidate the results of "
#~ "PROBE_CALIBRATE."
#~ msgstr ""

#~ msgid ""
#~ "After calibrating the probe X, Y, and Z offsets it is a good idea to verify "
#~ "that the probe provides repeatable results. Start by homing the printer and "
#~ "then move the head to a position near the center of the bed. Navigate to the"
#~ " OctoPrint terminal tab and run the `PROBE_ACCURACY` command."
#~ msgstr ""

#~ msgid ""
#~ "If the results of the test show a range value that is greater than 25 "
#~ "microns (.025mm) then the probe does not have sufficient accuracy for "
#~ "typical bed leveling procedures. It may be possible to tune the probe speed "
#~ "and/or probe start height to improve the repeatability of the probe. The "
#~ "`PROBE_ACCURACY` command allows one to run tests with different parameters "
#~ "to see their impact - see the [G-Codes document](G-Codes.md#probe_accuracy) "
#~ "for further details. If the probe generally obtains repeatable results but "
#~ "has an occasional outlier, then it may be possible to account for that by "
#~ "using multiple samples on each probe - read the description of the probe "
#~ "`samples` config parameters in the [config "
#~ "reference](Config_Reference.md#probe) for more details."
#~ msgstr ""

#~ msgid ""
#~ "This is a common issue with probes on delta printers, however it can occur "
#~ "on all printers."
#~ msgstr ""

#~ msgid ""
#~ "If the difference between the minimum reported z_offset and the maximum "
#~ "reported z_offset is greater than 25 microns (.025mm) then the probe is not "
#~ "suitable for typical bed leveling procedures. See the [Bed Level "
#~ "document](Bed_Level.md) for manual probe alternatives."
#~ msgstr ""

#~ msgid ""
#~ "To check for a temperature bias, start with the printer at room temperature "
#~ "and then home the printer, move the head to a position near the center of "
#~ "the bed, and run the `PROBE_ACCURACY` command. Note the results. Then, "
#~ "without homing or disabling the stepper motors, heat the printer nozzle and "
#~ "bed to printing temperature, and run the `PROBE_ACCURACY` command again. "
#~ "Ideally, the command will report identical results. As above, if the probe "
#~ "does have a temperature bias then be careful to always use the probe at a "
#~ "consistent temperature."
#~ msgstr ""

#~ msgid ""
#~ "In order to calibrate pressure advance the printer must be configured and "
#~ "operational as the tuning test involves printing and inspecting a test "
#~ "object. It is a good idea to read this document in full prior to running the"
#~ " test."
#~ msgstr ""

#~ msgid ""
#~ "This command makes the nozzle travel slower through corners to emphasize the"
#~ " effects of extruder pressure. Then for printers with a direct drive "
#~ "extruder run the command:"
#~ msgstr ""

#~ msgid "Then print the object. When fully printed the test print looks like:"
#~ msgstr ""

#~ msgid ""
#~ "Inspect the print and then use a digital calipers to find the height that "
#~ "has the best quality corners. When in doubt, prefer a lower height."
#~ msgstr ""

#~ msgid ""
#~ "Typical pressure advance values are between 0.050 and 1.000 (the high end "
#~ "usually only with bowden extruders). If there is no significant improvement "
#~ "with a pressure advance up to 1.000, then pressure advance is unlikely to "
#~ "improve the quality of prints. Return to a default configuration with "
#~ "pressure advance disabled."
#~ msgstr ""

#~ msgid ""
#~ "The pressure advance value is dependent on the extruder, the nozzle, and the"
#~ " filament. It is common for filament from different manufactures or with "
#~ "different pigments to require significantly different pressure advance "
#~ "values. Therefore, one should calibrate pressure advance on each printer and"
#~ " with each spool of filament."
#~ msgstr ""

#~ msgid ""
#~ "If a high pressure advance value (eg, over 0.200) is used then one may find "
#~ "that the extruder skips when returning to the printer's normal acceleration."
#~ " The pressure advance system accounts for pressure by pushing in extra "
#~ "filament during acceleration and retracting that filament during "
#~ "deceleration. With a high acceleration and high pressure advance the "
#~ "extruder may not have enough torque to push the required filament. If this "
#~ "occurs, either use a lower acceleration value or disable pressure advance."
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses a C module to handle some kinematics calculations more quickly."
#~ " This module needs to be compiled at packaging time to avoid introducing a "
#~ "runtime dependency on a compiler. To compile the C module, run `python2 "
#~ "klippy/chelper/__init__.py`."
#~ msgstr ""

#~ msgid ""
#~ "If you are building a package of Klipper from git, it is usual practice not "
#~ "to ship a .git directory, so the versioning must be handled without git. To "
#~ "do this, use the script shipped in `scripts/make_version.py` which should be"
#~ " run as follows: `python2 scripts/make_version.py YOURDISTRONAME > "
#~ "klippy/.version`."
#~ msgstr ""

#~ msgid "Overview information"
#~ msgstr ""

#~ msgid ""
#~ "[Config changes](Config_Changes.md): Recent software changes that may "
#~ "require users to update their printer config file."
#~ msgstr ""

#~ msgid ""
#~ "[Rotation Distance](Rotation_Distance.md): Calculating the rotation_distance"
#~ " stepper parameter."
#~ msgstr ""

#~ msgid ""
#~ "[Probe calibrate](Probe_Calibrate.md): Calibration of automatic Z probes."
#~ msgstr ""

#~ msgid ""
#~ "[Endstop phase](Endstop_Phase.md): Stepper assisted Z endstop positioning."
#~ msgstr ""

#~ msgid "[G-Codes](G-Codes.md): Information on commands supported by Klipper."
#~ msgstr ""

#~ msgid ""
#~ "[Multi-MCU Homing](Multi_MCU_Homing.md): Homing and probing using multiple "
#~ "micro-controllers."
#~ msgstr ""

#~ msgid ""
#~ "[Exclude Object](Exclude_Object.md): The guide to the Exclude Objecs "
#~ "implementation."
#~ msgstr ""

#~ msgid ""
#~ "[API Server](API_Server.md): Information on Klipper's command and control "
#~ "API."
#~ msgstr ""

#~ msgid ""
#~ "[Benchmarks](Benchmarks.md): Information on the Klipper benchmark method."
#~ msgstr ""

#~ msgid ""
#~ "[SDCard Updates](SDCard_Updates.md): Flash a micro-controller by copying a "
#~ "binary to an sdcard in the micro-controller."
#~ msgstr ""

#~ msgid "[CAN bus](CANBUS.md): Information on using CAN bus with Klipper."
#~ msgstr ""

#~ msgid "Command templates"
#~ msgstr ""

#~ msgid ""
#~ "The overshoot occurs due to possible message transmission delays between the"
#~ " micro-controller monitoring the endstop and the micro-controllers moving "
#~ "the stepper motors. The Klipper code is designed to limit this delay to no "
#~ "more than 25ms. (When multi-mcu homing is activated, the micro-controllers "
#~ "send periodic status messages and check that corresponding status messages "
#~ "are received within 25ms.)"
#~ msgstr ""

#~ msgid ""
#~ "Note that an axis with multiple steppers (eg, `stepper_z` and `stepper_z1`) "
#~ "need to be on the same micro-controller in order to use multi-mcu homing. "
#~ "For example, if an endstop is on a separate micro-controller from "
#~ "`stepper_z` then `stepper_z1` must be on the same micro-controller as "
#~ "`stepper_z`."
#~ msgstr ""

#~ msgid "Installation instructions"
#~ msgstr ""

#~ msgid ""
#~ "***Double-check your wiring before powering up to prevent damaging your "
#~ "MCU/Raspberry Pi or the accelerometer.***"
#~ msgstr ""

#~ msgid "ADXL345"
#~ msgstr ""

#~ msgid "RPi pin"
#~ msgstr ""

#~ msgid "3.3v DC power"
#~ msgstr ""

#~ msgid "GPIO08 (SPI0_CE0_N)"
#~ msgstr ""

#~ msgid "SDA"
#~ msgstr ""

#~ msgid "GPIO11 (SPI0_SCLK)"
#~ msgstr ""

#~ msgid ""
#~ "3.3V+SDA\n"
#~ "GND+SCL\n"
#~ msgstr ""

#~ msgid "MPU-9250 pin"
#~ msgstr ""

#~ msgid "GPIO02 (SDA1)"
#~ msgstr ""

#~ msgid "Recommended connection scheme for I2C(i2c0a) on the RP2040:"
#~ msgstr ""

#~ msgid "GP0 (I2C0 SDA)"
#~ msgstr ""

#~ msgid "Mounting the accelerometer"
#~ msgstr ""

#~ msgid ""
#~ "Note that on a bed slinger printer one must design 2 mounts: one for the "
#~ "toolhead and one for the bed, and run the measurements twice. See the "
#~ "corresponding [section](#bed-slinger-printers) for more details."
#~ msgstr ""

#~ msgid ""
#~ "sudo apt update\n"
#~ "sudo apt install python3-numpy python3-matplotlib libatlas-base-dev\n"
#~ msgstr ""

#~ msgid ""
#~ "Afterwards, check and follow the instructions in the [RPi Microcontroller "
#~ "document](RPi_microcontroller.md) to setup the \"linux mcu\" on the "
#~ "Raspberry Pi."
#~ msgstr ""

#~ msgid ""
#~ "It is advised to start with 1 probe point, in the middle of the print bed, "
#~ "slightly above it."
#~ msgstr ""

#~ msgid "Configure MPU-6000/9000 series With PICO"
#~ msgstr ""

#~ msgid "Measuring the resonances"
#~ msgstr ""

#~ msgid ""
#~ "For \"bed-slingers\" (e.g. more than one accelerometer), enter "
#~ "`ACCELEROMETER_QUERY CHIP=<chip>` where `<chip>` is the name of the chip as-"
#~ "entered, e.g. `CHIP=bed` (see: [bed-slinger](#bed-slinger-printers)) for all"
#~ " installed accelerometer chips."
#~ msgstr ""

#~ msgid ""
#~ "**If you are using MPU-6000/9000 series accelerometer and it show up as "
#~ "`mpu-unknown`, use with caution! They are probably refurbished chips!**"
#~ msgstr ""

#~ msgid ""
#~ "Note that it will create vibrations on X axis. It will also disable input "
#~ "shaping if it was enabled previously, as it is not valid to run the "
#~ "resonance testing with the input shaper enabled."
#~ msgstr ""

#~ msgid "TEST_RESONANCES AXIS=Y\n"
#~ msgstr ""

#~ msgid "![Resonances](img/calibrate-y.png)"
#~ msgstr ""

#~ msgid ""
#~ "or you can choose some other configuration yourself based on the generated "
#~ "charts: peaks in the power spectral density on the charts correspond to the "
#~ "resonance frequencies of the printer."
#~ msgstr ""

#~ msgid ""
#~ "However, you can also connect two accelerometers simultaneously, though they"
#~ " must be connected to different boards (say, to an RPi and printer MCU "
#~ "board), or to two different physical SPI interfaces on the same board "
#~ "(rarely available). Then they can be configured in the following manner:"
#~ msgstr ""

#~ msgid ""
#~ "Keep in mind that the input shaper can create some smoothing in parts. "
#~ "Automatic tuning of the input shaper performed by `calibrate_shaper.py` "
#~ "script or `SHAPER_CALIBRATE` command tries not to exacerbate the smoothing, "
#~ "but at the same time they try to minimize the resulting vibrations. "
#~ "Sometimes they can make a sub-optimal choice of the shaper frequency, or "
#~ "maybe you simply prefer to have less smoothing in parts at the expense of a "
#~ "larger remaining vibrations. In these cases, you can request to limit the "
#~ "maximum smoothing from the input shaper."
#~ msgstr ""

#~ msgid ""
#~ "Note that the reported `smoothing` values are some abstract projected "
#~ "values. These values can be used to compare different configurations: the "
#~ "higher the value, the more smoothing a shaper will create. However, these "
#~ "smoothing scores do not represent any real measure of smoothing, because the"
#~ " actual smoothing depends on [`max_accel`](#selecting-max-accel) and "
#~ "`square_corner_velocity` parameters. Therefore, you should print some test "
#~ "prints to see how much smoothing exactly a chosen configuration creates."
#~ msgstr ""

#~ msgid "![Resonances](img/calibrate-x-max-smoothing.png)"
#~ msgstr ""

#~ msgid ""
#~ "Note that if you chose a good `max_smoothing` value for both of your axes, "
#~ "you can store it in the `printer.cfg` as"
#~ msgstr ""

#~ msgid ""
#~ "Alternatively, follow [this](Resonance_Compensation.md#selecting-max_accel) "
#~ "part of the input shaper tuning guide and print the test model to choose "
#~ "`max_accel` parameter experimentally."
#~ msgstr ""

#~ msgid ""
#~ "`TEST_RESONANCES` command supports custom axes. While this is not really "
#~ "useful for input shaper calibration, it can be used to study printer "
#~ "resonances in-depth and to check, for example, belt tension."
#~ msgstr ""

#~ msgid ""
#~ "~/klipper/scripts/graph_accelerometer.py -c /tmp/raw_data_axis*.csv -o "
#~ "/tmp/resonances.png\n"
#~ msgstr ""

#~ msgid "and then use the same command"
#~ msgstr ""

#~ msgid "SHAPER_CALIBRATE\n"
#~ msgstr ""

#~ msgid ""
#~ "If your printer is a bed slinger printer, you can specify which axis to "
#~ "test, so that you can change the accelerometer mounting point between the "
#~ "tests (by default the test is performed for both axes):"
#~ msgstr ""

#~ msgid "Input Shaper re-calibration"
#~ msgstr ""

#~ msgid ""
#~ "Also, due to some noise in measurements, it is possible that the tuning "
#~ "results will be slightly different from one calibration run to another one. "
#~ "Still, it is not expected that the noise will affect the print quality too "
#~ "much. However, it is still advised to double-check the suggested parameters,"
#~ " and print some test prints before using them to confirm they are good."
#~ msgstr ""

#~ msgid ""
#~ "ignoring any errors for `SET_INPUT_SHAPER` command. For `TEST_RESONANCES` "
#~ "command, specify the desired test axis. The raw data will be written into "
#~ "`/tmp` directory on the RPi."
#~ msgstr ""

#~ msgid ""
#~ "plotting a frequency response (no extra parameters required), if multiple "
#~ "inputs are specified, the average frequency response is computed;"
#~ msgstr ""

#~ msgid "For example,"
#~ msgstr ""

#~ msgid ""
#~ "Providing several inputs to shaper_calibrate.py script can be useful if "
#~ "running some advanced tuning of the input shapers, for example:"
#~ msgstr ""

#~ msgid ""
#~ "Combining the resonance data from 2 axis (e.g. on a bed slinger printer to "
#~ "configure X-axis input_shaper from both X and Y axes resonances to cancel "
#~ "vibrations of the *bed* in case the nozzle 'catches' a print when moving in "
#~ "X axis direction)."
#~ msgstr ""

#~ msgid ""
#~ "An accurate Z endstop position is critical to obtaining high quality prints."
#~ msgstr ""

#~ msgid ""
#~ "Then follow the steps described at [\"the paper test\"](Bed_Level.md#the-"
#~ "paper-test) to determine the actual distance between the nozzle and bed at "
#~ "the given location. Once those steps are complete one can `ACCEPT` the "
#~ "position and save the results to the config file with:"
#~ msgstr ""

#~ msgid ""
#~ "The secret to getting good bed leveling with bed leveling screws is to "
#~ "utilize the printer's high precision motion system during the bed leveling "
#~ "process itself. This is done by commanding the nozzle to a position near "
#~ "each bed screw and then adjusting that screw until the bed is a set distance"
#~ " from the nozzle. Klipper has a tool to assist with this. In order to use "
#~ "the tool it is necessary to specify each screw XY location."
#~ msgstr ""

#~ msgid ""
#~ "Once the config file is ready, run `RESTART` to load that config, and then "
#~ "one can start the tool by running:"
#~ msgstr ""

#~ msgid ""
#~ "This system works best when the printer has a flat printing surface (such as"
#~ " glass) and has straight rails. Upon successful completion of the bed "
#~ "leveling tool the bed should be ready for printing."
#~ msgstr ""

#~ msgid "![bed_screws](img/bed_screws.svg.png)"
#~ msgstr ""

#~ msgid ""
#~ "When this feature is enabled, the `BED_SCREWS_ADJUST` tool will first prompt"
#~ " for coarse adjustments directly above each screw position, and once those "
#~ "are accepted, it will prompt for fine adjustments at the additional "
#~ "locations. Continue to use `ACCEPT` and `ADJUSTED` at each position."
#~ msgstr ""

#~ msgid ""
#~ "[screws_tilt_adjust]\n"
#~ "screw1: -5, 30\n"
#~ "screw1_name: front left screw\n"
#~ "screw2: 155, 30\n"
#~ "screw2_name: front right screw\n"
#~ "screw3: 155, 190\n"
#~ "screw3_name: rear right screw\n"
#~ "screw4: -5, 190\n"
#~ "screw4_name: rear left screw\n"
#~ "horizontal_move_z: 10.\n"
#~ "speed: 50.\n"
#~ "screw_thread: CW-M3\n"
#~ msgstr ""

#~ msgid "front left screw is the reference point you must not change it."
#~ msgstr ""

#~ msgid ""
#~ "Note that \"minutes\" refers to \"minutes of a clock face\". So, for "
#~ "example, 15 minutes is a quarter of a full turn."
#~ msgstr ""

#~ msgid ""
#~ "The `DIRECTION` parameter is useful if you can turn your bed adjustment "
#~ "screws in one direction only. For example, you might have screws that start "
#~ "tightened in their lowest (or highest) possible position, which can only be "
#~ "turned in a single direction, to raise (or lower) the bed. If you can only "
#~ "turn the screws clockwise, run `SCREWS_TILT_CALCULATE DIRECTION=CW`. If you "
#~ "can only turn them counter-clockwise, run `SCREWS_TILT_CALCULATE "
#~ "DIRECTION=CCW`. A suitable reference point will be chosen such that the bed "
#~ "can be leveled by turning all the screws in the given direction."
#~ msgstr ""

#~ msgid ""
#~ "See the [protocol](Protocol.md) document for more information on the format "
#~ "of commands and their transmission. The commands here are described using "
#~ "their \"printf\" style syntax - for those unfamiliar with that format, just "
#~ "note that where a '%...' sequence is seen it should be replaced with an "
#~ "actual integer. For example, a description with \"count=%c\" could be "
#~ "replaced with the text \"count=10\". Note that parameters that are "
#~ "considered \"enumerations\" (see the above protocol document) take a string "
#~ "value which is automatically converted to an integer value for the micro-"
#~ "controller. This is common with parameters named \"pin\" (or that have a "
#~ "suffix of \"_pin\")."
#~ msgstr ""

#~ msgid ""
#~ "`set_digital_out pin=%u value=%c` : This command immediately configures the "
#~ "given pin as a digital out GPIO and it sets it to either a low level "
#~ "(value=0) or a high level (value=1). This command may be useful for "
#~ "configuring the initial value of LEDs and for configuring the initial value "
#~ "of stepper driver micro-stepping pins."
#~ msgstr ""

#~ msgid ""
#~ "When the host first connects to the micro-controller it always starts by "
#~ "obtaining a data dictionary (see [protocol](Protocol.md) for more "
#~ "information). After the data dictionary is obtained the host will check if "
#~ "the micro-controller is in a \"configured\" state and configure it if not. "
#~ "Configuration involves the following phases:"
#~ msgstr ""

#~ msgid ""
#~ "`finalize_config crc=%u` : The finalize_config command transitions the "
#~ "micro-controller from an unconfigured state to a configured state. The crc "
#~ "parameter passed to the micro-controller is stored and provided back to the "
#~ "host in \"config\" response messages. By convention, the host takes a 32bit "
#~ "CRC of the configuration it will request and at the start of subsequent "
#~ "communication sessions it checks that the CRC stored in the micro-controller"
#~ " exactly matches its desired CRC. If the CRC does not match then the host "
#~ "knows the micro-controller has not been configured in the state desired by "
#~ "the host."
#~ msgstr ""

#~ msgid ""
#~ "`config_pwm_out oid=%c pin=%u cycle_ticks=%u value=%hu default_value=%hu "
#~ "max_duration=%u` : This command creates an internal object for hardware "
#~ "based PWM pins that the host may schedule updates for. Its usage is "
#~ "analogous to config_digital_out - see the description of the 'set_pwm_out' "
#~ "and 'config_digital_out' commands for parameter description."
#~ msgstr ""

#~ msgid ""
#~ "`config_spi oid=%c bus=%u pin=%u mode=%u rate=%u shutdown_msg=%*s` : This "
#~ "command creates an internal SPI object. It is used with spi_transfer and "
#~ "spi_send commands (see below). The \"bus\" identifies the SPI bus to use (if"
#~ " the micro-controller has more than one SPI bus available). The \"pin\" "
#~ "specifies the chip select (CS) pin for the device. The \"mode\" is the SPI "
#~ "mode (should be between 0 and 3). The \"rate\" parameter specifies the SPI "
#~ "bus rate (in cycles per second). Finally, the \"shutdown_msg\" is an SPI "
#~ "command to send to the given device should the micro-controller go into a "
#~ "shutdown state."
#~ msgstr ""

#~ msgid ""
#~ "`set_digital_out_pwm_cycle oid=%c cycle_ticks=%u` : This command configures "
#~ "a digital output pin (as created by config_digital_out) to use \"software "
#~ "PWM\". The 'cycle_ticks' is the number of clock ticks for the PWM cycle. "
#~ "Because the output switching is implemented in the micro-controller "
#~ "software, it is recommended that 'cycle_ticks' correspond to a time of 10ms "
#~ "or greater."
#~ msgstr ""

#~ msgid ""
#~ "`get_clock` : This command causes the micro-controller to generate a "
#~ "\"clock\" response message. The host sends this command once a second to "
#~ "obtain the value of the micro-controller clock and to estimate the drift "
#~ "between host and micro-controller clocks. It enables the host to accurately "
#~ "estimate the micro-controller clock."
#~ msgstr ""

#~ msgid ""
#~ "`reset_step_clock oid=%c clock=%u` : Normally, step timing is relative to "
#~ "the last step for a given stepper. This command resets the clock so that the"
#~ " next step is relative to the supplied 'clock' time. The host usually only "
#~ "sends this command at the start of a print."
#~ msgstr ""

#~ msgid ""
#~ "Each queue_step command utilizes an entry in the micro-controller \"move "
#~ "queue\". This queue is allocated when it receives the \"finalize_config\" "
#~ "command, and it reports the number of available queue entries in \"config\" "
#~ "response messages."
#~ msgstr ""

#~ msgid ""
#~ "`spi_send oid=%c data=%*s` : This command is similar to \"spi_transfer\", "
#~ "but it does not generate a \"spi_transfer_response\" message."
#~ msgstr ""

#~ msgid ""
#~ "Klipper implements a constant acceleration scheme whenever the print head "
#~ "changes velocity - the velocity is gradually changed to the new speed "
#~ "instead of suddenly jerking to it. Klipper always enforces acceleration "
#~ "between the tool head and the print. The filament leaving the extruder can "
#~ "be quite fragile - rapid jerks and/or extruder flow changes lead to poor "
#~ "quality and poor bed adhesion. Even when not extruding, if the print head is"
#~ " at the same level as the print then rapid jerking of the head can cause "
#~ "disruption of recently deposited filament. Limiting speed changes of the "
#~ "print head (relative to the print) reduces risks of disrupting the print."
#~ msgstr ""

#~ msgid "Trapezoid generator"
#~ msgstr ""

#~ msgid ""
#~ "The cruising speed is always greater than or equal to both the start speed "
#~ "and the end speed. The acceleration phase may be of zero duration (if the "
#~ "start speed is equal to the cruising speed), the cruising phase may be of "
#~ "zero duration (if the move immediately starts decelerating after "
#~ "acceleration), and/or the deceleration phase may be of zero duration (if the"
#~ " end speed is equal to the cruising speed)."
#~ msgstr ""

#~ msgid "Consider the following two moves contained on an XY plane:"
#~ msgstr ""

#~ msgid "![lookahead](img/lookahead.svg.png)"
#~ msgstr ""

#~ msgid "Key formula for look-ahead:"
#~ msgstr ""

#~ msgid "![zigzag](img/zigzag.svg.png)"
#~ msgstr ""

#~ msgid "Generating steps"
#~ msgstr ""

#~ msgid "move_distance = (start_velocity + .5 * accel * move_time) * move_time\n"
#~ msgstr ""

#~ msgid ""
#~ "cartesian_x_position = start_x + move_distance * total_x_movement / total_movement\n"
#~ "cartesian_y_position = start_y + move_distance * total_y_movement / total_movement\n"
#~ "cartesian_z_position = start_z + move_distance * total_z_movement / total_movement\n"
#~ msgstr ""

#~ msgid ""
#~ "stepper_x_position = cartesian_x_position\n"
#~ "stepper_y_position = cartesian_y_position\n"
#~ "stepper_z_position = cartesian_z_position\n"
#~ msgstr ""

#~ msgid "Delta Robots"
#~ msgstr ""

#~ msgid ""
#~ "With delta kinematics it is possible for a move that is accelerating in "
#~ "cartesian space to require an acceleration on a particular stepper motor "
#~ "greater than the move's acceleration. This can occur when a stepper arm is "
#~ "more horizontal than vertical and the line of movement passes near that "
#~ "stepper's tower. Although these moves could require a stepper motor "
#~ "acceleration greater than the printer's maximum configured move "
#~ "acceleration, the effective mass moved by that stepper would be smaller. "
#~ "Thus the higher stepper acceleration does not result in significantly higher"
#~ " stepper torque and it is therefore considered harmless."
#~ msgstr ""

#~ msgid ""
#~ "Basic extruder movement is simple to calculate. The step time generation "
#~ "uses the same formulas that cartesian robots use:"
#~ msgstr ""

#~ msgid ""
#~ "The \"pressure advance\" system attempts to account for this by using a "
#~ "different model for the extruder. Instead of naively believing that each "
#~ "mm^3 of filament fed into the extruder will result in that amount of mm^3 "
#~ "immediately exiting the extruder, it uses a model based on pressure. "
#~ "Pressure increases when filament is pushed into the extruder (as in [Hooke's"
#~ " law](https://en.wikipedia.org/wiki/Hooke%27s_law)) and the pressure "
#~ "necessary to extrude is dominated by the flow rate through the nozzle "
#~ "orifice (as in [Poiseuille's "
#~ "law](https://en.wikipedia.org/wiki/Poiseuille_law)). The key idea is that "
#~ "the relationship between filament, pressure, and flow rate can be modeled "
#~ "using a linear coefficient:"
#~ msgstr ""

#~ msgid "![pressure-advance](img/pressure-velocity.png)"
#~ msgstr ""

#~ msgid ""
#~ "smooth_pa_position(t) =\n"
#~ "    ( definitive_integral(pa_position(x) * (smooth_time/2 - abs(t - x)) * dx,\n"
#~ "                          from=t-smooth_time/2, to=t+smooth_time/2)\n"
#~ "     / (smooth_time/2)^2 )\n"
#~ msgstr ""

#~ msgid ""
#~ "Most Klipper settings are determined by a \"printer configuration file\" "
#~ "that will be stored on the Raspberry Pi. An appropriate configuration file "
#~ "can often be found by looking in the Klipper [config directory](../config/) "
#~ "for a file starting with a \"printer-\" prefix that corresponds to the "
#~ "target printer. The Klipper configuration file contains technical "
#~ "information about the printer that will be needed during the installation."
#~ msgstr ""

#~ msgid "Prepping an OS image"
#~ msgstr ""

#~ msgid ""
#~ "The above will download Klipper, install some system dependencies, setup "
#~ "Klipper to run at system startup, and start the Klipper host software. It "
#~ "will require an internet connection and it may take a few minutes to "
#~ "complete."
#~ msgstr ""

#~ msgid "make\n"
#~ msgstr ""

#~ msgid "It should report something similar to the following:"
#~ msgstr ""

#~ msgid ""
#~ "When flashing for the first time, make sure that OctoPrint is not connected "
#~ "directly to the printer (from the OctoPrint web page, under the "
#~ "\"Connection\" section, click \"Disconnect\")."
#~ msgstr ""

#~ msgid ""
#~ "Enter the Settings tab again and under \"Serial Connection\" change the "
#~ "\"Serial Port\" setting to \"/tmp/printer\"."
#~ msgstr ""

#~ msgid ""
#~ "The next step is to copy the [printer configuration file](#obtain-a-klipper-"
#~ "configuration-file) to the Raspberry Pi."
#~ msgstr ""

#~ msgid ""
#~ "It's common for each printer to have its own unique name for the micro-"
#~ "controller. The name may change after flashing Klipper, so rerun these steps"
#~ " again even if they were already done when flashing. Run:"
#~ msgstr ""

#~ msgid ""
#~ "Klipper reports error messages via the OctoPrint terminal tab. The "
#~ "\"status\" command can be used to re-report error messages. The default "
#~ "Klipper startup script also places a log in **/tmp/klippy.log** which "
#~ "provides more detailed information."
#~ msgstr ""

#~ msgid ""
#~ "To use Hall filament width sensor, read [Config "
#~ "Reference](Config_Reference.md#hall_filament_width_sensor) and [G-Code "
#~ "documentation](G-Codes.md#hall_filament_width_sensor)."
#~ msgstr ""

#~ msgid "Calibration procedure"
#~ msgstr ""

#~ msgid "Save raw sensor values in config parameter `Raw_dia1` and `Raw_dia2`"
#~ msgstr ""

#~ msgid "Logging"
#~ msgstr ""

#~ msgid "Klipper supports the following standard G-Code commands:"
#~ msgstr ""

#~ msgid "Turn off motors: `M18` or `M84`"
#~ msgstr ""

#~ msgid "Set position: `G92 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>]`"
#~ msgstr ""

#~ msgid ""
#~ "Note: If S is not specified and both P and T are specified, then the "
#~ "acceleration is set to the minimum of P and T. If only one of P or T is "
#~ "specified, the command has no effect."
#~ msgstr ""

#~ msgid "Note: M109 always waits for temperature to settle at requested value"
#~ msgstr ""

#~ msgid "Set fan speed: `M106 S<value>`"
#~ msgstr ""

#~ msgid "Get firmware version: `M115`"
#~ msgstr ""

#~ msgid "Additional Commands"
#~ msgstr ""

#~ msgid "ACCELEROMETER_MEASURE"
#~ msgstr ""

#~ msgid "ACCELEROMETER_DEBUG_READ"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when an [angle config "
#~ "section](Config_Reference.md#angle) is enabled."
#~ msgstr ""

#~ msgid ""
#~ "`ANGLE_DEBUG_READ CHIP=<config_name> REG=<register>`: Queries sensor "
#~ "register \"register\" (e.g. 44 or 0x2C). Can be useful for debugging "
#~ "purposes. This is only available for tle5012b chips."
#~ msgstr ""

#~ msgid "BED_MESH_CALIBRATE"
#~ msgstr ""

#~ msgid "BED_MESH_MAP"
#~ msgstr ""

#~ msgid "BED_MESH_PROFILE"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [bed_screws config "
#~ "section](Config_Reference.md#bed_screws) is enabled (also see the [manual "
#~ "level guide](Manual_Level.md#adjusting-bed-leveling-screws))."
#~ msgstr ""

#~ msgid "BED_TILT_CALIBRATE"
#~ msgstr ""

#~ msgid ""
#~ "`BLTOUCH_DEBUG COMMAND=<command>`: This sends a command to the BLTouch. It "
#~ "may be useful for debugging. Available commands are: `pin_down`, "
#~ "`touch_mode`, `pin_up`, `self_test`, `reset`. A BL-Touch V3.0 or V3.1 may "
#~ "also support `set_5V_output_mode`, `set_OD_output_mode`, `output_mode_store`"
#~ " commands."
#~ msgstr ""

#~ msgid "The configfile module is automatically loaded."
#~ msgstr ""

#~ msgid "UPDATE_DELAYED_GCODE"
#~ msgstr ""

#~ msgid "DELTA_CALIBRATE"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a [display config "
#~ "section](Config_Reference.md#gcode_macro) is enabled."
#~ msgstr ""

#~ msgid ""
#~ "The display_status module is automatically loaded if a [display config "
#~ "section](Config_Reference.md#display) is enabled. It provides the following "
#~ "standard G-Code commands:"
#~ msgstr ""

#~ msgid ""
#~ "`SET_DISPLAY_TEXT MSG=<message>`: Performs the equivalent of M117, setting "
#~ "the supplied `MSG` as the current display message. If `MSG` is omitted the "
#~ "display will be cleared."
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when an [endstop_phase config "
#~ "section](Config_Reference.md#endstop_phase) is enabled (also see the "
#~ "[endstop phase guide](Endstop_Phase.md))."
#~ msgstr ""

#~ msgid "`EXCLUDE_OBJECT`"
#~ msgstr ""

#~ msgid ""
#~ "When the `RESET` parameter is given, the list of excluded objects will be "
#~ "cleared. Additionally including `NAME` will only reset the named object. "
#~ "This **can** cause print failures, if layers were already skipped."
#~ msgstr ""

#~ msgid ""
#~ "When the `NAME` parameter is included, this defines an object to be "
#~ "excluded."
#~ msgstr ""

#~ msgid ""
#~ "When the `RESET` parameter is provided, all defined objects will be cleared,"
#~ " and the `[exclude_object]` module will be reset."
#~ msgstr ""

#~ msgid ""
#~ "`EXCLUDE_OBJECT_END [NAME=object_name]`: Denotes the end of the object's "
#~ "gcode for the layer. It is paired with `EXCLUDE_OBJECT_START`. A `NAME` "
#~ "parameter is optional, and will only warn when the provided name does not "
#~ "match the current object."
#~ msgstr ""

#~ msgid "SET_PRESSURE_ADVANCE"
#~ msgstr ""

#~ msgid "SYNC_EXTRUDER_MOTION"
#~ msgstr ""

#~ msgid "SYNC_STEPPER_TO_EXTRUDER"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a "
#~ "[filament_switch_sensor](Config_Reference.md#filament_switch_sensor) or "
#~ "[filament_motion_sensor](Config_Reference.md#filament_motion_sensor) config "
#~ "section is enabled."
#~ msgstr ""

#~ msgid ""
#~ "`SET_FILAMENT_SENSOR SENSOR=<sensor_name> ENABLE=[0|1]`: Sets the filament "
#~ "sensor on/off. If ENABLE is set to 0, the filament sensor will be disabled, "
#~ "if set to 1 it is enabled."
#~ msgstr ""

#~ msgid "The following additional commands are also available."
#~ msgstr ""

#~ msgid ""
#~ "`GET_RETRACTION`: Queries the current parameters used by firmware retraction"
#~ " and displays them on the terminal."
#~ msgstr ""

#~ msgid "FORCE_MOVE"
#~ msgstr ""

#~ msgid "[gcode]"
#~ msgstr ""

#~ msgid "FIRMWARE_RESTART"
#~ msgstr ""

#~ msgid "HELP"
#~ msgstr ""

#~ msgid "Arc Plane Select: G17 (XY plane), G18 (XZ plane), G19 (YZ plane)"
#~ msgstr ""

#~ msgid "[gcode_move]"
#~ msgstr ""

#~ msgid "SET_GCODE_OFFSET"
#~ msgstr ""

#~ msgid "RESTORE_GCODE_STATE"
#~ msgstr ""

#~ msgid "`QUERY_FILAMENT_WIDTH`: Return the current measured filament width."
#~ msgstr ""

#~ msgid ""
#~ "`DISABLE_FILAMENT_WIDTH_SENSOR`: Turn off the filament width sensor and stop"
#~ " using it for flow control."
#~ msgstr ""

#~ msgid ""
#~ "`QUERY_RAW_FILAMENT_WIDTH`: Return the current ADC channel readings and RAW "
#~ "sensor value for calibration points."
#~ msgstr ""

#~ msgid "`DISABLE_FILAMENT_WIDTH_LOG`: Turn off diameter logging."
#~ msgstr ""

#~ msgid "`TURN_OFF_HEATERS`: Turn off all heaters."
#~ msgstr ""

#~ msgid ""
#~ "`SET_HEATER_TEMPERATURE HEATER=<heater_name> [TARGET=<target_temperature>]`:"
#~ " Sets the target temperature for a heater. If a target temperature is not "
#~ "supplied, the target is 0."
#~ msgstr ""

#~ msgid ""
#~ "The following command is enabled if an [input_shaper config "
#~ "section](Config_Reference.md#input_shaper) has been enabled (also see the "
#~ "[resonance compensation guide](Resonance_Compensation.md))."
#~ msgstr ""

#~ msgid "The manual_probe module is automatically loaded."
#~ msgstr ""

#~ msgid "`ABORT`: This command terminates the manual probing tool."
#~ msgstr ""

#~ msgid "Z_OFFSET_APPLY_ENDSTOP"
#~ msgstr ""

#~ msgid ""
#~ "`MANUAL_STEPPER STEPPER=config_name [ENABLE=[0|1]] [SET_POSITION=<pos>] "
#~ "[SPEED=<speed>] [ACCEL=<accel>] [MOVE=<pos> [STOP_ON_ENDSTOP=[1|2|-1|-2]] "
#~ "[SYNC=0]]`: This command will alter the state of the stepper. Use the ENABLE"
#~ " parameter to enable/disable the stepper. Use the SET_POSITION parameter to "
#~ "force the stepper to think it is at the given position. Use the MOVE "
#~ "parameter to request a movement to the given position. If SPEED and/or ACCEL"
#~ " is specified then the given values will be used instead of the defaults "
#~ "specified in the config file. If an ACCEL of zero is specified then no "
#~ "acceleration will be performed. If STOP_ON_ENDSTOP=1 is specified then the "
#~ "move will end early should the endstop report as triggered (use "
#~ "STOP_ON_ENDSTOP=2 to complete the move without error even if the endstop "
#~ "does not trigger, use -1 or -2 to stop when the endstop reports not "
#~ "triggered). Normally future G-Code commands will be scheduled to run after "
#~ "the stepper move completes, however if a manual stepper move uses SYNC=0 "
#~ "then future G-Code movement commands may run in parallel with the stepper "
#~ "movement."
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when any of the [led config "
#~ "sections](Config_Reference.md#leds) are enabled."
#~ msgstr ""

#~ msgid ""
#~ "`SET_LED_TEMPLATE LED=<led_name> TEMPLATE=<template_name> "
#~ "[<param_x>=<literal>] [INDEX=<index>]`: Assign a "
#~ "[display_template](Config_Reference.md#display_template) to a given "
#~ "[LED](Config_Reference.md#leds). For example, if one defined a "
#~ "`[display_template my_led_template]` config section then one could assign "
#~ "`TEMPLATE=my_led_template` here. The display_template should produce a comma"
#~ " separated string containing four floating point numbers corresponding to "
#~ "red, green, blue, and white color settings. The template will be "
#~ "continuously evaluated and the LED will be automatically set to the "
#~ "resulting colors. One may set display_template parameters to use during "
#~ "template evaluation (parameters will be parsed as Python literals). If INDEX"
#~ " is not specified then all chips in the LED's daisy-chain will be set to the"
#~ " template, otherwise only the chip with the given index will be updated. If "
#~ "TEMPLATE is an empty string then this command will clear any previous "
#~ "template assigned to the LED (one can then use `SET_LED` commands to manage "
#~ "the LED's color settings)."
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [palette2 config "
#~ "section](Config_Reference.md#palette2) is enabled."
#~ msgstr ""

#~ msgid ""
#~ "`PALETTE_CONNECT`: This command initializes the connection with the Palette "
#~ "2."
#~ msgstr ""

#~ msgid ""
#~ "`PALETTE_CLEAR`: This command instructs the Palette 2 to clear all of the "
#~ "input and output paths of filament."
#~ msgstr ""

#~ msgid ""
#~ "`PALETTE_SMART_LOAD`: This command start the smart load sequence on the "
#~ "Palette 2. Filament is loaded automatically by extruding it the distance "
#~ "calibrated on the device for the printer, and instructs the Palette 2 once "
#~ "the loading has been completed. This command is the same as pressing **Smart"
#~ " Load** directly on the Palette 2 screen after the filament load is "
#~ "complete."
#~ msgstr ""

#~ msgid ""
#~ "`PID_CALIBRATE HEATER=<config_name> TARGET=<temperature> [WRITE_FILE=1]`: "
#~ "Perform a PID calibration test. The specified heater will be enabled until "
#~ "the specified target temperature is reached, and then the heater will be "
#~ "turned off and on for several cycles. If the WRITE_FILE parameter is "
#~ "enabled, then the file /tmp/heattest.txt will be created with a log of all "
#~ "temperature samples taken during the test."
#~ msgstr ""

#~ msgid "RESUME"
#~ msgstr ""

#~ msgid "CANCEL_PRINT"
#~ msgstr ""

#~ msgid "SET_PRINT_STATS_INFO"
#~ msgstr ""

#~ msgid ""
#~ "`PROBE [PROBE_SPEED=<mm/s>] [LIFT_SPEED=<mm/s>] [SAMPLES=<count>] "
#~ "[SAMPLE_RETRACT_DIST=<mm>] [SAMPLES_TOLERANCE=<mm>] "
#~ "[SAMPLES_TOLERANCE_RETRIES=<count>] [SAMPLES_RESULT=median|average]`: Move "
#~ "the nozzle downwards until the probe triggers. If any of the optional "
#~ "parameters are provided they override their equivalent setting in the [probe"
#~ " config section](Config_Reference.md#probe)."
#~ msgstr ""

#~ msgid ""
#~ "`PROBE_ACCURACY [PROBE_SPEED=<mm/s>] [SAMPLES=<count>] "
#~ "[SAMPLE_RETRACT_DIST=<mm>]`: Calculate the maximum, minimum, average, "
#~ "median, and standard deviation of multiple probe samples. By default, 10 "
#~ "SAMPLES are taken. Otherwise the optional parameters default to their "
#~ "equivalent setting in the probe config section."
#~ msgstr ""

#~ msgid ""
#~ "`Z_OFFSET_APPLY_PROBE`: Take the current Z Gcode offset (aka, babystepping),"
#~ " and subtract if from the probe's z_offset. This acts to take a frequently "
#~ "used babystepping value, and \"make it permanent\". Requires a `SAVE_CONFIG`"
#~ " to take effect."
#~ msgstr ""

#~ msgid ""
#~ "`QUERY_ADC [NAME=<config_name>] [PULLUP=<value>]`: Report the last analog "
#~ "value received for a configured analog pin. If NAME is not provided, the "
#~ "list of available adc names are reported. If PULLUP is provided (as a value "
#~ "in Ohms), the raw analog value along with the equivalent resistance given "
#~ "that pullup is reported."
#~ msgstr ""

#~ msgid "QUERY_ENDSTOPS"
#~ msgstr ""

#~ msgid ""
#~ "`MEASURE_AXES_NOISE`: Measures and outputs the noise for all axes of all "
#~ "enabled accelerometer chips."
#~ msgstr ""

#~ msgid ""
#~ "`SHAPER_CALIBRATE [AXIS=<axis>] [NAME=<name>] [FREQ_START=<min_freq>] "
#~ "[FREQ_END=<max_freq>] [HZ_PER_SEC=<hz_per_sec>] "
#~ "[MAX_SMOOTHING=<max_smoothing>]`: Similarly to `TEST_RESONANCES`, runs the "
#~ "resonance test as configured, and tries to find the optimal parameters for "
#~ "the input shaper for the requested axis (or both X and Y axes if `AXIS` "
#~ "parameter is unset). If `MAX_SMOOTHING` is unset, its value is taken from "
#~ "`[resonance_tester]` section, with the default being unset. See the [Max "
#~ "smoothing](Measuring_Resonances.md#max-smoothing) of the measuring "
#~ "resonances guide for more information on the use of this feature. The "
#~ "results of the tuning are printed to the console, and the frequency "
#~ "responses and the different input shapers values are written to a CSV "
#~ "file(s) `/tmp/calibration_data_<axis>_<name>.csv`. Unless specified, NAME "
#~ "defaults to the current time in \"YYYYMMDD_HHMMSS\" format. Note that the "
#~ "suggested input shaper parameters can be persisted in the config by issuing "
#~ "`SAVE_CONFIG` command."
#~ msgstr ""

#~ msgid ""
#~ "`RESPOND MSG=\"<message>\"`: echo the message prepended with the configured "
#~ "default prefix (or `echo: ` if no prefix is configured)."
#~ msgstr ""

#~ msgid ""
#~ "`RESPOND TYPE=error MSG=\"<message>\"`: echo the message prepended with `!! "
#~ "`."
#~ msgstr ""

#~ msgid ""
#~ "`SAVE_VARIABLE VARIABLE=<name> VALUE=<value>`: Saves the variable to disk so"
#~ " that it can be used across restarts. All stored variables are loaded into "
#~ "the `printer.save_variables.variables` dict at startup and can be used in "
#~ "gcode macros. The provided VALUE is parsed as a Python literal."
#~ msgstr ""

#~ msgid ""
#~ "When the [sdcard_loop config section](Config_Reference.md#sdcard_loop) is "
#~ "enabled, the following extended commands are available."
#~ msgstr ""

#~ msgid "`SDCARD_LOOP_END`: End a looped section in the SD print."
#~ msgstr ""

#~ msgid "SET_SERVO"
#~ msgstr ""

#~ msgid ""
#~ "`SET_SKEW [XY=<ac_length,bd_length,ad_length>] [XZ=<ac,bd,ad>] "
#~ "[YZ=<ac,bd,ad>] [CLEAR=<0|1>]`: Configures the [skew_correction] module with"
#~ " measurements (in mm) taken from a calibration print. One may enter "
#~ "measurements for any combination of planes, planes not entered will retain "
#~ "their current value. If `CLEAR=1` is entered then all skew correction will "
#~ "be disabled."
#~ msgstr ""

#~ msgid ""
#~ "`CALC_MEASURED_SKEW [AC=<ac_length>] [BD=<bd_length>] [AD=<ad_length>]`: "
#~ "Calculates and reports the skew (in radians and degrees) based on a measured"
#~ " print. This can be useful for determining the printer's current skew after "
#~ "correction has been applied. It may also be useful before correction is "
#~ "applied to determine if skew correction is necessary. See [Skew "
#~ "Correction](Skew_Correction.md) for details on skew calibration objects and "
#~ "measurements."
#~ msgstr ""

#~ msgid "SET_SMART_EFFECTOR"
#~ msgstr ""

#~ msgid "[stepper_enable]"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a [temperature_fan config "
#~ "section](Config_Reference.md#temperature_fan) is enabled."
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when any of the [tmcXXXX config "
#~ "sections](Config_Reference.md#tmc-stepper-driver-configuration) are enabled."
#~ msgstr ""

#~ msgid ""
#~ "`INIT_TMC STEPPER=<name>`: This command will initialize the TMC registers. "
#~ "Needed to re-enable the driver if power to the chip is turned off then back "
#~ "on."
#~ msgstr ""

#~ msgid ""
#~ "`SET_TMC_FIELD STEPPER=<name> FIELD=<field> VALUE=<value>`: This will alter "
#~ "the value of the specified register field of the TMC driver. This command is"
#~ " intended for low-level diagnostics and debugging only because changing the "
#~ "fields during run-time can lead to undesired and potentially dangerous "
#~ "behavior of your printer. Permanent changes should be made using the printer"
#~ " configuration file instead. No sanity checks are performed for the given "
#~ "values."
#~ msgstr ""

#~ msgid ""
#~ "`SET_VELOCITY_LIMIT [VELOCITY=<value>] [ACCEL=<value>] "
#~ "[ACCEL_TO_DECEL=<value>] [SQUARE_CORNER_VELOCITY=<value>]`: Modify the "
#~ "printer's velocity limits."
#~ msgstr ""

#~ msgid ""
#~ "`TUNING_TOWER COMMAND=<command> PARAMETER=<name> START=<value> "
#~ "[SKIP=<value>] [FACTOR=<value> [BAND=<value>]] | [STEP_DELTA=<value> "
#~ "STEP_HEIGHT=<value>]`: A tool for tuning a parameter on each Z height during"
#~ " a print. The tool will run the given `COMMAND` with the given `PARAMETER` "
#~ "assigned to a value that varies with `Z` according to a formula. Use "
#~ "`FACTOR` if you will use a ruler or calipers to measure the Z height of the "
#~ "optimum value, or `STEP_DELTA` and `STEP_HEIGHT` if the tuning tower model "
#~ "has bands of discrete values as is common with temperature towers. If "
#~ "`SKIP=<value>` is specified, the tuning process doesn't begin until Z height"
#~ " `<value>` is reached, and below that the value will be set to `START`; in "
#~ "this case, the `z_height` used in the formulas below is actually `max(z - "
#~ "skip, 0)`. There are three possible combinations of options:"
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports the following standard G-Code commands if the "
#~ "[virtual_sdcard config section](Config_Reference.md#virtual_sdcard) is "
#~ "enabled:"
#~ msgstr ""

#~ msgid "Start/resume SD print: `M24`"
#~ msgstr ""

#~ msgid ""
#~ "In addition, the following extended commands are available when the "
#~ "\"virtual_sdcard\" config section is enabled."
#~ msgstr ""

#~ msgid "`SDCARD_RESET_FILE`: Unload file and clear SD state."
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [z_tilt config "
#~ "section](Config_Reference.md#z_tilt) is enabled."
#~ msgstr ""

#~ msgid ""
#~ "Best in class performance. Klipper is able to achieve high stepping rates on"
#~ " both new and old micro-controllers. Even old 8bit micro-controllers can "
#~ "obtain rates over 175K steps per second. On more recent micro-controllers, "
#~ "several million steps per second are possible. Higher stepper rates enable "
#~ "higher print velocities. The stepper event timing remains precise even at "
#~ "high speeds which improves overall stability."
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports \"Input Shaping\" to reduce the impact of vibrations on "
#~ "print quality. This can reduce or eliminate \"ringing\" (also known as "
#~ "\"ghosting\", \"echoing\", or \"rippling\") in prints. It may also allow one"
#~ " to obtain faster printing speeds while still maintaining high print "
#~ "quality."
#~ msgstr ""

#~ msgid ""
#~ "Simpler code. Klipper uses a very high level language (Python) for most "
#~ "code. The kinematics algorithms, the G-code parsing, the heating and "
#~ "thermistor algorithms, etc. are all written in Python. This makes it easier "
#~ "to develop new functionality."
#~ msgstr ""

#~ msgid "Klipper supports many standard 3d printer features:"
#~ msgstr ""

#~ msgid ""
#~ "Support for cartesian, delta, corexy, corexz, hybrid-corexy, hybrid-corexz, "
#~ "deltesian, rotary delta, polar, and cable winch style printers."
#~ msgstr ""

#~ msgid ""
#~ "Support for common temperature sensors (eg, common thermistors, AD595, "
#~ "AD597, AD849x, PT100, PT1000, MAX6675, MAX31855, MAX31856, MAX31865, BME280,"
#~ " HTU21D, DS18B20, and LM75). Custom thermistors and custom analog "
#~ "temperature sensors can also be configured. One can monitor the internal "
#~ "micro-controller temperature sensor and the internal temperature sensor of a"
#~ " Raspberry Pi."
#~ msgstr ""

#~ msgid ""
#~ "Support for common LCD displays attached directly to the printer. A default "
#~ "menu is also available. The contents of the display and menu can be fully "
#~ "customized via the config file."
#~ msgstr ""

#~ msgid ""
#~ "Support for measuring and recording acceleration using an adxl345, mpu9250, "
#~ "and mpu6050 accelerometers."
#~ msgstr ""

#~ msgid "Step Benchmarks"
#~ msgstr ""

#~ msgid "3 steppers active"
#~ msgstr ""

#~ msgid "20Mhz AVR"
#~ msgstr ""

#~ msgid "686K"
#~ msgstr ""

#~ msgid "578K"
#~ msgstr ""

#~ msgid "STM32G0B1"
#~ msgstr ""

#~ msgid "1180K"
#~ msgstr ""

#~ msgid "981K"
#~ msgstr ""

#~ msgid "LPC1768"
#~ msgstr ""

#~ msgid "2353K"
#~ msgstr ""

#~ msgid "1636K"
#~ msgstr ""

#~ msgid "SAMD51"
#~ msgstr ""

#~ msgid "3652K"
#~ msgstr ""

#~ msgid "2634K"
#~ msgstr ""

#~ msgid ""
#~ "If unsure of the micro-controller on a particular board, find the "
#~ "appropriate [config file](../config/), and look for the micro-controller "
#~ "name in the comments at the top of that file."
#~ msgstr ""

#~ msgid "How do I calculate the rotation_distance config parameter?"
#~ msgstr ""

#~ msgid ""
#~ "The name found in the above command is stable and it is possible to use it "
#~ "in the config file and while flashing the micro-controller code. For "
#~ "example, a flash command might look similar to:"
#~ msgstr ""

#~ msgid "When the micro-controller restarts the device changes to /dev/ttyUSB1"
#~ msgstr ""

#~ msgid ""
#~ "If you're having an intermittent failure or you do have a standard setup, "
#~ "then double check that Klipper isn't running when flashing (sudo service "
#~ "klipper stop), make sure OctoPrint isn't trying to connect directly to the "
#~ "device (open the Connection tab in the web page and click Disconnect if the "
#~ "Serial Port is set to the device), and make sure FLASH_DEVICE is set "
#~ "correctly for your board (see the [question above](#wheres-my-serial-port))."
#~ msgstr ""

#~ msgid ""
#~ "If you want to change the baud rate anyway, then the new rate will need to "
#~ "be configured in the micro-controller (during **make menuconfig**) and that "
#~ "updated code will need to be compiled and flashed to the micro-controller. "
#~ "The Klipper printer.cfg file will also need to be updated to match that baud"
#~ " rate (see the [config reference](Config_Reference.md#mcu) for details). For"
#~ " example:"
#~ msgstr ""

#~ msgid "Can I run Klipper on something other than a Raspberry Pi 3?"
#~ msgstr ""

#~ msgid ""
#~ "Klipper has been run on other machines. The Klipper host software only "
#~ "requires Python running on a Linux (or similar) computer. However, if you "
#~ "wish to run it on a different machine you will need Linux admin knowledge to"
#~ " install the system prerequisites for that particular machine. See the "
#~ "[install-octopi.sh](../scripts/install-octopi.sh) script for further "
#~ "information on the necessary Linux admin steps."
#~ msgstr ""

#~ msgid "Can I run multiple instances of Klipper on the same host machine?"
#~ msgstr ""

#~ msgid ""
#~ "~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer2.cfg -l "
#~ "/tmp/klippy2.log -I /tmp/printer2\n"
#~ msgstr ""

#~ msgid ""
#~ "Klipper creates a \"virtual serial port\" via the \"/tmp/printer\" file, and"
#~ " it emulates a classic 3d-printer serial interface via that file. In "
#~ "general, alternative software may work with Klipper as long as it can be "
#~ "configured to use \"/tmp/printer\" for the printer serial port."
#~ msgstr ""

#~ msgid ""
#~ "If you want to move the head after a print finishes, consider adding the "
#~ "desired movement to the \"custom g-code\" section of your slicer."
#~ msgstr ""

#~ msgid ""
#~ "I converted my config from Marlin and the X/Y axes work fine, but I just get"
#~ " a screeching noise when homing the Z axis"
#~ msgstr ""

#~ msgid ""
#~ "If using the TMC2208 (or TMC2224) driver in \"standalone mode\" then make "
#~ "sure to use the [latest version of Klipper](#how-do-i-upgrade-to-the-latest-"
#~ "software). A workaround for a TMC2208 \"stealthchop\" driver problem was "
#~ "added to Klipper in mid-March of 2020."
#~ msgstr ""

#~ msgid ""
#~ "If using a Raspberry Pi, use a [good quality power "
#~ "supply](https://www.raspberrypi.com/documentation/computers/raspberry-"
#~ "pi.html#power-supply) for the Raspberry Pi and use a [good quality USB "
#~ "cable](https://forums.raspberrypi.com/viewtopic.php?p=589877#p589877) to "
#~ "connect that power supply to the Pi. If you get \"under voltage\" warnings "
#~ "from OctoPrint, this is related to the power supply and it must be fixed."
#~ msgstr ""

#~ msgid "My Raspberry Pi keeps rebooting during prints"
#~ msgstr ""

#~ msgid ""
#~ "The workaround is to use a restart_method other than \"command\" or to flash"
#~ " an updated bootloader to the AVR device. Flashing a new bootloader is a one"
#~ " time step that typically requires an external programmer - see "
#~ "[Bootloaders](Bootloaders.md) for further details."
#~ msgstr ""

#~ msgid ""
#~ "In addition, the micro-controller software is configured with a minimum and "
#~ "maximum temperature range for each heater at startup (see the min_temp and "
#~ "max_temp parameters in the [config reference](Config_Reference.md#extruder) "
#~ "for details). If the micro-controller detects that the temperature is "
#~ "outside of that range then it will also enter a \"shutdown\" state."
#~ msgstr ""

#~ msgid ""
#~ "Long answer: Klipper uses the standard pin names defined by the micro-"
#~ "controller. On the Atmega chips these hardware pins have names like `PA4`, "
#~ "`PC7`, or `PD2`."
#~ msgstr ""

#~ msgid "It depends on the type of device and type of pin:"
#~ msgstr ""

#~ msgid ""
#~ "SPI pins: When using hardware SPI it is necessary to wire the pins to the "
#~ "micro-controller's SPI capable pins. However, most devices can be configured"
#~ " to use \"software SPI\", in which case any general purpose IO pins may be "
#~ "used."
#~ msgstr ""

#~ msgid ""
#~ "Navigate to the OctoPrint terminal tab and issue an M112 command in the "
#~ "terminal box. The M112 command will cause Klipper to enter into a "
#~ "\"shutdown\" state, and it will cause OctoPrint to disconnect from Klipper. "
#~ "Navigate to the OctoPrint connection area and click on \"Connect\" to cause "
#~ "OctoPrint to reconnect. Navigate back to the terminal tab and issue a "
#~ "FIRMWARE_RESTART command to clear the Klipper error state. After completing "
#~ "this sequence, the previous heating request will be canceled and a new print"
#~ " may be started."
#~ msgstr ""

#~ msgid ""
#~ "Note that endstop switches themselves tend to trigger at slightly different "
#~ "positions, so a difference of a couple of microsteps is likely the result of"
#~ " endstop inaccuracies. A stepper motor itself can only lose steps in "
#~ "increments of 4 full steps. (So, if one is using 16 microsteps, then a lost "
#~ "step on the stepper would result in the \"mcu:\" step counter being off by a"
#~ " multiple of 64 microsteps.)"
#~ msgstr ""

#~ msgid ""
#~ "There are some related questions: Why doesn't Klipper pause the print "
#~ "instead? Report a warning instead? Check for errors before the print? Ignore"
#~ " errors in user typed commands? etc? Currently Klipper reads commands using "
#~ "the G-Code protocol, and unfortunately the G-Code command protocol is not "
#~ "flexible enough to make these alternatives practical today. There is "
#~ "developer interest in improving the user experience during abnormal events, "
#~ "but it is expected that will require notable infrastructure work (including "
#~ "a shift away from G-Code)."
#~ msgstr ""

#~ msgid ""
#~ "cd ~/klipper\n"
#~ "git pull\n"
#~ "~/klipper/scripts/install-octopi.sh\n"
#~ msgstr ""

#~ msgid ""
#~ "cd ~/klipper\n"
#~ "git pull\n"
#~ "sudo service klipper restart\n"
#~ msgstr ""

#~ msgid "How do I uninstall Klipper?"
#~ msgstr ""

#~ msgid "Workflow Overview"
#~ msgstr ""

#~ msgid ""
#~ "When Klipper processes the `EXCLUDE_OBJECT_DEFINE` block, it will update the"
#~ " status with the known objects and pass it on to clients."
#~ msgstr ""

#~ msgid ""
#~ "The client will receive the updated status from Klipper and can use that "
#~ "information to reflect the object's status in the UI."
#~ msgstr ""

#~ msgid "Object Definitions"
#~ msgstr ""

#~ msgid ""
#~ "All available G-Code commands are documented in the [G-Code "
#~ "Reference](./G-Codes.md#excludeobject)"
#~ msgstr ""

#~ msgid "The Klipper firmware is restarted."
#~ msgstr ""

#~ msgid ""
#~ "As the print progresses, the `exclude_object.current_object` status field "
#~ "will be updated as Klipper processes `EXCLUDE_OBJECT_START` and "
#~ "`EXCLUDE_OBJECT_END` commands. The `current_object` field will be set even "
#~ "if the object has been excluded. Undefined objects marked with a "
#~ "`EXCLUDE_OBJECT_START` will be added to the known objects to assist in UI "
#~ "hinting, without any additional metadata."
#~ msgstr ""

#~ msgid "Guidelines"
#~ msgstr ""

#~ msgid ""
#~ "The `kit` prefix is for 3d printers that are assembled according to a widely"
#~ " used specification. These \"kit\" printers are generally distinct from "
#~ "normal \"printers\" in that they are not sold by a manufacturer."
#~ msgstr ""

#~ msgid ""
#~ "Do not use spaces or special characters in the config filename. The filename"
#~ " should contain only characters `A-Z`, `a-z`, `0-9`, `-`, and `.`."
#~ msgstr ""

#~ msgid ""
#~ "Do not specify `pressure_advance` in an example config, as that value is "
#~ "specific to the filament, not the printer hardware. Similarly, do not "
#~ "specify `max_extrude_only_velocity` nor `max_extrude_only_accel` settings."
#~ msgstr ""

#~ msgid ""
#~ "Do not copy the field documentation into the example config files. (Doing so"
#~ " creates a maintenance burden as an update to the documentation would then "
#~ "require changing it in many places.)"
#~ msgstr ""

#~ msgid ""
#~ "Avoid defining field values that are set to their default value. For "
#~ "example, one should not specify `min_extrude_temp: 170` as that is already "
#~ "the default value."
#~ msgstr ""

#~ msgid ""
#~ "Do not disable a default safety system in an example config file. For "
#~ "example, a config should not specify a custom `max_extrude_cross_section`. "
#~ "Do not enable debugging features. For example there should not be a "
#~ "`force_move` config section."
#~ msgstr ""

#~ msgid ""
#~ "The stepper phase adjusted endstop mechanism can use the precision of the "
#~ "stepper motors to improve the precision of the endstop switches. A stepper "
#~ "motor moves by cycling through a series of phases until in completes four "
#~ "\"full steps\". So, a stepper motor using 16 micro-steps would have 64 "
#~ "phases and when moving in a positive direction it would cycle through "
#~ "phases: 0, 1, 2, ... 61, 62, 63, 0, 1, 2, etc. Crucially, when the stepper "
#~ "motor is at a particular position on a linear rail it should always be at "
#~ "the same stepper phase. Thus, when a carriage triggers the endstop switch "
#~ "the stepper controlling that carriage should always be at the same stepper "
#~ "motor phase. Klipper's endstop phase system combines the stepper phase with "
#~ "the endstop trigger to improve the accuracy of the endstop."
#~ msgstr ""

#~ msgid "[endstop_phase]\n"
#~ msgstr ""

#~ msgid "ENDSTOP_PHASE_CALIBRATE STEPPER=stepper_z\n"
#~ msgstr ""

#~ msgid ""
#~ "In order to use this system the endstop must be accurate enough to identify "
#~ "the stepper position within two \"full steps\". So, for example, if a "
#~ "stepper is using 16 micro-steps with a step distance of 0.005mm then the "
#~ "endstop must have an accuracy of at least 0.160mm. If one gets \"Endstop "
#~ "stepper_z incorrect phase\" type error messages than in may be due to an "
#~ "endstop that is not sufficiently accurate. If recalibration does not help "
#~ "then disable endstop phase adjustments by removing them from the config "
#~ "file."
#~ msgstr ""

#~ msgid ""
#~ "Ultimately, the delta calibration is dependent on the precision of the tower"
#~ " endstop switches. If one is using Trinamic stepper motor drivers then "
#~ "consider enabling [endstop phase](Endstop_Phase.md) detection to improve the"
#~ " accuracy of those switches."
#~ msgstr ""

#~ msgid ""
#~ "If using a probe that is mounted on the side of the hotend (that is, it has "
#~ "an X or Y offset) then note that performing delta calibration will "
#~ "invalidate the results of probe calibration. These types of probes are "
#~ "rarely suitable for use on a delta (because minor effector tilt will result "
#~ "in a probe location bias). If using the probe anyway, then be sure to rerun "
#~ "probe calibration after any delta calibration."
#~ msgstr ""

#~ msgid ""
#~ "During the delta calibration process it may be necessary for the printer to "
#~ "probe below what would otherwise be considered the plane of the bed. It is "
#~ "typical to permit this during calibration by updating the config so that the"
#~ " printer's `minimum_z_position=-5`. (Once calibration completes, one can "
#~ "remove this setting from the config.)"
#~ msgstr ""

#~ msgid ""
#~ "After probing the seven points new delta parameters will be calculated. Save"
#~ " and apply these parameters by running:"
#~ msgstr ""

#~ msgid ""
#~ "This calibration procedure requires printing a test object and measuring "
#~ "parts of that test object with digital calipers."
#~ msgstr ""

#~ msgid ""
#~ "If possible, perform the measurements described below while the object is "
#~ "still attached to the print bed, but don't worry if the part detaches from "
#~ "the bed - just try to avoid bending the object when performing the "
#~ "measurements."
#~ msgstr ""

#~ msgid "![delta_cal_e_step1](img/delta_cal_e_step1.png)"
#~ msgstr ""

#~ msgid ""
#~ "Then measure the distance between the A pillar and the pillar across from "
#~ "the C label."
#~ msgstr ""

#~ msgid "Enter these parameters into Klipper:"
#~ msgstr ""

#~ msgid "![delta_cal_e_step3](img/delta_cal_e_step3.png)"
#~ msgstr ""

#~ msgid "![delta-ab-pillar](img/delta-outer-pillar.jpg)"
#~ msgstr ""

#~ msgid "DELTA_ANALYZE OUTER_PILLAR_WIDTHS=<a>,<far_c>,<b>,<far_a>,<c>,<far_b>\n"
#~ msgstr ""

#~ msgid "Finally, perform the enhanced delta calibration by running:"
#~ msgstr ""

#~ msgid ""
#~ "If the delta printer has good dimensional accuracy then the distance between"
#~ " any two pillars should be around 74mm and the width of every pillar should "
#~ "be around 9mm. (Specifically, the goal is for the distance between any two "
#~ "pillars minus the width of one of the pillars to be exactly 65mm.) Should "
#~ "there be a dimensional inaccuracy in the part then the DELTA_ANALYZE routine"
#~ " will calculate new delta parameters using both the distance measurements "
#~ "and the previous height measurements from the last DELTA_CALIBRATE command."
#~ msgstr ""

#~ msgid ""
#~ "Note that performing delta calibration will invalidate any previously "
#~ "obtained bed mesh. After performing a new delta calibration be sure to rerun"
#~ " BED_MESH_CALIBRATE."
#~ msgstr ""

#~ msgid ""
#~ "The main Klipper GitHub repository uses \"github actions\" to run a series "
#~ "of regression tests. It can be useful to run some of these tests locally."
#~ msgstr ""

#~ msgid ""
#~ "tar xfz klipper-dict-20??????.tar.gz\n"
#~ "~/klippy-env/bin/python ~/klipper/scripts/test_klippy.py -d dict/ ~/klipper/test/klippy/*.test\n"
#~ msgstr ""

#~ msgid ""
#~ "See the \"HELP\" command within the tool for more information on its "
#~ "functionality."
#~ msgstr ""

#~ msgid ""
#~ "To run Klippy in this batch mode, there is a one time step necessary to "
#~ "generate the micro-controller \"data dictionary\". This is done by compiling"
#~ " the micro-controller code to obtain the **out/klipper.dict** file:"
#~ msgstr ""

#~ msgid ""
#~ "The above will produce a file **test.serial** with the binary serial output."
#~ " This output can be translated to readable text with:"
#~ msgstr ""

#~ msgid "Motion analysis and data logging"
#~ msgstr ""

#~ msgid ""
#~ "This command will connect to the Klipper API Server, subscribe to status and"
#~ " motion information, and log the results. Two files are generated - a "
#~ "compressed data file and an index file (eg, `mylog.json.gz` and "
#~ "`mylog.index.gz`). After starting the logging, it is possible to complete "
#~ "prints and other actions - the logging will continue in the background. When"
#~ " done logging, hit `ctrl-c` to exit from the `data_logger.py` tool."
#~ msgstr ""

#~ msgid "Graphs can be generated with a command like the following:"
#~ msgstr ""

#~ msgid ""
#~ "The list of available datasets can be found using the `-l` option - for "
#~ "example:"
#~ msgstr ""

#~ msgid ""
#~ "Many matplotlib options are available; some examples are \"color\", "
#~ "\"label\", \"alpha\", and \"linestyle\"."
#~ msgstr ""

#~ msgid ""
#~ "The Klippy log file (/tmp/klippy.log) stores statistics on bandwidth, micro-"
#~ "controller load, and host buffer load. It can be useful to graph these "
#~ "statistics after a print."
#~ msgstr ""

#~ msgid "One can then view the resulting **loadgraph.png** file."
#~ msgstr ""

#~ msgid ""
#~ "mkdir work_directory\n"
#~ "cd work_directory\n"
#~ "cp /tmp/klippy.log .\n"
#~ "~/klipper/scripts/logextract.py ./klippy.log\n"
#~ msgstr ""

#~ msgid ""
#~ "To use simulavr, download the simulavr package and compile with python "
#~ "support. Note that the build system may need to have some packages (such as "
#~ "swig) installed in order to build the python module."
#~ msgstr ""

#~ msgid ""
#~ "This commmand should report a specific file (e.g. "
#~ "**./build/pysimulavr/_pysimulavr.cpython-39-x86_64-linux-gnu.so**) and not "
#~ "an error."
#~ msgstr ""

#~ msgid ""
#~ "cd /path/to/klipper\n"
#~ "make menuconfig\n"
#~ msgstr ""

#~ msgid "./scripts/avrsim.py out/klipper.elf\n"
#~ msgstr ""

#~ msgid ""
#~ "One useful feature of simulavr is its ability to create signal wave "
#~ "generation files with the exact timing of events. To do this, follow the "
#~ "directions above, but run avrsim.py with a command-line like the following:"
#~ msgstr ""

#~ msgid "[Discord Chat](#discord-chat)"
#~ msgstr ""

#~ msgid ""
#~ "[I found a bug in the Klipper software](#i-found-a-bug-in-the-klipper-"
#~ "software)"
#~ msgstr ""

#~ msgid ""
#~ "There is a [Klipper Community Discourse "
#~ "server](https://community.klipper3d.org) for discussions on Klipper."
#~ msgstr ""

#~ msgid "I have a question about Klipper"
#~ msgstr ""

#~ msgid ""
#~ "Many questions we receive are general 3d-printing questions that are not "
#~ "specific to Klipper. If you have a general question or are experiencing "
#~ "general printing problems, then you will likely get a better response by "
#~ "asking in a general 3d-printing forum or a forum dedicated to your printer "
#~ "hardware."
#~ msgstr ""

#~ msgid ""
#~ "Unfortunately, we receive many more requests for help than we could possibly"
#~ " answer. Most problem reports we see are eventually tracked down to:"
#~ msgstr ""

#~ msgid ""
#~ "If you are experiencing a printing problem, then we recommend carefully "
#~ "inspecting the printer hardware (all joints, wires, screws, etc.) and verify"
#~ " nothing is abnormal. We find most printing problems are not related to the "
#~ "Klipper software. If you do find a problem with the printer hardware then "
#~ "you will likely get a better response by searching in a general 3d-printing "
#~ "forum or in a forum dedicated to your printer hardware."
#~ msgstr ""

#~ msgid ""
#~ "Problems should be reported in the [Klipper Community Forum](#community-"
#~ "forum)."
#~ msgstr ""

#~ msgid ""
#~ "Obtain the Klipper log file from the event. The log file has been engineered"
#~ " to answer common questions the Klipper developers have about the software "
#~ "and its environment (software version, hardware type, configuration, event "
#~ "timing, and hundreds of other questions)."
#~ msgstr ""

#~ msgid ""
#~ "Do not modify the log file in any way; do not provide a snippet of the log. "
#~ "Only the full unmodified log file provides the necessary information."
#~ msgstr ""

#~ msgid "Klipper is open-source software and we appreciate new contributions."
#~ msgstr ""

#~ msgid ""
#~ "Klipper github may be used by contributors to share the status of their work"
#~ " to improve Klipper. It is expected that the person opening a github ticket "
#~ "is actively working on the given task and will be the one performing all the"
#~ " work necessary to accomplish it. The Klipper github is not used for "
#~ "requests, nor to report bugs, nor to ask questions. Use the [Klipper "
#~ "Community Forum](#community-forum) or the [Klipper Community "
#~ "Discord](#discord-chat) instead."
#~ msgstr ""

#~ msgid "Verify temperature"
#~ msgstr ""

#~ msgid "Verify M112"
#~ msgstr ""

#~ msgid ""
#~ "Navigate to the Octoprint temperature tab and type in 50 followed by enter "
#~ "in the \"Tool\" temperature box. The extruder temperature in the graph "
#~ "should start to increase (within about 30 seconds or so). Then go to the "
#~ "\"Tool\" temperature drop-down box and select \"Off\". After several minutes"
#~ " the temperature should start to return to its initial room temperature "
#~ "value. If the temperature does not increase then verify the \"heater_pin\" "
#~ "setting in the config."
#~ msgstr ""

#~ msgid "Verify endstops"
#~ msgstr ""

#~ msgid "Verify stepper motors"
#~ msgstr ""

#~ msgid ""
#~ "After verifying all endstops and verifying all stepper motors the homing "
#~ "mechanism should be tested. Issue a G28 command to home all axes. Remove "
#~ "power from the printer if it does not home properly. Rerun the endstop and "
#~ "stepper motor verification steps if necessary."
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports [PID control](https://en.wikipedia.org/wiki/PID_controller)"
#~ " for the extruder and bed heaters. In order to use this control mechanism, "
#~ "it is necessary to calibrate the PID settings on each printer (PID settings "
#~ "found in other firmwares or in the example configuration files often work "
#~ "poorly)."
#~ msgstr ""

#~ msgid "Next steps"
#~ msgstr ""

#~ msgid "Micro-controller configuration"
#~ msgstr ""

#~ msgid ""
#~ "Input pins may be preceded by `^` to indicate that a hardware pull-up "
#~ "resistor should be enabled for the pin. If the micro-controller supports "
#~ "pull-down resistors then an input pin may alternatively be preceded by `~`."
#~ msgstr ""

#~ msgid ""
#~ "[mcu]\n"
#~ "serial:\n"
#~ "#   The serial port to connect to the MCU. If unsure (or if it\n"
#~ "#   changes) see the \"Where's my serial port?\" section of the FAQ.\n"
#~ "#   This parameter must be provided when using a serial port.\n"
#~ "#baud: 250000\n"
#~ "#   The baud rate to use. The default is 250000.\n"
#~ "#canbus_uuid:\n"
#~ "#   If using a device connected to a CAN bus then this sets the unique\n"
#~ "#   chip identifier to connect to. This value must be provided when using\n"
#~ "#   CAN bus for communication.\n"
#~ "#canbus_interface:\n"
#~ "#   If using a device connected to a CAN bus then this sets the CAN\n"
#~ "#   network interface to use. The default is 'can0'.\n"
#~ "#restart_method:\n"
#~ "#   This controls the mechanism the host will use to reset the\n"
#~ "#   micro-controller. The choices are 'arduino', 'cheetah', 'rpi_usb',\n"
#~ "#   and 'command'. The 'arduino' method (toggle DTR) is common on\n"
#~ "#   Arduino boards and clones. The 'cheetah' method is a special\n"
#~ "#   method needed for some Fysetc Cheetah boards. The 'rpi_usb' method\n"
#~ "#   is useful on Raspberry Pi boards with micro-controllers powered\n"
#~ "#   over USB - it briefly disables power to all USB ports to\n"
#~ "#   accomplish a micro-controller reset. The 'command' method involves\n"
#~ "#   sending a Klipper command to the micro-controller so that it can\n"
#~ "#   reset itself. The default is 'arduino' if the micro-controller\n"
#~ "#   communicates over a serial port, 'command' otherwise.\n"
#~ msgstr ""

#~ msgid "Common kinematic settings"
#~ msgstr ""

#~ msgid "[stepper]"
#~ msgstr ""

#~ msgid "Cartesian Kinematics"
#~ msgstr ""

#~ msgid "Linear Delta Kinematics"
#~ msgstr ""

#~ msgid "Deltesian Kinematics"
#~ msgstr ""

#~ msgid "CoreXY Kinematics"
#~ msgstr ""

#~ msgid "CoreXZ Kinematics"
#~ msgstr ""

#~ msgid "Hybrid-CoreXY Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: hybrid_corexy\n"
#~ "max_z_velocity:\n"
#~ "#   This sets the maximum velocity (in mm/s) of movement along the z\n"
#~ "#   axis. The default is to use max_velocity for max_z_velocity.\n"
#~ "max_z_accel:\n"
#~ "#   This sets the maximum acceleration (in mm/s^2) of movement along\n"
#~ "#   the z axis. The default is to use max_accel for max_z_accel.\n"
#~ "\n"
#~ "# The stepper_x section is used to describe the X axis as well as the\n"
#~ "# stepper controlling the X-Y movement.\n"
#~ "[stepper_x]\n"
#~ "\n"
#~ "# The stepper_y section is used to describe the stepper controlling\n"
#~ "# the Y axis.\n"
#~ "[stepper_y]\n"
#~ "\n"
#~ "# The stepper_z section is used to describe the stepper controlling\n"
#~ "# the Z axis.\n"
#~ "[stepper_z]\n"
#~ msgstr ""

#~ msgid "Polar Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: polar\n"
#~ "max_z_velocity:\n"
#~ "#   This sets the maximum velocity (in mm/s) of movement along the z\n"
#~ "#   axis. This setting can be used to restrict the maximum speed of\n"
#~ "#   the z stepper motor. The default is to use max_velocity for\n"
#~ "#   max_z_velocity.\n"
#~ "max_z_accel:\n"
#~ "#   This sets the maximum acceleration (in mm/s^2) of movement along\n"
#~ "#   the z axis. It limits the acceleration of the z stepper motor. The\n"
#~ "#   default is to use max_accel for max_z_accel.\n"
#~ "\n"
#~ "# The stepper_bed section is used to describe the stepper controlling\n"
#~ "# the bed.\n"
#~ "[stepper_bed]\n"
#~ "gear_ratio:\n"
#~ "#   A gear_ratio must be specified and rotation_distance may not be\n"
#~ "#   specified. For example, if the bed has an 80 toothed pulley driven\n"
#~ "#   by a stepper with a 16 toothed pulley then one would specify a\n"
#~ "#   gear ratio of \"80:16\". This parameter must be provided.\n"
#~ "\n"
#~ "# The stepper_arm section is used to describe the stepper controlling\n"
#~ "# the carriage on the arm.\n"
#~ "[stepper_arm]\n"
#~ "\n"
#~ "# The stepper_z section is used to describe the stepper controlling\n"
#~ "# the Z axis.\n"
#~ "[stepper_z]\n"
#~ msgstr ""

#~ msgid ""
#~ "ROTARY DELTA KINEMATICS ARE A WORK IN PROGRESS. Homing moves may timeout and"
#~ " some boundary checks are not implemented."
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to cable winch printers are described here - see "
#~ "[common kinematic settings](#common-kinematic-settings) for available "
#~ "parameters."
#~ msgstr ""

#~ msgid ""
#~ "It is possible to define a special \"none\" kinematics to disable kinematic "
#~ "support in Klipper. This may be useful for controlling devices that are not "
#~ "typical 3d-printers or for debugging purposes."
#~ msgstr ""

#~ msgid ""
#~ "[extruder]\n"
#~ "step_pin:\n"
#~ "dir_pin:\n"
#~ "enable_pin:\n"
#~ "microsteps:\n"
#~ "rotation_distance:\n"
#~ "#full_steps_per_rotation:\n"
#~ "#gear_ratio:\n"
#~ "#   See the \"stepper\" section for a description of the above\n"
#~ "#   parameters. If none of the above parameters are specified then no\n"
#~ "#   stepper will be associated with the nozzle hotend (though a\n"
#~ "#   SYNC_EXTRUDER_MOTION command may associate one at run-time).\n"
#~ "nozzle_diameter:\n"
#~ "#   Diameter of the nozzle orifice (in mm). This parameter must be\n"
#~ "#   provided.\n"
#~ "filament_diameter:\n"
#~ "#   The nominal diameter of the raw filament (in mm) as it enters the\n"
#~ "#   extruder. This parameter must be provided.\n"
#~ "#max_extrude_cross_section:\n"
#~ "#   Maximum area (in mm^2) of an extrusion cross section (eg,\n"
#~ "#   extrusion width multiplied by layer height). This setting prevents\n"
#~ "#   excessive amounts of extrusion during relatively small XY moves.\n"
#~ "#   If a move requests an extrusion rate that would exceed this value\n"
#~ "#   it will cause an error to be returned. The default is: 4.0 *\n"
#~ "#   nozzle_diameter^2\n"
#~ "#instantaneous_corner_velocity: 1.000\n"
#~ "#   The maximum instantaneous velocity change (in mm/s) of the\n"
#~ "#   extruder during the junction of two moves. The default is 1mm/s.\n"
#~ "#max_extrude_only_distance: 50.0\n"
#~ "#   Maximum length (in mm of raw filament) that a retraction or\n"
#~ "#   extrude-only move may have. If a retraction or extrude-only move\n"
#~ "#   requests a distance greater than this value it will cause an error\n"
#~ "#   to be returned. The default is 50mm.\n"
#~ "#max_extrude_only_velocity:\n"
#~ "#max_extrude_only_accel:\n"
#~ "#   Maximum velocity (in mm/s) and acceleration (in mm/s^2) of the\n"
#~ "#   extruder motor for retractions and extrude-only moves. These\n"
#~ "#   settings do not have any impact on normal printing moves. If not\n"
#~ "#   specified then they are calculated to match the limit an XY\n"
#~ "#   printing move with a cross section of 4.0*nozzle_diameter^2 would\n"
#~ "#   have.\n"
#~ "#pressure_advance: 0.0\n"
#~ "#   The amount of raw filament to push into the extruder during\n"
#~ "#   extruder acceleration. An equal amount of filament is retracted\n"
#~ "#   during deceleration. It is measured in millimeters per\n"
#~ "#   millimeter/second. The default is 0, which disables pressure\n"
#~ "#   advance.\n"
#~ "#pressure_advance_smooth_time: 0.040\n"
#~ "#   A time range (in seconds) to use when calculating the average\n"
#~ "#   extruder velocity for pressure advance. A larger value results in\n"
#~ "#   smoother extruder movements. This parameter may not exceed 200ms.\n"
#~ "#   This setting only applies if pressure_advance is non-zero. The\n"
#~ "#   default is 0.040 (40 milliseconds).\n"
#~ "#\n"
#~ "# The remaining variables describe the extruder heater.\n"
#~ "heater_pin:\n"
#~ "#   PWM output pin controlling the heater. This parameter must be\n"
#~ "#   provided.\n"
#~ "#max_power: 1.0\n"
#~ "#   The maximum power (expressed as a value from 0.0 to 1.0) that the\n"
#~ "#   heater_pin may be set to. The value 1.0 allows the pin to be set\n"
#~ "#   fully enabled for extended periods, while a value of 0.5 would\n"
#~ "#   allow the pin to be enabled for no more than half the time. This\n"
#~ "#   setting may be used to limit the total power output (over extended\n"
#~ "#   periods) to the heater. The default is 1.0.\n"
#~ "sensor_type:\n"
#~ "#   Type of sensor - common thermistors are \"EPCOS 100K B57560G104F\",\n"
#~ "#   \"ATC Semitec 104GT-2\", \"ATC Semitec 104NT-4-R025H42G\", \"Generic\n"
#~ "#   3950\",\"Honeywell 100K 135-104LAG-J01\", \"NTC 100K MGB18-104F39050L32\",\n"
#~ "#   \"SliceEngineering 450\", and \"TDK NTCG104LH104JT1\". See the\n"
#~ "#   \"Temperature sensors\" section for other sensors. This parameter\n"
#~ "#   must be provided.\n"
#~ "sensor_pin:\n"
#~ "#   Analog input pin connected to the sensor. This parameter must be\n"
#~ "#   provided.\n"
#~ "#pullup_resistor: 4700\n"
#~ "#   The resistance (in ohms) of the pullup attached to the thermistor.\n"
#~ "#   This parameter is only valid when the sensor is a thermistor. The\n"
#~ "#   default is 4700 ohms.\n"
#~ "#smooth_time: 1.0\n"
#~ "#   A time value (in seconds) over which temperature measurements will\n"
#~ "#   be smoothed to reduce the impact of measurement noise. The default\n"
#~ "#   is 1 seconds.\n"
#~ "control:\n"
#~ "#   Control algorithm (either pid or watermark). This parameter must\n"
#~ "#   be provided.\n"
#~ "pid_Kp:\n"
#~ "pid_Ki:\n"
#~ "pid_Kd:\n"
#~ "#   The proportional (pid_Kp), integral (pid_Ki), and derivative\n"
#~ "#   (pid_Kd) settings for the PID feedback control system. Klipper\n"
#~ "#   evaluates the PID settings with the following general formula:\n"
#~ "#     heater_pwm = (Kp*error + Ki*integral(error) - Kd*derivative(error)) / 255\n"
#~ "#   Where \"error\" is \"requested_temperature - measured_temperature\"\n"
#~ "#   and \"heater_pwm\" is the requested heating rate with 0.0 being full\n"
#~ "#   off and 1.0 being full on. Consider using the PID_CALIBRATE\n"
#~ "#   command to obtain these parameters. The pid_Kp, pid_Ki, and pid_Kd\n"
#~ "#   parameters must be provided for PID heaters.\n"
#~ "#max_delta: 2.0\n"
#~ "#   On 'watermark' controlled heaters this is the number of degrees in\n"
#~ "#   Celsius above the target temperature before disabling the heater\n"
#~ "#   as well as the number of degrees below the target before\n"
#~ "#   re-enabling the heater. The default is 2 degrees Celsius.\n"
#~ "#pwm_cycle_time: 0.100\n"
#~ "#   Time in seconds for each software PWM cycle of the heater. It is\n"
#~ "#   not recommended to set this unless there is an electrical\n"
#~ "#   requirement to switch the heater faster than 10 times a second.\n"
#~ "#   The default is 0.100 seconds.\n"
#~ "#min_extrude_temp: 170\n"
#~ "#   The minimum temperature (in Celsius) at which extruder move\n"
#~ "#   commands may be issued. The default is 170 Celsius.\n"
#~ "min_temp:\n"
#~ "max_temp:\n"
#~ "#   The maximum range of valid temperatures (in Celsius) that the\n"
#~ "#   heater must remain within. This controls a safety feature\n"
#~ "#   implemented in the micro-controller code - should the measured\n"
#~ "#   temperature ever fall outside this range then the micro-controller\n"
#~ "#   will go into a shutdown state. This check can help detect some\n"
#~ "#   heater and sensor hardware failures. Set this range just wide\n"
#~ "#   enough so that reasonable temperatures do not result in an error.\n"
#~ "#   These parameters must be provided.\n"
#~ msgstr ""

#~ msgid "Bed level support"
#~ msgstr ""

#~ msgid ""
#~ " rectangular bed, probe_count = 3, 3:\n"
#~ "             x---x---x (max_point)\n"
#~ "             |\n"
#~ "             x---x---x\n"
#~ "                     |\n"
#~ " (min_point) x---x---x\n"
#~ "\n"
#~ " round bed, round_probe_count = 5, bed_radius = r:\n"
#~ "                 x (0, r) end\n"
#~ "               /\n"
#~ "             x---x---x\n"
#~ "                       \\\n"
#~ " (-r, 0) x---x---x---x---x (r, 0)\n"
#~ "           \\\n"
#~ "             x---x---x\n"
#~ "                   /\n"
#~ "                 x  (0, -r) start\n"
#~ msgstr ""

#~ msgid ""
#~ "[bed_tilt]\n"
#~ "#x_adjust: 0\n"
#~ "#   The amount to add to each move's Z height for each mm on the X\n"
#~ "#   axis. The default is 0.\n"
#~ "#y_adjust: 0\n"
#~ "#   The amount to add to each move's Z height for each mm on the Y\n"
#~ "#   axis. The default is 0.\n"
#~ "#z_adjust: 0\n"
#~ "#   The amount to add to the Z height when the nozzle is nominally at\n"
#~ "#   0, 0. The default is 0.\n"
#~ "# The remaining parameters control a BED_TILT_CALIBRATE extended\n"
#~ "# g-code command that may be used to calibrate appropriate x and y\n"
#~ "# adjustment parameters.\n"
#~ "#points:\n"
#~ "#   A list of X, Y coordinates (one per line; subsequent lines\n"
#~ "#   indented) that should be probed during a BED_TILT_CALIBRATE\n"
#~ "#   command. Specify coordinates of the nozzle and be sure the probe\n"
#~ "#   is above the bed at the given nozzle coordinates. The default is\n"
#~ "#   to not enable the command.\n"
#~ "#speed: 50\n"
#~ "#   The speed (in mm/s) of non-probing moves during the calibration.\n"
#~ "#   The default is 50.\n"
#~ "#horizontal_move_z: 5\n"
#~ "#   The height (in mm) that the head should be commanded to move to\n"
#~ "#   just prior to starting a probe operation. The default is 5.\n"
#~ msgstr ""

#~ msgid ""
#~ "Tool to help adjust bed screws tilt using Z probe. One may define a "
#~ "screws_tilt_adjust config section to enable a SCREWS_TILT_CALCULATE g-code "
#~ "command."
#~ msgstr ""

#~ msgid ""
#~ "[z_tilt]\n"
#~ "#z_positions:\n"
#~ "#   A list of X, Y coordinates (one per line; subsequent lines\n"
#~ "#   indented) describing the location of each bed \"pivot point\". The\n"
#~ "#   \"pivot point\" is the point where the bed attaches to the given Z\n"
#~ "#   stepper. It is described using nozzle coordinates (the X, Y position\n"
#~ "#   of the nozzle if it could move directly above the point). The\n"
#~ "#   first entry corresponds to stepper_z, the second to stepper_z1,\n"
#~ "#   the third to stepper_z2, etc. This parameter must be provided.\n"
#~ "#points:\n"
#~ "#   A list of X, Y coordinates (one per line; subsequent lines\n"
#~ "#   indented) that should be probed during a Z_TILT_ADJUST command.\n"
#~ "#   Specify coordinates of the nozzle and be sure the probe is above\n"
#~ "#   the bed at the given nozzle coordinates. This parameter must be\n"
#~ "#   provided.\n"
#~ "#speed: 50\n"
#~ "#   The speed (in mm/s) of non-probing moves during the calibration.\n"
#~ "#   The default is 50.\n"
#~ "#horizontal_move_z: 5\n"
#~ "#   The height (in mm) that the head should be commanded to move to\n"
#~ "#   just prior to starting a probe operation. The default is 5.\n"
#~ "#retries: 0\n"
#~ "#   Number of times to retry if the probed points aren't within\n"
#~ "#   tolerance.\n"
#~ "#retry_tolerance: 0\n"
#~ "#   If retries are enabled then retry if largest and smallest probed\n"
#~ "#   points differ more than retry_tolerance. Note the smallest unit of\n"
#~ "#   change here would be a single step. However if you are probing\n"
#~ "#   more points than steppers then you will likely have a fixed\n"
#~ "#   minimum value for the range of probed points which you can learn\n"
#~ "#   by observing command output.\n"
#~ msgstr ""

#~ msgid "Where x is the 0, 0 point on the bed"
#~ msgstr ""

#~ msgid ""
#~ "Temperature-dependant toolhead Z position adjustment. Compensate for "
#~ "vertical toolhead movement caused by thermal expansion of the printer's "
#~ "frame in real-time using a temperature sensor (typically coupled to a "
#~ "vertical section of frame)."
#~ msgstr ""

#~ msgid "[safe_z_home]"
#~ msgstr ""

#~ msgid ""
#~ "Homing override. One may use this mechanism to run a series of g-code "
#~ "commands in place of a G28 found in the normal g-code input. This may be "
#~ "useful on printers that require a specific procedure to home the machine."
#~ msgstr ""

#~ msgid ""
#~ "[endstop_phase stepper_z]\n"
#~ "#endstop_accuracy:\n"
#~ "#   Sets the expected accuracy (in mm) of the endstop. This represents\n"
#~ "#   the maximum error distance the endstop may trigger (eg, if an\n"
#~ "#   endstop may occasionally trigger 100um early or up to 100um late\n"
#~ "#   then set this to 0.200 for 200um). The default is\n"
#~ "#   4*rotation_distance/full_steps_per_rotation.\n"
#~ "#trigger_phase:\n"
#~ "#   This specifies the phase of the stepper motor driver to expect\n"
#~ "#   when hitting the endstop. It is composed of two numbers separated\n"
#~ "#   by a forward slash character - the phase and the total number of\n"
#~ "#   phases (eg, \"7/64\"). Only set this value if one is sure the\n"
#~ "#   stepper motor driver is reset every time the mcu is reset. If this\n"
#~ "#   is not set, then the stepper phase will be detected on the first\n"
#~ "#   home and that phase will be used on all subsequent homes.\n"
#~ "#endstop_align_zero: False\n"
#~ "#   If true then the position_endstop of the axis will effectively be\n"
#~ "#   modified so that the zero position for the axis occurs at a full\n"
#~ "#   step on the stepper motor. (If used on the Z axis and the print\n"
#~ "#   layer height is a multiple of a full step distance then every\n"
#~ "#   layer will occur on a full step.) The default is False.\n"
#~ msgstr ""

#~ msgid ""
#~ "Execute a gcode on a set delay. See the [command template "
#~ "guide](Command_Templates.md#delayed-gcodes) and [command "
#~ "reference](G-Codes.md#delayed_gcode) for more information."
#~ msgstr ""

#~ msgid ""
#~ "Idle timeout. An idle timeout is automatically enabled - add an explicit "
#~ "idle_timeout config section to change the default settings."
#~ msgstr ""

#~ msgid ""
#~ "[virtual_sdcard]\n"
#~ "path:\n"
#~ "#   The path of the local directory on the host machine to look for\n"
#~ "#   g-code files. This is a read-only directory (sdcard file writes\n"
#~ "#   are not supported). One may point this to OctoPrint's upload\n"
#~ "#   directory (generally ~/.octoprint/uploads/ ). This parameter must\n"
#~ "#   be provided.\n"
#~ "#on_error_gcode:\n"
#~ "#   A list of G-Code commands to execute when an error is reported.\n"
#~ "\n"
#~ msgstr ""

#~ msgid ""
#~ "Support manually moving stepper motors for diagnostic purposes. Note, using "
#~ "this feature may place the printer in an invalid state - see the [command "
#~ "reference](G-Codes.md#force_move) for important details."
#~ msgstr ""

#~ msgid ""
#~ "Firmware filament retraction. This enables G10 (retract) and G11 (unretract)"
#~ " GCODE commands issued by many slicers. The parameters below provide startup"
#~ " defaults, although the values can be adjusted via the SET_RETRACTION "
#~ "[command](G-Codes.md#firmware_retraction)), allowing per-filament settings "
#~ "and runtime tuning."
#~ msgstr ""

#~ msgid "Enable the \"M118\" and \"RESPOND\" extended [commands](G-Codes.md#respond)."
#~ msgstr ""

#~ msgid "[exclude_object]\n"
#~ msgstr ""

#~ msgid ""
#~ "Support for ADXL345 accelerometers. This support allows one to query "
#~ "accelerometer measurements from the sensor. This enables an "
#~ "ACCELEROMETER_MEASURE command (see [G-Codes](G-Codes.md#adxl345) for more "
#~ "information). The default chip name is \"default\", but one may specify an "
#~ "explicit name (eg, [adxl345 my_chip_name])."
#~ msgstr ""

#~ msgid ""
#~ "[mpu9250 my_accelerometer]\n"
#~ "#i2c_address:\n"
#~ "#   Default is 104 (0x68). If AD0 is high, it would be 0x69 instead.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed: 400000\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters. The default \"i2c_speed\" is 400000.\n"
#~ "#axes_map: x, y, z\n"
#~ "#   See the \"adxl345\" section for information on this parameter.\n"
#~ msgstr ""

#~ msgid "[board_pins]"
#~ msgstr ""

#~ msgid ""
#~ "Include file support. One may include additional config file from the main "
#~ "printer config file. Wildcards may also be used (eg, \"configs/*.cfg\")."
#~ msgstr ""

#~ msgid ""
#~ "[duplicate_pin_override]\n"
#~ "pins:\n"
#~ "#   A comma separated list of pins that may be used multiple times in\n"
#~ "#   a config file without normal error checks. This parameter must be\n"
#~ "#   provided.\n"
#~ msgstr ""

#~ msgid ""
#~ "BLTouch probe. One may define this section (instead of a probe section) to "
#~ "enable a BLTouch probe. See [BL-Touch guide](BLTouch.md) and [command "
#~ "reference](G-Codes.md#bltouch) for further information. A virtual "
#~ "\"probe:z_virtual_endstop\" pin is also created (see the \"probe\" section "
#~ "for the details)."
#~ msgstr ""

#~ msgid "Additional stepper motors and extruders"
#~ msgstr ""

#~ msgid "[extruder1]"
#~ msgstr ""

#~ msgid ""
#~ "Support for cartesian printers with dual carriages on a single axis. The "
#~ "active carriage is set via the SET_DUAL_CARRIAGE extended g-code command. "
#~ "The \"SET_DUAL_CARRIAGE CARRIAGE=1\" command will activate the carriage "
#~ "defined in this section (CARRIAGE=0 will return activation to the primary "
#~ "carriage). Dual carriage support is typically combined with extra extruders "
#~ "- the SET_DUAL_CARRIAGE command is often called at the same time as the "
#~ "ACTIVATE_EXTRUDER command. Be sure to park the carriages during "
#~ "deactivation."
#~ msgstr ""

#~ msgid ""
#~ "Support for additional steppers synchronized to the movement of an extruder "
#~ "(one may define any number of sections with an \"extruder_stepper\" prefix)."
#~ msgstr ""

#~ msgid ""
#~ "[manual_stepper my_stepper]\n"
#~ "#step_pin:\n"
#~ "#dir_pin:\n"
#~ "#enable_pin:\n"
#~ "#microsteps:\n"
#~ "#rotation_distance:\n"
#~ "#   See the \"stepper\" section for a description of these parameters.\n"
#~ "#velocity:\n"
#~ "#   Set the default velocity (in mm/s) for the stepper. This value\n"
#~ "#   will be used if a MANUAL_STEPPER command does not specify a SPEED\n"
#~ "#   parameter. The default is 5mm/s.\n"
#~ "#accel:\n"
#~ "#   Set the default acceleration (in mm/s^2) for the stepper. An\n"
#~ "#   acceleration of zero will result in no acceleration. This value\n"
#~ "#   will be used if a MANUAL_STEPPER command does not specify an ACCEL\n"
#~ "#   parameter. The default is zero.\n"
#~ "#endstop_pin:\n"
#~ "#   Endstop switch detection pin. If specified, then one may perform\n"
#~ "#   \"homing moves\" by adding a STOP_ON_ENDSTOP parameter to\n"
#~ "#   MANUAL_STEPPER movement commands.\n"
#~ msgstr ""

#~ msgid ""
#~ "[verify_heater heater_config_name]\n"
#~ "#max_error: 120\n"
#~ "#   The maximum \"cumulative temperature error\" before raising an\n"
#~ "#   error. Smaller values result in stricter checking and larger\n"
#~ "#   values allow for more time before an error is reported.\n"
#~ "#   Specifically, the temperature is inspected once a second and if it\n"
#~ "#   is close to the target temperature then an internal \"error\n"
#~ "#   counter\" is reset; otherwise, if the temperature is below the\n"
#~ "#   target range then the counter is increased by the amount the\n"
#~ "#   reported temperature differs from that range. Should the counter\n"
#~ "#   exceed this \"max_error\" then an error is raised. The default is\n"
#~ "#   120.\n"
#~ "#check_gain_time:\n"
#~ "#   This controls heater verification during initial heating. Smaller\n"
#~ "#   values result in stricter checking and larger values allow for\n"
#~ "#   more time before an error is reported. Specifically, during\n"
#~ "#   initial heating, as long as the heater increases in temperature\n"
#~ "#   within this time frame (specified in seconds) then the internal\n"
#~ "#   \"error counter\" is reset. The default is 20 seconds for extruders\n"
#~ "#   and 60 seconds for heater_bed.\n"
#~ "#hysteresis: 5\n"
#~ "#   The maximum temperature difference (in Celsius) to a target\n"
#~ "#   temperature that is considered in range of the target. This\n"
#~ "#   controls the max_error range check. It is rare to customize this\n"
#~ "#   value. The default is 5.\n"
#~ "#heating_gain: 2\n"
#~ "#   The minimum temperature (in Celsius) that the heater must increase\n"
#~ "#   by during the check_gain_time check. It is rare to customize this\n"
#~ "#   value. The default is 2.\n"
#~ msgstr ""

#~ msgid "[thermistor]"
#~ msgstr ""

#~ msgid ""
#~ "Custom ADC temperature sensors (one may define any number of sections with "
#~ "an \"adc_temperature\" prefix). This allows one to define a custom "
#~ "temperature sensor that measures a voltage on an Analog to Digital Converter"
#~ " (ADC) pin and uses linear interpolation between a set of configured "
#~ "temperature/voltage (or temperature/resistance) measurements to determine "
#~ "the temperature. The resulting sensor can be used as a sensor_type in a "
#~ "heater section. (For example, if one defines a \"[adc_temperature "
#~ "my_sensor]\" section then one may use a \"sensor_type: my_sensor\" when "
#~ "defining a heater.) Be sure to place the sensor section in the config file "
#~ "above its first use in a heater section."
#~ msgstr ""

#~ msgid ""
#~ "[heater_generic my_generic_heater]\n"
#~ "#gcode_id:\n"
#~ "#   The id to use when reporting the temperature in the M105 command.\n"
#~ "#   This parameter must be provided.\n"
#~ "#heater_pin:\n"
#~ "#max_power:\n"
#~ "#sensor_type:\n"
#~ "#sensor_pin:\n"
#~ "#smooth_time:\n"
#~ "#control:\n"
#~ "#pid_Kp:\n"
#~ "#pid_Ki:\n"
#~ "#pid_Kd:\n"
#~ "#pwm_cycle_time:\n"
#~ "#min_temp:\n"
#~ "#max_temp:\n"
#~ "#   See the \"extruder\" section for the definition of the above\n"
#~ "#   parameters.\n"
#~ msgstr ""

#~ msgid "Temperature sensors"
#~ msgstr ""

#~ msgid ""
#~ "sensor_type:\n"
#~ "#   One of \"EPCOS 100K B57560G104F\", \"ATC Semitec 104GT-2\",\n"
#~ "#   \"ATC Semitec 104NT-4-R025H42G\", \"Generic 3950\",\n"
#~ "#   \"Honeywell 100K 135-104LAG-J01\", \"NTC 100K MGB18-104F39050L32\",\n"
#~ "#   \"SliceEngineering 450\", or \"TDK NTCG104LH104JT1\"\n"
#~ "sensor_pin:\n"
#~ "#   Analog input pin connected to the thermistor. This parameter must\n"
#~ "#   be provided.\n"
#~ "#pullup_resistor: 4700\n"
#~ "#   The resistance (in ohms) of the pullup attached to the thermistor.\n"
#~ "#   The default is 4700 ohms.\n"
#~ "#inline_resistor: 0\n"
#~ "#   The resistance (in ohms) of an extra (not heat varying) resistor\n"
#~ "#   that is placed inline with the thermistor. It is rare to set this.\n"
#~ "#   The default is 0 ohms.\n"
#~ msgstr ""

#~ msgid "Directly connected PT1000 sensor"
#~ msgstr ""

#~ msgid ""
#~ "MAXxxxxx serial peripheral interface (SPI) temperature based sensors. The "
#~ "following parameters are available in heater sections that use one of these "
#~ "sensor types."
#~ msgstr ""

#~ msgid ""
#~ "sensor_type: BME280\n"
#~ "#i2c_address:\n"
#~ "#   Default is 118 (0x76). Some BME280 sensors have an address of 119\n"
#~ "#   (0x77).\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ msgstr ""

#~ msgid "LM75 temperature sensor"
#~ msgstr ""

#~ msgid ""
#~ "The atsam, atsamd, and stm32 micro-controllers contain an internal "
#~ "temperature sensor. One can use the \"temperature_mcu\" sensor to monitor "
#~ "these temperatures."
#~ msgstr ""

#~ msgid ""
#~ "sensor_type: temperature_host\n"
#~ "#sensor_path:\n"
#~ "#   The path to temperature system file. The default is\n"
#~ "#   \"/sys/class/thermal/thermal_zone0/temp\" which is the temperature\n"
#~ "#   system file on a Raspberry Pi computer.\n"
#~ msgstr ""

#~ msgid "Fans"
#~ msgstr ""

#~ msgid "[heater_fan]"
#~ msgstr ""

#~ msgid ""
#~ "Controller cooling fan (one may define any number of sections with a "
#~ "\"controller_fan\" prefix). A \"controller fan\" is a fan that will be "
#~ "enabled whenever its associated heater or its associated stepper driver is "
#~ "active. The fan will stop whenever an idle_timeout is reached to ensure no "
#~ "overheating will occur after deactivating a watched component."
#~ msgstr ""

#~ msgid ""
#~ "[temperature_fan my_temp_fan]\n"
#~ "#pin:\n"
#~ "#max_power:\n"
#~ "#shutdown_speed:\n"
#~ "#cycle_time:\n"
#~ "#hardware_pwm:\n"
#~ "#kick_start_time:\n"
#~ "#off_below:\n"
#~ "#tachometer_pin:\n"
#~ "#tachometer_ppr:\n"
#~ "#tachometer_poll_interval:\n"
#~ "#enable_pin:\n"
#~ "#   See the \"fan\" section for a description of the above parameters.\n"
#~ "#sensor_type:\n"
#~ "#sensor_pin:\n"
#~ "#control:\n"
#~ "#max_delta:\n"
#~ "#min_temp:\n"
#~ "#max_temp:\n"
#~ "#   See the \"extruder\" section for a description of the above parameters.\n"
#~ "#pid_Kp:\n"
#~ "#pid_Ki:\n"
#~ "#pid_Kd:\n"
#~ "#   The proportional (pid_Kp), integral (pid_Ki), and derivative\n"
#~ "#   (pid_Kd) settings for the PID feedback control system. Klipper\n"
#~ "#   evaluates the PID settings with the following general formula:\n"
#~ "#     fan_pwm = max_power - (Kp*e + Ki*integral(e) - Kd*derivative(e)) / 255\n"
#~ "#   Where \"e\" is \"target_temperature - measured_temperature\" and\n"
#~ "#   \"fan_pwm\" is the requested fan rate with 0.0 being full off and\n"
#~ "#   1.0 being full on. The pid_Kp, pid_Ki, and pid_Kd parameters must\n"
#~ "#   be provided when the PID control algorithm is enabled.\n"
#~ "#pid_deriv_time: 2.0\n"
#~ "#   A time value (in seconds) over which temperature measurements will\n"
#~ "#   be smoothed when using the PID control algorithm. This may reduce\n"
#~ "#   the impact of measurement noise. The default is 2 seconds.\n"
#~ "#target_temp: 40.0\n"
#~ "#   A temperature (in Celsius) that will be the target temperature.\n"
#~ "#   The default is 40 degrees.\n"
#~ "#max_speed: 1.0\n"
#~ "#   The fan speed (expressed as a value from 0.0 to 1.0) that the fan\n"
#~ "#   will be set to when the sensor temperature exceeds the set value.\n"
#~ "#   The default is 1.0.\n"
#~ "#min_speed: 0.3\n"
#~ "#   The minimum fan speed (expressed as a value from 0.0 to 1.0) that\n"
#~ "#   the fan will be set to for PID temperature fans.\n"
#~ "#   The default is 0.3.\n"
#~ "#gcode_id:\n"
#~ "#   If set, the temperature will be reported in M105 queries using the\n"
#~ "#   given id. The default is to not report the temperature via M105.\n"
#~ msgstr ""

#~ msgid ""
#~ "Support for LEDs (and LED strips) controlled via micro-controller PWM pins "
#~ "(one may define any number of sections with an \"led\" prefix). See the "
#~ "[command reference](G-Codes.md#led) for more information."
#~ msgstr ""

#~ msgid ""
#~ "Note that the [linux mcu](RPi_microcontroller.md) implementation does not "
#~ "currently support directly connected neopixels. The current design using the"
#~ " Linux kernel interface does not allow this scenario because the kernel GPIO"
#~ " interface is not fast enough to provide the required pulse rates."
#~ msgstr ""

#~ msgid ""
#~ "[dotstar my_dotstar]\n"
#~ "data_pin:\n"
#~ "#   The pin connected to the data line of the dotstar. This parameter\n"
#~ "#   must be provided.\n"
#~ "clock_pin:\n"
#~ "#   The pin connected to the clock line of the dotstar. This parameter\n"
#~ "#   must be provided.\n"
#~ "#chain_count:\n"
#~ "#   See the \"neopixel\" section for information on this parameter.\n"
#~ "#initial_RED: 0.0\n"
#~ "#initial_GREEN: 0.0\n"
#~ "#initial_BLUE: 0.0\n"
#~ "#   See the \"led\" section for information on these parameters.\n"
#~ msgstr ""

#~ msgid "[pca9632]"
#~ msgstr ""

#~ msgid ""
#~ "Servos (one may define any number of sections with a \"servo\" prefix). The "
#~ "servos may be controlled using the SET_SERVO [g-code "
#~ "command](G-Codes.md#servo). For example: SET_SERVO SERVO=my_servo ANGLE=180"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_button my_gcode_button]\n"
#~ "pin:\n"
#~ "#   The pin on which the button is connected. This parameter must be\n"
#~ "#   provided.\n"
#~ "#analog_range:\n"
#~ "#   Two comma separated resistances (in Ohms) specifying the minimum\n"
#~ "#   and maximum resistance range for the button. If analog_range is\n"
#~ "#   provided then the pin must be an analog capable pin. The default\n"
#~ "#   is to use digital gpio for the button.\n"
#~ "#analog_pullup_resistor:\n"
#~ "#   The pullup resistance (in Ohms) when analog_range is specified.\n"
#~ "#   The default is 4700 ohms.\n"
#~ "#press_gcode:\n"
#~ "#   A list of G-Code commands to execute when the button is pressed.\n"
#~ "#   G-Code templates are supported. This parameter must be provided.\n"
#~ "#release_gcode:\n"
#~ "#   A list of G-Code commands to execute when the button is released.\n"
#~ "#   G-Code templates are supported. The default is to not run any\n"
#~ "#   commands on a button release.\n"
#~ msgstr ""

#~ msgid ""
#~ "Statically configured digital output pins (one may define any number of "
#~ "sections with a \"static_digital_output\" prefix). Pins configured here will"
#~ " be setup as a GPIO output during MCU configuration. They can not be changed"
#~ " at run-time."
#~ msgstr ""

#~ msgid ""
#~ "[multi_pin my_multi_pin]\n"
#~ "pins:\n"
#~ "#   A comma separated list of pins associated with this alias. This\n"
#~ "#   parameter must be provided.\n"
#~ msgstr ""

#~ msgid ""
#~ "Configure a TMC2130 stepper motor driver via SPI bus. To use this feature, "
#~ "define a config section with a \"tmc2130\" prefix followed by the name of "
#~ "the corresponding stepper config section (for example, \"[tmc2130 "
#~ "stepper_x]\")."
#~ msgstr ""

#~ msgid ""
#~ "[tmc2208 stepper_x]\n"
#~ "uart_pin:\n"
#~ "#   The pin connected to the TMC2208 PDN_UART line. This parameter\n"
#~ "#   must be provided.\n"
#~ "#tx_pin:\n"
#~ "#   If using separate receive and transmit lines to communicate with\n"
#~ "#   the driver then set uart_pin to the receive pin and tx_pin to the\n"
#~ "#   transmit pin. The default is to use uart_pin for both reading and\n"
#~ "#   writing.\n"
#~ "#select_pins:\n"
#~ "#   A comma separated list of pins to set prior to accessing the\n"
#~ "#   tmc2208 UART. This may be useful for configuring an analog mux for\n"
#~ "#   UART communication. The default is to not configure any pins.\n"
#~ "#interpolate: True\n"
#~ "#   If true, enable step interpolation (the driver will internally\n"
#~ "#   step at a rate of 256 micro-steps). This interpolation does\n"
#~ "#   introduce a small systemic positional deviation - see\n"
#~ "#   TMC_Drivers.md for details. The default is True.\n"
#~ "run_current:\n"
#~ "#   The amount of current (in amps RMS) to configure the driver to use\n"
#~ "#   during stepper movement. This parameter must be provided.\n"
#~ "#hold_current:\n"
#~ "#   The amount of current (in amps RMS) to configure the driver to use\n"
#~ "#   when the stepper is not moving. Setting a hold_current is not\n"
#~ "#   recommended (see TMC_Drivers.md for details). The default is to\n"
#~ "#   not reduce the current.\n"
#~ "#sense_resistor: 0.110\n"
#~ "#   The resistance (in ohms) of the motor sense resistor. The default\n"
#~ "#   is 0.110 ohms.\n"
#~ "#stealthchop_threshold: 0\n"
#~ "#   The velocity (in mm/s) to set the \"stealthChop\" threshold to. When\n"
#~ "#   set, \"stealthChop\" mode will be enabled if the stepper motor\n"
#~ "#   velocity is below this value. The default is 0, which disables\n"
#~ "#   \"stealthChop\" mode.\n"
#~ "#driver_IHOLDDELAY: 8\n"
#~ "#driver_TPOWERDOWN: 20\n"
#~ "#driver_TBL: 2\n"
#~ "#driver_TOFF: 3\n"
#~ "#driver_HEND: 0\n"
#~ "#driver_HSTRT: 5\n"
#~ "#driver_PWM_AUTOGRAD: True\n"
#~ "#driver_PWM_AUTOSCALE: True\n"
#~ "#driver_PWM_LIM: 12\n"
#~ "#driver_PWM_REG: 8\n"
#~ "#driver_PWM_FREQ: 1\n"
#~ "#driver_PWM_GRAD: 14\n"
#~ "#driver_PWM_OFS: 36\n"
#~ "#   Set the given register during the configuration of the TMC2208\n"
#~ "#   chip. This may be used to set custom motor parameters. The\n"
#~ "#   defaults for each parameter are next to the parameter name in the\n"
#~ "#   above list.\n"
#~ msgstr ""

#~ msgid "[tmc2660]"
#~ msgstr ""

#~ msgid ""
#~ "Configure a TMC5160 stepper motor driver via SPI bus. To use this feature, "
#~ "define a config section with a \"tmc5160\" prefix followed by the name of "
#~ "the corresponding stepper config section (for example, \"[tmc5160 "
#~ "stepper_x]\")."
#~ msgstr ""

#~ msgid ""
#~ "Statically configured AD5206 digipots connected via SPI bus (one may define "
#~ "any number of sections with an \"ad5206\" prefix)."
#~ msgstr ""

#~ msgid ""
#~ "[mcp4451 my_digipot]\n"
#~ "i2c_address:\n"
#~ "#   The i2c address that the chip is using on the i2c bus. This\n"
#~ "#   parameter must be provided.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#wiper_0:\n"
#~ "#wiper_1:\n"
#~ "#wiper_2:\n"
#~ "#wiper_3:\n"
#~ "#   The value to statically set the given MCP4451 \"wiper\" to. This is\n"
#~ "#   typically set to a number between 0.0 and 1.0 with 1.0 being the\n"
#~ "#   highest resistance and 0.0 being the lowest resistance. However,\n"
#~ "#   the range may be changed with the 'scale' parameter (see below).\n"
#~ "#   If a wiper is not specified then it is left unconfigured.\n"
#~ "#scale:\n"
#~ "#   This parameter can be used to alter how the 'wiper_x' parameters\n"
#~ "#   are interpreted. If provided, then the 'wiper_x' parameters should\n"
#~ "#   be between 0.0 and 'scale'. This may be useful when the MCP4451 is\n"
#~ "#   used to set stepper voltage references. The 'scale' can be set to\n"
#~ "#   the equivalent stepper amperage if the MCP4451 were at its highest\n"
#~ "#   resistance, and then the 'wiper_x' parameters can be specified\n"
#~ "#   using the desired amperage value for the stepper. The default is\n"
#~ "#   to not scale the 'wiper_x' parameters.\n"
#~ msgstr ""

#~ msgid ""
#~ "Statically configured MCP4018 digipot connected via two gpio \"bit banging\""
#~ " pins (one may define any number of sections with an \"mcp4018\" prefix)."
#~ msgstr ""

#~ msgid ""
#~ "[display]\n"
#~ "lcd_type:\n"
#~ "#   The type of LCD chip in use. This may be \"hd44780\", \"hd44780_spi\",\n"
#~ "#   \"st7920\", \"emulated_st7920\", \"uc1701\", \"ssd1306\", or \"sh1106\".\n"
#~ "#   See the display sections below for information on each type and\n"
#~ "#   additional parameters they provide. This parameter must be\n"
#~ "#   provided.\n"
#~ "#display_group:\n"
#~ "#   The name of the display_data group to show on the display. This\n"
#~ "#   controls the content of the screen (see the \"display_data\" section\n"
#~ "#   for more information). The default is _default_20x4 for hd44780\n"
#~ "#   displays and _default_16x4 for other displays.\n"
#~ "#menu_timeout:\n"
#~ "#   Timeout for menu. Being inactive this amount of seconds will\n"
#~ "#   trigger menu exit or return to root menu when having autorun\n"
#~ "#   enabled. The default is 0 seconds (disabled)\n"
#~ "#menu_root:\n"
#~ "#   Name of the main menu section to show when clicking the encoder\n"
#~ "#   on the home screen. The defaults is __main, and this shows the\n"
#~ "#   the default menus as defined in klippy/extras/display/menu.cfg\n"
#~ "#menu_reverse_navigation:\n"
#~ "#   When enabled it will reverse up and down directions for list\n"
#~ "#   navigation. The default is False. This parameter is optional.\n"
#~ "#encoder_pins:\n"
#~ "#   The pins connected to encoder. 2 pins must be provided when using\n"
#~ "#   encoder. This parameter must be provided when using menu.\n"
#~ "#encoder_steps_per_detent:\n"
#~ "#   How many steps the encoder emits per detent (\"click\"). If the\n"
#~ "#   encoder takes two detents to move between entries or moves two\n"
#~ "#   entries from one detent, try changing this. Allowed values are 2\n"
#~ "#   (half-stepping) or 4 (full-stepping). The default is 4.\n"
#~ "#click_pin:\n"
#~ "#   The pin connected to 'enter' button or encoder 'click'. This\n"
#~ "#   parameter must be provided when using menu. The presence of an\n"
#~ "#   'analog_range_click_pin' config parameter turns this parameter\n"
#~ "#   from digital to analog.\n"
#~ "#back_pin:\n"
#~ "#   The pin connected to 'back' button. This parameter is optional,\n"
#~ "#   menu can be used without it. The presence of an\n"
#~ "#   'analog_range_back_pin' config parameter turns this parameter from\n"
#~ "#   digital to analog.\n"
#~ "#up_pin:\n"
#~ "#   The pin connected to 'up' button. This parameter must be provided\n"
#~ "#   when using menu without encoder. The presence of an\n"
#~ "#   'analog_range_up_pin' config parameter turns this parameter from\n"
#~ "#   digital to analog.\n"
#~ "#down_pin:\n"
#~ "#   The pin connected to 'down' button. This parameter must be\n"
#~ "#   provided when using menu without encoder. The presence of an\n"
#~ "#   'analog_range_down_pin' config parameter turns this parameter from\n"
#~ "#   digital to analog.\n"
#~ "#kill_pin:\n"
#~ "#   The pin connected to 'kill' button. This button will call\n"
#~ "#   emergency stop. The presence of an 'analog_range_kill_pin' config\n"
#~ "#   parameter turns this parameter from digital to analog.\n"
#~ "#analog_pullup_resistor: 4700\n"
#~ "#   The resistance (in ohms) of the pullup attached to the analog\n"
#~ "#   button. The default is 4700 ohms.\n"
#~ "#analog_range_click_pin:\n"
#~ "#   The resistance range for a 'enter' button. Range minimum and\n"
#~ "#   maximum comma-separated values must be provided when using analog\n"
#~ "#   button.\n"
#~ "#analog_range_back_pin:\n"
#~ "#   The resistance range for a 'back' button. Range minimum and\n"
#~ "#   maximum comma-separated values must be provided when using analog\n"
#~ "#   button.\n"
#~ "#analog_range_up_pin:\n"
#~ "#   The resistance range for a 'up' button. Range minimum and maximum\n"
#~ "#   comma-separated values must be provided when using analog button.\n"
#~ "#analog_range_down_pin:\n"
#~ "#   The resistance range for a 'down' button. Range minimum and\n"
#~ "#   maximum comma-separated values must be provided when using analog\n"
#~ "#   button.\n"
#~ "#analog_range_kill_pin:\n"
#~ "#   The resistance range for a 'kill' button. Range minimum and\n"
#~ "#   maximum comma-separated values must be provided when using analog\n"
#~ "#   button.\n"
#~ msgstr ""

#~ msgid "hd44780_spi display"
#~ msgstr ""

#~ msgid ""
#~ "Information on configuring st7920 displays (which is used in "
#~ "\"RepRapDiscount 12864 Full Graphic Smart Controller\" type displays)."
#~ msgstr ""

#~ msgid ""
#~ "[display]\n"
#~ "lcd_type: emulated_st7920\n"
#~ "#   Set to \"emulated_st7920\" for emulated_st7920 displays.\n"
#~ "en_pin:\n"
#~ "spi_software_sclk_pin:\n"
#~ "spi_software_mosi_pin:\n"
#~ "spi_software_miso_pin:\n"
#~ "#   The pins connected to an emulated_st7920 type lcd. The en_pin\n"
#~ "#   corresponds to the cs_pin of the st7920 type lcd,\n"
#~ "#   spi_software_sclk_pin corresponds to sclk_pin and\n"
#~ "#   spi_software_mosi_pin corresponds to sid_pin. The\n"
#~ "#   spi_software_miso_pin needs to be set to an unused pin of the\n"
#~ "#   printer mainboard as the st7920 as no MISO pin but the software\n"
#~ "#   spi implementation requires this pin to be configured.\n"
#~ "...\n"
#~ msgstr ""

#~ msgid "ssd1306 and sh1106 displays"
#~ msgstr ""

#~ msgid ""
#~ "Support for displaying custom data on an lcd screen. One may create any "
#~ "number of display groups and any number of data items under those groups. "
#~ "The display will show all the data items for a given group if the "
#~ "display_group option in the [display] section is set to the given group "
#~ "name."
#~ msgstr ""

#~ msgid ""
#~ "Display data text \"macros\" (one may define any number of sections with a "
#~ "display_template prefix). See the [command templates](Command_Templates.md) "
#~ "document for information on template evaluation."
#~ msgstr ""

#~ msgid "[display_glyph]"
#~ msgstr ""

#~ msgid "[display my_extra_display]"
#~ msgstr ""

#~ msgid "Customizable lcd display menus."
#~ msgstr ""

#~ msgid "Filament sensors"
#~ msgstr ""

#~ msgid "[filament_motion_sensor]"
#~ msgstr ""

#~ msgid ""
#~ "TSLl401CL Based Filament Width Sensor. See the "
#~ "[guide](TSL1401CL_Filament_Width_Sensor.md) for more information."
#~ msgstr ""

#~ msgid "Board specific hardware support"
#~ msgstr ""

#~ msgid ""
#~ "[sx1509 my_sx1509]\n"
#~ "i2c_address:\n"
#~ "#   I2C address used by this expander. Depending on the hardware\n"
#~ "#   jumpers this is one out of the following addresses: 62 63 112\n"
#~ "#   113. This parameter must be provided.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#i2c_bus:\n"
#~ "#   If the I2C implementation of your micro-controller supports\n"
#~ "#   multiple I2C busses, you may specify the bus name here. The\n"
#~ "#   default is to use the default micro-controller i2c bus.\n"
#~ msgstr ""

#~ msgid "[adc_scaled]"
#~ msgstr ""

#~ msgid "[replicape]"
#~ msgstr ""

#~ msgid ""
#~ "Palette 2 multimaterial support - provides a tighter integration supporting "
#~ "Palette 2 devices in connected mode."
#~ msgstr ""

#~ msgid ""
#~ "[palette2]\n"
#~ "serial:\n"
#~ "#   The serial port to connect to the Palette 2.\n"
#~ "#baud: 115200\n"
#~ "#   The baud rate to use. The default is 115200.\n"
#~ "#feedrate_splice: 0.8\n"
#~ "#   The feedrate to use when splicing, default is 0.8\n"
#~ "#feedrate_normal: 1.0\n"
#~ "#   The feedrate to use after splicing, default is 1.0\n"
#~ "#auto_load_speed: 2\n"
#~ "#   Extrude feedrate when autoloading, default is 2 (mm/s)\n"
#~ "#auto_cancel_variation: 0.1\n"
#~ "#   Auto cancel print when ping varation is above this threshold\n"
#~ msgstr ""

#~ msgid "Common SPI settings"
#~ msgstr ""

#~ msgid ""
#~ "The following parameters are generally available for devices using an I2C "
#~ "bus."
#~ msgstr ""

#~ msgid "Changes"
#~ msgstr ""

#~ msgid ""
#~ "20220407: The temperature_fan `pid_integral_max` config option has been "
#~ "removed (it was deprecated on 20210612)."
#~ msgstr ""

#~ msgid ""
#~ "20220304: There is no longer a default for the `extruder` parameter of "
#~ "[extruder_stepper](Config_Reference.md#extruder_stepper) config sections. If"
#~ " desired, specify `extruder: extruder` explicitly to associate the stepper "
#~ "motor with the \"extruder\" motion queue at startup."
#~ msgstr ""

#~ msgid ""
#~ "20211110: The \"NTC 100K beta 3950\" temperature sensor is deprecated. This "
#~ "sensor will be removed in the near future. Most users will find the "
#~ "\"Generic 3950\" temperature sensor more accurate. To continue to use the "
#~ "older (typically less accurate) definition, define a custom "
#~ "[thermistor](Config_Reference.md#thermistor) with `temperature1: 25`, "
#~ "`resistance1: 100000`, and `beta: 3950`."
#~ msgstr ""

#~ msgid ""
#~ "20210903: The default [`smooth_time`](Config_Reference.md#extruder) for "
#~ "heaters has changed to 1 second (from 2 seconds). For most printers this "
#~ "will result in more stable temperature control."
#~ msgstr ""

#~ msgid ""
#~ "20210819: In some cases, a `G28` homing move may end in a position that is "
#~ "nominally outside the valid movement range. In rare situations this may "
#~ "result in confusing \"Move out of range\" errors after homing. If this "
#~ "occurs, change your start scripts to move the toolhead to a valid position "
#~ "immediately after homing."
#~ msgstr ""

#~ msgid ""
#~ "20210612: The `pid_integral_max` config option in heater and temperature_fan"
#~ " sections is deprecated. The option will be removed in the near future."
#~ msgstr ""

#~ msgid ""
#~ "20210313: Klipper's support for micro-controllers that communicate with CAN "
#~ "bus has changed. If using CAN bus then all micro-controllers must be "
#~ "reflashed and the [Klipper configuration must be updated](CANBUS.md)."
#~ msgstr ""

#~ msgid ""
#~ "20210201: The `TEST_RESONANCES` command will now disable input shaping if it"
#~ " was previously enabled (and re-enable it after the test). In order to "
#~ "override this behavior and keep the input shaping enabled, one can pass an "
#~ "additional parameter `INPUT_SHAPING=1` to the command."
#~ msgstr ""

#~ msgid ""
#~ "20201218: Rotary delta and polar printers must now specify a `gear_ratio` "
#~ "for their rotary steppers, and they may no longer specify a `step_distance` "
#~ "parameter. See the [config reference](Config_Reference.md#stepper) for the "
#~ "format of the new gear_ratio paramter."
#~ msgstr ""

#~ msgid ""
#~ "20201029: The neopixel `color_order_GRB` config option has been removed. If "
#~ "necessary, update the config to set the new `color_order` option to RGB, "
#~ "GRB, RGBW, or GRBW."
#~ msgstr ""

#~ msgid ""
#~ "20200816: The gcode macro `printer.gcode` object has been renamed to "
#~ "`printer.gcode_move`. Several undocumented variables in `printer.toolhead` "
#~ "and `printer.gcode` have been removed. See docs/Command_Templates.md for a "
#~ "list of available template variables."
#~ msgstr ""

#~ msgid ""
#~ "20200725: The servo `enable` config parameter and the SET_SERVO `ENABLE` "
#~ "parameter have been removed. Update any macros to use `SET_SERVO "
#~ "SERVO=my_servo WIDTH=0` to disable a servo."
#~ msgstr ""

#~ msgid ""
#~ "20200531: The default USB vendor/product id is now 0x1d50/0x614e. These new "
#~ "ids are reserved for Klipper (thanks to the openmoko project). This change "
#~ "should not require any config changes, but the new ids may appear in system "
#~ "logs."
#~ msgstr ""

#~ msgid ""
#~ "20200308: The default `__test` menu item was removed. If the config file has"
#~ " a custom menu then be sure to remove all references to this `__test` menu "
#~ "item."
#~ msgstr ""

#~ msgid ""
#~ "20191210: The builtin T0, T1, T2, ... commands have been removed. The "
#~ "extruder activate_gcode and deactivate_gcode config options have been "
#~ "removed. If these commands (and scripts) are needed then define individual "
#~ "[gcode_macro T0] style macros that call the ACTIVATE_EXTRUDER command. See "
#~ "the config/sample-idex.cfg and sample-multi-extruder.cfg files for examples."
#~ msgstr ""

#~ msgid ""
#~ "20191121: The pressure_advance_lookahead_time parameter has been removed. "
#~ "See example.cfg for alternate configuration settings."
#~ msgstr ""

#~ msgid ""
#~ "20191003: The move_to_previous option in [safe_z_homing] now defaults to "
#~ "False. (It was effectively False prior to 20190918.)"
#~ msgstr ""

#~ msgid ""
#~ "20190710: The z_hop option was removed from the [firmware_retract] config "
#~ "section. The z_hop support was incomplete and could cause incorrect behavior"
#~ " with several common slicers."
#~ msgstr ""

#~ msgid ""
#~ "20190606: The \"samples\", \"samples_result\", and \"sample_retract_dist\" "
#~ "config options have been moved to the \"probe\" config section. These "
#~ "options are no longer supported in the \"delta_calibrate\", \"bed_tilt\", "
#~ "\"bed_mesh\", \"screws_tilt_adjust\", \"z_tilt\", or \"quad_gantry_level\" "
#~ "config sections."
#~ msgstr ""

#~ msgid ""
#~ "20190404: The i2c_bus and spi_bus parameters (in various config sections) "
#~ "now take a bus name instead of a number."
#~ msgstr ""

#~ msgid ""
#~ "20190310: The [controller_fan] config section now always takes a name (such "
#~ "as [controller_fan my_controller_fan])."
#~ msgstr ""

#~ msgid ""
#~ "20190224: The bed_shape option has been removed from bed_mesh. The radius "
#~ "option has been renamed to bed_radius. Users with round beds should supply "
#~ "the bed_radius and round_probe_count options."
#~ msgstr ""

#~ msgid ""
#~ "Case is not important for the G-Code macro name - MY_MACRO and my_macro will"
#~ " evaluate the same and may be called in either upper or lower case. If any "
#~ "numbers are used in the macro name then they must all be at the end of the "
#~ "name (eg, TEST_MACRO25 is valid, but MACRO25_TEST3 is not)."
#~ msgstr ""

#~ msgid ""
#~ "Note how the `gcode:` config option always starts at the beginning of the "
#~ "line and subsequent lines in the G-Code macro never start at the beginning."
#~ msgstr ""

#~ msgid ""
#~ "The terminal will display the description when you use the `HELP` command or"
#~ " the autocomplete function."
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro MOVE_UP]\n"
#~ "gcode:\n"
#~ "  SAVE_GCODE_STATE NAME=my_move_up_state\n"
#~ "  G91\n"
#~ "  G1 Z10 F300\n"
#~ "  RESTORE_GCODE_STATE NAME=my_move_up_state\n"
#~ msgstr ""

#~ msgid "An example of a complex macro:"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro SET_PERCENT]\n"
#~ "gcode:\n"
#~ "  M117 Now at { params.VALUE|float * 100 }%\n"
#~ msgstr ""

#~ msgid "The \"rawparams\" variable"
#~ msgstr ""

#~ msgid "The \"printer\" Variable"
#~ msgstr ""

#~ msgid ""
#~ "Important! Macros are first evaluated in entirety and only then are the "
#~ "resulting commands executed. If a macro issues a command that alters the "
#~ "state of the printer, the results of that state change will not be visible "
#~ "during the evaluation of the macro. This can also result in subtle behavior "
#~ "when a macro generates commands that call other macros, as the called macro "
#~ "is evaluated when it is invoked (which is after the entire evaluation of the"
#~ " calling macro)."
#~ msgstr ""

#~ msgid "Actions"
#~ msgstr ""

#~ msgid ""
#~ "`action_raise_error(msg)`: Abort the current macro (and any calling macros) "
#~ "and write the given `msg` to the /tmp/printer pseudo-terminal. The first "
#~ "line of `msg` will be sent with a \"!! \" prefix and subsequent lines will "
#~ "have a \"// \" prefix."
#~ msgstr ""

#~ msgid ""
#~ "The SET_GCODE_VARIABLE command may be useful for saving state between macro "
#~ "calls. Variable names may not contain any upper case characters. For "
#~ "example:"
#~ msgstr ""

#~ msgid ""
#~ "The [delayed_gcode] configuration option can be used to execute a delayed "
#~ "gcode sequence:"
#~ msgstr ""

#~ msgid ""
#~ "[delayed_gcode welcome]\n"
#~ "initial_duration: 5.\n"
#~ "gcode:\n"
#~ "  M117 Welcome!\n"
#~ msgstr ""

#~ msgid "UPDATE_DELAYED_GCODE ID=report_temp DURATION=0\n"
#~ msgstr ""

#~ msgid "`menu.width` - element width (number of display columns)"
#~ msgstr ""

#~ msgid "The following actions are available in menu templates:"
#~ msgstr ""

#~ msgid ""
#~ "`menu.exit(force)` - will execute menu exit command, optional boolean "
#~ "parameter `<force>` default value False."
#~ msgstr ""

#~ msgid ""
#~ "As an example, it could be used to save the state of 2-in-1-out hotend and "
#~ "when starting a print ensure that the active extruder is used, instead of "
#~ "T0:"
#~ msgstr ""

#~ msgid ""
#~ "The **src/** directory contains the C source for the micro-controller code. "
#~ "The **src/atsam/**, **src/atsamd/**, **src/avr/**, **src/linux/**, "
#~ "**src/lpc176x/**, **src/pru/**, and **src/stm32/** directories contain "
#~ "architecture specific micro-controller code. The **src/simulator/** contains"
#~ " code stubs that allow the micro-controller to be test compiled on other "
#~ "architectures. The **src/generic/** directory contains helper code that may "
#~ "be useful across different architectures. The build arranges for includes of"
#~ " \"board/somefile.h\" to first look in the current architecture directory "
#~ "(eg, src/avr/somefile.h) and then in the generic directory (eg, "
#~ "src/generic/somefile.h)."
#~ msgstr ""

#~ msgid ""
#~ "The **scripts/** directory contains build-time scripts useful for compiling "
#~ "the micro-controller code."
#~ msgstr ""

#~ msgid ""
#~ "Execution of the micro-controller code starts in architecture specific code "
#~ "(eg, **src/avr/main.c**) which ultimately calls sched_main() located in "
#~ "**src/sched.c**. The sched_main() code starts by running all functions that "
#~ "have been tagged with the DECL_INIT() macro. It then goes on to repeatedly "
#~ "run all functions tagged with the DECL_TASK() macro."
#~ msgstr ""

#~ msgid ""
#~ "In the event an error is detected the code can invoke shutdown() (a macro "
#~ "which calls sched_shutdown() located in **src/sched.c**). Invoking "
#~ "shutdown() causes all functions tagged with the DECL_SHUTDOWN() macro to be "
#~ "run. Shutdown functions always run with interrupts disabled."
#~ msgstr ""

#~ msgid ""
#~ "Initial execution starts in **klippy/klippy.py**. This reads the command-"
#~ "line arguments, opens the printer config file, instantiates the main printer"
#~ " objects, and starts the serial connection. The main execution of G-code "
#~ "commands is in the process_commands() method in **klippy/gcode.py**. This "
#~ "code translates the G-code commands into printer object calls, which "
#~ "frequently translate the actions to commands to be executed on the micro-"
#~ "controller (as declared via the DECL_COMMAND macro in the micro-controller "
#~ "code)."
#~ msgstr ""

#~ msgid ""
#~ "Processing for a move command starts in gcode.py. The goal of gcode.py is to"
#~ " translate G-code into internal calls. A G1 command will invoke cmd_G1() in "
#~ "klippy/extras/gcode_move.py. The gcode_move.py code handles changes in "
#~ "origin (eg, G92), changes in relative vs absolute positions (eg, G90), and "
#~ "unit changes (eg, F6000=100mm/s). The code path for a move is: "
#~ "`_process_data() -> _process_commands() -> cmd_G1()`. Ultimately the "
#~ "ToolHead class is invoked to execute the actual request: `cmd_G1() -> "
#~ "ToolHead.move()`"
#~ msgstr ""

#~ msgid "MoveQueue.add_move() places the move object on the \"look-ahead\" queue."
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
#~ "finding_algorithm) to generate the step times for each stepper. For "
#~ "efficiency reasons, the stepper pulse times are generated in C code. The "
#~ "moves are first placed on a \"trapezoid motion queue\": "
#~ "`ToolHead._process_moves() -> trapq_append()` (in klippy/chelper/trapq.c). "
#~ "The step times are then generated: `ToolHead._process_moves() -> "
#~ "ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> "
#~ "itersolve_generate_steps() -> itersolve_gen_steps_range()` (in "
#~ "klippy/chelper/itersolve.c). The goal of the iterative solver is to find "
#~ "step times given a function that calculates a stepper position from a time. "
#~ "This is done by repeatedly \"guessing\" various times until the stepper "
#~ "position formula returns the desired position of the next step on the "
#~ "stepper. The feedback produced from each guess is used to improve future "
#~ "guesses so that the process rapidly converges to the desired time. The "
#~ "kinematic stepper position formulas are located in the klippy/chelper/ "
#~ "directory (eg, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c)."
#~ msgstr ""

#~ msgid ""
#~ "Processing of the queue_step commands on the micro-controller starts in "
#~ "src/command.c which parses the command and calls `command_queue_step()`. The"
#~ " command_queue_step() code (in src/stepper.c) just appends the parameters of"
#~ " each queue_step command to a per stepper queue. Under normal operation the "
#~ "queue_step command is parsed and queued at least 100ms before the time of "
#~ "its first step. Finally, the generation of stepper events is done in "
#~ "`stepper_event()`. It's called from the hardware timer interrupt at the "
#~ "scheduled time of the first step. The stepper_event() code generates a step "
#~ "pulse and then reschedules itself to run at the time of the next step pulse "
#~ "for the given queue_step parameters. The parameters for each queue_step "
#~ "command are \"interval\", \"count\", and \"add\". At a high-level, "
#~ "stepper_event() runs the following, 'count' times: `do_step(); "
#~ "next_wake_time = last_wake_time + interval; interval += add;`"
#~ msgstr ""

#~ msgid ""
#~ "The easiest way to add a new module is to use an existing module as a "
#~ "reference - see **klippy/extras/servo.py** as an example."
#~ msgstr ""

#~ msgid ""
#~ "Use the `config.get_printer()` method to obtain a reference to the main "
#~ "\"printer\" class. This \"printer\" class stores references to all the "
#~ "\"printer objects\" that have been instantiated. Use the "
#~ "`printer.lookup_object()` method to find references to other printer "
#~ "objects. Almost all functionality (even core kinematic modules) are "
#~ "encapsulated in one of these printer objects. Note, though, that when a new "
#~ "module is instantiated, not all other printer objects will have been "
#~ "instantiated. The \"gcode\" and \"pins\" modules will always be available, "
#~ "but for other modules it is a good idea to defer the lookup."
#~ msgstr ""

#~ msgid ""
#~ "If there is an error in the user's config, be sure to raise it during the "
#~ "`load_config()` or \"connect event\" phases. Use either `raise "
#~ "config.error(\"my error\")` or `raise printer.config_error(\"my error\")` to"
#~ " report the error."
#~ msgstr ""

#~ msgid ""
#~ "Do not use global variables. All state should be stored in the printer "
#~ "object returned from the `load_config()` function. This is important as "
#~ "otherwise the RESTART command may not perform as expected. Also, for similar"
#~ " reasons, if any external files (or sockets) are opened then be sure to "
#~ "register a \"klippy:disconnect\" event handler and close them from that "
#~ "callback."
#~ msgstr ""

#~ msgid ""
#~ "If submitting the module for inclusion in the main Klipper code, be sure to "
#~ "place a copyright notice at the top of the module. See the existing modules "
#~ "for the preferred format."
#~ msgstr ""

#~ msgid ""
#~ "Start by studying the \"[code flow of a move](#code-flow-of-a-move-"
#~ "command)\" section and the [Kinematics document](Kinematics.md)."
#~ msgstr ""

#~ msgid ""
#~ "Other methods. Implement the `check_move()`, `get_status()`, "
#~ "`get_steppers()`, `home()`, and `set_position()` methods. These functions "
#~ "are typically used to provide kinematic specific checks. However, at the "
#~ "start of development one can use boiler-plate code here."
#~ msgstr ""

#~ msgid ""
#~ "Start by identifying any 3rd party libraries that will be used during the "
#~ "port. Common examples include \"CMSIS\" wrappers and manufacturer \"HAL\" "
#~ "libraries. All 3rd party code needs to be GNU GPLv3 compatible. The 3rd "
#~ "party code should be committed to the Klipper lib/ directory. Update the "
#~ "lib/README file with information on where and when the library was obtained."
#~ " It is preferable to copy the code into the Klipper repository unchanged, "
#~ "but if any changes are required then those changes should be listed "
#~ "explicitly in the lib/README file."
#~ msgstr ""

#~ msgid ""
#~ "Add support for timer dispatch from hardware interrupts. See Klipper [commit"
#~ " "
#~ "970831ee](https://github.com/Klipper3d/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)"
#~ " as an example of steps 1-5 done for the LPC176x architecture."
#~ msgstr ""

#~ msgid "Consider adding build test cases in the test/ directory."
#~ msgstr ""

#~ msgid "Coordinate Systems"
#~ msgstr ""

#~ msgid ""
#~ "The \"mcu\" position (`stepper.get_mcu_position()` in the code) is the total"
#~ " number of steps the micro-controller has issued in a positive direction "
#~ "minus the number of steps issued in a negative direction since the micro-"
#~ "controller was last reset. If the robot is in motion when the query is "
#~ "issued then the reported value includes moves buffered on the micro-"
#~ "controller, but does not include moves on the look-ahead queue."
#~ msgstr ""

#~ msgid ""
#~ "The \"gcode\" position is the last requested position from a `G1` (or `G0`) "
#~ "command in cartesian coordinates relative to the coordinate system specified"
#~ " in the config file. This may differ from the \"toolhead\" position if a "
#~ "g-code transformation (eg, bed_mesh, bed_tilt, skew_correction) is in "
#~ "effect. This may differ from the actual coordinates specified in the last "
#~ "`G1` command if the g-code origin has been changed (eg, `G92`, "
#~ "`SET_GCODE_OFFSET`, `M221`). The `M114` command "
#~ "(`gcode_move.get_status()['gcode_position']`) will report the last g-code "
#~ "position relative to the current g-code coordinate system."
#~ msgstr ""

#~ msgid ""
#~ "Fundamental to the operation of Klipper is the handling of clocks, times, "
#~ "and timestamps. Klipper executes actions on the printer by scheduling events"
#~ " to occur in the near future. For example, to turn on a fan, the code might "
#~ "schedule a change to a GPIO pin in a 100ms. It is rare for the code to "
#~ "attempt to take an instantaneous action. Thus, the handling of time within "
#~ "Klipper is critical to correct operation."
#~ msgstr ""

#~ msgid ""
#~ "MCU clock. This is the hardware clock counter on each micro-controller. It "
#~ "is stored as an integer and its update rate is relative to the frequency of "
#~ "the given micro-controller. The host software translates its internal times "
#~ "to clocks before transmission to the mcu. The mcu code only ever tracks time"
#~ " in clock ticks. Within the host code, clock values are tracked as 64bit "
#~ "integers, while the mcu code uses 32bit integers. Within the host code, "
#~ "clocks are generally stored in variables with names containing *clock* or "
#~ "*ticks*."
#~ msgstr ""

#~ msgid ""
#~ "Multiple micro-controllers: The host software supports using multiple micro-"
#~ "controllers on a single printer. In this case, the \"MCU clock\" of each "
#~ "micro-controller is tracked separately. The clocksync.py code handles clock "
#~ "drift between micro-controllers by modifying the way it converts from "
#~ "\"print time\" to \"MCU clock\". On secondary mcus, the mcu frequency that "
#~ "is used in this conversion is regularly updated to account for measured "
#~ "drift."
#~ msgstr ""

#~ msgid "Overview of Contribution Process"
#~ msgstr ""

#~ msgid ""
#~ "After a successful review, the reviewer will \"approve the review\" on "
#~ "GitHub and a [maintainer](#reviewers) will commit the change to the Klipper "
#~ "master branch."
#~ msgstr ""

#~ msgid ""
#~ "It is understood that there are many ways to accomplish a task; it is not "
#~ "the intent of the review to discuss the \"best\" implementation. Where "
#~ "possible, review discussions focused on facts and measurements are "
#~ "preferable."
#~ msgstr ""

#~ msgid ""
#~ "Submitters are expected to test their changes prior to submission. The "
#~ "reviewers look for errors, but they don't, in general, test submissions. An "
#~ "accepted submission is often deployed to thousands of printers within a few "
#~ "weeks of acceptance. Quality of submissions is therefore considered a "
#~ "priority."
#~ msgstr ""

#~ msgid ""
#~ "Code submissions should not contain excessive debugging code, debugging "
#~ "options, nor run-time debug logging."
#~ msgstr ""

#~ msgid ""
#~ "Reviewers need to identify, at least in their own minds, roughly \"who the "
#~ "target audience is\", a rough scale of \"the size of that audience\", the "
#~ "\"benefit\" they will obtain, how the \"benefit is measured\", and the "
#~ "\"results of those measurement tests\". In most cases this will be obvious "
#~ "to both the submitter and the reviewer, and it is not explicitly stated "
#~ "during a review."
#~ msgstr ""

#~ msgid ""
#~ "All new modules, config options, commands, command parameters, and documents"
#~ " should have \"high impact\". We do not want to burden users with options "
#~ "that they can not reasonably configure nor do we want to burden them with "
#~ "options that don't provide a notable benefit."
#~ msgstr ""

#~ msgid ""
#~ "Is the copyright of the submission clear, non-gratuitous, and compatible?"
#~ msgstr ""

#~ msgid ""
#~ "Does the submission follow guidelines specified in the Klipper "
#~ "documentation?"
#~ msgstr ""

#~ msgid ""
#~ "All commands and command parameters must be documented in <G-Codes.md>."
#~ msgstr ""

#~ msgid ""
#~ "Any change that makes a non-backwards compatible change to a command or "
#~ "config file setting must be documented in <Config_Changes.md>."
#~ msgstr ""

#~ msgid ""
#~ "Commits must not have a merge conflict. New additions to the Klipper master "
#~ "branch are always done via a \"rebase\" or \"squash and rebase\". It is "
#~ "generally not necessary for submitters to re-merge their submission on every"
#~ " update to the Klipper master repository. However, if there is a merge "
#~ "conflict, then submitters are recommended to use `git rebase` to address the"
#~ " conflict."
#~ msgstr ""

#~ msgid ""
#~ "It is not a goal of a review to discuss \"better implementations\". However,"
#~ " if a reviewer struggles to understand the implementation of a submission, "
#~ "then they may ask for changes to make the implementation more transparent. "
#~ "In particular, if reviewers can not convince themselves that a submission is"
#~ " free of defects then changes may be necessary."
#~ msgstr ""

#~ msgid ""
#~ "To help with a review, follow the steps outlined in [what to expect in a "
#~ "review](#what-to-expect-in-a-review) to verify the submission. After "
#~ "completing the review, add a comment to the GitHub Pull Request with your "
#~ "findings. If the submission passes the review then please state that "
#~ "explicitly in the comment - for example something like \"I reviewed this "
#~ "change according to the steps in the CONTRIBUTING document and everything "
#~ "looks good to me\". If unable to complete some steps in the review then "
#~ "please explicitly state which steps were reviewed and which steps were not "
#~ "reviewed - for example something like \"I didn't check the code for defects,"
#~ " but I reviewed everything else in the CONTRIBUTING document and it looks "
#~ "good\"."
#~ msgstr ""

#~ msgid "Name"
#~ msgstr ""

#~ msgid "@dmbutyugin"
#~ msgstr ""

#~ msgid "@KevinOConnor"
#~ msgstr ""

#~ msgid "Configuration files, documentation"
#~ msgstr ""

#~ msgid "Format of commit messages"
#~ msgstr ""

#~ msgid ""
#~ "It is important to have a \"Signed-off-by\" line on each commit - it "
#~ "certifies that you agree to the [developer certificate of origin](developer-"
#~ "certificate-of-origin). It must contain your real name (sorry, no pseudonyms"
#~ " or anonymous contributions) and contain a current email address."
#~ msgstr ""

#~ msgid "All titles (H1) are translated"
#~ msgstr ""

#~ msgid "Once the requirements are met, you need to:"
#~ msgstr ""

#~ msgid ""
#~ "Currently, there isn't a method for correctly translating pictures in the "
#~ "documentation"
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses only CAN 2.0A standard size CAN bus packets, which are limited "
#~ "to 8 data bytes and an 11-bit CAN bus identifier. In order to support "
#~ "efficient communication, each micro-controller is assigned at run-time a "
#~ "unique 1-byte CAN bus nodeid (`canbus_nodeid`) for general Klipper command "
#~ "and response traffic. Klipper command messages going from host to micro-"
#~ "controller use the CAN bus id of `canbus_nodeid * 2 + 256`, while Klipper "
#~ "response messages from micro-controller to host use `canbus_nodeid * 2 + 256"
#~ " + 1`."
#~ msgstr ""

#~ msgid "CMD_QUERY_UNASSIGNED message"
#~ msgstr ""

#~ msgid ""
#~ "This command assigns a `canbus_nodeid` to the micro-controller with a given "
#~ "`canbus_uuid`."
#~ msgstr ""

#~ msgid "Data Packets"
#~ msgstr ""

#~ msgid ""
#~ "Klipper currently supports CAN on stm32, same5x, and rp2040 chips. In "
#~ "addition, the micro-controller chip must be on a board that has a CAN "
#~ "transceiver."
#~ msgstr ""

#~ msgid ""
#~ "Use a [Waveshare Raspberry Pi CAN hat](https://www.waveshare.com/rs485-can-"
#~ "hat.htm) or one of its many clones."
#~ msgstr ""

#~ msgid ""
#~ "Note that the \"Raspberry Pi CAN hat\" also requires [changes to "
#~ "config.txt](https://www.waveshare.com/wiki/RS485_CAN_HAT)."
#~ msgstr ""

#~ msgid ""
#~ "To test that the resistors are correct, one can remove power to the printer "
#~ "and use a multi-meter to check the resistance between the CANH and CANL "
#~ "wires - it should report ~60 ohms on a correctly wired CAN bus."
#~ msgstr ""

#~ msgid ""
#~ "If uninitialized CAN devices are detected the above command will report "
#~ "lines like the following:"
#~ msgstr ""

#~ msgid ""
#~ "Update the Klipper [mcu configuration](Config_Reference.md#mcu) to use the "
#~ "CAN bus to communicate with the device - for example:"
#~ msgstr ""

#~ msgid ""
#~ "When Klipper uses this mode the micro-controller appears as a \"USB CAN bus "
#~ "adapter\" under Linux. The \"Klipper bridge mcu\" itself will appear as if "
#~ "was on this CAN bus - it can be identified via `canbus_query.py` and "
#~ "configured like other CAN bus Klipper nodes. It will appear alongside other "
#~ "devices that are actually on the CAN bus."
#~ msgstr ""

#~ msgid ""
#~ "Whenever the \"bridge mcu\" is reset, Linux will disable the corresponding "
#~ "`can0` interface. To ensure proper handling of FIRMWARE_RESTART and RESTART "
#~ "commands, it is recommended to replace `auto` with `allow-hotplug` in the "
#~ "`/etc/network/interfaces.d/can0` file. For example:"
#~ msgstr ""

#~ msgid ""
#~ "If one can flash a bootloader to a micro-controller then one can generally "
#~ "also use that mechanism to flash an application, but care should be taken "
#~ "when doing this as one may inadvertently remove the bootloader. In contrast,"
#~ " a bootloader will generally only permit a user to flash an application. It "
#~ "is therefore recommended to use a bootloader to flash an application where "
#~ "possible."
#~ msgstr ""

#~ msgid ""
#~ "To flash a bootloader itself, the AVR chips require an external hardware "
#~ "flashing tool (which communicates with the chip using SPI). This tool can be"
#~ " purchased (for example, do a web search for \"avr isp\", \"arduino isp\", "
#~ "or \"usb tiny isp\"). It is also possible to use another Arduino or "
#~ "Raspberry Pi to flash an AVR bootloader (for example, do a web search for "
#~ "\"program an avr using raspberry pi\"). The examples below are written "
#~ "assuming an \"AVR ISP Mk2\" type device is in use."
#~ msgstr ""

#~ msgid "To flash the bootloader itself use something like:"
#~ msgstr ""

#~ msgid "Atmega1280"
#~ msgstr ""

#~ msgid "Atmega1284p"
#~ msgstr ""

#~ msgid ""
#~ "Note that a number of \"Melzi\" style boards come preloaded with a "
#~ "bootloader that uses a baud rate of 57600. In this case, to flash an "
#~ "application use something like this instead:"
#~ msgstr ""

#~ msgid ""
#~ "The Teensy++ device from pjrc.com comes with a proprietary bootloader. It "
#~ "requires a custom flashing tool from "
#~ "<https://github.com/PaulStoffregen/teensy_loader_cli>. One can flash an "
#~ "application with it using something like:"
#~ msgstr ""

#~ msgid ""
#~ "wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/optiboot/optiboot_atmega168.hex'\n"
#~ "\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0x04:m -U hfuse:w:0xDD:m -U lfuse:w:0xFF:m\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega168.hex\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
#~ msgstr ""

#~ msgid ""
#~ "It is not common to use a bootloader with the SAM3 mcu. The chip itself has "
#~ "a ROM that allows the flash to be programmed from 3.3V serial port or from "
#~ "USB."
#~ msgstr ""

#~ msgid "SAM4 micro-controllers (Duet Wifi)"
#~ msgstr ""

#~ msgid "bossac --port=/dev/ttyACM0 -b -U -e -w -v -R out/klipper.bin\n"
#~ msgstr ""

#~ msgid "source [find target/at91samdXX.cfg]\n"
#~ msgstr ""

#~ msgid ""
#~ "at91samd bootloader 0\n"
#~ "program samd21_sam_ba.bin verify\n"
#~ msgstr ""

#~ msgid ""
#~ "avrdude -c stk500v2 -p atmega2560 -P /dev/ttyACM0 -u "
#~ "-Uflash:w:out/klipper.elf.hex:i\n"
#~ msgstr ""

#~ msgid ""
#~ "Obtain a bootloader - several bootloaders are available from "
#~ "<https://github.com/adafruit/uf2-samdx1/releases/latest>. For example:"
#~ msgstr ""

#~ msgid "bossac -U -p /dev/ttyACM0 --offset=0x4000 -w out/klipper.bin -v -b -R\n"
#~ msgstr ""

#~ msgid ""
#~ "Note that if one is using a Raspberry Pi for the 3.3V serial, the stm32flash"
#~ " protocol uses a serial parity mode which the Raspberry Pi's \"mini UART\" "
#~ "does not support. See "
#~ "<https://www.raspberrypi.com/documentation/computers/configuration.html#configuring-"
#~ "uarts> for details on enabling the full uart on the Raspberry Pi GPIO pins."
#~ msgstr ""

#~ msgid "This bootloader can be flashed via 3.3V serial with something like:"
#~ msgstr ""

#~ msgid ""
#~ "The bootloader typically runs for only a short period after boot. It may be "
#~ "necessary to time the above command so that it runs while the bootloader is "
#~ "still active (the bootloader will flash a board led while it is running). "
#~ "Alternatively, set the \"boot 0\" pin to low and \"boot 1\" pin to high to "
#~ "stay in the bootloader after a reset."
#~ msgstr ""

#~ msgid ""
#~ "It is not possible to use stm32flash for the SKR Mini E3 as the boot0 pin is"
#~ " tied directly to ground and not broken out via header pins. It is "
#~ "recommended to use a STLink V2 with STM32Cubeprogrammer to flash the "
#~ "bootloader. If you don't have access to a STLink it is also possible to use "
#~ "a [Raspberry Pi and OpenOCD](#running-openocd-on-the-raspberry-pi) with the "
#~ "following chip config:"
#~ msgstr ""

#~ msgid "finally, you can flash with commands similar to:"
#~ msgstr ""

#~ msgid ""
#~ "Prior flashing the SKR Mini E3 with this bootloader you should be aware that"
#~ " you will no longer be able to update firmware via the sdcard."
#~ msgstr ""

#~ msgid ""
#~ "The hid-flash program is used to upload a binary to the bootloader. You can "
#~ "install this software with the following commands:"
#~ msgstr ""

#~ msgid "alternatively, you can use `make flash` to flash klipper directly:"
#~ msgstr ""

#~ msgid ""
#~ "It may be necessary to manually enter the bootloader, this can be done by "
#~ "setting \"boot 0\" low and \"boot 1\" high. On the SKR Mini E3 \"Boot 1\" is"
#~ " not available, so it may be done by setting pin PA2 low if you flashed "
#~ "\"hid_btt_skr_mini_e3.bin\". This pin is labeld \"TX0\" on the TFT header in"
#~ " the SKR Mini E3's \"PIN\" document. There is a ground pin next to PA2 which"
#~ " you can use to pull PA2 low."
#~ msgstr ""

#~ msgid ""
#~ "For STM32F072 boards it is also possible to flash the bootloader over USB "
#~ "(via DFU) with something like:"
#~ msgstr ""

#~ msgid "STM32F103/STM32F0x2 with CanBoot bootloader"
#~ msgstr ""

#~ msgid ""
#~ "The `flash_can.py` utility supplied in the `lib/canboot` folder may be used "
#~ "to upload Klipper firmware. The device UUID is necessary to flash. If you do"
#~ " not have a UUID it is possible to query nodes currently running the "
#~ "bootloader:"
#~ msgstr ""

#~ msgid ""
#~ "python3 flash_can.py -i can0 -f ~/klipper/out/klipper.bin -u aabbccddeeff\n"
#~ msgstr ""

#~ msgid ""
#~ "STM32F4 microcontrollers come equipped with a built-in system bootloader "
#~ "capable of flashing over USB (via DFU), 3.3v Serial, and various other "
#~ "methods (see STM Document AN2606 for more information). Some STM32F4 boards,"
#~ " such as the SKR Pro 1.1, are not able to enter the DFU bootloader. The HID "
#~ "bootloader is available for STM32F405/407 based boards should the user "
#~ "prefer flashing over USB over using the sdcard. Note that you may need to "
#~ "configure and build a version specific to your board, a [build for the SKR "
#~ "Pro 1.1 is available "
#~ "here](https://github.com/Arksine/STM32_HID_Bootloader/releases/latest)."
#~ msgstr ""

#~ msgid ""
#~ "As with the STM32F1, the STM32F4 uses the hid-flash tool to upload binaries "
#~ "to the MCU. See the instructions above for details on how to build and use "
#~ "hid-flash."
#~ msgstr ""

#~ msgid ""
#~ "It is common for Smoothieboards to come with a bootloader from: "
#~ "<https://github.com/triffid/LPC17xx-DFU-Bootloader>. When using this "
#~ "bootloader the application must be compiled with a start address of 16KiB. "
#~ "The easiest way to flash an application with this bootloader is to copy the "
#~ "application file (eg, `out/klipper.bin`) to a file named `firmware.bin` on "
#~ "an SD card, and then to reboot the micro-controller with that SD card."
#~ msgstr ""

#~ msgid ""
#~ "Begin by downloading and compiling the software (each step may take several "
#~ "minutes and the \"make\" step may take 30+ minutes):"
#~ msgstr ""

#~ msgid "nano ~/openocd/openocd.cfg\n"
#~ msgstr ""

#~ msgid ""
#~ "Poweroff both the the Raspberry Pi and the target chip before wiring! Verify"
#~ " the target chip uses 3.3V prior to connecting to a Raspberry Pi!"
#~ msgstr ""

#~ msgid "Run OpenOCD:"
#~ msgstr ""

#~ msgid "telnet 127.0.0.1 4444\n"
#~ msgstr ""

#~ msgid "Add the following to the OpenOCD config file:"
#~ msgstr ""

#~ msgid "Within gdb run:"
#~ msgstr ""

#~ msgid ""
#~ "This section describes the mechanism used to generate the Klipper micro-"
#~ "controller step rate benchmarks."
#~ msgstr ""

#~ msgid "Step rate benchmark test"
#~ msgstr ""

#~ msgid ""
#~ "On a failure, one can copy-and-paste the following to clear the error in "
#~ "preparation for the next test:"
#~ msgstr ""

#~ msgid "ECHO Test result is: {\"%.0fK\" % (3. * freq / ticks / 1000.)}\n"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PA5 dir_pin=PA4 invert_step=0 step_pulse_ticks=32\n"
#~ "config_stepper oid=1 step_pin=PA3 dir_pin=PA2 invert_step=0 step_pulse_ticks=32\n"
#~ "config_stepper oid=2 step_pin=PC7 dir_pin=PC6 invert_step=0 step_pulse_ticks=32\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid "1 stepper"
#~ msgstr ""

#~ msgid "Arduino Due step rate benchmark"
#~ msgstr ""

#~ msgid "sam3x8e"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the Duet Maestro:"
#~ msgstr ""

#~ msgid "260"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `59314d99` with gcc version `gcc version "
#~ "10.3.1 20210621 (release) (GNU Arm Embedded Toolchain 10.3-2021.07)`."
#~ msgstr ""

#~ msgid "Beaglebone PRU step rate benchmark"
#~ msgstr ""

#~ msgid "pru"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the STM32F042:"
#~ msgstr ""

#~ msgid "249"
#~ msgstr ""

#~ msgid "stm32f103"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the STM32F4:"
#~ msgstr ""

#~ msgid "46"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on a STM32H743VIT6:"
#~ msgstr ""

#~ msgid "44"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PB13 dir_pin=PB12 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=PB10 dir_pin=PB2 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=PB0 dir_pin=PC5 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid "243"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `59314d99` with gcc version `arm-none-eabi-"
#~ "gcc (Fedora 10.2.0-4.fc34) 10.2.0`. The 120Mhz LPC1769 results were obtained"
#~ " by overclocking an LPC1768 to 120Mhz."
#~ msgstr ""

#~ msgid "lpc1769"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PA27 dir_pin=PA20 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=PB3 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=PA17 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid "306"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `59314d99` with gcc version `arm-none-eabi-"
#~ "gcc (Fedora 10.2.0-4.fc34) 10.2.0` on a SAMD51J19A micro-controller."
#~ msgstr ""

#~ msgid "3 stepper (200Mhz)"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=gpio25 dir_pin=gpio3 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=gpio26 dir_pin=gpio4 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=gpio27 dir_pin=gpio5 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid "Linux MCU step rate benchmark"
#~ msgstr ""

#~ msgid "Linux (RPi3)"
#~ msgstr ""

#~ msgid ""
#~ "The command dispatch benchmark tests how many \"dummy\" commands the micro-"
#~ "controller can process. It is primarily a test of the hardware communication"
#~ " mechanism. The test is run using the console.py tool (described in "
#~ "<Debugging.md>). The following is cut-and-paste into the console.py terminal"
#~ " window:"
#~ msgstr ""

#~ msgid "MCU"
#~ msgstr ""

#~ msgid "stm32f042 (CAN)"
#~ msgstr ""

#~ msgid "atmega2560 (serial)"
#~ msgstr ""

#~ msgid "sam3x8e (serial)"
#~ msgstr ""

#~ msgid "01d2183f"
#~ msgstr ""

#~ msgid "arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0"
#~ msgstr ""

#~ msgid "pru-gcc (GCC) 8.0.0 20170530 (experimental)"
#~ msgstr ""

#~ msgid "418K"
#~ msgstr ""

#~ msgid "628K"
#~ msgstr ""

#~ msgid "samd51 (USB)"
#~ msgstr ""

#~ msgid "rp2040 (USB)"
#~ msgstr ""

#~ msgid "Host Benchmarks"
#~ msgstr ""

#~ msgid "Basic Configuration"
#~ msgstr ""

#~ msgid ""
#~ "`speed: 120` *Default Value: 50* The speed in which the tool moves between "
#~ "points."
#~ msgstr ""

#~ msgid ""
#~ "`probe_count: 5, 3` *Default Value: 3, 3* The number of points to probe on "
#~ "each axis, specified as X, Y integer values. In this example 5 points will "
#~ "be probed along the X axis, with 3 points along the Y axis, for a total of "
#~ "15 probed points. Note that if you wanted a square grid, for example 3x3, "
#~ "this could be specified as a single integer value that is used for both "
#~ "axes, ie `probe_count: 3`. Note that a mesh requires a minimum probe_count "
#~ "of 3 along each axis."
#~ msgstr ""

#~ msgid ""
#~ "This example assumes a printer equipped with a round bed radius of 100mm. We"
#~ " will use the same probe offsets as the rectangular example, 24 mm on X and "
#~ "5 mm on Y."
#~ msgstr ""

#~ msgid ""
#~ "`round_probe_count: 5` *Default Value: 5* This is an integer value that "
#~ "defines the maximum number of probed points along the X and Y axes. By "
#~ "\"maximum\", we mean the number of points probed along the mesh origin. This"
#~ " value must be an odd number, as it is required that the center of the mesh "
#~ "is probed."
#~ msgstr ""

#~ msgid ""
#~ "Below the more advanced configuration options are explained in detail. Each "
#~ "example will build upon the basic rectangular bed configuration shown above."
#~ " Each of the advanced options apply to round beds in the same manner."
#~ msgstr ""

#~ msgid ""
#~ "`mesh_pps: 2, 3` *Default Value: 2, 2* The `mesh_pps` option is shorthand "
#~ "for Mesh Points Per Segment. This option specifies how many points to "
#~ "interpolate for each segment along the X and Y axes. Consider a 'segment' to"
#~ " be the space between each probed point. Like `probe_count`, `mesh_pps` is "
#~ "specified as an X, Y integer pair, and also may be specified a single "
#~ "integer that is applied to both axes. In this example there are 4 segments "
#~ "along the X axis and 2 segments along the Y axis. This evaluates to 8 "
#~ "interpolated points along X, 6 interpolated points along Y, which results in"
#~ " a 13x8 mesh. Note that if mesh_pps is set to 0 then mesh interpolation is "
#~ "disabled and the probed matrix will be sampled directly."
#~ msgstr ""

#~ msgid "![bedmesh_interpolated](img/bedmesh_interpolated.svg)"
#~ msgstr ""

#~ msgid ""
#~ "`move_check_distance: 5` *Default Value: 5* The minimum distance to check "
#~ "for the desired change in Z before performing a split. In this example, a "
#~ "move longer than 5mm will be traversed by the algorithm. Each 5mm a mesh Z "
#~ "lookup will occur, comparing it with the Z value of the previous move. If "
#~ "the delta meets the threshold set by `split_delta_z`, the move will be split"
#~ " and traversal will continue. This process repeats until the end of the move"
#~ " is reached, where a final adjustment will be applied. Moves shorter than "
#~ "the `move_check_distance` have the correct Z adjustment applied directly to "
#~ "the move without traversal or splitting."
#~ msgstr ""

#~ msgid ""
#~ "When \"fade\" is enabled Z adjustment is phased out over a distance defined "
#~ "by the configuration. This is accomplished by applying small adjustments to "
#~ "the layer height, either increasing or decreasing depending on the shape of "
#~ "the bed. When fade has completed, Z adjustment is no longer applied, "
#~ "allowing the top of the print to be flat rather than mirror the shape of the"
#~ " bed. Fade also may have some undesirable traits, if you fade too quickly it"
#~ " can result in visible artifacts on the print. Also, if your bed is "
#~ "significantly warped, fade can shrink or stretch the Z height of the print. "
#~ "As such, fade is disabled by default."
#~ msgstr ""

#~ msgid ""
#~ "`fade_target: 0` *Default Value: The average Z value of the mesh* The "
#~ "`fade_target` can be thought of as an additional Z offset applied to the "
#~ "entire bed after fade completes. Generally speaking we would like this value"
#~ " to be 0, however there are circumstances where it should not be. For "
#~ "example, lets assume your homing position on the bed is an outlier, its .2 "
#~ "mm lower than the average probed height of the bed. If the `fade_target` is "
#~ "0, fade will shrink the print by an average of .2 mm across the bed. By "
#~ "setting the `fade_target` to .2, the homed area will expand by .2 mm, "
#~ "however the rest of the bed will have an accurately sized. Generally its a "
#~ "good idea to leave `fade_target` out of the configuration so the average "
#~ "height of the mesh is used, however it may be desirable to manually adjust "
#~ "the fade target if one wants to print on a specific portion of the bed."
#~ msgstr ""

#~ msgid ""
#~ "`relative_reference_index: 7` *Default Value: None (disabled)* When the "
#~ "probed points are generated they are each assigned an index. You can look up"
#~ " this index in klippy.log or by using BED_MESH_OUTPUT (see the section on "
#~ "Bed Mesh GCodes below for more information). If you assign an index to the "
#~ "`relative_reference_index` option, the value probed at this coordinate will "
#~ "replace the probe's z_offset. This effectively makes this coordinate the "
#~ "\"zero\" reference for the mesh."
#~ msgstr ""

#~ msgid ""
#~ "The `faulty_region` options may be configured to compensate for this affect."
#~ " If a generated point lies within a faulty region bed mesh will attempt to "
#~ "probe up to 4 points at the boundaries of this region. These probed values "
#~ "will be averaged and inserted in the mesh as the Z value at the generated "
#~ "(X, Y) coordinate."
#~ msgstr ""

#~ msgid "![bedmesh_interpolated](img/bedmesh_faulty_regions.svg)"
#~ msgstr ""

#~ msgid "Initiates the probing procedure for Bed Mesh Calibration."
#~ msgstr ""

#~ msgid "`MESH_MIN`"
#~ msgstr ""

#~ msgid "`MESH_RADIUS`"
#~ msgstr ""

#~ msgid "`RELATIVE_REFERNCE_INDEX`"
#~ msgstr ""

#~ msgid "`BED_MESH_PROFILE SAVE=<name> LOAD=<name> REMOVE=<name>`"
#~ msgstr ""

#~ msgid "`BED_MESH_PROFILE REMOVE=default`"
#~ msgstr ""

#~ msgid ""
#~ "Outputs the current mesh state to the terminal. Note that the mesh itself is"
#~ " output"
#~ msgstr ""

#~ msgid "Clear Mesh State"
#~ msgstr ""

#~ msgid "`BED_MESH_OFFSET [X=<value>] [Y=<value>]`"
#~ msgstr ""

#~ msgid ""
#~ "In order to get good quality prints the printer should be calibrated so that"
#~ " Z distances are accurate to within about 25 microns (.025mm). This is a "
#~ "small distance - significantly smaller than the width of a typical human "
#~ "hair. This scale can not be measured \"by eye\". Subtle effects (such as "
#~ "heat expansion) impact measurements at this scale. The secret to getting "
#~ "high accuracy is to use a repeatable process and to use a leveling method "
#~ "that leverages the high accuracy of the printer's own motion system."
#~ msgstr ""

#~ msgid ""
#~ "For printers with an \"automatic Z probe\" be sure to calibrate the probe "
#~ "following the directions in the [Probe Calibrate](Probe_Calibrate.md) "
#~ "document. For delta printers, see the [Delta Calibrate](Delta_Calibrate.md) "
#~ "document. For printers with bed screws and traditional Z endstops, see the "
#~ "[Manual Level](Manual_Level.md) document."
#~ msgstr ""

#~ msgid ""
#~ "It is important to understand the \"paper test\" even if one has an "
#~ "\"automatic Z probe\". The probe itself often needs to be calibrated to get "
#~ "good results. That probe calibration is done using this \"paper test\"."
#~ msgstr ""

#~ msgid ""
#~ "If one always prints on a particular tape or printing surface then one may "
#~ "perform the paper test with that tape/surface in place. However, note that "
#~ "tape itself has a thickness and different tapes (or any other printing "
#~ "surface) will impact Z measurements. Be sure to rerun the paper test to "
#~ "measure each type of surface that is in use."
#~ msgstr ""

#~ msgid ""
#~ "It may seem odd to calibrate the distance at room temperature when the goal "
#~ "is to have a consistent distance when heated. However, if one calibrates "
#~ "when the nozzle is heated, it tends to impart small amounts of molten "
#~ "plastic on to the paper, which changes the amount of friction felt. That "
#~ "makes it harder to get a good calibration. Calibrating while the bed/nozzle "
#~ "is hot also greatly increases the risk of burning oneself. The amount of "
#~ "thermal expansion is stable, so it is easily accounted for later in the "
#~ "calibration process."
#~ msgstr ""

#~ msgid ""
#~ "Recv: // Starting manual Z probe. Use TESTZ to adjust position.\n"
#~ "Recv: // Finish with ACCEPT or ABORT command.\n"
#~ "Recv: // Z position: ?????? --> 5.000 <-- ??????\n"
#~ msgstr ""

#~ msgid ""
#~ "Use the TESTZ command to request the nozzle to move closer to the paper. For"
#~ " example:"
#~ msgstr ""

#~ msgid "Recv: // Z position: 0.130 --> 0.230 <-- 0.280\n"
#~ msgstr ""

#~ msgid ""
#~ "This will accept the given Z height and proceed with the given calibration "
#~ "tool."
#~ msgstr ""

#~ msgid ""
#~ "After successfully performing bed leveling, one may go on to calculate a "
#~ "more precise value for the combined impact of \"thermal expansion\", "
#~ "\"thickness of the paper\", and \"amount of friction felt during the paper "
#~ "test\"."
#~ msgstr ""

#~ msgid ""
#~ "If the bottom layer consistently appears narrower than subsequent layers "
#~ "then one can use the SET_GCODE_OFFSET command to make a negative Z "
#~ "adjustment. If one is unsure, then one can decrease the Z adjustment until "
#~ "the bottom layer of prints exhibit a small bulge, and then back-off until it"
#~ " disappears."
#~ msgstr ""

#~ msgid ""
#~ "Start by installing the [Debian 9.9 2019-08-03 4GB SD "
#~ "IoT](https://beagleboard.org/latest-images) image. One may run the image "
#~ "from either a micro-SD card or from builtin eMMC. If using the eMMC, install"
#~ " it to eMMC now by following the instructions from the above link."
#~ msgstr ""

#~ msgid "One may then install Octoprint:"
#~ msgstr ""

#~ msgid ""
#~ "It is necessary to modify OctoPrint's **/etc/default/octoprint** "
#~ "configuration file. One must change the `OCTOPRINT_USER` user to `debian`, "
#~ "change `NICELEVEL` to `0`, uncomment the `BASEDIR`, `CONFIGFILE`, and "
#~ "`DAEMON` settings and change the references from `/home/pi/` to "
#~ "`/home/debian/`:"
#~ msgstr ""

#~ msgid ""
#~ "Make sure the OctoPrint web server is accessible - it should be at: "
#~ "<http://beaglebone:5000/>"
#~ msgstr ""

#~ msgid ""
#~ "It is also necessary to compile and install the micro-controller code for a "
#~ "Linux host process. Configure it a second time for a \"Linux process\":"
#~ msgstr ""

#~ msgid "Then install this micro-controller code as well:"
#~ msgstr ""

#~ msgid "Printing on the Beaglebone"
#~ msgstr ""

#~ msgid ""
#~ "Hook up the BL-Touch \"servo\" connector to a `control_pin` according to the"
#~ " BL-Touch documentation or your MCU documentation. Using the original "
#~ "wiring, the yellow wire from the triple is the `control_pin` and the white "
#~ "wire from the pair is the `sensor_pin`. You need to configure these pins "
#~ "according to your wiring. Most BL-Touch devices require a pullup on the "
#~ "sensor pin (prefix the pin name with \"^\"). For example:"
#~ msgstr ""

#~ msgid ""
#~ "It's important that the z_hop movement in safe_z_home is high enough that "
#~ "the probe doesn't hit anything even if the probe pin happens to be in its "
#~ "lowest state."
#~ msgstr ""

#~ msgid ""
#~ "If the above is looking good, it's time to test that the control pin is "
#~ "working correctly. First run `BLTOUCH_DEBUG COMMAND=pin_down` in your "
#~ "printer terminal. Verify that the pin moves down and that the red LED on the"
#~ " probe turns off. If not, check your wiring and configuration again. Next "
#~ "issue a `BLTOUCH_DEBUG COMMAND=pin_up`, verify that the pin moves up, and "
#~ "that the red light turns on again. If it's flashing then there's some "
#~ "problem."
#~ msgstr ""

#~ msgid "BL-Touch gone bad"
#~ msgstr ""

#~ msgid ""
#~ "However, the BL-Touch may also not be able to calibrate itself anymore. This"
#~ " happens if the screw on its top is in the wrong position or the magnetic "
#~ "core inside the probe pin has moved. If it has moved up so that it sticks to"
#~ " the screw, it may not be able to lower its pin anymore. With this behavior "
#~ "you need to open the screw and use a ball-point pen to push it gently back "
#~ "into place. Re-Insert the pin into the BL-Touch so that it falls into the "
#~ "extracted position. Carefully readjust the headless screw into place. You "
#~ "need to find the right position so it is able to lower and raise the pin and"
#~ " the red light turns on and of. Use the `reset`, `pin_up` and `pin_down` "
#~ "commands to achieve this."
#~ msgstr ""

#~ msgid ""
#~ "Some \"clone\" devices do not support `touch_mode` and as a result the "
#~ "`QUERY_PROBE` command does not work. Despite this, it may still be possible "
#~ "to perform probing and homing with these devices. On these devices the "
#~ "`QUERY_PROBE` command during the [initial tests](#initial-tests) will not "
#~ "succeed, however the subsequent `G28` (or `PROBE`) test does succeed. It may"
#~ " be possible to use these \"clone\" devices with Klipper if one does not "
#~ "utilize the `QUERY_PROBE` command and one does not enable the "
#~ "`probe_with_touch_mode` feature."
#~ msgstr ""

#~ msgid ""
#~ "Some BL-Touch v3.0 and BL-Touch 3.1 devices may require configuring "
#~ "`probe_with_touch_mode` in the printer config file."
#~ msgstr ""

#~ msgid "Multi-probing without stowing"
#~ msgstr ""

#~ msgid ""
#~ "Note, however, that some \"clone\" devices and the BL-Touch v2.0 (and "
#~ "earlier) may have reduced accuracy when `probe_with_touch_mode` is set to "
#~ "True. On these devices it is a good idea to test the probe accuracy before "
#~ "and after setting `probe_with_touch_mode` (use the `PROBE_ACCURACY` command "
#~ "to test)."
#~ msgstr ""

#~ msgid "BL-Touch output mode"
#~ msgstr ""

#~ msgid ""
#~ "you have a BL-Touch Smart V3.0, you need the use 'set_output_mode: 5V' "
#~ "parameter to ensure this setting at each startup, since the probe cannot "
#~ "remember the needed setting."
#~ msgstr ""

#~ msgid ""
#~ "In order to use the API server, the klippy.py host software must be started "
#~ "with the `-a` parameter. For example:"
#~ msgstr ""

#~ msgid "Request format"
#~ msgstr ""

#~ msgid "~/klipper/scripts/whconsole.py /tmp/klippy_uds\n"
#~ msgstr ""

#~ msgid "A request might look like:"
#~ msgstr ""

#~ msgid ""
#~ "Each request must be a JSON dictionary. (This document uses the Python term "
#~ "\"dictionary\" to describe a \"JSON object\" - a mapping of key/value pairs "
#~ "contained within `{}`.)"
#~ msgstr ""

#~ msgid ""
#~ "If the processing of a request results in an error, then the response "
#~ "message will contain an \"error\" field instead of a \"result\" field. For "
#~ "example, the request: `{\"id\": 123, \"method\": \"gcode/script\", "
#~ "\"params\": {\"script\": \"G1 X200\"}}` might result in an error response "
#~ "such as: `{\"id\": 123, \"error\": {\"message\": \"Must home axis first: "
#~ "200.000 0.000 0.000 [0.000]\", \"error\": \"WebRequestError\"}}`"
#~ msgstr ""

#~ msgid "For example:"
#~ msgstr ""

#~ msgid "and cause Klipper to send future messages similar to:"
#~ msgstr ""

#~ msgid ""
#~ "By convention, Klipper \"endpoints\" are of the form "
#~ "`<module_name>/<some_name>`. When making a request to an \"endpoint\", the "
#~ "full name must be set in the \"method\" parameter of the request dictionary "
#~ "(eg, `{\"method\"=\"gcode/restart\"}`)."
#~ msgstr ""

#~ msgid "emergency_stop"
#~ msgstr ""

#~ msgid ""
#~ "For example: `{\"id\": 123, \"method\": \"register_remote_method\", "
#~ "\"params\": {\"response_template\": {\"action\": \"run_paneldue_beep\"}, "
#~ "\"remote_method\": \"paneldue_beep\"}}` will return: `{\"id\": 123, "
#~ "\"result\": {}}`"
#~ msgstr ""

#~ msgid "objects/list"
#~ msgstr ""

#~ msgid ""
#~ "The \"objects\" parameter in the request must be a dictionary containing the"
#~ " printer objects that are to be queried - the key contains the printer "
#~ "object name and the value is either \"null\" (to query all fields) or a list"
#~ " of field names."
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows one to query and then subscribe to information from "
#~ "printer objects. The endpoint request and response is identical to the "
#~ "\"objects/query\" endpoint. For example: `{\"id\": 123, \"method\": "
#~ "\"objects/subscribe\", \"params\": {\"objects\":{\"toolhead\": "
#~ "[\"position\"], \"webhooks\": [\"state\"]}, \"response_template\":{}}}` "
#~ "might return: `{\"id\": 123, \"result\": {\"status\": {\"webhooks\": "
#~ "{\"state\": \"ready\"}, \"toolhead\": {\"position\": [0.0, 0.0, 0.0, 0.0]}},"
#~ " \"eventtime\": 3052153.382083195}}` and result in subsequent asynchronous "
#~ "messages such as: `{\"params\": {\"status\": {\"webhooks\": {\"state\": "
#~ "\"shutdown\"}}, \"eventtime\": 3052165.418815847}}`"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows one to run a series of G-Code commands. For example: "
#~ "`{\"id\": 123, \"method\": \"gcode/script\", \"params\": {\"script\": "
#~ "\"G90\"}}`"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows one to request a restart - it is similar to running the"
#~ " G-Code \"RESTART\" command. For example: `{\"id\": 123, \"method\": "
#~ "\"gcode/restart\"}`"
#~ msgstr ""

#~ msgid "gcode/subscribe_output"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint is used to subscribe to Klipper's internal stepper queue_step "
#~ "command stream for a stepper. Obtaining these low-level motion updates may "
#~ "be useful for diagnostic and debugging purposes. Using this endpoint may "
#~ "increase Klipper's system load."
#~ msgstr ""

#~ msgid ""
#~ "This endpoint is used to subscribe to Klipper's internal \"trapezoid motion "
#~ "queue\". Obtaining these low-level motion updates may be useful for "
#~ "diagnostic and debugging purposes. Using this endpoint may increase "
#~ "Klipper's system load."
#~ msgstr ""

#~ msgid ""
#~ "A request may look like: `{\"id\": 123, \"method\":\"adxl345/dump_adxl345\","
#~ " \"params\": {\"sensor\": \"adxl345\", \"response_template\": {}}}` and "
#~ "might return: `{\"id\": "
#~ "123,\"result\":{\"header\":[\"time\",\"x_acceleration\",\"y_acceleration\", "
#~ "\"z_acceleration\"]}}` and might later produce asynchronous messages such "
#~ "as: "
#~ "`{\"params\":{\"overflows\":0,\"data\":[[3292.432935,-535.44309,-1529.8374,9561.4],"
#~ " [3292.433256,-382.45935,-1606.32927,9561.48375]]}}`"
#~ msgstr ""

#~ msgid "pause_resume/cancel"
#~ msgstr ""

#~ msgid "pause_resume/resume"
#~ msgstr ""

#~ msgid "toc title: Welcome"
#~ msgstr ""

#~ msgid ""
#~ "Klipper is a 3d-Printer firmware. It combines the power of a general purpose"
#~ " computer with one or more micro-controllers. See the "
#~ "[features](Features.md) document for more information on why you should use "
#~ "Klipper."
#~ msgstr ""

#~ msgid ""
#~ "Klipper is Free Software. Read the [documentation](Overview.md) or view [the"
#~ " Klipper code on github](https://github.com/Klipper3d/klipper). We depend on"
#~ " the generous support from our [sponsors](Sponsors.md)."
#~ msgstr ""

#~ msgid ""
#~ "This document describes how to setup a PWM-controlled laser or spindle using"
#~ " `output_pin` and some macros."
#~ msgstr ""

#~ msgid ""
#~ "**Warning:** When driving a laser, keep all security precautions that you "
#~ "can think of! Diode lasers are usually inverted. This means, that when the "
#~ "MCU restarts, the laser will be *fully on* for the time it takes the MCU to "
#~ "start up again. For good measure, it is recommended to *always* wear "
#~ "appropriate laser-goggles of the right wavelength if the laser is powered; "
#~ "and to disconnect the laser when it is not needed. Also, you should "
#~ "configure a safety timeout, so that when your host or MCU encounters an "
#~ "error, the tool will stop."
#~ msgstr ""

#~ msgid "Current Limitations"
#~ msgstr ""

#~ msgid "Commands"
#~ msgstr ""

#~ msgid "Laserweb Configuration"
#~ msgstr ""

#~ msgid ""
#~ "GCODE START:\n"
#~ "    M5            ; Disable Laser\n"
#~ "    G21           ; Set units to mm\n"
#~ "    G90           ; Absolute positioning\n"
#~ "    G0 Z0 F7000   ; Set Non-Cutting speed\n"
#~ "\n"
#~ "GCODE END:\n"
#~ "    M5            ; Disable Laser\n"
#~ "    G91           ; relative\n"
#~ "    G0 Z+20 F4000 ;\n"
#~ "    G90           ; absolute\n"
#~ "\n"
#~ "GCODE HOMING:\n"
#~ "    M5            ; Disable Laser\n"
#~ "    G28           ; Home all axis\n"
#~ "\n"
#~ "TOOL ON:\n"
#~ "    M3 $INTENSITY\n"
#~ "\n"
#~ "TOOL OFF:\n"
#~ "    M5            ; Disable Laser\n"
#~ "\n"
#~ "LASER INTENSITY:\n"
#~ "    S\n"
#~ msgstr ""

#~ msgid ""
#~ "This document describes Filament Width Sensor host module. Hardware used for"
#~ " developing this host module is based on TSL1401CL linear sensor array but "
#~ "it can work with any sensor array that has analog output. You can find "
#~ "designs at "
#~ "[Thingiverse](https://www.thingiverse.com/search?q=filament%20width%20sensor)."
#~ msgstr ""

#~ msgid ""
#~ "Sensor generates analog output based on calculated filament width. Output "
#~ "voltage always equals to detected filament width (Ex. 1.65v, 1.70v, 3.0v). "
#~ "Host module monitors voltage changes and adjusts extrusion multiplier."
#~ msgstr ""

#~ msgid ""
#~ "Sensor readings done with 10 mm intervals by default. If necessary you are "
#~ "free to change this setting by editing ***MEASUREMENT_INTERVAL_MM*** "
#~ "parameter in **filament_width_sensor.py** file."
#~ msgstr ""

#~ msgid ""
#~ "This document provides information on using Trinamic stepper motor drivers "
#~ "in SPI/UART mode on Klipper."
#~ msgstr ""

#~ msgid ""
#~ "In addition to this document, be sure to review the [TMC driver config "
#~ "reference](Config_Reference.md#tmc-stepper-driver-configuration)."
#~ msgstr ""

#~ msgid ""
#~ "A higher driver current increases positional accuracy and torque. However, a"
#~ " higher current also increases the heat produced by the stepper motor and "
#~ "the stepper motor driver. If the stepper motor driver gets too hot it will "
#~ "disable itself and Klipper will report an error. If the stepper motor gets "
#~ "too hot, it loses torque and positional accuracy. (If it gets very hot it "
#~ "may also melt plastic parts attached to it or near it.)"
#~ msgstr ""

#~ msgid "Prefer to not specify a hold_current"
#~ msgstr ""

#~ msgid ""
#~ "Most stepper motors will not obtain a significant benefit to reducing "
#~ "current during normal prints, because few printing moves will leave a "
#~ "stepper motor idle for sufficiently long to activate the `hold_current` "
#~ "feature. And, it is unlikely that one would want to introduce subtle print "
#~ "artifacts to the few printing moves that do leave a stepper idle "
#~ "sufficiently long."
#~ msgstr ""

#~ msgid ""
#~ "Some printers with dedicated Z motors that are idle during normal printing "
#~ "moves (no bed_mesh, no bed_tilt, no Z skew_correction, no \"vase mode\" "
#~ "prints, etc.) may find that Z motors do run cooler with a `hold_current`. If"
#~ " implementing this then be sure to take into account this type of "
#~ "uncommanded Z axis movement during bed leveling, bed probing, probe "
#~ "calibration, and similar. The `driver_TPOWERDOWN` and `driver_IHOLDDELAY` "
#~ "should also be calibrated accordingly. If unsure, prefer to not specify a "
#~ "`hold_current`."
#~ msgstr ""

#~ msgid ""
#~ "By default, Klipper places the TMC drivers in \"spreadCycle\" mode. If the "
#~ "driver supports \"stealthChop\" then it can be enabled by adding "
#~ "`stealthchop_threshold: 999999` to the TMC config section."
#~ msgstr ""

#~ msgid ""
#~ "Tests comparing modes have shown an increased \"positional lag\" of around "
#~ "75% of a full-step during constant velocity moves when using stealthChop "
#~ "mode (for example, on a printer with 40mm rotation_distance and 200 "
#~ "steps_per_rotation, position deviation of constant speed moves increased by "
#~ "~0.150mm). However, this \"delay in obtaining the requested position\" may "
#~ "not manifest as a significant print defect and one may prefer the quieter "
#~ "behavior of stealthChop mode."
#~ msgstr ""

#~ msgid "TMC interpolate setting introduces small position deviation"
#~ msgstr ""

#~ msgid ""
#~ "For best positional accuracy consider using spreadCycle mode and disable "
#~ "interpolation (set `interpolate: False` in the TMC driver config). When "
#~ "configured this way, one may increase the `microstep` setting to reduce "
#~ "audible noise during stepper movement. Typically, a microstep setting of "
#~ "`64` or `128` will have similar audible noise as interpolation, and do so "
#~ "without introducing a systemic positional error."
#~ msgstr ""

#~ msgid "Sensorless Homing"
#~ msgstr ""

#~ msgid ""
#~ "This guide covers the setup of sensorless homing for the X axis of your "
#~ "(cartesian) printer. However, it works the same with all other axes (that "
#~ "require an end stop). You should configure and tune it for one axis at a "
#~ "time."
#~ msgstr ""

#~ msgid ""
#~ "Be sure that your mechanical components are able to handle the load of the "
#~ "carriage bumping into the limit of the axis repeatedly. Especially "
#~ "leadscrews might generate a lot of force. Homing a Z axis by bumping the "
#~ "nozzle into the printing surface might not be a good idea. For best results,"
#~ " verify that the axis carriage will make a firm contact with the axis limit."
#~ msgstr ""

#~ msgid ""
#~ "Further, the stall detection of the stepper driver is dependent on the "
#~ "mechanical load on the motor, the motor current and the motor temperature "
#~ "(coil resistance)."
#~ msgstr ""

#~ msgid "Prerequisites"
#~ msgstr ""

#~ msgid ""
#~ "A stallGuard capable TMC stepper driver (tmc2130, tmc2209, tmc2660, or "
#~ "tmc5160)."
#~ msgstr ""

#~ msgid ""
#~ "The appropriate \"DIAG\" or \"SG_TST\" pin of TMC driver connected to the "
#~ "micro-controller."
#~ msgstr ""

#~ msgid "The procedure described here has six major steps:"
#~ msgstr ""

#~ msgid "Configure the `printer.cfg` file to enable sensorless homing."
#~ msgstr ""

#~ msgid ""
#~ "Find the stallguard setting with lowest sensitivity that successfully homes "
#~ "with a single touch."
#~ msgstr ""

#~ msgid "Create or update `printer.cfg` macros to home consistently."
#~ msgstr ""

#~ msgid ""
#~ "The homing speed is an important choice when performing sensorless homing. "
#~ "It's desirable to use a slow homing speed so that the carriage does not "
#~ "exert excessive force on the frame when making contact with the end of the "
#~ "rail. However, the TMC drivers can't reliably detect a stall at very slow "
#~ "speeds."
#~ msgstr ""

#~ msgid ""
#~ "[stepper_x]\n"
#~ "rotation_distance: 40\n"
#~ "homing_speed: 20\n"
#~ "...\n"
#~ msgstr ""

#~ msgid ""
#~ "The `homing_retract_dist` setting must be set to zero in the `stepper_x` "
#~ "config section to disable the second homing move. The second homing attempt "
#~ "does not add value when using sensorless homing, it will not work reliably, "
#~ "and it will confuse the tuning process."
#~ msgstr ""

#~ msgid ""
#~ "It is necessary to configure the sensorless homing pins and to configure "
#~ "initial \"stallguard\" settings. A tmc2209 example configuration for an X "
#~ "axis might look like:"
#~ msgstr ""

#~ msgid "An example tmc2130 or tmc5160 config might look like:"
#~ msgstr ""

#~ msgid "An example tmc2660 config might look like:"
#~ msgstr ""

#~ msgid ""
#~ "The examples above only show settings specific to sensorless homing. See the"
#~ " [config reference](Config_Reference.md#tmc-stepper-driver-configuration) "
#~ "for all the available options."
#~ msgstr ""

#~ msgid ""
#~ "Place the carriage near the center of the rail. Use the SET_TMC_FIELD "
#~ "command to set the highest sensitivity. For tmc2209:"
#~ msgstr ""

#~ msgid "For tmc2130, tmc5160, and tmc2660:"
#~ msgstr ""

#~ msgid ""
#~ "Then issue a `G28 X0` command and verify the axis does not move at all or "
#~ "quickly stops moving. If the axis does not stop, then issue an `M112` to "
#~ "halt the printer - something is not correct with the diag/sg_tst pin wiring "
#~ "or configuration and it must be corrected before continuing."
#~ msgstr ""

#~ msgid ""
#~ "When searching for maximum_sensitivity, it may be convenient to jump to "
#~ "different VALUE settings (so as to bisect the VALUE parameter). If doing "
#~ "this then be prepared to issue an `M112` command to halt the printer, as a "
#~ "setting with a very low sensitivity may cause the axis to repeatedly "
#~ "\"bang\" into the end of the rail."
#~ msgstr ""

#~ msgid ""
#~ "During these tuning tests, if a `G28 X0` command does not move all the way "
#~ "to the axis limit, then be careful with issuing any regular movement "
#~ "commands (eg, `G1`). Klipper will not have a correct understanding of the "
#~ "carriage position and a move command may cause undesirable and confusing "
#~ "results."
#~ msgstr ""

#~ msgid ""
#~ "When homing with the found *maximum_sensitivity* value, the axis should move"
#~ " to the end of the rail and stop with a \"single touch\" - that is, there "
#~ "should not be a \"clicking\" or \"banging\" sound. (If there is a banging or"
#~ " clicking sound at maximum_sensitivity then the homing_speed may be too low,"
#~ " the driver current may be too low, or sensorless homing may not be a good "
#~ "choice for the axis.)"
#~ msgstr ""

#~ msgid "Update printer.cfg with sensitivity value"
#~ msgstr ""

#~ msgid ""
#~ "For tmc2209 set this in the config as `driver_SGTHRS`, for other TMC drivers"
#~ " set this in the config as `driver_SGT`."
#~ msgstr ""

#~ msgid ""
#~ "Note that if any change is made to driver current, homing speed, or a "
#~ "notable change is made to the printer hardware, then it will be necessary to"
#~ " run the tuning process again."
#~ msgstr ""

#~ msgid ""
#~ "After sensorless homing completes the carriage will be pressed against the "
#~ "end of the rail and the stepper will exert a force on the frame until the "
#~ "carriage is moved away. It is a good idea to create a macro to home the axis"
#~ " and immediately move the carriage away from the end of the rail."
#~ msgstr ""

#~ msgid ""
#~ "It can also be useful to have that macro set the driver current before "
#~ "homing and set a new current after the carriage has moved away."
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro SENSORLESS_HOME_X]\n"
#~ "gcode:\n"
#~ "    {% set HOME_CUR = 0.700 %}\n"
#~ "    {% set driver_config = printer.configfile.settings['tmc2209 stepper_x'] %}\n"
#~ "    {% set RUN_CUR = driver_config.run_current %}\n"
#~ "    # Set current for sensorless homing\n"
#~ "    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={HOME_CUR}\n"
#~ "    # Pause to ensure driver stall flag is clear\n"
#~ "    G4 P2000\n"
#~ "    # Home\n"
#~ "    G28 X0\n"
#~ "    # Move away\n"
#~ "    G90\n"
#~ "    G1 X5 F1200\n"
#~ "    # Set current during print\n"
#~ "    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={RUN_CUR}\n"
#~ msgstr ""

#~ msgid ""
#~ "Note that if the driver current during homing is changed, then the tuning "
#~ "process should be run again."
#~ msgstr ""

#~ msgid ""
#~ "It is possible to use sensorless homing on the X and Y carriages of a CoreXY"
#~ " printer. Klipper uses the `[stepper_x]` stepper to detect stalls when "
#~ "homing the X carriage and uses the `[stepper_y]` stepper to detect stalls "
#~ "when homing the Y carriage."
#~ msgstr ""

#~ msgid ""
#~ "When using sensorless homing on CoreXY, make sure there is no `hold_current`"
#~ " configured for either stepper."
#~ msgstr ""

#~ msgid ""
#~ "After tuning is complete, when homing both X and Y, use macros to ensure "
#~ "that one axis is homed first, then move that carriage away from the axis "
#~ "limit, pause for at least 2 seconds, and then start the homing of the other "
#~ "carriage. The move away from the axis avoids homing one axis while the other"
#~ " is pressed against the axis limit (which may skew the stall detection). The"
#~ " pause is necessary to ensure the driver's stall flag is cleared prior to "
#~ "homing again."
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro HOME]\n"
#~ "gcode:\n"
#~ "    G90\n"
#~ "    # Home Z\n"
#~ "    G28 Z0\n"
#~ "    G1 Z10 F1200\n"
#~ "    # Home Y\n"
#~ "    G28 Y0\n"
#~ "    G1 Y5 F1200\n"
#~ "    # Home X\n"
#~ "    G4 P2000\n"
#~ "    G28 X0\n"
#~ "    G1 X5 F1200\n"
#~ msgstr ""

#~ msgid ""
#~ "The `[DUMP_TMC command](G-Codes.md#dump_tmc) is a useful tool when "
#~ "configuring and diagnosing the drivers. It will report all fields configured"
#~ " by Klipper as well as all fields that can be queried from the driver."
#~ msgstr ""

#~ msgid "Configuring driver_XXX settings"
#~ msgstr ""

#~ msgid ""
#~ "In addition, almost all fields can be modified at run-time using the "
#~ "[SET_TMC_FIELD command](G-Codes.md#set_tmc_field)."
#~ msgstr ""

#~ msgid ""
#~ "Note that the Trinamic datasheets sometime use wording that can confuse a "
#~ "high-level setting (such as \"hysteresis end\") with a low-level field value"
#~ " (eg, \"HEND\"). In Klipper, `driver_XXX` and SET_TMC_FIELD always set the "
#~ "low-level field value that is actually written to the driver. So, for "
#~ "example, if the Trinamic datasheet states that a value of 3 must be written "
#~ "to the HEND field to obtain a \"hysteresis end\" of 0, then set "
#~ "`driver_HEND=3` to obtain the high-level value of 0."
#~ msgstr ""

#~ msgid "Can I use stealthChop mode on an extruder with pressure advance?"
#~ msgstr ""

#~ msgid ""
#~ "However, \"stealthChop\" mode may produce lower motor torque and/or produce "
#~ "higher motor heat. It may or may not be an adequate mode for your particular"
#~ " printer."
#~ msgstr ""

#~ msgid ""
#~ "This occurs when Klipper is unable to communicate with a tmc2208 or tmc2209 "
#~ "driver."
#~ msgstr ""

#~ msgid ""
#~ "If this error occurs after flashing Klipper for the first time, then the "
#~ "stepper driver may have been previously programmed in a state that is not "
#~ "compatible with Klipper. To reset the state, remove all power from the "
#~ "printer for several seconds (physically unplug both USB and power plugs)."
#~ msgstr ""

#~ msgid ""
#~ "I keep getting \"Unable to write tmc spi 'stepper_x' register ...\" errors?"
#~ msgstr ""

#~ msgid ""
#~ "Otherwise, this error is typically the result of incorrect SPI wiring, an "
#~ "incorrect Klipper configuration of the SPI settings, or an incomplete "
#~ "configuration of devices on an SPI bus."
#~ msgstr ""

#~ msgid "Why did I get a \"TMC reports error: ...\" error?"
#~ msgstr ""

#~ msgid ""
#~ "It's also possible that a **TMC reports error** shutdown occurs due to SPI "
#~ "errors that prevent communication with the driver (on tmc2130, tmc5160, or "
#~ "tmc2660). If this occurs, it's common for the reported driver status to show"
#~ " `00000000` or `ffffffff` - for example: `TMC reports error: DRV_STATUS: "
#~ "ffffffff ...` OR `TMC reports error: READRSP@RDSEL2: 00000000 ...`. Such a "
#~ "failure may be due to an SPI wiring problem or may be due to a self-reset or"
#~ " failure of the TMC driver."
#~ msgstr ""

#~ msgid "TMC reports error: `... ot=1(OvertempError!)`"
#~ msgstr ""

#~ msgid "TMC reports error: `... ShortToGND` OR `LowSideShort`"
#~ msgstr ""

#~ msgid ""
#~ "This error may also occur if using stealthChop mode and the TMC driver is "
#~ "not able to accurately predict the mechanical load of the motor. (If the "
#~ "driver makes a poor prediction then it may send too much current through the"
#~ " motor and trigger its own over-current detection.) To test this, disable "
#~ "stealthChop mode and check if the errors continue to occur."
#~ msgstr ""

#~ msgid ""
#~ "This indicates that the driver has reset itself mid-print. This may be due "
#~ "to voltage or wiring issues."
#~ msgstr ""

#~ msgid ""
#~ "This indicates the driver has detected a low-voltage event and has disabled "
#~ "itself. This may be due to wiring or power supply issues."
#~ msgstr ""

#~ msgid ""
#~ "The [Trinamic website](https://www.trinamic.com/) has guides on configuring "
#~ "the drivers. These guides are often technical, low-level, and may require "
#~ "specialized hardware. Regardless, they are the best source of information."
#~ msgstr ""

#~ msgid ""
#~ "This document is a reference of printer status information available in "
#~ "Klipper [macros](Command_Templates.md), [display "
#~ "fields](Config_Reference.md#display), and via the [API "
#~ "Server](API_Server.md)."
#~ msgstr ""

#~ msgid "angle"
#~ msgstr ""

#~ msgid ""
#~ "`temperature`: The last temperature reading (in Celsius) from a tle5012b "
#~ "magnetic hall sensor. This value is only available if the angle sensor is a "
#~ "tle5012b chip and if measurements are in progress (otherwise it reports "
#~ "`None`)."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[bed_mesh](Config_Reference.md#bed_mesh) object:"
#~ msgstr ""

#~ msgid ""
#~ "`profiles`: The set of currently defined profiles as setup using "
#~ "BED_MESH_PROFILE."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "`Config_Reference.md#bed_screws` object:"
#~ msgstr ""

#~ msgid ""
#~ "`state`: The bed screws adjustment tool state. It is one of the following "
#~ "strings: \"adjust\", \"fine\"."
#~ msgstr ""

#~ msgid "`accepted_screws`: The number of accepted screws."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `configfile` object (this "
#~ "object is always available):"
#~ msgstr ""

#~ msgid ""
#~ "`config.<section>.<option>`: Returns the given raw config file setting as "
#~ "read by Klipper during the last software start or restart. (Any settings "
#~ "changed at run-time will not be reflected here.) All values are returned as "
#~ "strings."
#~ msgstr ""

#~ msgid ""
#~ "`save_config_pending_items`: Contains the sections and options that were "
#~ "changed and would be persisted by a `SAVE_CONFIG`."
#~ msgstr ""

#~ msgid "display_status"
#~ msgstr ""

#~ msgid ""
#~ "`progress`: The progress value of the last `M73` G-Code command (or "
#~ "`virtual_sdcard.progress` if no recent `M73` received)."
#~ msgstr ""

#~ msgid "endstop_phase"
#~ msgstr ""

#~ msgid ""
#~ "`last_home.<stepper name>.phase`: The phase of the stepper motor at the end "
#~ "of the last home attempt."
#~ msgstr ""

#~ msgid ""
#~ "`last_home.<stepper name>.mcu_position`: The position (as tracked by the "
#~ "micro-controller) of the stepper motor at the end of the last home attempt. "
#~ "The position is the total number of steps taken in a forward direction minus"
#~ " the total number of steps taken in the reverse direction since the micro-"
#~ "controller was last restarted."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[exclude_object](Exclude_Object.md) object:"
#~ msgstr ""

#~ msgid "Here is a JSON sample:"
#~ msgstr ""

#~ msgid ""
#~ "`excluded_objects`: An array of strings listing the names of excluded "
#~ "objects."
#~ msgstr ""

#~ msgid "extruder_stepper"
#~ msgstr ""

#~ msgid ""
#~ "`pressure_advance`: The current [pressure advance](Pressure_Advance.md) "
#~ "value."
#~ msgstr ""

#~ msgid "fan"
#~ msgstr ""

#~ msgid "`speed`: The fan speed as a float between 0.0 and 1.0."
#~ msgstr ""

#~ msgid "filament_switch_sensor"
#~ msgstr ""

#~ msgid "`enabled`: Returns True if the switch sensor is currently enabled."
#~ msgstr ""

#~ msgid "filament_motion_sensor"
#~ msgstr ""

#~ msgid "`enabled`: Returns True if the motion sensor is currently enabled."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[firmware_retraction](Config_Reference.md#firmware_retraction) object:"
#~ msgstr ""

#~ msgid "gcode_macro"
#~ msgstr ""

#~ msgid ""
#~ "`<variable>`: The current value of a [gcode_macro "
#~ "variable](Command_Templates.md#variables)."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `gcode_move` object (this "
#~ "object is always available):"
#~ msgstr ""

#~ msgid ""
#~ "`position`: The last commanded position of the toolhead using the coordinate"
#~ " system specified in the config file. It is possible to access the x, y, z, "
#~ "and e components of this position (eg, `position.x`)."
#~ msgstr ""

#~ msgid "`speed`: The last speed set in a `G1` command (in mm/s)."
#~ msgstr ""

#~ msgid ""
#~ "`extrude_factor`: The \"extrude factor override\" as set by an `M221` "
#~ "command. This is a floating point value such that 1.0 means no override and,"
#~ " for example, 2.0 would double requested extrusions."
#~ msgstr ""

#~ msgid ""
#~ "`absolute_extrude`: This returns True if in `M82` absolute extrude mode or "
#~ "False if in `M83` relative mode."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[hall_filament_width_sensor](Config_Reference.md#hall_filament_width_sensor)"
#~ " object:"
#~ msgstr ""

#~ msgid "`Diameter`: The last reading from the sensor in mm."
#~ msgstr ""

#~ msgid "heater"
#~ msgstr ""

#~ msgid ""
#~ "`temperature`: The last reported temperature (in Celsius as a float) for the"
#~ " given heater."
#~ msgstr ""

#~ msgid ""
#~ "`power`: The last setting of the PWM pin (a value between 0.0 and 1.0) "
#~ "associated with the heater."
#~ msgstr ""

#~ msgid "heaters"
#~ msgstr ""

#~ msgid ""
#~ "`available_heaters`: Returns a list of all currently available heaters by "
#~ "their full config section names, e.g. `[\"extruder\", \"heater_bed\", "
#~ "\"heater_generic my_custom_heater\"]`."
#~ msgstr ""

#~ msgid "idle_timeout"
#~ msgstr ""

#~ msgid ""
#~ "`state`: The current state of the printer as tracked by the idle_timeout "
#~ "module. It is one of the following strings: \"Idle\", \"Printing\", "
#~ "\"Ready\"."
#~ msgstr ""

#~ msgid "led"
#~ msgstr ""

#~ msgid ""
#~ "`color_data`: A list of color lists containing the RGBW values for a led in "
#~ "the chain. Each value is represented as a float from 0.0 to 1.0. Each color "
#~ "list contains 4 items (red, green, blue, white) even if the underyling LED "
#~ "supports fewer color channels. For example, the blue value (3rd item in "
#~ "color list) of the second neopixel in a chain could be accessed at "
#~ "`printer[\"neopixel <config_name>\"].color_data[1][2]`."
#~ msgstr ""

#~ msgid "The following information is available in the `manual_probe` object:"
#~ msgstr ""

#~ msgid ""
#~ "`z_position`: The current height of the nozzle (as the printer currently "
#~ "understands it)."
#~ msgstr ""

#~ msgid ""
#~ "`z_position_upper`: Last probe attempt just greater than the current height."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in [mcu](Config_Reference.md#mcu) and"
#~ " [mcu some_name](Config_Reference.md#mcu-my_extra_mcu) objects:"
#~ msgstr ""

#~ msgid ""
#~ "`mcu_build_versions`: Information on the build tools used to generate the "
#~ "micro-controller code (as reported by the micro-controller)."
#~ msgstr ""

#~ msgid ""
#~ "`last_stats.<statistics_name>`: Statistics information on the micro-"
#~ "controller connection."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `motion_report` object (this "
#~ "object is automatically available if any stepper config section is defined):"
#~ msgstr ""

#~ msgid ""
#~ "`live_velocity`: The requested toolhead velocity (in mm/s) at the current "
#~ "time."
#~ msgstr ""

#~ msgid "output_pin"
#~ msgstr ""

#~ msgid "`value`: The \"value\" of the pin, as set by a `SET_PIN` command."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[palette2](Config_Reference.md#palette2) object:"
#~ msgstr ""

#~ msgid ""
#~ "`remaining_load_length`: When starting a Palette 2 print, this will be the "
#~ "amount of filament to load into the extruder."
#~ msgstr ""

#~ msgid "pause_resume"
#~ msgstr ""

#~ msgid ""
#~ "`is_paused`: Returns true if a PAUSE command has been executed without a "
#~ "corresponding RESUME."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `print_stats` object (this "
#~ "object is automatically available if a "
#~ "[virtual_sdcard](Config_Reference.md#virtual_sdcard) config section is "
#~ "defined):"
#~ msgstr ""

#~ msgid ""
#~ "`info.total_layer`: The total layer value of the last `SET_PRINT_STATS_INFO "
#~ "TOTAL_LAYER=<value>` G-Code command."
#~ msgstr ""

#~ msgid "probe"
#~ msgstr ""

#~ msgid ""
#~ "`last_query`: Returns True if the probe was reported as \"triggered\" during"
#~ " the last QUERY_PROBE command. Note, if this is used in a macro, due to the "
#~ "order of template expansion, the QUERY_PROBE command must be run prior to "
#~ "the macro containing this reference."
#~ msgstr ""

#~ msgid "quad_gantry_level"
#~ msgstr ""

#~ msgid ""
#~ "`applied`: True if the gantry leveling process has been run and completed "
#~ "successfully."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `query_endstops` object (this "
#~ "object is available if any endstop is defined):"
#~ msgstr ""

#~ msgid "screws_tilt_adjust"
#~ msgstr ""

#~ msgid ""
#~ "`error`: Returns True if the most recent `SCREWS_TILT_CALCULATE` command "
#~ "included the `MAX_DEVIATION` parameter and any of the probed screw points "
#~ "exceeded the specified `MAX_DEVIATION`."
#~ msgstr ""

#~ msgid "`name`: The name of the screw as specified in the config file."
#~ msgstr ""

#~ msgid "`y`: The Y coordinate of the screw as specified in the config file."
#~ msgstr ""

#~ msgid ""
#~ "`sign`: A string specifying the direction to turn to screw for the necessary"
#~ " adjustment. Either \"CW\" for clockwise or \"CCW\" for counterclockwise. "
#~ "The base screw will not have a `sign` key."
#~ msgstr ""

#~ msgid "servo"
#~ msgstr ""

#~ msgid ""
#~ "`printer[\"servo <config_name>\"].value`: The last setting of the PWM pin (a"
#~ " value between 0.0 and 1.0) associated with the servo."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the `system_stats` object (this "
#~ "object is always available):"
#~ msgstr ""

#~ msgid "temperature sensors"
#~ msgstr ""

#~ msgid ""
#~ "[bme280 "
#~ "config_section_name](Config_Reference.md#bmp280bme280bme680-temperature-"
#~ "sensor), [htu21d config_section_name](Config_Reference.md#htu21d-sensor), "
#~ "[lm75 config_section_name](Config_Reference.md#lm75-temperature-sensor), and"
#~ " [temperature_host config_section_name](Config_Reference.md#host-"
#~ "temperature-sensor) objects:"
#~ msgstr ""

#~ msgid ""
#~ "`humidity`, `pressure`, `gas`: The last read values from the sensor (only on"
#~ " bme280, htu21d, and lm75 sensors)."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in [temperature_fan "
#~ "some_name](Config_Reference.md#temperature_fan) objects:"
#~ msgstr ""

#~ msgid "temperature_sensor"
#~ msgstr ""

#~ msgid ""
#~ "`measured_min_temp`, `measured_max_temp`: The lowest and highest temperature"
#~ " seen by the sensor since the Klipper host software was last restarted."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in [TMC stepper "
#~ "driver](Config_Reference.md#tmc-stepper-driver-configuration) objects (eg, "
#~ "`[tmc2208 stepper_x]`):"
#~ msgstr ""

#~ msgid ""
#~ "`phase_offset_position`: The \"commanded position\" corresponding to the "
#~ "driver's \"zero\" phase. This field may be null if the phase offset is not "
#~ "known."
#~ msgstr ""

#~ msgid "`run_current`: The currently set run current."
#~ msgstr ""

#~ msgid "toolhead"
#~ msgstr ""

#~ msgid ""
#~ "`position`: The last commanded position of the toolhead relative to the "
#~ "coordinate system specified in the config file. It is possible to access the"
#~ " x, y, z, and e components of this position (eg, `position.x`)."
#~ msgstr ""

#~ msgid ""
#~ "`homed_axes`: The current cartesian axes considered to be in a \"homed\" "
#~ "state. This is a string containing one or more of \"x\", \"y\", \"z\"."
#~ msgstr ""

#~ msgid ""
#~ "For Delta printers the `cone_start_z` is the max z height at maximum radius "
#~ "(`printer.toolhead.cone_start_z`)."
#~ msgstr ""

#~ msgid ""
#~ "`stalls`: The total number of times (since the last restart) that the "
#~ "printer had to be paused because the toolhead moved faster than moves could "
#~ "be read from the G-Code input."
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in "
#~ "[dual_carriage](Config_Reference.md#dual_carriage) on a hybrid_corexy or "
#~ "hybrid_corexz robot"
#~ msgstr ""

#~ msgid ""
#~ "`active_carriage`: The current active carriage. Possible values are: "
#~ "\"CARRIAGE_0\", \"CARRIAGE_1\""
#~ msgstr ""

#~ msgid ""
#~ "The following information is available in the "
#~ "[virtual_sdcard](Config_Reference.md#virtual_sdcard) object:"
#~ msgstr ""

#~ msgid ""
#~ "`progress`: An estimate of the current print progress (based of file size "
#~ "and file position)."
#~ msgstr ""

#~ msgid "`file_position`: The current position (in bytes) of an active print."
#~ msgstr ""

#~ msgid "webhooks"
#~ msgstr ""

#~ msgid ""
#~ "`state`: Returns a string indicating the current Klipper state. Possible "
#~ "values are: \"ready\", \"startup\", \"shutdown\", \"error\"."
#~ msgstr ""

#~ msgid "z_thermal_adjust"
#~ msgstr ""

#~ msgid "`enabled`: Returns True if adjustment is enabled."
#~ msgstr ""

#~ msgid "`measured_min_temp`: Minimum measured temperature. [degC]"
#~ msgstr ""

#~ msgid "`current_z_adjust`: Last computed Z adjustment [mm]."
#~ msgstr ""

#~ msgid "z_tilt"
#~ msgstr ""

#~ msgid ""
#~ "`applied`: True if the z-tilt leveling process has been run and completed "
#~ "successfully."
#~ msgstr ""

#~ msgid ""
#~ "Klipper is Free Software. We depend on the generous support from sponsors. "
#~ "Please consider sponsoring Klipper or supporting our sponsors."
#~ msgstr ""

#~ msgid ""
#~ "[<img src=\"./img/sponsors/BTT_BTT.png\" width=\"200\" />](https://bigtree-"
#~ "tech.com/collections/all-products)"
#~ msgstr ""

#~ msgid "Klipper Developers"
#~ msgstr ""

#~ msgid ""
#~ "Eric is the author of bed_mesh, spi_flash, and several other Klipper "
#~ "modules. Eric has a donations page at: <https://ko-fi.com/arksine>"
#~ msgstr ""

#~ msgid ""
#~ "Klipper is frequently used with other Free Software. Consider using or "
#~ "supporting these projects."
#~ msgstr ""

#~ msgid "[Mainsail](https://github.com/mainsail-crew/mainsail)"
#~ msgstr ""

#~ msgid "[OctoPrint](https://octoprint.org/)"
#~ msgstr ""

#~ msgid ""
#~ "This document provides some tips for configuring a \"slicer\" application "
#~ "for use with Klipper. Common slicers used with Klipper are Slic3r, Cura, "
#~ "Simplify3D, etc."
#~ msgstr ""

#~ msgid ""
#~ "Many slicers have an option to configure the \"G-Code flavor\". The default "
#~ "is frequently \"Marlin\" and that works well with Klipper. The "
#~ "\"Smoothieware\" setting also works well with Klipper."
#~ msgstr ""

#~ msgid ""
#~ "Slicers will often allow one to configure \"Start G-Code\" and \"End "
#~ "G-Code\" sequences. It is often convenient to define custom macros in the "
#~ "Klipper config file instead - such as: `[gcode_macro START_PRINT]` and "
#~ "`[gcode_macro END_PRINT]`. Then one can just run START_PRINT and END_PRINT "
#~ "in the slicer's configuration. Defining these actions in the Klipper "
#~ "configuration may make it easier to tweak the printer's start and end steps "
#~ "as changes do not require re-slicing."
#~ msgstr ""

#~ msgid ""
#~ "See the [config reference](Config_Reference.md#gcode_macro) for details on "
#~ "defining a gcode_macro."
#~ msgstr ""

#~ msgid ""
#~ "The maximum speed and acceleration of retraction moves are controlled in "
#~ "Klipper by the `max_extrude_only_velocity` and `max_extrude_only_accel` "
#~ "config settings. These settings have a default value that should work well "
#~ "on many printers. However, if one has configured a large retraction in the "
#~ "slicer (eg, 5mm or greater) then one may find they limit the desired speed "
#~ "of retractions."
#~ msgstr ""

#~ msgid "Do not enable \"coasting\""
#~ msgstr ""

#~ msgid ""
#~ "Specifically, if the slicer dramatically changes the extrusion rate between "
#~ "moves then Klipper will perform deceleration and acceleration between moves."
#~ " This is likely to make blobbing worse, not better."
#~ msgstr ""

#~ msgid "Do not use \"extra restart distance\" on Simplify3d"
#~ msgstr ""

#~ msgid "Disable \"PreloadVE\" on KISSlicer"
#~ msgstr ""

#~ msgid "Disable any \"advanced extruder pressure\" settings"
#~ msgstr ""

#~ msgid ""
#~ "Specifically, these slicer settings can instruct the firmware to make wild "
#~ "changes to the extrusion rate in the hope that the firmware will approximate"
#~ " those requests and the printer will roughly obtain a desirable extruder "
#~ "pressure. Klipper, however, utilizes precise kinematic calculations and "
#~ "timing. When Klipper is commanded to make significant changes to the "
#~ "extrusion rate it will plan out the corresponding changes to velocity, "
#~ "acceleration, and extruder movement - which is not the slicer's intent. The "
#~ "slicer may even command excessive extrusion rates to the point that it "
#~ "triggers Klipper's maximum extrusion cross-section check."
#~ msgstr ""

#~ msgid ""
#~ "Software based skew correction can help resolve dimensional inaccuracies "
#~ "resulting from a printer assembly that is not perfectly square. Note that if"
#~ " your printer is significantly skewed it is strongly recommended to first "
#~ "use mechanical means to get your printer as square as possible prior to "
#~ "applying software based correction."
#~ msgstr ""

#~ msgid ""
#~ "The first step in correcting skew is to print a [calibration "
#~ "object](https://www.thingiverse.com/thing:2563185/files) along the plane you"
#~ " want to correct. There is also a [calibration "
#~ "object](https://www.thingiverse.com/thing:2972743) that includes all planes "
#~ "in one model. You want the object oriented so that corner A is toward the "
#~ "origin of the plane."
#~ msgstr ""

#~ msgid "Take your measurements"
#~ msgstr ""

#~ msgid "![skew_lengths](img/skew_lengths.png)"
#~ msgstr ""

#~ msgid ""
#~ "Make sure `[skew_correction]` is in printer.cfg. You may now use the "
#~ "`SET_SKEW` gcode to configure skew_correcton. For example, if your measured "
#~ "lengths along XY are as follows:"
#~ msgstr ""

#~ msgid "`SET_SKEW` can be used to configure skew correction for the XY plane."
#~ msgstr ""

#~ msgid "You may also add measurements for XZ and YZ to the gcode:"
#~ msgstr ""

#~ msgid ""
#~ "The `[skew_correction]` module also supports profile management in a manner "
#~ "similar to `[bed_mesh]`. After setting skew using the `SET_SKEW` gcode, you "
#~ "may use the `SKEW_PROFILE` gcode to save it:"
#~ msgstr ""

#~ msgid ""
#~ "After this command you will be prompted to issue a `SAVE_CONFIG` gcode to "
#~ "save the profile to persistent storage. If no profile is named "
#~ "`my_skew_profile` then a new profile will be created. If the named profile "
#~ "exists it will be overwritten."
#~ msgstr ""

#~ msgid "SKEW_PROFILE LOAD=my_skew_profile\n"
#~ msgstr ""

#~ msgid "SKEW_PROFILE REMOVE=my_skew_profile\n"
#~ msgstr ""

#~ msgid "Verifying your correction"
#~ msgstr ""

#~ msgid "CALC_MEASURED_SKEW AC=<ac_length> BD=<bd_length> AD=<ad_length>\n"
#~ msgstr ""

#~ msgid ""
#~ "Keep in mind that it is possible for `[skew_correction]` to generate a "
#~ "correction that moves the tool beyond the printer's boundaries on the X "
#~ "and/or Y axes. It is recommended to arrange parts away from the edges when "
#~ "using `[skew_correction]`."
#~ msgstr ""

#~ msgid ""
#~ "Many of today's popular controller boards ship with a bootloader capable of "
#~ "updating firmware via SD Card. While this is convenient in many "
#~ "circumstances, these bootloaders typically provide no other way to update "
#~ "firmware. This can be a nuisance if your board is mounted in a location that"
#~ " is difficult to access or if you need to update firmware often. After "
#~ "Klipper has been initially flashed to a controller it is possible to "
#~ "transfer new firmware to the SD Card and initiate the flashing procedure via"
#~ " ssh."
#~ msgstr ""

#~ msgid ""
#~ "The procedure for updating MCU firmware using the SD Card is similar to that"
#~ " of other methods. Instead of using `make flash` it is necessary to run a "
#~ "helper script, `flash-sdcard.sh`. Updating a BigTreeTech SKR 1.3 might look "
#~ "like the following:"
#~ msgstr ""

#~ msgid ""
#~ "It is up to the user to determine the device location and board name. If a "
#~ "user needs to flash multiple boards, `flash-sdcard.sh` (or `make flash` if "
#~ "appropriate) should be run for each board prior to restarting the Klipper "
#~ "service."
#~ msgstr ""

#~ msgid "./scripts/flash-sdcard.sh -l\n"
#~ msgstr ""

#~ msgid "Advanced Usage"
#~ msgstr ""

#~ msgid ""
#~ "./scripts/flash-sdcard.sh -h\n"
#~ "SD Card upload utility for Klipper\n"
#~ "\n"
#~ "usage: flash_sdcard.sh [-h] [-l] [-c] [-b <baud>] [-f <firmware>]\n"
#~ "                       <device> <board>\n"
#~ "\n"
#~ "positional arguments:\n"
#~ "  <device>        device serial port\n"
#~ "  <board>         board type\n"
#~ "\n"
#~ "optional arguments:\n"
#~ "  -h              show this message\n"
#~ "  -l              list available boards\n"
#~ "  -c              run flash check/verify only (skip upload)\n"
#~ "  -b <baud>       serial baud rate (default is 250000)\n"
#~ "  -f <firmware>   path to klipper.bin\n"
#~ msgstr ""

#~ msgid "./scripts/flash-sdcard.sh -b 115200 /dev/ttyAMA0 btt-skr-v1.3\n"
#~ msgstr ""

#~ msgid ""
#~ "./scripts/flash-sdcard.sh -f ~/downloads/klipper.bin /dev/ttyAMA0 btt-"
#~ "skr-v1.3\n"
#~ msgstr ""

#~ msgid ""
#~ "The `-c` option is used to perform a check or verify-only operation to test "
#~ "if the board is running the specified firmware correctly. This option is "
#~ "primarily intended for cases where a manual power-cycle is necessary to "
#~ "complete the flashing procedure, such as with bootloaders that use SDIO mode"
#~ " instead of SPI to access their SD Cards. (See Caveats below) But, it can "
#~ "also be used anytime to verify if the code flashed into the board matches "
#~ "the version in your build folder on any supported board."
#~ msgstr ""

#~ msgid ""
#~ "While it is possible to flash a build that changes the Serial Baud or "
#~ "connection interface (ie: from USB to UART), verification will always fail "
#~ "as the script will be unable to reconnect to the MCU to verify the current "
#~ "version."
#~ msgstr ""

#~ msgid "Board Definitions"
#~ msgstr ""

#~ msgid ""
#~ "BOARD_DEFS = {\n"
#~ "    'generic-lpc1768': {\n"
#~ "        'mcu': \"lpc1768\",\n"
#~ "        'spi_bus': \"ssp1\",\n"
#~ "        \"cs_pin\": \"P0.6\"\n"
#~ "    },\n"
#~ "    ...<further definitions>\n"
#~ "}\n"
#~ msgstr ""

#~ msgid ""
#~ "`mcu`: The mcu type. This can be retrevied after configuring the build via "
#~ "`make menuconfig` by running `cat .config | grep CONFIG_MCU`. This field is "
#~ "required."
#~ msgstr ""

#~ msgid ""
#~ "`cs_pin`: The Chip Select Pin connected to the SD Card. This should be "
#~ "retreived from the board schematic. This field is required."
#~ msgstr ""

#~ msgid ""
#~ "`current_firmware_path`: The path on the SD Card where the renamed firmware "
#~ "file is located after a successful flash. The default is `firmware.cur`."
#~ msgstr ""

#~ msgid ""
#~ "If software SPI is required, the `spi_bus` field should be set to `swspi` "
#~ "and the following additional field should be specified:"
#~ msgstr ""

#~ msgid ""
#~ "It should be exceedingly rare that Software SPI is necessary, typically only"
#~ " boards with design errors or boards that normally only support SDIO mode "
#~ "for their SD Card will require it. The `btt-skr-pro` board definition "
#~ "provides an example of the former, and the `btt-octopus-f446-v1` board "
#~ "definition provides an example of the latter."
#~ msgstr ""

#~ msgid ""
#~ "BOARD_ALIASES = {\n"
#~ "    ...<previous aliases>,\n"
#~ "    'my-new-board': BOARD_DEFS['generic-lpc1768'],\n"
#~ "}\n"
#~ msgstr ""

#~ msgid "Flashing Boards that use SDIO"
#~ msgstr ""

#~ msgid ""
#~ "There are two scenarios -- one with the RPi Host running on a separate power"
#~ " supply and the other when the RPi Host is running on the same power supply "
#~ "as the main board being flashed. The difference is whether or not it's "
#~ "necessary to also shutdown the RPi and then `ssh` again after the flashing "
#~ "is complete in order to do the verification step, or if the verification can"
#~ " be done immediately. Here's examples of the two scenarios:"
#~ msgstr ""

#~ msgid ""
#~ "A typical session with the RPi on a Separate Power Supply looks like the "
#~ "following. You will, of course, need to use your proper device path and "
#~ "board name:"
#~ msgstr ""

#~ msgid "SDIO Programming with RPi on the Same Power Supply"
#~ msgstr ""

#~ msgid ""
#~ "sudo service klipper stop\n"
#~ "cd ~/klipper\n"
#~ "git pull\n"
#~ "make clean\n"
#~ "make menuconfig\n"
#~ "make\n"
#~ "./scripts/flash-sdcard.sh /dev/ttyACM0 btt-octopus-f446-v1\n"
#~ "sudo shutdown -h now\n"
#~ "[[[wait for the RPi to shutdown, then power-cycle and ssh again to the RPi when it restarts]]]\n"
#~ "sudo service klipper stop\n"
#~ "cd ~/klipper\n"
#~ "./scripts/flash-sdcard.sh -c /dev/ttyACM0 btt-octopus-f446-v1\n"
#~ "sudo service klipper start\n"
#~ msgstr ""

#~ msgid "SDIO to SPI Pin Mapping"
#~ msgstr ""

#~ msgid "SD Card Pin"
#~ msgstr ""

#~ msgid "SDIO Pin Name"
#~ msgstr ""

#~ msgid "9"
#~ msgstr ""

#~ msgid "None (PU)*"
#~ msgstr ""

#~ msgid "CMD"
#~ msgstr ""

#~ msgid "+3.3V (VDD)"
#~ msgstr ""

#~ msgid "SCLK"
#~ msgstr ""

#~ msgid "GND (VSS)"
#~ msgstr ""

#~ msgid "DATA0"
#~ msgstr ""

#~ msgid "8"
#~ msgstr ""

#~ msgid "Card Detect (CD)"
#~ msgstr ""

#~ msgid "\\* None (PU) indicates an unused pin with a pull-up resistor"
#~ msgstr ""

#~ msgid ""
#~ "Stepper motor drivers on Klipper require a `rotation_distance` parameter in "
#~ "each [stepper config section](Config_Reference.md#stepper). The "
#~ "`rotation_distance` is the amount of distance that the axis moves with one "
#~ "full revolution of the stepper motor. This document describes how one can "
#~ "configure this value."
#~ msgstr ""

#~ msgid ""
#~ "The designers of your 3d printer originally calculated `steps_per_mm` from a"
#~ " rotation distance. If you know the steps_per_mm then it is possible to use "
#~ "this general formula to obtain that original rotation distance:"
#~ msgstr ""

#~ msgid ""
#~ "Or, if you have an older Klipper configuration and know the `step_distance` "
#~ "parameter you can use this formula:"
#~ msgstr ""

#~ msgid ""
#~ "The `<full_steps_per_rotation>` setting is determined from the type of "
#~ "stepper motor. Most stepper motors are \"1.8 degree steppers\" and therefore"
#~ " have 200 full steps per rotation (360 divided by 1.8 is 200). Some stepper "
#~ "motors are \"0.9 degree steppers\" and thus have 400 full steps per "
#~ "rotation. Other stepper motors are rare. If unsure, do not set "
#~ "full_steps_per_rotation in the config file and use 200 in the formula above."
#~ msgstr ""

#~ msgid ""
#~ "Almost all printers should have a whole number for `rotation_distance` on X,"
#~ " Y, and Z type axes. If the above formula results in a rotation_distance "
#~ "that is within .01 of a whole number then round the final value to that "
#~ "whole_number."
#~ msgstr ""

#~ msgid ""
#~ "On an extruder, the `rotation_distance` is the amount of distance the "
#~ "filament travels for one full rotation of the stepper motor. The best way to"
#~ " get an accurate value for this setting is to use a \"measure and trim\" "
#~ "procedure."
#~ msgstr ""

#~ msgid "Then use the following procedure to \"measure and trim\":"
#~ msgstr ""

#~ msgid ""
#~ "Use a marker to place a mark on the filament around 70mm from the intake of "
#~ "the extruder body. Then use a digital calipers to measure the actual "
#~ "distance of that mark as precisely as one can. Note this as "
#~ "`<initial_mark_distance>`."
#~ msgstr ""

#~ msgid ""
#~ "Use the digital calipers to measure the new distance between the extruder "
#~ "body and the mark on the filament. Note this as "
#~ "`<subsequent_mark_distance>`. Then calculate: `actual_extrude_distance = "
#~ "<initial_mark_distance> - <subsequent_mark_distance>`"
#~ msgstr ""

#~ msgid ""
#~ "If the actual_extrude_distance differs from requested_extrude_distance by "
#~ "more than about 2mm then it is a good idea to perform the steps above a "
#~ "second time."
#~ msgstr ""

#~ msgid "Obtaining rotation_distance by inspecting the hardware"
#~ msgstr ""

#~ msgid "Belt driven axes"
#~ msgstr ""

#~ msgid ""
#~ "First determine the type of belt. Most printers use a 2mm belt pitch (that "
#~ "is, each tooth on the belt is 2mm apart). Then count the number of teeth on "
#~ "the stepper motor pulley. The rotation_distance is then calculated as:"
#~ msgstr ""

#~ msgid ""
#~ "For example, if a printer has a 2mm belt and uses a pulley with 20 teeth, "
#~ "then the rotation distance is 40."
#~ msgstr ""

#~ msgid ""
#~ "It is easy to calculate the rotation_distance for common lead screws using "
#~ "the following formula:"
#~ msgstr ""

#~ msgid ""
#~ "For example, the common \"T8 leadscrew\" has a rotation distance of 8 (it "
#~ "has a pitch of 2mm and has 4 separate threads)."
#~ msgstr ""

#~ msgid "Extruder"
#~ msgstr ""

#~ msgid ""
#~ "If the extruder uses gears then it will also be necessary to [determine and "
#~ "set the gear_ratio](#using-a-gear_ratio) for the extruder."
#~ msgstr ""

#~ msgid "Using a gear_ratio"
#~ msgstr ""

#~ msgid ""
#~ "When `gear_ratio` is set, the `rotation_distance` represents the distance "
#~ "the axis moves with one full rotation of the final gear on the gear box. If,"
#~ " for example, one is using a gearbox with a \"5:1\" ratio, then one could "
#~ "calculate the rotation_distance with [knowledge of the hardware](#obtaining-"
#~ "rotation_distance-by-inspecting-the-hardware) and then add `gear_ratio: 5:1`"
#~ " to the config."
#~ msgstr ""

#~ msgid ""
#~ "Note that sometimes a gearbox will have a slightly different gear ratio than"
#~ " what it is advertised as. The common BMG extruder motor gears are an "
#~ "example of this - they are advertised as \"3:1\" but actually use \"50:17\" "
#~ "gearing. (Using teeth numbers without a common denominator may improve "
#~ "overall gear wear as the teeth don't always mesh the same way with each "
#~ "revolution.) The common \"5.18:1 planetary gearbox\", is more accurately "
#~ "configured with `gear_ratio: 57:11`."
#~ msgstr ""

#~ msgid ""
#~ "In most cases, gear_ratio should be defined with whole numbers as common "
#~ "gears and pulleys have a whole number of teeth on them. However, in cases "
#~ "where a belt drives a pulley using friction instead of teeth, it may make "
#~ "sense to use a floating point number in the gear ratio (eg, `gear_ratio: "
#~ "107.237:16`)."
#~ msgstr ""

#~ msgid ""
#~ "|![Ringing test](img/ringing-test.jpg)|![3D "
#~ "Benchy](img/ringing-3dbenchy.jpg)|"
#~ msgstr ""

#~ msgid ""
#~ "[Input shaping](https://en.wikipedia.org/wiki/Input_shaping) is an open-loop"
#~ " control technique which creates a commanding signal that cancels its own "
#~ "vibrations. Input shaping requires some tuning and measurements before it "
#~ "can be enabled. Besides ringing, Input Shaping typically reduces the "
#~ "vibrations and shaking of the printer in general, and may also improve the "
#~ "reliability of the stealthChop mode of Trinamic stepper drivers."
#~ msgstr ""

#~ msgid ""
#~ "Slice the ringing test model, which can be found in "
#~ "[docs/prints/ringing_tower.stl](prints/ringing_tower.stl), in the slicer:"
#~ msgstr ""

#~ msgid "Infill and top layers can be set to 0."
#~ msgstr ""

#~ msgid ""
#~ "Use sufficiently high speed, around 80-100 mm/sec, for **external** "
#~ "perimeters."
#~ msgstr ""

#~ msgid "Make sure any \"dynamic acceleration control\" is disabled in the slicer."
#~ msgstr ""

#~ msgid "Ringing frequency"
#~ msgstr ""

#~ msgid ""
#~ "If `square_corner_velocity` parameter was changed, revert it back to 5.0. It"
#~ " is not advised to increase it when using input shaper because it can cause "
#~ "more smoothing in parts - it is better to use higher acceleration value "
#~ "instead."
#~ msgstr ""

#~ msgid "Disable Pressure Advance: `SET_PRESSURE_ADVANCE ADVANCE=0`"
#~ msgstr ""

#~ msgid ""
#~ "Execute the command: `TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT "
#~ "PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5` Basically, we try "
#~ "to make ringing more pronounced by setting different large values for "
#~ "acceleration. This command will increase the acceleration every 5 mm "
#~ "starting from 1500 mm/sec^2: 1500 mm/sec^2, 2000 mm/sec^2, 2500 mm/sec^2 and"
#~ " so forth up until 7000 mm/sec^2 at the last band."
#~ msgstr ""

#~ msgid ""
#~ "You can stop the print earlier if the ringing is clearly visible and you see"
#~ " that acceleration gets too high for your printer (e.g. printer shakes too "
#~ "much or starts skipping steps)."
#~ msgstr ""

#~ msgid ""
#~ "|![Mark ringing](img/ringing-mark.jpg)|![Measure ringing](img/ringing-"
#~ "measure.jpg)|"
#~ msgstr ""

#~ msgid ""
#~ "Compute the ringing frequency of X axis as *V* &middot; *N* / *D* (Hz), "
#~ "where *V* is the velocity for outer perimeters (mm/sec). For the example "
#~ "above, we marked 6 oscillations, and the test was printed at 100 mm/sec "
#~ "velocity, so the frequency is 100 * 6 / 12.14  49.4 Hz."
#~ msgstr ""

#~ msgid ""
#~ "Note that ringing on the test print should follow the pattern of the curved "
#~ "notches, as in the picture above. If it doesn't, then this defect is not "
#~ "really a ringing and has a different origin - either mechanical, or an "
#~ "extruder issue. It should be fixed first before enabling and tuning input "
#~ "shapers."
#~ msgstr ""

#~ msgid ""
#~ "Ringing frequency can depend on the position of the model within the "
#~ "buildplate and Z height, *especially on delta printers*; you can check if "
#~ "you see the differences in frequencies at different positions along the "
#~ "sides of the test model and at different heights. You can calculate the "
#~ "average ringing frequencies over X and Y axes if that is the case."
#~ msgstr ""

#~ msgid ""
#~ "Note that the ringing frequencies can change if the changes are made to the "
#~ "printer that affect the moving mass or change the stiffness of the system, "
#~ "for example:"
#~ msgstr ""

#~ msgid "Belts are tightened."
#~ msgstr ""

#~ msgid ""
#~ "Different bed is installed on a bed-slinger printer, or glass added, etc."
#~ msgstr ""

#~ msgid "Input shaper configuration"
#~ msgstr ""

#~ msgid ""
#~ "[input_shaper]\n"
#~ "shaper_freq_x: ...  # frequency for the X mark of the test model\n"
#~ "shaper_freq_y: ...  # frequency for the Y mark of the test model\n"
#~ msgstr ""

#~ msgid "Choosing input shaper"
#~ msgstr ""

#~ msgid ""
#~ "For most of the printers, either MZV or EI shapers can be recommended. This "
#~ "section describes a testing process to choose between them, and figure out a"
#~ " few other related parameters."
#~ msgstr ""

#~ msgid "Restart the firmware: `RESTART`"
#~ msgstr ""

#~ msgid "Execute: `SET_INPUT_SHAPER SHAPER_TYPE=MZV`"
#~ msgstr ""

#~ msgid ""
#~ "If you see no ringing at this point, then MZV shaper can be recommended for "
#~ "use."
#~ msgstr ""

#~ msgid ""
#~ "Now try EI input shaper. To try it, repeat steps (1)-(6) from above, but "
#~ "executing at step 4 the following command instead: `SET_INPUT_SHAPER "
#~ "SHAPER_TYPE=EI`."
#~ msgstr ""

#~ msgid ""
#~ "[input_shaper]\n"
#~ "shaper_freq_x: ...\n"
#~ "shaper_freq_y: ...\n"
#~ "shaper_type: mzv\n"
#~ msgstr ""

#~ msgid ""
#~ "EI shaper may be more suited for bed slinger printers (if the resonance "
#~ "frequency and resulting smoothing allows): as more filament is deposited on "
#~ "the moving bed, the mass of the bed increases and the resonance frequency "
#~ "will decrease. Since EI shaper is more robust to resonance frequency "
#~ "changes, it may work better when printing large parts."
#~ msgstr ""

#~ msgid ""
#~ "You should have a printed test for the shaper you chose from the previous "
#~ "step (if you don't, print the test model sliced with the [suggested "
#~ "parameters](#tuning) with the pressure advance disabled "
#~ "`SET_PRESSURE_ADVANCE ADVANCE=0` and with the tuning tower enabled as "
#~ "`TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 "
#~ "STEP_DELTA=500 STEP_HEIGHT=5`). Note that at very high accelerations, "
#~ "depending on the resonance frequency and the input shaper you chose (e.g. EI"
#~ " shaper creates more smoothing than MZV), input shaping may cause too much "
#~ "smoothing and rounding of the parts. So, max_accel should be chosen such as "
#~ "to prevent that. Another parameter that can impact smoothing is "
#~ "`square_corner_velocity`, so it is not advisable to increase it above the "
#~ "default 5 mm/sec to prevent increased smoothing."
#~ msgstr ""

#~ msgid ""
#~ "Next, check the smoothing. To help with that, the test model has a small gap"
#~ " in the wall (0.15 mm):"
#~ msgstr ""

#~ msgid ""
#~ "As the acceleration increases, so does the smoothing, and the actual gap in "
#~ "the print widens:"
#~ msgstr ""

#~ msgid ""
#~ "In this picture, the acceleration increases left to right, and the gap "
#~ "starts to grow starting from 3500 mm/sec^2 (5-th band from the left). So the"
#~ " good value for max_accel = 3000 (mm/sec^2) in this case to avoid the "
#~ "excessive smoothing."
#~ msgstr ""

#~ msgid ""
#~ "Choose the minimum out of the two acceleration values (from ringing and "
#~ "smoothing), and put it as `max_accel` into printer.cfg."
#~ msgstr ""

#~ msgid ""
#~ "At very low ringing frequencies (~25 Hz and below) even MZV shaper may "
#~ "create too much smoothing. If that is the case, you can also try to repeat "
#~ "the steps in [Choosing input shaper](#choosing-input-shaper) section with ZV"
#~ " shaper, by using `SET_INPUT_SHAPER SHAPER_TYPE=ZV` command instead. ZV "
#~ "shaper should show even less smoothing than MZV, but is more sensitive to "
#~ "errors in measuring the ringing frequencies."
#~ msgstr ""

#~ msgid "Fine-tuning resonance frequencies"
#~ msgstr ""

#~ msgid ""
#~ "Assuming that you have sliced the ringing model with suggested parameters, "
#~ "complete the following steps for each of the axes X and Y:"
#~ msgstr ""

#~ msgid "Execute: `SET_INPUT_SHAPER SHAPER_TYPE=ZV`"
#~ msgstr ""

#~ msgid ""
#~ "Calculate the necessary parameters for the `TUNING_TOWER` command to tune "
#~ "`shaper_freq_x` parameter as follows: start = shaper_freq_x * 83 / 132 and "
#~ "factor = shaper_freq_x / 66, where `shaper_freq_x` here is the current value"
#~ " in `printer.cfg`."
#~ msgstr ""

#~ msgid "Print the test model."
#~ msgstr ""

#~ msgid ""
#~ "Find the band which shows ringing the least and count its number from the "
#~ "bottom starting at 1."
#~ msgstr ""

#~ msgid ""
#~ "Repeat these steps for the Y axis in the same manner, replacing references "
#~ "to X axis with the axis Y (e.g. replace `shaper_freq_x` with `shaper_freq_y`"
#~ " in the formulae and in the `TUNING_TOWER` command)."
#~ msgstr ""

#~ msgid ""
#~ "After both new `shaper_freq_x` and `shaper_freq_y` parameters have been "
#~ "calculated, you can update `[input_shaper]` section in `printer.cfg` with "
#~ "the new `shaper_freq_x` and `shaper_freq_y` values."
#~ msgstr ""

#~ msgid ""
#~ "If you use Pressure Advance, it may need to be re-tuned. Follow the "
#~ "[instructions](Pressure_Advance.md#tuning-pressure-advance) to find the new "
#~ "value, if it differs from the previous one. Make sure to restart Klipper "
#~ "before tuning Pressure Advance."
#~ msgstr ""

#~ msgid ""
#~ "If you are unable to measure the ringing frequencies, e.g. if the distance "
#~ "between the oscillations is not stable, you may still be able to take "
#~ "advantage of input shaping techniques, but the results may not be as good as"
#~ " with proper measurements of the frequencies, and will require a bit more "
#~ "tuning and printing the test model. Note that another possibility is to "
#~ "purchase and install an accelerometer and measure the resonances with it "
#~ "(refer to the [docs](Measuring_Resonances.md) describing the required "
#~ "hardware and the setup process) - but this option requires some crimping and"
#~ " soldering."
#~ msgstr ""

#~ msgid "`RESTART`"
#~ msgstr ""

#~ msgid "`SET_PRESSURE_ADVANCE ADVANCE=0`"
#~ msgstr ""

#~ msgid ""
#~ "`TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 "
#~ "STEP_DELTA=500 STEP_HEIGHT=5`"
#~ msgstr ""

#~ msgid ""
#~ "`SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=50 SHAPER_FREQ_Y=50`"
#~ msgstr ""

#~ msgid ""
#~ "`SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=40 SHAPER_FREQ_Y=40`"
#~ msgstr ""

#~ msgid ""
#~ "If none of the models demonstrate improvements in ringing, then, "
#~ "unfortunately, it does not look like the input shaping techniques can help "
#~ "with your case."
#~ msgstr ""

#~ msgid ""
#~ "Now check if EI shaper would be good enough in your case. Choose EI shaper "
#~ "frequency based on the frequency of 2HUMP_EI shaper you chose:"
#~ msgstr ""

#~ msgid "For 2HUMP_EI 50 Hz shaper, use EI shaper with shaper_freq = 40 Hz."
#~ msgstr ""

#~ msgid "Now print the test model one more time, running"
#~ msgstr ""

#~ msgid ""
#~ "providing the shaper_freq_x=... and shaper_freq_y=... as determined "
#~ "previously."
#~ msgstr ""

#~ msgid ""
#~ "[input_shaper]\n"
#~ "shaper_freq_x: 50\n"
#~ "shaper_freq_y: 50\n"
#~ "shaper_type: 2hump_ei\n"
#~ msgstr ""

#~ msgid "Troubleshooting and FAQ"
#~ msgstr ""

#~ msgid ""
#~ "First, make sure it is not some other problem with the printer instead of "
#~ "ringing. If the measurements are not reliable because, say, the distance "
#~ "between the oscillations is not stable, it might mean that the printer has "
#~ "several resonance frequencies on the same axis. One may try to follow the "
#~ "tuning process described in [Unreliable measurements of ringing "
#~ "frequencies](#unreliable-measurements-of-ringing-frequencies) section and "
#~ "still get something out of the input shaping technique. Another possibility "
#~ "is to install an accelerometer, [measure](Measuring_Resonances.md) the "
#~ "resonances with it, and auto-tune the input shaper using the results of "
#~ "those measurements."
#~ msgstr ""

#~ msgid ""
#~ "Check the considerations in [Selecting max_accel](#selecting-max_accel) "
#~ "section. If the resonance frequency is low, one should not set too high "
#~ "max_accel or increase square_corner_velocity parameters. It might also be "
#~ "better to choose MZV or even ZV input shapers over EI (or 2HUMP_EI and "
#~ "3HUMP_EI shapers)."
#~ msgstr ""

#~ msgid ""
#~ "It is possible that after some time the resonance frequencies have changed. "
#~ "E.g. maybe the belts tension has changed (belts got more loose), etc. It is "
#~ "a good idea to check and re-measure the ringing frequencies as described in "
#~ "[Ringing frequency](#ringing-frequency) section and update your config file "
#~ "if necessary."
#~ msgstr ""

#~ msgid ""
#~ "There is no dedicated support for dual carriages with input shapers, but it "
#~ "does not mean this setup will not work. One should run the tuning twice for "
#~ "each of the carriages, and calculate the ringing frequencies for X and Y "
#~ "axes for each of the carriages independently. Then put the values for "
#~ "carriage 0 into [input_shaper] section, and change the values on the fly "
#~ "when changing carriages, e.g. as a part of some macro:"
#~ msgstr ""

#~ msgid "And similarly when switching back to carriage 0."
#~ msgstr ""

#~ msgid ""
#~ "No, `input_shaper` feature has pretty much no impact on the print times by "
#~ "itself. However, the value of `max_accel` certainly does (tuning of this "
#~ "parameter described in [this section](#selecting-max_accel))."
#~ msgstr ""

#~ msgid "Input shapers"
#~ msgstr ""

#~ msgid "Input <br> shaper"
#~ msgstr ""

#~ msgid "Vibration reduction 20x <br> (5% vibration tolerance)"
#~ msgstr ""

#~ msgid "ZV"
#~ msgstr ""

#~ msgid " 5% shaper_freq"
#~ msgstr ""

#~ msgid "0.75 / shaper_freq"
#~ msgstr ""

#~ msgid "-10%...+15% shaper_freq"
#~ msgstr ""

#~ msgid "1 / shaper_freq"
#~ msgstr ""

#~ msgid " 22% shaper_freq"
#~ msgstr ""

#~ msgid " 20% shaper_freq"
#~ msgstr ""

#~ msgid "2HUMP_EI"
#~ msgstr ""

#~ msgid " 35% shaper_freq"
#~ msgstr ""

#~ msgid "3HUMP_EI"
#~ msgstr ""

#~ msgid "-45...+50% shaper_freq"
#~ msgstr ""

#~ msgid ""
#~ "A note on vibration reduction: the values in the table above are "
#~ "approximate. If the damping ratio of the printer is known for each axis, the"
#~ " shaper can be configured more precisely and it will then reduce the "
#~ "resonances in a bit wider range of frequencies. However, the damping ratio "
#~ "is usually unknown and is hard to estimate without a special equipment, so "
#~ "Klipper uses 0.1 value by default, which is a good all-round value. The "
#~ "frequency ranges in the table cover a number of different possible damping "
#~ "ratios around that value (approx. from 0.05 to 0.2)."
#~ msgstr ""

#~ msgid "**How to use this table:**"
#~ msgstr ""

#~ msgid ""
#~ "One can estimate a range of frequencies in which the shaper reduces "
#~ "vibrations. For example, MZV with shaper_freq = 35 Hz reduces vibrations to "
#~ "5% for frequencies [33.6, 36.4] Hz. 3HUMP_EI with shaper_freq = 50 Hz "
#~ "reduces vibrations to 5% in range [27.5, 75] Hz."
#~ msgstr ""

#~ msgid ""
#~ "If one needs to reduce vibrations at several very different frequencies "
#~ "(say, 30 Hz and 100 Hz), they may see that the table above does not provide "
#~ "enough information. In this case one may have more luck with "
#~ "[scripts/graph_shaper.py](../scripts/graph_shaper.py) script, which is more "
#~ "flexible."
#~ msgstr ""

#~ msgid ""
#~ "History of Klipper releases. Please see [installation](Installation.md) for "
#~ "information on installing Klipper."
#~ msgstr ""

#~ msgid "Available on 20221128. Major changes in this release:"
#~ msgstr ""

#~ msgid ""
#~ "Support for Python3. The Klipper host code will run with either Python2 or "
#~ "Python3."
#~ msgstr ""

#~ msgid "Support for CanBoot bootloader."
#~ msgstr ""

#~ msgid ""
#~ "Improved error handling for max31856, max31855, max31865, and max6675 "
#~ "temperature sensors."
#~ msgstr ""

#~ msgid ""
#~ "Several micro-controller improvements. New support for stm32h743, stm32h750,"
#~ " stm32l412, stm32g0b1, same70, same51, and same54 chips. Support for i2c "
#~ "reads on atsamd and stm32f0. Hardware pwm support on stm32. Linux mcu signal"
#~ " based event dispatch. New rp2040 support for \"make flash\", i2c, and "
#~ "rp2040-e5 USB errata."
#~ msgstr ""

#~ msgid "Several bug fixes and code cleanups."
#~ msgstr ""

#~ msgid "Available on 20210929. Major changes in this release:"
#~ msgstr ""

#~ msgid ""
#~ "Klipper now has a [Community Discord Server](https://discord.klipper3d.org) "
#~ "and a [Community Discourse Server](https://community.klipper3d.org)."
#~ msgstr ""

#~ msgid "Automated support for flashing firmware via sdcard on many boards."
#~ msgstr ""

#~ msgid ""
#~ "Klipper now uses `rotation_distance` to configure stepper motor travel "
#~ "distances."
#~ msgstr ""

#~ msgid ""
#~ "New \"motion analysis\" system. Klipper's internal motion updates and sensor"
#~ " results can be tracked and logged for analysis."
#~ msgstr ""

#~ msgid "Support for the rp2040 micro-controller (Raspberry Pi Pico boards)."
#~ msgstr ""

#~ msgid ""
#~ "Many additional modules added: ds18b20, duplicate_pin_override, "
#~ "filament_motion_sensor, palette2, motion_report, pca9533, pulse_counter, "
#~ "save_variables, sdcard_loop, temperature_host, temperature_mcu"
#~ msgstr ""

#~ msgid "Available on 20201020. Major changes in this release:"
#~ msgstr ""

#~ msgid ""
#~ "New \"Smooth Pressure Advance\" system. This implements \"Pressure Advance\""
#~ " without introducing instantaneous velocity changes. It is also now possible"
#~ " to tune pressure advance using a \"Tuning Tower\" method."
#~ msgstr ""

#~ msgid ""
#~ "The LCD display and menu are now configurable using the Jinja2 template "
#~ "language."
#~ msgstr ""

#~ msgid "Improved BL-Touch v3 support."
#~ msgstr ""

#~ msgid "New kinematic support for \"Rotary Delta\" and \"CoreXZ\" printers."
#~ msgstr ""

#~ msgid "Improved handling of Python \"garbage collection\" events."
#~ msgstr ""

#~ msgid "Klipper 0.9.1"
#~ msgstr ""

#~ msgid "Klipper 0.8.0"
#~ msgstr ""

#~ msgid ""
#~ "New G-Code command template support. G-Code in the config file is now "
#~ "evaluated with the Jinja2 template language."
#~ msgstr ""

#~ msgid "New support for TMC2209 and TMC5160 drivers."
#~ msgstr ""

#~ msgid "Improved support for TMC UART handling with an analog mux."
#~ msgstr ""

#~ msgid ""
#~ "New manual_probe, bed_screws, screws_tilt_adjust, skew_correction, "
#~ "safe_z_home modules added."
#~ msgstr ""

#~ msgid ""
#~ "Improved documentation for BL-Touch, probe calibration, endstop calibration,"
#~ " delta calibration, sensorless homing, and endstop phase calibration."
#~ msgstr ""

#~ msgid "Many Klipper micro-controller improvements:"
#~ msgstr ""

#~ msgid "New USB CDC driver implementations on SAM3X, SAM4, STM32F4."
#~ msgstr ""

#~ msgid "Software SPI support."
#~ msgstr ""

#~ msgid "Early output pin settings can be configured in the micro-controller."
#~ msgstr ""

#~ msgid "Klipper now has a logo."
#~ msgstr ""

#~ msgid "The config file can now include other config files."
#~ msgstr ""

#~ msgid ""
#~ "Many additional commands added: RESTORE_GCODE_STATE, SAVE_GCODE_STATE, "
#~ "SET_GCODE_VARIABLE, SET_HEATER_TEMPERATURE, SET_IDLE_TIMEOUT, "
#~ "SET_TEMPERATURE_FAN_TARGET"
#~ msgstr ""

#~ msgid "Available on 20181220. Major changes in this release:"
#~ msgstr ""

#~ msgid ""
#~ "New support for \"enhanced\" delta calibration (calibrates print x/y "
#~ "dimensions on delta printers)"
#~ msgstr ""

#~ msgid ""
#~ "Improved temperature sensor support: MAX6675, MAX31855, MAX31856, MAX31865, "
#~ "custom thermistors, common pt100 style sensors"
#~ msgstr ""

#~ msgid ""
#~ "Several new commands added: SAVE_CONFIG, SET_PRESSURE_ADVANCE, "
#~ "SET_GCODE_OFFSET, SET_VELOCITY_LIMIT, STEPPER_BUZZ, TURN_OFF_HEATERS, M204, "
#~ "custom g-code macros"
#~ msgstr ""

#~ msgid "Support for run-time menus"
#~ msgstr ""

#~ msgid "Support for \"uc1701\" and \"ssd1306\" displays"
#~ msgstr ""

#~ msgid ""
#~ "Klipper ported to: LPC176x (Smoothieboards), SAM4E8E (Duet2), SAMD21 "
#~ "(Arduino Zero), STM32F103 (\"Blue pill\" devices), atmega32u4"
#~ msgstr ""

#~ msgid "Performance improvements on ARM processors"
#~ msgstr ""

#~ msgid "New automatic test cases for the Klipper host software"
#~ msgstr ""

#~ msgid ""
#~ "Documentation updates for bootloaders, benchmarking, micro-controller "
#~ "porting, config checks, pin mapping, slicer settings, packaging, and more"
#~ msgstr ""

#~ msgid "Klipper 0.6.0"
#~ msgstr ""

#~ msgid "Enhanced heater and thermistor hardware failure checks"
#~ msgstr ""

#~ msgid ""
#~ "Initial support for automatic parameter calibration on deltas (via a new "
#~ "delta_calibrate command)"
#~ msgstr ""

#~ msgid "Initial support for \"safe homing\" and homing overrides"
#~ msgstr ""

#~ msgid "New multi-extruder improvements:"
#~ msgstr ""

#~ msgid "Initial support for dual carriages"
#~ msgstr ""

#~ msgid ""
#~ "Support for custom digital and pwm output pins (with a new SET_PIN command)"
#~ msgstr ""

#~ msgid "Support for setting different arm lengths on each tower of a delta"
#~ msgstr ""

#~ msgid "Several documentation updates:"
#~ msgstr ""

#~ msgid "New bltouch sensor config example"
#~ msgstr ""

#~ msgid ""
#~ "Initial support for continuous integration testing on all github commits"
#~ msgstr ""

#~ msgid "Available on 20171025. Major changes in this release:"
#~ msgstr ""

#~ msgid ""
#~ "Initial support for running on the Beaglebone PRU. Initial support for the "
#~ "Replicape board."
#~ msgstr ""

#~ msgid ""
#~ "Support for multiple micro-controllers. (For example, one could control an "
#~ "extruder with one micro-controller and the rest of the printer with "
#~ "another.) Software clock synchronization is implemented to coordinate "
#~ "actions between micro-controllers."
#~ msgstr ""

#~ msgid ""
#~ "Support for controlling servos and support for defining nozzle cooling fans."
#~ msgstr ""

#~ msgid "Available on 20170503. Major changes in this release:"
#~ msgstr ""

#~ msgid "Support for corexy kinematics"
#~ msgstr ""

#~ msgid ""
#~ "Stepper performance improvements (20Mhz AVRs over 175K steps per second, "
#~ "Arduino Due over 460K)"
#~ msgstr ""

#~ msgid ""
#~ "The pressure advance algorithm now works with look-ahead to reduce pressure "
#~ "changes during cornering."
#~ msgstr ""

#~ msgid "Support for AD595 sensors"
#~ msgstr ""

#~ msgid "Available on 20161223. Major changes in this release:"
#~ msgstr ""

#~ msgid "Support for robots with delta kinematics"
#~ msgstr ""

#~ msgid "Support for USB based AVR micro-controllers"
#~ msgstr ""

#~ msgid ""
#~ "New \"stepper phased based endstop\" feature - enables higher precision on "
#~ "endstop homing."
#~ msgstr ""

#~ msgid ""
#~ "Support for reloading the Klipper config and restarting the host software by"
#~ " issuing a \"restart\" command from the terminal."
#~ msgstr ""

#~ msgid ""
#~ "Improved error reporting. Most errors now shown via the terminal along with "
#~ "help on how to resolve."
#~ msgstr ""

#~ msgid ""
#~ "Initial release of Klipper. Available on 20160525. Major features available "
#~ "in the initial release include:"
#~ msgstr ""

#~ msgid ""
#~ "Support for common g-code commands. Support for interfacing with OctoPrint."
#~ msgstr ""

#~ msgid "Support for AVR micro-controllers via standard serial ports"
#~ msgstr ""

#~ msgid ""
#~ "This document describes the process of running Klipper on a RPi and use the "
#~ "same RPi as secondary mcu."
#~ msgstr ""

#~ msgid ""
#~ "Often the MCUs dedicated to controlling 3D printers have a limited and pre-"
#~ "configured number of exposed pins to manage the main printing functions "
#~ "(thermal resistors, extruders, steppers ...). Using the RPi where Klipper is"
#~ " installed as a secondary MCU gives the possibility to directly use the "
#~ "GPIOs and the buses (i2c, spi) of the RPi inside klipper without using "
#~ "Octoprint plugins (if used) or external programs giving the ability to "
#~ "control everything within the print GCODE."
#~ msgstr ""

#~ msgid "Install the rc script"
#~ msgstr ""

#~ msgid "After installing Klipper, install the script. run:"
#~ msgstr ""

#~ msgid ""
#~ "To compile the Klipper micro-controller code, start by configuring it for "
#~ "the \"Linux process\":"
#~ msgstr ""

#~ msgid "sudo usermod -a -G tty pi\n"
#~ msgstr ""

#~ msgid ""
#~ "The Klipper messaging protocol is used for low-level communication between "
#~ "the Klipper host software and the Klipper micro-controller software. At a "
#~ "high level the protocol can be thought of as a series of command and "
#~ "response strings that are compressed, transmitted, and then processed at the"
#~ " receiving side. An example series of commands in uncompressed human-"
#~ "readable format might look like:"
#~ msgstr ""

#~ msgid ""
#~ "See the [mcu commands](MCU_Commands.md) document for information on "
#~ "available commands. See the [debugging](Debugging.md) document for "
#~ "information on how to translate a G-Code file into its corresponding human-"
#~ "readable micro-controller commands."
#~ msgstr ""

#~ msgid ""
#~ "The goal of the protocol is to enable an error-free communication channel "
#~ "between the host and micro-controller that is low-latency, low-bandwidth, "
#~ "and low-complexity for the micro-controller."
#~ msgstr ""

#~ msgid ""
#~ "The Klipper transmission protocol can be thought of as a "
#~ "[RPC](https://en.wikipedia.org/wiki/Remote_procedure_call) mechanism between"
#~ " micro-controller and host. The micro-controller software declares the "
#~ "commands that the host may invoke along with the response messages that it "
#~ "can generate. The host uses that information to command the micro-controller"
#~ " to perform actions and to interpret the results."
#~ msgstr ""

#~ msgid ""
#~ "The micro-controller software declares a \"command\" by using the "
#~ "DECL_COMMAND() macro in the C code. For example:"
#~ msgstr ""

#~ msgid ""
#~ "The above declares a command named \"update_digital_out\". This allows the "
#~ "host to \"invoke\" this command which would cause the "
#~ "command_update_digital_out() C function to be executed in the micro-"
#~ "controller. The above also indicates that the command takes two integer "
#~ "parameters. When the command_update_digital_out() C code is executed, it "
#~ "will be passed an array containing these two integers - the first "
#~ "corresponding to the 'oid' and the second corresponding to the 'value'."
#~ msgstr ""

#~ msgid ""
#~ "The micro-controller build will collect all commands declared with "
#~ "DECL_COMMAND(), determine their parameters, and arrange for them to be "
#~ "callable."
#~ msgstr ""

#~ msgid ""
#~ "To send information from the micro-controller to the host a \"response\" is "
#~ "generated. These are both declared and transmitted using the sendf() C "
#~ "macro. For example:"
#~ msgstr ""

#~ msgid ""
#~ "The above transmits a \"status\" response message that contains two integer "
#~ "parameters (\"clock\" and \"status\"). The micro-controller build "
#~ "automatically finds all sendf() calls and generates encoders for them. The "
#~ "first parameter of the sendf() function describes the response and it is in "
#~ "the same format as command declarations."
#~ msgstr ""

#~ msgid ""
#~ "The sendf() macro should only be invoked from command or task handlers, and "
#~ "it should not be invoked from interrupts or timers. The code does not need "
#~ "to issue a sendf() in response to a received command, it is not limited in "
#~ "the number of times sendf() may be invoked, and it may invoke sendf() at any"
#~ " time from a task handler."
#~ msgstr ""

#~ msgid ""
#~ "To simplify debugging, there is also an output() C function. For example:"
#~ msgstr ""

#~ msgid ""
#~ "The output() function is similar in usage to printf() - it is intended to "
#~ "generate and format arbitrary messages for human consumption."
#~ msgstr ""

#~ msgid ""
#~ "Enumerations allow the host code to use string identifiers for parameters "
#~ "that the micro-controller handles as integers. They are declared in the "
#~ "micro-controller code - for example:"
#~ msgstr ""

#~ msgid ""
#~ "If the first example, the DECL_ENUMERATION() macro defines an enumeration "
#~ "for any command/response message with a parameter name of \"spi_bus\" or "
#~ "parameter name with a suffix of \"_spi_bus\". For those parameters the "
#~ "string \"spi\" is a valid value and it will be transmitted with an integer "
#~ "value of zero."
#~ msgstr ""

#~ msgid "Declaring constants"
#~ msgstr ""

#~ msgid "DECL_CONSTANT(\"SERIAL_BAUD\", 250000);\n"
#~ msgstr ""

#~ msgid "DECL_CONSTANT_STR(\"MCU\", \"pru\");\n"
#~ msgstr ""

#~ msgid ""
#~ "To accomplish the above RPC mechanism, each command and response is encoded "
#~ "into a binary format for transmission. This section describes the "
#~ "transmission system."
#~ msgstr ""

#~ msgid ""
#~ "All data sent from host to micro-controller and vice-versa are contained in "
#~ "\"message blocks\". A message block has a two byte header and a three byte "
#~ "trailer. The format of a message block is:"
#~ msgstr ""

#~ msgid ""
#~ "The length byte contains the number of bytes in the message block including "
#~ "the header and trailer bytes (thus the minimum message length is 5 bytes). "
#~ "The maximum message block length is currently 64 bytes. The sequence byte "
#~ "contains a 4 bit sequence number in the low-order bits and the high-order "
#~ "bits always contain 0x10 (the high-order bits are reserved for future use). "
#~ "The content bytes contain arbitrary data and its format is described in the "
#~ "following section. The crc bytes contain a 16bit CCITT "
#~ "[CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) of the message "
#~ "block including the header bytes but excluding the trailer bytes. The sync "
#~ "byte is 0x7e."
#~ msgstr ""

#~ msgid "Message Block Contents"
#~ msgstr ""

#~ msgid ""
#~ "As an example, the following four commands might be placed in a single "
#~ "message block:"
#~ msgstr ""

#~ msgid "and encoded into the following eight VLQ integers:"
#~ msgstr ""

#~ msgid ""
#~ "In order to encode and parse the message contents, both the host and micro-"
#~ "controller must agree on the command ids and the number of parameters each "
#~ "command has. So, in the above example, both the host and micro-controller "
#~ "would know that \"id_update_digital_out\" is always followed by two "
#~ "parameters, and \"id_get_config\" and \"id_get_clock\" have zero parameters."
#~ " The host and micro-controller share a \"data dictionary\" that maps the "
#~ "command descriptions (eg, \"update_digital_out oid=%c value=%c\") to their "
#~ "integer command-ids. When processing the data, the parser will know to "
#~ "expect a specific number of VLQ encoded parameters following a given command"
#~ " id."
#~ msgstr ""

#~ msgid "Variable Length Quantities"
#~ msgstr ""

#~ msgid "Integer"
#~ msgstr ""

#~ msgid "-32 .. 95"
#~ msgstr ""

#~ msgid "-524288 .. 1572863"
#~ msgstr ""

#~ msgid "-2147483648 .. 4294967295"
#~ msgstr ""

#~ msgid ""
#~ "As an exception to the above encoding rules, if a parameter to a command or "
#~ "response is a dynamic string then the parameter is not encoded as a simple "
#~ "VLQ integer. Instead it is encoded by transmitting the length as a VLQ "
#~ "encoded integer followed by the contents itself:"
#~ msgstr ""

#~ msgid ""
#~ "The command descriptions found in the data dictionary allow both the host "
#~ "and micro-controller to know which command parameters use simple VLQ "
#~ "encoding and which parameters use string encoding."
#~ msgstr ""

#~ msgid ""
#~ "In order for meaningful communications to be established between micro-"
#~ "controller and host, both sides must agree on a \"data dictionary\". This "
#~ "data dictionary contains the integer identifiers for commands and responses "
#~ "along with their descriptions."
#~ msgstr ""

#~ msgid ""
#~ "The host queries the data dictionary when it first connects to the micro-"
#~ "controller. Once the host downloads the data dictionary from the micro-"
#~ "controller, it uses that data dictionary to encode all commands and to parse"
#~ " all responses from the micro-controller. The host must therefore handle a "
#~ "dynamic data dictionary. However, to keep the micro-controller software "
#~ "simple, the micro-controller always uses its static (compiled in) data "
#~ "dictionary."
#~ msgstr ""

#~ msgid ""
#~ "The format of the transmitted data dictionary itself is a zlib compressed "
#~ "JSON string. The micro-controller build process generates the string, "
#~ "compresses it, and stores it in the text section of the micro-controller "
#~ "flash. The data dictionary can be much larger than the maximum message block"
#~ " size - the host downloads it by sending multiple identify commands "
#~ "requesting progressive chunks of the data dictionary. Once all chunks are "
#~ "obtained the host will assemble the chunks, uncompress the data, and parse "
#~ "the contents."
#~ msgstr ""

#~ msgid "Message flow"
#~ msgstr ""

#~ msgid ""
#~ "The low-level host code implements an automatic retransmission system for "
#~ "lost and corrupt message blocks sent to the micro-controller. To facilitate "
#~ "this, the micro-controller transmits an \"ack message block\" after each "
#~ "successfully received message block. The host schedules a timeout after "
#~ "sending each block and it will retransmit should the timeout expire without "
#~ "receiving a corresponding \"ack\". In addition, if the micro-controller "
#~ "detects a corrupt or out-of-order block it may transmit a \"nak message "
#~ "block\" to facilitate fast retransmission."
#~ msgstr ""

#~ msgid ""
#~ "The protocol facilitates a \"window\" transmission system so that the host "
#~ "can have many outstanding message blocks in-flight at a time. (This is in "
#~ "addition to the many commands that may be present in a given message block.)"
#~ " This allows maximum bandwidth utilization even in the event of transmission"
#~ " latency. The timeout, retransmit, windowing, and ack mechanism are inspired"
#~ " by similar mechanisms in "
#~ "[TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)."
#~ msgstr ""

#~ msgid ""
#~ "This document describes the method for calibrating the X, Y, and Z offsets "
#~ "of an \"automatic z probe\" in Klipper. This is useful for users that have a"
#~ " `[probe]` or `[bltouch]` section in their config file."
#~ msgstr ""

#~ msgid ""
#~ "To calibrate the X and Y offset, navigate to the OctoPrint \"Control\" tab, "
#~ "home the printer, and then use the OctoPrint jogging buttons to move the "
#~ "head to a position near the center of the bed."
#~ msgstr ""

#~ msgid "PROBE\n"
#~ msgstr ""

#~ msgid ""
#~ "Issue a `GET_POSITION` command and record the toolhead XY location reported "
#~ "by that command. For example if one sees:"
#~ msgstr ""

#~ msgid ""
#~ "then one would record a probe X position of 46.5 and probe Y position of 27."
#~ msgstr ""

#~ msgid "G1 F300 X57 Y30 Z15\n"
#~ msgstr ""

#~ msgid ""
#~ "The x_offset is then the `nozzle_x_position - probe_x_position` and y_offset"
#~ " is similarly the `nozzle_y_position - probe_y_position`. Update the "
#~ "printer.cfg file with the given values, remove the tape/marks from the bed, "
#~ "and then issue a `RESTART` command so that the new values take effect."
#~ msgstr ""

#~ msgid ""
#~ "Providing an accurate probe z_offset is critical to obtaining high quality "
#~ "prints. The z_offset is the distance between the nozzle and bed when the "
#~ "probe triggers. The Klipper `PROBE_CALIBRATE` tool can be used to obtain "
#~ "this value - it will run an automatic probe to measure the probe's Z trigger"
#~ " position and then start a manual probe to obtain the nozzle Z height. The "
#~ "probe z_offset will then be calculated from these measurements."
#~ msgstr ""

#~ msgid ""
#~ "This tool will perform an automatic probe, then lift the head, move the "
#~ "nozzle over the location of the probe point, and start the manual probe "
#~ "tool. If the nozzle does not move to a position above the automatic probe "
#~ "point, then `ABORT` the manual probe tool and perform the XY probe offset "
#~ "calibration described above."
#~ msgstr ""

#~ msgid ""
#~ "Note that if a change is made to the printer's motion system, hotend "
#~ "position, or probe location then it will invalidate the results of "
#~ "PROBE_CALIBRATE."
#~ msgstr ""

#~ msgid ""
#~ "If the results of PROBE_CALIBRATE are invalidated, then any previous [bed "
#~ "mesh](Bed_Mesh.md) results that were obtained using the probe are also "
#~ "invalidated - it will be necessary to rerun BED_MESH_CALIBRATE after "
#~ "recalibrating the probe."
#~ msgstr ""

#~ msgid ""
#~ "After calibrating the probe X, Y, and Z offsets it is a good idea to verify "
#~ "that the probe provides repeatable results. Start by homing the printer and "
#~ "then move the head to a position near the center of the bed. Navigate to the"
#~ " OctoPrint terminal tab and run the `PROBE_ACCURACY` command."
#~ msgstr ""

#~ msgid ""
#~ "Recv: // probe accuracy: at X:0.000 Y:0.000 Z:10.000\n"
#~ "Recv: // and read 10 times with speed of 5 mm/s\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.506948\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.519448\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.519448\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.506948\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.519448\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.519448\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.506948\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.506948\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.519448\n"
#~ "Recv: // probe at -0.003,0.005 is z=2.506948\n"
#~ "Recv: // probe accuracy results: maximum 2.519448, minimum 2.506948, range 0.012500, average 2.513198, median 2.513198, standard deviation 0.006250\n"
#~ msgstr ""

#~ msgid ""
#~ "If the results of the test show a range value that is greater than 25 "
#~ "microns (.025mm) then the probe does not have sufficient accuracy for "
#~ "typical bed leveling procedures. It may be possible to tune the probe speed "
#~ "and/or probe start height to improve the repeatability of the probe. The "
#~ "`PROBE_ACCURACY` command allows one to run tests with different parameters "
#~ "to see their impact - see the [G-Codes document](G-Codes.md#probe_accuracy) "
#~ "for further details. If the probe generally obtains repeatable results but "
#~ "has an occasional outlier, then it may be possible to account for that by "
#~ "using multiple samples on each probe - read the description of the probe "
#~ "`samples` config parameters in the [config "
#~ "reference](Config_Reference.md#probe) for more details."
#~ msgstr ""

#~ msgid "Location Bias Check"
#~ msgstr ""

#~ msgid ""
#~ "This is a common issue with probes on delta printers, however it can occur "
#~ "on all printers."
#~ msgstr ""

#~ msgid ""
#~ "For delta printers, try measuring the z_offset at a position near the A "
#~ "tower, at a position near the B tower, and at a position near the C tower. "
#~ "For cartesian, corexy, and similar printers, try measuring the z_offset at "
#~ "positions near the four corners of the bed."
#~ msgstr ""

#~ msgid ""
#~ "If the difference between the minimum reported z_offset and the maximum "
#~ "reported z_offset is greater than 25 microns (.025mm) then the probe is not "
#~ "suitable for typical bed leveling procedures. See the [Bed Level "
#~ "document](Bed_Level.md) for manual probe alternatives."
#~ msgstr ""

#~ msgid ""
#~ "Many probes have a systemic bias when probing at different temperatures. For"
#~ " example, the probe may consistently trigger at a lower height when the "
#~ "probe is at a higher temperature."
#~ msgstr ""

#~ msgid ""
#~ "To check for a temperature bias, start with the printer at room temperature "
#~ "and then home the printer, move the head to a position near the center of "
#~ "the bed, and run the `PROBE_ACCURACY` command. Note the results. Then, "
#~ "without homing or disabling the stepper motors, heat the printer nozzle and "
#~ "bed to printing temperature, and run the `PROBE_ACCURACY` command again. "
#~ "Ideally, the command will report identical results. As above, if the probe "
#~ "does have a temperature bias then be careful to always use the probe at a "
#~ "consistent temperature."
#~ msgstr ""

#~ msgid "Tuning pressure advance"
#~ msgstr ""

#~ msgid ""
#~ "In order to calibrate pressure advance the printer must be configured and "
#~ "operational as the tuning test involves printing and inspecting a test "
#~ "object. It is a good idea to read this document in full prior to running the"
#~ " test."
#~ msgstr ""

#~ msgid "Prepare for the test by issuing the following G-Code command:"
#~ msgstr ""

#~ msgid ""
#~ "This command makes the nozzle travel slower through corners to emphasize the"
#~ " effects of extruder pressure. Then for printers with a direct drive "
#~ "extruder run the command:"
#~ msgstr ""

#~ msgid "For long bowden extruders use:"
#~ msgstr ""

#~ msgid "Then print the object. When fully printed the test print looks like:"
#~ msgstr ""

#~ msgid ""
#~ "The above TUNING_TOWER command instructs Klipper to alter the "
#~ "pressure_advance setting on each layer of the print. Higher layers in the "
#~ "print will have a larger pressure advance value set. Layers below the ideal "
#~ "pressure_advance setting will have blobbing at the corners, and layers above"
#~ " the ideal setting can lead to rounded corners and poor extrusion leading up"
#~ " to the corner."
#~ msgstr ""

#~ msgid ""
#~ "Inspect the print and then use a digital calipers to find the height that "
#~ "has the best quality corners. When in doubt, prefer a lower height."
#~ msgstr ""

#~ msgid ""
#~ "The pressure_advance value can then be calculated as `pressure_advance = "
#~ "<start> + <measured_height> * <factor>`. (For example, `0 + 12.90 * .020` "
#~ "would be `.258`.)"
#~ msgstr ""

#~ msgid ""
#~ "Typical pressure advance values are between 0.050 and 1.000 (the high end "
#~ "usually only with bowden extruders). If there is no significant improvement "
#~ "with a pressure advance up to 1.000, then pressure advance is unlikely to "
#~ "improve the quality of prints. Return to a default configuration with "
#~ "pressure advance disabled."
#~ msgstr ""

#~ msgid ""
#~ "At the completion of this test, set `pressure_advance = <calculated_value>` "
#~ "in the `[extruder]` section of the configuration file and issue a RESTART "
#~ "command. The RESTART command will clear the test state and return the "
#~ "acceleration and cornering speeds to their normal values."
#~ msgstr ""

#~ msgid ""
#~ "The pressure advance value is dependent on the extruder, the nozzle, and the"
#~ " filament. It is common for filament from different manufactures or with "
#~ "different pigments to require significantly different pressure advance "
#~ "values. Therefore, one should calibrate pressure advance on each printer and"
#~ " with each spool of filament."
#~ msgstr ""

#~ msgid ""
#~ "The test print is designed to run with a high extruder flow rate, but "
#~ "otherwise \"normal\" slicer settings. A high flow rate is obtained by using "
#~ "a high printing speed (eg, 100mm/s) and a coarse layer height (typically "
#~ "around 75% of the nozzle diameter). Other slicer settings should be similar "
#~ "to their defaults (eg, perimeters of 2 or 3 lines, normal retraction "
#~ "amount). It can be useful to set the external perimeter speed to be the same"
#~ " speed as the rest of the print, but it is not a requirement."
#~ msgstr ""

#~ msgid ""
#~ "If a high pressure advance value (eg, over 0.200) is used then one may find "
#~ "that the extruder skips when returning to the printer's normal acceleration."
#~ " The pressure advance system accounts for pressure by pushing in extra "
#~ "filament during acceleration and retracting that filament during "
#~ "deceleration. With a high acceleration and high pressure advance the "
#~ "extruder may not have enough torque to push the required filament. If this "
#~ "occurs, either use a lower acceleration value or disable pressure advance."
#~ msgstr ""

#~ msgid ""
#~ "The pressure advance system does not change the timing or path of the "
#~ "toolhead. A print with pressure advance enabled will take the same amount of"
#~ " time as a print without pressure advance. Pressure advance also does not "
#~ "change the total amount of filament extruded during a print. Pressure "
#~ "advance results in extra extruder movement during move acceleration and "
#~ "deceleration. A very high pressure advance setting will result in a very "
#~ "large amount of extruder movement during acceleration and deceleration, and "
#~ "no configuration setting places a limit on the amount of that movement."
#~ msgstr ""

#~ msgid ""
#~ "Klipper is somewhat of a packaging anomaly among python programs, as it "
#~ "doesn't use setuptools to build and install. Some notes regarding how best "
#~ "to package it are as follows:"
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses a C module to handle some kinematics calculations more quickly."
#~ " This module needs to be compiled at packaging time to avoid introducing a "
#~ "runtime dependency on a compiler. To compile the C module, run `python2 "
#~ "klippy/chelper/__init__.py`."
#~ msgstr ""

#~ msgid ""
#~ "Many distributions have a policy of compiling all python code before "
#~ "packaging to improve startup time. You can do this by running `python2 -m "
#~ "compileall klippy`."
#~ msgstr ""

#~ msgid ""
#~ "If you are building a package of Klipper from git, it is usual practice not "
#~ "to ship a .git directory, so the versioning must be handled without git. To "
#~ "do this, use the script shipped in `scripts/make_version.py` which should be"
#~ " run as follows: `python2 scripts/make_version.py YOURDISTRONAME > "
#~ "klippy/.version`."
#~ msgstr ""

#~ msgid ""
#~ "klipper-git is packaged for Arch Linux, and has a PKGBUILD (package build "
#~ "script) available at [Arch User "
#~ "Repositiory](https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=klipper-"
#~ "git)."
#~ msgstr ""

#~ msgid "Overview"
#~ msgstr ""

#~ msgid "Overview information"
#~ msgstr ""

#~ msgid "[FAQ](FAQ.md): Frequently asked questions."
#~ msgstr ""

#~ msgid ""
#~ "[Config changes](Config_Changes.md): Recent software changes that may "
#~ "require users to update their printer config file."
#~ msgstr ""

#~ msgid "[Installation](Installation.md): Guide to installing Klipper."
#~ msgstr ""

#~ msgid ""
#~ "[Rotation Distance](Rotation_Distance.md): Calculating the rotation_distance"
#~ " stepper parameter."
#~ msgstr ""

#~ msgid "[Bed level](Bed_Level.md): Information on \"bed leveling\" in Klipper."
#~ msgstr ""

#~ msgid ""
#~ "[Probe calibrate](Probe_Calibrate.md): Calibration of automatic Z probes."
#~ msgstr ""

#~ msgid ""
#~ "[Manual level](Manual_Level.md): Calibration of Z endstops (and similar)."
#~ msgstr ""

#~ msgid ""
#~ "[Endstop phase](Endstop_Phase.md): Stepper assisted Z endstop positioning."
#~ msgstr ""

#~ msgid ""
#~ "[Measuring resonances](Measuring_Resonances.md): Information on using "
#~ "adxl345 accelerometer hardware to measure resonance."
#~ msgstr ""

#~ msgid "[G-Codes](G-Codes.md): Information on commands supported by Klipper."
#~ msgstr ""

#~ msgid ""
#~ "[Status Reference](Status_Reference.md): Information available to macros "
#~ "(and similar)."
#~ msgstr ""

#~ msgid ""
#~ "[Multi-MCU Homing](Multi_MCU_Homing.md): Homing and probing using multiple "
#~ "micro-controllers."
#~ msgstr ""

#~ msgid ""
#~ "[Skew correction](Skew_Correction.md): Adjustments for axes not perfectly "
#~ "square."
#~ msgstr ""

#~ msgid ""
#~ "[Exclude Object](Exclude_Object.md): The guide to the Exclude Objecs "
#~ "implementation."
#~ msgstr ""

#~ msgid ""
#~ "[Kinematics](Kinematics.md): Technical details on how Klipper implements "
#~ "motion."
#~ msgstr ""

#~ msgid ""
#~ "[API Server](API_Server.md): Information on Klipper's command and control "
#~ "API."
#~ msgstr ""

#~ msgid ""
#~ "[CAN bus protocol](CANBUS_protocol.md): Klipper CAN bus message format."
#~ msgstr ""

#~ msgid ""
#~ "[Benchmarks](Benchmarks.md): Information on the Klipper benchmark method."
#~ msgstr ""

#~ msgid "[Packaging](Packaging.md): Information on building OS packages."
#~ msgstr ""

#~ msgid ""
#~ "[SDCard Updates](SDCard_Updates.md): Flash a micro-controller by copying a "
#~ "binary to an sdcard in the micro-controller."
#~ msgstr ""

#~ msgid ""
#~ "[Beaglebone](Beaglebone.md): Details for running Klipper on the Beaglebone "
#~ "PRU."
#~ msgstr ""

#~ msgid "[CAN bus](CANBUS.md): Information on using CAN bus with Klipper."
#~ msgstr ""

#~ msgid "[Hall filament width sensor](Hall_Filament_Width_Sensor.md)"
#~ msgstr ""

#~ msgid "Configuration Reference"
#~ msgstr ""

#~ msgid "Command templates"
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports a mechanism for homing with an endstop attached to one "
#~ "micro-controller while its stepper motors are on a different micro-"
#~ "controller. This support is referred to as \"multi-mcu homing\". This "
#~ "feature is also used when a Z probe is on a different micro-controller than "
#~ "the Z stepper motors."
#~ msgstr ""

#~ msgid ""
#~ "The overshoot occurs due to possible message transmission delays between the"
#~ " micro-controller monitoring the endstop and the micro-controllers moving "
#~ "the stepper motors. The Klipper code is designed to limit this delay to no "
#~ "more than 25ms. (When multi-mcu homing is activated, the micro-controllers "
#~ "send periodic status messages and check that corresponding status messages "
#~ "are received within 25ms.)"
#~ msgstr ""

#~ msgid ""
#~ "Stepper motor overshoot should not adversely impact the precision of the "
#~ "homing and probing procedure. The Klipper code will detect the overshoot and"
#~ " account for it in its calculations. However, it is important that the "
#~ "hardware design is capable of handling overshoot without causing damage to "
#~ "the machine."
#~ msgstr ""

#~ msgid ""
#~ "Note that an axis with multiple steppers (eg, `stepper_z` and `stepper_z1`) "
#~ "need to be on the same micro-controller in order to use multi-mcu homing. "
#~ "For example, if an endstop is on a separate micro-controller from "
#~ "`stepper_z` then `stepper_z1` must be on the same micro-controller as "
#~ "`stepper_z`."
#~ msgstr ""

#~ msgid ""
#~ "Klipper has built-in support for ADXL345 accelerometer, which can be used to"
#~ " measure resonance frequencies of the printer for different axes, and auto-"
#~ "tune [input shapers](Resonance_Compensation.md) to compensate for "
#~ "resonances. Note that using ADXL345 requires some soldering and crimping. "
#~ "ADXL345 can be connected to a Raspberry Pi directly, or to an SPI interface "
#~ "of an MCU board (it needs to be reasonably fast)."
#~ msgstr ""

#~ msgid "Installation instructions"
#~ msgstr ""

#~ msgid ""
#~ "An ethernet cable with shielded twisted pairs (cat5e or better) is "
#~ "recommended for signal integrety over a long distance. If you still "
#~ "experience signal integrity issues (SPI/I2C errors), shorten the cable."
#~ msgstr ""

#~ msgid ""
#~ "***Double-check your wiring before powering up to prevent damaging your "
#~ "MCU/Raspberry Pi or the accelerometer.***"
#~ msgstr ""

#~ msgid "Suggested twisted pair order:"
#~ msgstr ""

#~ msgid "ADXL345"
#~ msgstr ""

#~ msgid ""
#~ "You need to connect ADXL345 to your Raspberry Pi via SPI. Note that the I2C "
#~ "connection, which is suggested by ADXL345 documentation, has too low "
#~ "throughput and **will not work**. The recommended connection scheme:"
#~ msgstr ""

#~ msgid "RPi pin"
#~ msgstr ""

#~ msgid "3V3 (or VCC)"
#~ msgstr ""

#~ msgid "3.3v DC power"
#~ msgstr ""

#~ msgid "Ground"
#~ msgstr ""

#~ msgid "GPIO08 (SPI0_CE0_N)"
#~ msgstr ""

#~ msgid "21"
#~ msgstr ""

#~ msgid "SDA"
#~ msgstr ""

#~ msgid "SCL"
#~ msgstr ""

#~ msgid "GPIO11 (SPI0_SCLK)"
#~ msgstr ""

#~ msgid "![ADXL345-Rpi](img/adxl345-fritzing.png)"
#~ msgstr ""

#~ msgid ""
#~ "3.3V+SDA\n"
#~ "GND+SCL\n"
#~ msgstr ""

#~ msgid ""
#~ "Alternatives to the ADXL345 are "
#~ "MPU-9250/MPU-9255/MPU-6515/MPU-6050/MPU-6500. These accelerometers have been"
#~ " tested to work over I2C on the RPi or RP2040(pico) at 400kbaud."
#~ msgstr ""

#~ msgid "MPU-9250 pin"
#~ msgstr ""

#~ msgid "09"
#~ msgstr ""

#~ msgid "GPIO02 (SDA1)"
#~ msgstr ""

#~ msgid "GPIO03 (SCL1)"
#~ msgstr ""

#~ msgid "Recommended connection scheme for I2C(i2c0a) on the RP2040:"
#~ msgstr ""

#~ msgid "3v3"
#~ msgstr ""

#~ msgid "GP0 (I2C0 SDA)"
#~ msgstr ""

#~ msgid "GP1 (I2C0 SCL)"
#~ msgstr ""

#~ msgid "Mounting the accelerometer"
#~ msgstr ""

#~ msgid "An example of mounting ADXL345 on the SmartEffector:"
#~ msgstr ""

#~ msgid ""
#~ "Note that on a bed slinger printer one must design 2 mounts: one for the "
#~ "toolhead and one for the bed, and run the measurements twice. See the "
#~ "corresponding [section](#bed-slinger-printers) for more details."
#~ msgstr ""

#~ msgid "Software installation"
#~ msgstr ""

#~ msgid ""
#~ "sudo apt update\n"
#~ "sudo apt install python3-numpy python3-matplotlib libatlas-base-dev\n"
#~ msgstr ""

#~ msgid "~/klippy-env/bin/pip install -v numpy\n"
#~ msgstr ""

#~ msgid ""
#~ "Afterwards, check and follow the instructions in the [RPi Microcontroller "
#~ "document](RPi_microcontroller.md) to setup the \"linux mcu\" on the "
#~ "Raspberry Pi."
#~ msgstr ""

#~ msgid "Add the following to the printer.cfg file:"
#~ msgstr ""

#~ msgid ""
#~ "It is advised to start with 1 probe point, in the middle of the print bed, "
#~ "slightly above it."
#~ msgstr ""

#~ msgid ""
#~ "Make sure the Linux I2C driver is enabled and the baud rate is set to 400000"
#~ " (see [Enabling I2C](RPi_microcontroller.md#optional-enabling-i2c) section "
#~ "for more details). Then, add the following to the printer.cfg:"
#~ msgstr ""

#~ msgid "Configure MPU-6000/9000 series With PICO"
#~ msgstr ""

#~ msgid ""
#~ "[mcu pico]\n"
#~ "serial: /dev/serial/by-id/<your PICO's serial ID>\n"
#~ "\n"
#~ "[mpu9250]\n"
#~ "i2c_mcu: pico\n"
#~ "i2c_bus: i2c1a\n"
#~ "\n"
#~ "[resonance_tester]\n"
#~ "accel_chip: mpu9250\n"
#~ "probe_points:\n"
#~ "    100, 100, 20  # an example\n"
#~ "\n"
#~ "[static_digital_output pico_3V3pwm] # Improve power stability\n"
#~ "pin: pico:gpio23\n"
#~ msgstr ""

#~ msgid "Measuring the resonances"
#~ msgstr ""

#~ msgid "Now you can test a connection."
#~ msgstr ""

#~ msgid ""
#~ "For \"bed-slingers\" (e.g. more than one accelerometer), enter "
#~ "`ACCELEROMETER_QUERY CHIP=<chip>` where `<chip>` is the name of the chip as-"
#~ "entered, e.g. `CHIP=bed` (see: [bed-slinger](#bed-slinger-printers)) for all"
#~ " installed accelerometer chips."
#~ msgstr ""

#~ msgid "Recv: // adxl345 values (x, y, z): 470.719200, 941.438400, 9728.196800\n"
#~ msgstr ""

#~ msgid ""
#~ "**If you are using MPU-6000/9000 series accelerometer and it show up as "
#~ "`mpu-unknown`, use with caution! They are probably refurbished chips!**"
#~ msgstr ""

#~ msgid "Now you can run some real-life tests. Run the following command:"
#~ msgstr ""

#~ msgid ""
#~ "Note that it will create vibrations on X axis. It will also disable input "
#~ "shaping if it was enabled previously, as it is not valid to run the "
#~ "resonance testing with the input shaper enabled."
#~ msgstr ""

#~ msgid ""
#~ "[resonance_tester]\n"
#~ "accel_chip: adxl345\n"
#~ "accel_per_hz: 50  # default is 75\n"
#~ "probe_points: ...\n"
#~ msgstr ""

#~ msgid "TEST_RESONANCES AXIS=Y\n"
#~ msgstr ""

#~ msgid ""
#~ "~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png\n"
#~ "~/klipper/scripts/calibrate_shaper.py /tmp/resonances_y_*.csv -o /tmp/shaper_calibrate_y.png\n"
#~ msgstr ""

#~ msgid "![Resonances](img/calibrate-y.png)"
#~ msgstr ""

#~ msgid ""
#~ "The suggested configuration can be added to `[input_shaper]` section of "
#~ "`printer.cfg`, e.g.:"
#~ msgstr ""

#~ msgid ""
#~ "or you can choose some other configuration yourself based on the generated "
#~ "charts: peaks in the power spectral density on the charts correspond to the "
#~ "resonance frequencies of the printer."
#~ msgstr ""

#~ msgid "Bed-slinger printers"
#~ msgstr ""

#~ msgid ""
#~ "However, you can also connect two accelerometers simultaneously, though they"
#~ " must be connected to different boards (say, to an RPi and printer MCU "
#~ "board), or to two different physical SPI interfaces on the same board "
#~ "(rarely available). Then they can be configured in the following manner:"
#~ msgstr ""

#~ msgid ""
#~ "Then the commands `TEST_RESONANCES AXIS=X` and `TEST_RESONANCES AXIS=Y` will"
#~ " use the correct accelerometer for each axis."
#~ msgstr ""

#~ msgid ""
#~ "Keep in mind that the input shaper can create some smoothing in parts. "
#~ "Automatic tuning of the input shaper performed by `calibrate_shaper.py` "
#~ "script or `SHAPER_CALIBRATE` command tries not to exacerbate the smoothing, "
#~ "but at the same time they try to minimize the resulting vibrations. "
#~ "Sometimes they can make a sub-optimal choice of the shaper frequency, or "
#~ "maybe you simply prefer to have less smoothing in parts at the expense of a "
#~ "larger remaining vibrations. In these cases, you can request to limit the "
#~ "maximum smoothing from the input shaper."
#~ msgstr ""

#~ msgid "![Resonances](img/calibrate-x.png)"
#~ msgstr ""

#~ msgid ""
#~ "Note that the reported `smoothing` values are some abstract projected "
#~ "values. These values can be used to compare different configurations: the "
#~ "higher the value, the more smoothing a shaper will create. However, these "
#~ "smoothing scores do not represent any real measure of smoothing, because the"
#~ " actual smoothing depends on [`max_accel`](#selecting-max-accel) and "
#~ "`square_corner_velocity` parameters. Therefore, you should print some test "
#~ "prints to see how much smoothing exactly a chosen configuration creates."
#~ msgstr ""

#~ msgid ""
#~ "~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o "
#~ "/tmp/shaper_calibrate_x.png --max_smoothing=0.2\n"
#~ msgstr ""

#~ msgid "![Resonances](img/calibrate-x-max-smoothing.png)"
#~ msgstr ""

#~ msgid ""
#~ "If you compare to the previously suggested parameters, the vibrations are a "
#~ "bit larger, but the smoothing is significantly smaller than previously, "
#~ "allowing larger maximum acceleration."
#~ msgstr ""

#~ msgid ""
#~ "Note that if you chose a good `max_smoothing` value for both of your axes, "
#~ "you can store it in the `printer.cfg` as"
#~ msgstr ""

#~ msgid ""
#~ "Then, if you [rerun](#input-shaper-re-calibration) the input shaper auto-"
#~ "tuning using `SHAPER_CALIBRATE` Klipper command in the future, it will use "
#~ "the stored `max_smoothing` value as a reference."
#~ msgstr ""

#~ msgid ""
#~ "Alternatively, follow [this](Resonance_Compensation.md#selecting-max_accel) "
#~ "part of the input shaper tuning guide and print the test model to choose "
#~ "`max_accel` parameter experimentally."
#~ msgstr ""

#~ msgid ""
#~ "If you are doing a shaper re-calibration and the reported smoothing for the "
#~ "suggested shaper configuration is almost the same as what you got during the"
#~ " previous calibration, this step can be skipped."
#~ msgstr ""

#~ msgid ""
#~ "`TEST_RESONANCES` command supports custom axes. While this is not really "
#~ "useful for input shaper calibration, it can be used to study printer "
#~ "resonances in-depth and to check, for example, belt tension."
#~ msgstr ""

#~ msgid ""
#~ "TEST_RESONANCES AXIS=1,1 OUTPUT=raw_data\n"
#~ "TEST_RESONANCES AXIS=1,-1 OUTPUT=raw_data\n"
#~ msgstr ""

#~ msgid ""
#~ "~/klipper/scripts/graph_accelerometer.py -c /tmp/raw_data_axis*.csv -o "
#~ "/tmp/resonances.png\n"
#~ msgstr ""

#~ msgid ""
#~ "For Delta printers with the default tower placement (tower A ~= 210 degrees,"
#~ " B ~= 330 degrees, and C ~= 90 degrees), execute"
#~ msgstr ""

#~ msgid "and then use the same command"
#~ msgstr ""

#~ msgid "Input Shaper auto-calibration"
#~ msgstr ""

#~ msgid "SHAPER_CALIBRATE\n"
#~ msgstr ""

#~ msgid ""
#~ "Calculating the best input shaper parameters for y axis\n"
#~ "Fitted shaper 'zv' frequency = 39.0 Hz (vibrations = 13.2%, smoothing ~= 0.105)\n"
#~ "To avoid too much smoothing with 'zv', suggested max_accel <= 5900 mm/sec^2\n"
#~ "Fitted shaper 'mzv' frequency = 36.8 Hz (vibrations = 1.7%, smoothing ~= 0.150)\n"
#~ "To avoid too much smoothing with 'mzv', suggested max_accel <= 4000 mm/sec^2\n"
#~ "Fitted shaper 'ei' frequency = 36.6 Hz (vibrations = 2.2%, smoothing ~= 0.240)\n"
#~ "To avoid too much smoothing with 'ei', suggested max_accel <= 2500 mm/sec^2\n"
#~ "Fitted shaper '2hump_ei' frequency = 48.0 Hz (vibrations = 0.0%, smoothing ~= 0.234)\n"
#~ "To avoid too much smoothing with '2hump_ei', suggested max_accel <= 2500 mm/sec^2\n"
#~ "Fitted shaper '3hump_ei' frequency = 59.0 Hz (vibrations = 0.0%, smoothing ~= 0.235)\n"
#~ "To avoid too much smoothing with '3hump_ei', suggested max_accel <= 2500 mm/sec^2\n"
#~ "Recommended shaper_type_y = mzv, shaper_freq_y = 36.8 Hz\n"
#~ msgstr ""

#~ msgid ""
#~ "If your printer is a bed slinger printer, you can specify which axis to "
#~ "test, so that you can change the accelerometer mounting point between the "
#~ "tests (by default the test is performed for both axes):"
#~ msgstr ""

#~ msgid "You can execute `SAVE_CONFIG` twice - after calibrating each axis."
#~ msgstr ""

#~ msgid "Input Shaper re-calibration"
#~ msgstr ""

#~ msgid "SHAPER_CALIBRATE AXIS=X\n"
#~ msgstr ""

#~ msgid ""
#~ "Also, due to some noise in measurements, it is possible that the tuning "
#~ "results will be slightly different from one calibration run to another one. "
#~ "Still, it is not expected that the noise will affect the print quality too "
#~ "much. However, it is still advised to double-check the suggested parameters,"
#~ " and print some test prints before using them to confirm they are good."
#~ msgstr ""

#~ msgid ""
#~ "It is possible to generate the raw accelerometer data and process it offline"
#~ " (e.g. on a host machine), for example to find resonances. In order to do "
#~ "so, run the following commands via Octoprint terminal:"
#~ msgstr ""

#~ msgid ""
#~ "ignoring any errors for `SET_INPUT_SHAPER` command. For `TEST_RESONANCES` "
#~ "command, specify the desired test axis. The raw data will be written into "
#~ "`/tmp` directory on the RPi."
#~ msgstr ""

#~ msgid ""
#~ "The data can be processed later by the following scripts: "
#~ "`scripts/graph_accelerometer.py` and `scripts/calibrate_shaper.py`. Both of "
#~ "them accept one or several raw csv files as the input depending on the mode."
#~ " The graph_accelerometer.py script supports several modes of operation:"
#~ msgstr ""

#~ msgid ""
#~ "plotting a frequency response (no extra parameters required), if multiple "
#~ "inputs are specified, the average frequency response is computed;"
#~ msgstr ""

#~ msgid ""
#~ "plotting the spectrogram (use `-s` parameter), only 1 input is supported; "
#~ "you can additionally specify which accelerometer axis to consider via `-a "
#~ "x`, `-a y` or `-a z` parameter (if none specified, the sum of vibrations for"
#~ " all axes is used)."
#~ msgstr ""

#~ msgid "For example,"
#~ msgstr ""

#~ msgid ""
#~ "will plot the comparison of several `/tmp/raw_data_x_*.csv` files for Z axis"
#~ " to `/tmp/resonances_x.png` file."
#~ msgstr ""

#~ msgid ""
#~ "Providing several inputs to shaper_calibrate.py script can be useful if "
#~ "running some advanced tuning of the input shapers, for example:"
#~ msgstr ""

#~ msgid ""
#~ "Running `TEST_RESONANCES AXIS=Y OUTPUT=raw_data` twice on a bed slinger with"
#~ " a glass bed and a magnetic surfaces (which is lighter) to find the input "
#~ "shaper parameters that work well for any print surface configuration."
#~ msgstr ""

#~ msgid ""
#~ "Combining the resonance data from 2 axis (e.g. on a bed slinger printer to "
#~ "configure X-axis input_shaper from both X and Y axes resonances to cancel "
#~ "vibrations of the *bed* in case the nozzle 'catches' a print when moving in "
#~ "X axis direction)."
#~ msgstr ""

#~ msgid ""
#~ "This document describes tools for calibrating a Z endstop and for performing"
#~ " adjustments to bed leveling screws."
#~ msgstr ""

#~ msgid ""
#~ "An accurate Z endstop position is critical to obtaining high quality prints."
#~ msgstr ""

#~ msgid ""
#~ "To perform a Z endstop calibration, home the printer, command the head to "
#~ "move to a Z position that is at least five millimeters above the bed (if it "
#~ "is not already), command the head to move to an XY position near the center "
#~ "of the bed, then navigate to the OctoPrint terminal tab and run:"
#~ msgstr ""

#~ msgid ""
#~ "Then follow the steps described at [\"the paper test\"](Bed_Level.md#the-"
#~ "paper-test) to determine the actual distance between the nozzle and bed at "
#~ "the given location. Once those steps are complete one can `ACCEPT` the "
#~ "position and save the results to the config file with:"
#~ msgstr ""

#~ msgid ""
#~ "Some printers have the ability to manually adjust the location of the "
#~ "physical endstop switch. However, it's recommended to perform Z endstop "
#~ "positioning in software with Klipper - once the physical location of the "
#~ "endstop is in a convenient location, one can make any further adjustments by"
#~ " running Z_ENDSTOP_CALIBRATE or by manually updating the Z position_endstop "
#~ "in the configuration file."
#~ msgstr ""

#~ msgid ""
#~ "The secret to getting good bed leveling with bed leveling screws is to "
#~ "utilize the printer's high precision motion system during the bed leveling "
#~ "process itself. This is done by commanding the nozzle to a position near "
#~ "each bed screw and then adjusting that screw until the bed is a set distance"
#~ " from the nozzle. Klipper has a tool to assist with this. In order to use "
#~ "the tool it is necessary to specify each screw XY location."
#~ msgstr ""

#~ msgid ""
#~ "[bed_screws]\n"
#~ "screw1: 100, 50\n"
#~ "screw2: 100, 150\n"
#~ "screw3: 150, 100\n"
#~ msgstr ""

#~ msgid ""
#~ "Once the config file is ready, run `RESTART` to load that config, and then "
#~ "one can start the tool by running:"
#~ msgstr ""

#~ msgid ""
#~ "This tool will move the printer's nozzle to each screw XY location and then "
#~ "move the nozzle to a Z=0 height. At this point one can use the \"paper "
#~ "test\" to adjust the bed screw directly under the nozzle. See the "
#~ "information described in [\"the paper test\"](Bed_Level.md#the-paper-test), "
#~ "but adjust the bed screw instead of commanding the nozzle to different "
#~ "heights. Adjust the bed screw until there is a small amount of friction when"
#~ " pushing the paper back and forth."
#~ msgstr ""

#~ msgid ""
#~ "This system works best when the printer has a flat printing surface (such as"
#~ " glass) and has straight rails. Upon successful completion of the bed "
#~ "leveling tool the bed should be ready for printing."
#~ msgstr ""

#~ msgid ""
#~ "If the printer uses three bed screws and all three screws are under the bed,"
#~ " then it may be possible to perform a second \"high precision\" bed leveling"
#~ " step. This is done by commanding the nozzle to locations where the bed "
#~ "moves a larger distance with each bed screw adjustment."
#~ msgstr ""

#~ msgid "![bed_screws](img/bed_screws.svg.png)"
#~ msgstr ""

#~ msgid ""
#~ "To enable this feature, one would determine the additional nozzle "
#~ "coordinates and add them to the config file. For example, it might look "
#~ "like:"
#~ msgstr ""

#~ msgid ""
#~ "When this feature is enabled, the `BED_SCREWS_ADJUST` tool will first prompt"
#~ " for coarse adjustments directly above each screw position, and once those "
#~ "are accepted, it will prompt for fine adjustments at the additional "
#~ "locations. Continue to use `ACCEPT` and `ADJUSTED` at each position."
#~ msgstr ""

#~ msgid ""
#~ "This is another way to calibrate the bed level using the bed probe. To use "
#~ "it you must have a Z probe (BL Touch, Inductive sensor, etc)."
#~ msgstr ""

#~ msgid ""
#~ "[screws_tilt_adjust]\n"
#~ "screw1: -5, 30\n"
#~ "screw1_name: front left screw\n"
#~ "screw2: 155, 30\n"
#~ "screw2_name: front right screw\n"
#~ "screw3: 155, 190\n"
#~ "screw3_name: rear right screw\n"
#~ "screw4: -5, 190\n"
#~ "screw4_name: rear left screw\n"
#~ "horizontal_move_z: 10.\n"
#~ "speed: 50.\n"
#~ "screw_thread: CW-M3\n"
#~ msgstr ""

#~ msgid ""
#~ "Send: G28\n"
#~ "Recv: ok\n"
#~ "Send: SCREWS_TILT_CALCULATE\n"
#~ "Recv: // 01:20 means 1 full turn and 20 minutes, CW=clockwise, CCW=counter-clockwise\n"
#~ "Recv: // front left screw (base) : x=-5.0, y=30.0, z=2.48750\n"
#~ "Recv: // front right screw : x=155.0, y=30.0, z=2.36000 : adjust CW 01:15\n"
#~ "Recv: // rear right screw : y=155.0, y=190.0, z=2.71500 : adjust CCW 00:50\n"
#~ "Recv: // read left screw : x=-5.0, y=190.0, z=2.47250 : adjust CW 00:02\n"
#~ "Recv: ok\n"
#~ msgstr ""

#~ msgid "front left screw is the reference point you must not change it."
#~ msgstr ""

#~ msgid "rear right screw must be turned counter-clockwise 50 minutes"
#~ msgstr ""

#~ msgid ""
#~ "Note that \"minutes\" refers to \"minutes of a clock face\". So, for "
#~ "example, 15 minutes is a quarter of a full turn."
#~ msgstr ""

#~ msgid ""
#~ "If using a probe that is mounted on the side of the hotend (that is, it has "
#~ "an X or Y offset) then note that adjusting the bed tilt will invalidate any "
#~ "previous probe calibration that was performed with a tilted bed. Be sure to "
#~ "run [probe calibration](Probe_Calibrate.md) after the bed screws have been "
#~ "adjusted."
#~ msgstr ""

#~ msgid ""
#~ "The `DIRECTION` parameter is useful if you can turn your bed adjustment "
#~ "screws in one direction only. For example, you might have screws that start "
#~ "tightened in their lowest (or highest) possible position, which can only be "
#~ "turned in a single direction, to raise (or lower) the bed. If you can only "
#~ "turn the screws clockwise, run `SCREWS_TILT_CALCULATE DIRECTION=CW`. If you "
#~ "can only turn them counter-clockwise, run `SCREWS_TILT_CALCULATE "
#~ "DIRECTION=CCW`. A suitable reference point will be chosen such that the bed "
#~ "can be leveled by turning all the screws in the given direction."
#~ msgstr ""

#~ msgid ""
#~ "This document provides information on the low-level micro-controller "
#~ "commands that are sent from the Klipper \"host\" software and processed by "
#~ "the Klipper micro-controller software. This document is not an authoritative"
#~ " reference for these commands, nor is it an exclusive list of all available "
#~ "commands."
#~ msgstr ""

#~ msgid ""
#~ "See the [protocol](Protocol.md) document for more information on the format "
#~ "of commands and their transmission. The commands here are described using "
#~ "their \"printf\" style syntax - for those unfamiliar with that format, just "
#~ "note that where a '%...' sequence is seen it should be replaced with an "
#~ "actual integer. For example, a description with \"count=%c\" could be "
#~ "replaced with the text \"count=10\". Note that parameters that are "
#~ "considered \"enumerations\" (see the above protocol document) take a string "
#~ "value which is automatically converted to an integer value for the micro-"
#~ "controller. This is common with parameters named \"pin\" (or that have a "
#~ "suffix of \"_pin\")."
#~ msgstr ""

#~ msgid ""
#~ "It may be necessary to take certain one-time actions to configure the micro-"
#~ "controller and its peripherals. This section lists common commands available"
#~ " for that purpose. Unlike most micro-controller commands, these commands run"
#~ " as soon as they are received and they do not require any particular setup."
#~ msgstr ""

#~ msgid ""
#~ "`set_digital_out pin=%u value=%c` : This command immediately configures the "
#~ "given pin as a digital out GPIO and it sets it to either a low level "
#~ "(value=0) or a high level (value=1). This command may be useful for "
#~ "configuring the initial value of LEDs and for configuring the initial value "
#~ "of stepper driver micro-stepping pins."
#~ msgstr ""

#~ msgid "Low-level micro-controller configuration"
#~ msgstr ""

#~ msgid ""
#~ "When the host first connects to the micro-controller it always starts by "
#~ "obtaining a data dictionary (see [protocol](Protocol.md) for more "
#~ "information). After the data dictionary is obtained the host will check if "
#~ "the micro-controller is in a \"configured\" state and configure it if not. "
#~ "Configuration involves the following phases:"
#~ msgstr ""

#~ msgid ""
#~ "`allocate_oids count=%c` : This command is issued to inform the micro-"
#~ "controller of the maximum number of object-ids (oid) that the host requires."
#~ " It is only valid to issue this command once. An oid is an integer "
#~ "identifier allocated to each stepper, each endstop, and each schedulable "
#~ "gpio pin. The host determines in advance the number of oids it will require "
#~ "to operate the hardware and passes this to the micro-controller so that it "
#~ "may allocate sufficient memory to store a mapping from oid to internal "
#~ "object."
#~ msgstr ""

#~ msgid ""
#~ "`finalize_config crc=%u` : The finalize_config command transitions the "
#~ "micro-controller from an unconfigured state to a configured state. The crc "
#~ "parameter passed to the micro-controller is stored and provided back to the "
#~ "host in \"config\" response messages. By convention, the host takes a 32bit "
#~ "CRC of the configuration it will request and at the start of subsequent "
#~ "communication sessions it checks that the CRC stored in the micro-controller"
#~ " exactly matches its desired CRC. If the CRC does not match then the host "
#~ "knows the micro-controller has not been configured in the state desired by "
#~ "the host."
#~ msgstr ""

#~ msgid "This section lists some commonly used config commands."
#~ msgstr ""

#~ msgid ""
#~ "`config_pwm_out oid=%c pin=%u cycle_ticks=%u value=%hu default_value=%hu "
#~ "max_duration=%u` : This command creates an internal object for hardware "
#~ "based PWM pins that the host may schedule updates for. Its usage is "
#~ "analogous to config_digital_out - see the description of the 'set_pwm_out' "
#~ "and 'config_digital_out' commands for parameter description."
#~ msgstr ""

#~ msgid ""
#~ "`config_stepper oid=%c step_pin=%c dir_pin=%c invert_step=%c "
#~ "step_pulse_ticks=%u` : This command creates an internal stepper object. The "
#~ "'step_pin' and 'dir_pin' parameters specify the step and direction pins "
#~ "respectively; this command will configure them in digital output mode. The "
#~ "'invert_step' parameter specifies whether a step occurs on a rising edge "
#~ "(invert_step=0) or falling edge (invert_step=1). The 'step_pulse_ticks' "
#~ "parameter specifies the minimum duration of the step pulse. If the mcu "
#~ "exports the constant 'STEPPER_BOTH_EDGE=1' then setting step_pulse_ticks=0 "
#~ "and invert_step=-1 will setup for stepping on both the rising and falling "
#~ "edges of the step pin."
#~ msgstr ""

#~ msgid ""
#~ "`config_spi oid=%c bus=%u pin=%u mode=%u rate=%u shutdown_msg=%*s` : This "
#~ "command creates an internal SPI object. It is used with spi_transfer and "
#~ "spi_send commands (see below). The \"bus\" identifies the SPI bus to use (if"
#~ " the micro-controller has more than one SPI bus available). The \"pin\" "
#~ "specifies the chip select (CS) pin for the device. The \"mode\" is the SPI "
#~ "mode (should be between 0 and 3). The \"rate\" parameter specifies the SPI "
#~ "bus rate (in cycles per second). Finally, the \"shutdown_msg\" is an SPI "
#~ "command to send to the given device should the micro-controller go into a "
#~ "shutdown state."
#~ msgstr ""

#~ msgid "Common commands"
#~ msgstr ""

#~ msgid ""
#~ "`set_digital_out_pwm_cycle oid=%c cycle_ticks=%u` : This command configures "
#~ "a digital output pin (as created by config_digital_out) to use \"software "
#~ "PWM\". The 'cycle_ticks' is the number of clock ticks for the PWM cycle. "
#~ "Because the output switching is implemented in the micro-controller "
#~ "software, it is recommended that 'cycle_ticks' correspond to a time of 10ms "
#~ "or greater."
#~ msgstr ""

#~ msgid ""
#~ "`queue_pwm_out oid=%c clock=%u value=%hu` : Schedules a change to a hardware"
#~ " PWM output pin. See the 'queue_digital_out' and 'config_pwm_out' commands "
#~ "for more info."
#~ msgstr ""

#~ msgid ""
#~ "`get_clock` : This command causes the micro-controller to generate a "
#~ "\"clock\" response message. The host sends this command once a second to "
#~ "obtain the value of the micro-controller clock and to estimate the drift "
#~ "between host and micro-controller clocks. It enables the host to accurately "
#~ "estimate the micro-controller clock."
#~ msgstr ""

#~ msgid ""
#~ "`queue_step oid=%c interval=%u count=%hu add=%hi` : This command schedules "
#~ "'count' number of steps for the given stepper, with 'interval' number of "
#~ "clock ticks between each step. The first step will be 'interval' number of "
#~ "clock ticks since the last scheduled step for the given stepper. If 'add' is"
#~ " non-zero then the interval will be adjusted by 'add' amount after each "
#~ "step. This command appends the given interval/count/add sequence to a per-"
#~ "stepper queue. There may be hundreds of these sequences queued during normal"
#~ " operation. New sequence are appended to the end of the queue and as each "
#~ "sequence completes its 'count' number of steps it is popped from the front "
#~ "of the queue. This system allows the micro-controller to queue potentially "
#~ "hundreds of thousands of steps - all with reliable and predictable schedule "
#~ "times."
#~ msgstr ""

#~ msgid ""
#~ "`reset_step_clock oid=%c clock=%u` : Normally, step timing is relative to "
#~ "the last step for a given stepper. This command resets the clock so that the"
#~ " next step is relative to the supplied 'clock' time. The host usually only "
#~ "sends this command at the start of a print."
#~ msgstr ""

#~ msgid ""
#~ "`endstop_home oid=%c clock=%u sample_ticks=%u sample_count=%c rest_ticks=%u "
#~ "pin_value=%c` : This command is used during stepper \"homing\" operations. "
#~ "To use this command a 'config_endstop' command with the same 'oid' parameter"
#~ " must have been issued during micro-controller configuration. When this "
#~ "command is invoked, the micro-controller will sample the endstop pin every "
#~ "'rest_ticks' clock ticks and check if it has a value equal to 'pin_value'. "
#~ "If the value matches (and it continues to match for 'sample_count' "
#~ "additional samples spread 'sample_ticks' apart) then the movement queue for "
#~ "the associated stepper will be cleared and the stepper will come to an "
#~ "immediate halt. The host uses this command to implement homing - the host "
#~ "instructs the endstop to sample for the endstop trigger and then it issues a"
#~ " series of queue_step commands to move a stepper towards the endstop. Once "
#~ "the stepper hits the endstop, the trigger will be detected, the movement "
#~ "halted, and the host notified."
#~ msgstr ""

#~ msgid ""
#~ "Each queue_step command utilizes an entry in the micro-controller \"move "
#~ "queue\". This queue is allocated when it receives the \"finalize_config\" "
#~ "command, and it reports the number of available queue entries in \"config\" "
#~ "response messages."
#~ msgstr ""

#~ msgid "SPI Commands"
#~ msgstr ""

#~ msgid ""
#~ "`spi_send oid=%c data=%*s` : This command is similar to \"spi_transfer\", "
#~ "but it does not generate a \"spi_transfer_response\" message."
#~ msgstr ""

#~ msgid ""
#~ "This document provides an overview of how Klipper implements robot motion "
#~ "(its [kinematics](https://en.wikipedia.org/wiki/Kinematics)). The contents "
#~ "may be of interest to both developers interested in working on the Klipper "
#~ "software as well as users interested in better understanding the mechanics "
#~ "of their machines."
#~ msgstr ""

#~ msgid ""
#~ "Klipper implements a constant acceleration scheme whenever the print head "
#~ "changes velocity - the velocity is gradually changed to the new speed "
#~ "instead of suddenly jerking to it. Klipper always enforces acceleration "
#~ "between the tool head and the print. The filament leaving the extruder can "
#~ "be quite fragile - rapid jerks and/or extruder flow changes lead to poor "
#~ "quality and poor bed adhesion. Even when not extruding, if the print head is"
#~ " at the same level as the print then rapid jerking of the head can cause "
#~ "disruption of recently deposited filament. Limiting speed changes of the "
#~ "print head (relative to the print) reduces risks of disrupting the print."
#~ msgstr ""

#~ msgid ""
#~ "Klipper implements constant acceleration. The key formula for constant "
#~ "acceleration is:"
#~ msgstr ""

#~ msgid "Trapezoid generator"
#~ msgstr ""

#~ msgid "![trapezoid](img/trapezoid.svg.png)"
#~ msgstr ""

#~ msgid ""
#~ "The cruising speed is always greater than or equal to both the start speed "
#~ "and the end speed. The acceleration phase may be of zero duration (if the "
#~ "start speed is equal to the cruising speed), the cruising phase may be of "
#~ "zero duration (if the move immediately starts decelerating after "
#~ "acceleration), and/or the deceleration phase may be of zero duration (if the"
#~ " end speed is equal to the cruising speed)."
#~ msgstr ""

#~ msgid "Look-ahead"
#~ msgstr ""

#~ msgid "Consider the following two moves contained on an XY plane:"
#~ msgstr ""

#~ msgid ""
#~ "In the above situation it is possible to fully decelerate after the first "
#~ "move and then fully accelerate at the start of the next move, but that is "
#~ "not ideal as all that acceleration and deceleration would greatly increase "
#~ "the print time and the frequent changes in extruder flow would result in "
#~ "poor print quality."
#~ msgstr ""

#~ msgid "![lookahead](img/lookahead.svg.png)"
#~ msgstr ""

#~ msgid "![lookahead](img/lookahead-slow.svg.png)"
#~ msgstr ""

#~ msgid "Key formula for look-ahead:"
#~ msgstr ""

#~ msgid "Smoothed look-ahead"
#~ msgstr ""

#~ msgid "![zigzag](img/zigzag.svg.png)"
#~ msgstr ""

#~ msgid "![smoothed](img/smoothed.svg.png)"
#~ msgstr ""

#~ msgid "Generating steps"
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
#~ "finding_algorithm) to generate the step times for each stepper. The code "
#~ "contains the formulas to calculate the ideal cartesian coordinates of the "
#~ "head at each moment in time, and it has the kinematic formulas to calculate "
#~ "the ideal stepper positions based on those cartesian coordinates. With these"
#~ " formulas, Klipper can determine the ideal time that the stepper should be "
#~ "at each step position. The given steps are then scheduled at these "
#~ "calculated times."
#~ msgstr ""

#~ msgid "move_distance = (start_velocity + .5 * accel * move_time) * move_time\n"
#~ msgstr ""

#~ msgid "move_distance = cruise_velocity * move_time\n"
#~ msgstr ""

#~ msgid ""
#~ "cartesian_x_position = start_x + move_distance * total_x_movement / total_movement\n"
#~ "cartesian_y_position = start_y + move_distance * total_y_movement / total_movement\n"
#~ "cartesian_z_position = start_z + move_distance * total_z_movement / total_movement\n"
#~ msgstr ""

#~ msgid ""
#~ "Generating steps for cartesian printers is the simplest case. The movement "
#~ "on each axis is directly related to the movement in cartesian space."
#~ msgstr ""

#~ msgid ""
#~ "stepper_x_position = cartesian_x_position\n"
#~ "stepper_y_position = cartesian_y_position\n"
#~ "stepper_z_position = cartesian_z_position\n"
#~ msgstr ""

#~ msgid ""
#~ "Generating steps on a CoreXY machine is only a little more complex than "
#~ "basic cartesian robots. The key formulas are:"
#~ msgstr ""

#~ msgid "Delta Robots"
#~ msgstr ""

#~ msgid ""
#~ "stepper_position = (sqrt(arm_length^2\n"
#~ "                         - (cartesian_x_position - tower_x_position)^2\n"
#~ "                         - (cartesian_y_position - tower_y_position)^2)\n"
#~ "                    + cartesian_z_position)\n"
#~ msgstr ""

#~ msgid ""
#~ "With delta kinematics it is possible for a move that is accelerating in "
#~ "cartesian space to require an acceleration on a particular stepper motor "
#~ "greater than the move's acceleration. This can occur when a stepper arm is "
#~ "more horizontal than vertical and the line of movement passes near that "
#~ "stepper's tower. Although these moves could require a stepper motor "
#~ "acceleration greater than the printer's maximum configured move "
#~ "acceleration, the effective mass moved by that stepper would be smaller. "
#~ "Thus the higher stepper acceleration does not result in significantly higher"
#~ " stepper torque and it is therefore considered harmless."
#~ msgstr ""

#~ msgid "Extruder kinematics"
#~ msgstr ""

#~ msgid ""
#~ "Basic extruder movement is simple to calculate. The step time generation "
#~ "uses the same formulas that cartesian robots use:"
#~ msgstr ""

#~ msgid ""
#~ "Experimentation has shown that it's possible to improve the modeling of the "
#~ "extruder beyond the basic extruder formula. In the ideal case, as an "
#~ "extrusion move progresses, the same volume of filament should be deposited "
#~ "at each point along the move and there should be no volume extruded after "
#~ "the move. Unfortunately, it's common to find that the basic extrusion "
#~ "formulas cause too little filament to exit the extruder at the start of "
#~ "extrusion moves and for excess filament to extrude after extrusion ends. "
#~ "This is often referred to as \"ooze\"."
#~ msgstr ""

#~ msgid ""
#~ "The \"pressure advance\" system attempts to account for this by using a "
#~ "different model for the extruder. Instead of naively believing that each "
#~ "mm^3 of filament fed into the extruder will result in that amount of mm^3 "
#~ "immediately exiting the extruder, it uses a model based on pressure. "
#~ "Pressure increases when filament is pushed into the extruder (as in [Hooke's"
#~ " law](https://en.wikipedia.org/wiki/Hooke%27s_law)) and the pressure "
#~ "necessary to extrude is dominated by the flow rate through the nozzle "
#~ "orifice (as in [Poiseuille's "
#~ "law](https://en.wikipedia.org/wiki/Poiseuille_law)). The key idea is that "
#~ "the relationship between filament, pressure, and flow rate can be modeled "
#~ "using a linear coefficient:"
#~ msgstr ""

#~ msgid ""
#~ "See the [pressure advance](Pressure_Advance.md) document for information on "
#~ "how to find this pressure advance coefficient."
#~ msgstr ""

#~ msgid "![pressure-advance](img/pressure-velocity.png)"
#~ msgstr ""

#~ msgid ""
#~ "The \"smoothing\" is implemented using a weighted average of the extruder "
#~ "position over a small time period (as specified by the "
#~ "`pressure_advance_smooth_time` config parameter). This averaging can span "
#~ "multiple g-code moves. Note how the extruder motor will start moving prior "
#~ "to the nominal start of the first extrusion move and will continue to move "
#~ "after the nominal end of the last extrusion move."
#~ msgstr ""

#~ msgid ""
#~ "smooth_pa_position(t) =\n"
#~ "    ( definitive_integral(pa_position(x) * (smooth_time/2 - abs(t - x)) * dx,\n"
#~ "                          from=t-smooth_time/2, to=t+smooth_time/2)\n"
#~ "     / (smooth_time/2)^2 )\n"
#~ msgstr ""

#~ msgid ""
#~ "These instructions assume the software will run on a Raspberry Pi computer "
#~ "in conjunction with OctoPrint. It is recommended that a Raspberry Pi 2, 3, "
#~ "or 4 computer be used as the host machine (see the [FAQ](FAQ.md#can-i-run-"
#~ "klipper-on-something-other-than-a-raspberry-pi-3) for other machines)."
#~ msgstr ""

#~ msgid ""
#~ "Most Klipper settings are determined by a \"printer configuration file\" "
#~ "that will be stored on the Raspberry Pi. An appropriate configuration file "
#~ "can often be found by looking in the Klipper [config directory](../config/) "
#~ "for a file starting with a \"printer-\" prefix that corresponds to the "
#~ "target printer. The Klipper configuration file contains technical "
#~ "information about the printer that will be needed during the installation."
#~ msgstr ""

#~ msgid ""
#~ "If no configuration file for the printer can be found, but the type of "
#~ "printer control board is known, then look for an appropriate [config "
#~ "file](../config/) starting with a \"generic-\" prefix. These example printer"
#~ " board files should allow one to successfully complete the initial "
#~ "installation, but will require some customization to obtain full printer "
#~ "functionality."
#~ msgstr ""

#~ msgid "Prepping an OS image"
#~ msgstr ""

#~ msgid ""
#~ "After installing OctoPi and upgrading OctoPrint, it will be necessary to ssh"
#~ " into the target machine to run a handful of system commands. If using a "
#~ "Linux or MacOS desktop, then the \"ssh\" software should already be "
#~ "installed on the desktop. There are free ssh clients available for other "
#~ "desktops (eg, [PuTTY](https://www.chiark.greenend.org.uk/~sgtatham/putty/))."
#~ " Use the ssh utility to connect to the Raspberry Pi (ssh pi@octopi -- "
#~ "password is \"raspberry\") and run the following commands:"
#~ msgstr ""

#~ msgid ""
#~ "The above will download Klipper, install some system dependencies, setup "
#~ "Klipper to run at system startup, and start the Klipper host software. It "
#~ "will require an internet connection and it may take a few minutes to "
#~ "complete."
#~ msgstr ""

#~ msgid ""
#~ "To compile the micro-controller code, start by running these commands on the"
#~ " Raspberry Pi:"
#~ msgstr ""

#~ msgid "make\n"
#~ msgstr ""

#~ msgid ""
#~ "Otherwise, the following steps are often used to \"flash\" the printer "
#~ "control board. First, it is necessary to determine the serial port connected"
#~ " to the micro-controller. Run the following:"
#~ msgstr ""

#~ msgid "It should report something similar to the following:"
#~ msgstr ""

#~ msgid ""
#~ "For common micro-controllers, the code can be flashed with something similar"
#~ " to:"
#~ msgstr ""

#~ msgid ""
#~ "When flashing for the first time, make sure that OctoPrint is not connected "
#~ "directly to the printer (from the OctoPrint web page, under the "
#~ "\"Connection\" section, click \"Disconnect\")."
#~ msgstr ""

#~ msgid ""
#~ "The OctoPrint web server needs to be configured to communicate with the "
#~ "Klipper host software. Using a web browser, login to the OctoPrint web page "
#~ "and then configure the following items:"
#~ msgstr ""

#~ msgid ""
#~ "Enter the Settings tab again and under \"Serial Connection\" change the "
#~ "\"Serial Port\" setting to \"/tmp/printer\"."
#~ msgstr ""

#~ msgid ""
#~ "From the main page, under the \"Connection\" section (at the top left of the"
#~ " page) make sure the \"Serial Port\" is set to \"/tmp/printer\" and click "
#~ "\"Connect\". (If \"/tmp/printer\" is not an available selection then try "
#~ "reloading the page.)"
#~ msgstr ""

#~ msgid ""
#~ "The next step is to copy the [printer configuration file](#obtain-a-klipper-"
#~ "configuration-file) to the Raspberry Pi."
#~ msgstr ""

#~ msgid ""
#~ "Alternatively, one can also copy and edit the file directly on the Raspberry"
#~ " Pi via ssh. That may look something like the following (be sure to update "
#~ "the command to use the appropriate printer config filename):"
#~ msgstr ""

#~ msgid ""
#~ "It's common for each printer to have its own unique name for the micro-"
#~ "controller. The name may change after flashing Klipper, so rerun these steps"
#~ " again even if they were already done when flashing. Run:"
#~ msgstr ""

#~ msgid ""
#~ "After creating and editing the file it will be necessary to issue a "
#~ "\"restart\" command in the OctoPrint web terminal to load the config. A "
#~ "\"status\" command will report the printer is ready if the Klipper config "
#~ "file is successfully read and the micro-controller is successfully found and"
#~ " configured."
#~ msgstr ""

#~ msgid ""
#~ "Klipper reports error messages via the OctoPrint terminal tab. The "
#~ "\"status\" command can be used to re-report error messages. The default "
#~ "Klipper startup script also places a log in **/tmp/klippy.log** which "
#~ "provides more detailed information."
#~ msgstr ""

#~ msgid ""
#~ "This document describes Filament Width Sensor host module. Hardware used for"
#~ " developing this host module is based on two Hall linear sensors (ss49e for "
#~ "example). Sensors in the body are located opposite sides. Principle of "
#~ "operation: two hall sensors work in differential mode, temperature drift "
#~ "same for sensor. Special temperature compensation not needed."
#~ msgstr ""

#~ msgid ""
#~ "To use Hall filament width sensor, read [Config "
#~ "Reference](Config_Reference.md#hall_filament_width_sensor) and [G-Code "
#~ "documentation](G-Codes.md#hall_filament_width_sensor)."
#~ msgstr ""

#~ msgid "Template for menu variables"
#~ msgstr ""

#~ msgid "Calibration procedure"
#~ msgstr ""

#~ msgid "Insert first calibration rod (1.5 mm size) get first raw sensor value"
#~ msgstr ""

#~ msgid "Save raw sensor values in config parameter `Raw_dia1` and `Raw_dia2`"
#~ msgstr ""

#~ msgid "By default, the sensor is disabled at power-on."
#~ msgstr ""

#~ msgid "Logging"
#~ msgstr ""

#~ msgid ""
#~ "Issue **ENABLE_FILAMENT_WIDTH_LOG** command to start logging and issue "
#~ "**DISABLE_FILAMENT_WIDTH_LOG** command to stop logging. To enable logging at"
#~ " power-on, set the `logging` parameter to `true`."
#~ msgstr ""

#~ msgid ""
#~ "This document describes the commands that Klipper supports. These are "
#~ "commands that one may enter into the OctoPrint terminal tab."
#~ msgstr ""

#~ msgid "Klipper supports the following standard G-Code commands:"
#~ msgstr ""

#~ msgid "Dwell: `G4 P<milliseconds>`"
#~ msgstr ""

#~ msgid "Turn off motors: `M18` or `M84`"
#~ msgstr ""

#~ msgid "Use absolute/relative distances for extrusion: `M82`, `M83`"
#~ msgstr ""

#~ msgid "Set position: `G92 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>]`"
#~ msgstr ""

#~ msgid "Set extrude factor override percentage: `M221 S<percent>`"
#~ msgstr ""

#~ msgid ""
#~ "Note: If S is not specified and both P and T are specified, then the "
#~ "acceleration is set to the minimum of P and T. If only one of P or T is "
#~ "specified, the command has no effect."
#~ msgstr ""

#~ msgid "Set extruder temperature: `M104 [T<index>] [S<temperature>]`"
#~ msgstr ""

#~ msgid "Note: M109 always waits for temperature to settle at requested value"
#~ msgstr ""

#~ msgid "Set bed temperature and wait: `M190 S<temperature>`"
#~ msgstr ""

#~ msgid "Set fan speed: `M106 S<value>`"
#~ msgstr ""

#~ msgid "Emergency stop: `M112`"
#~ msgstr ""

#~ msgid "Get firmware version: `M115`"
#~ msgstr ""

#~ msgid ""
#~ "Klipper's goal is to support the G-Code commands produced by common 3rd "
#~ "party software (eg, OctoPrint, Printrun, Slic3r, Cura, etc.) in their "
#~ "standard configurations. It is not a goal to support every possible G-Code "
#~ "command. Instead, Klipper prefers human readable [\"extended G-Code "
#~ "commands\"](#additional-commands). Similarly, the G-Code terminal output is "
#~ "only intended to be human readable - see the [API Server "
#~ "document](API_Server.md) if controlling Klipper from external software."
#~ msgstr ""

#~ msgid "Additional Commands"
#~ msgstr ""

#~ msgid ""
#~ "This section is organized by Klipper module name, which generally follows "
#~ "the section names specified in the [printer configuration "
#~ "file](Config_Reference.md). Note that some modules are automatically loaded."
#~ msgstr ""

#~ msgid "ACCELEROMETER_MEASURE"
#~ msgstr ""

#~ msgid "ACCELEROMETER_QUERY"
#~ msgstr ""

#~ msgid "ACCELEROMETER_DEBUG_READ"
#~ msgstr ""

#~ msgid "ACCELEROMETER_DEBUG_WRITE"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when an [angle config "
#~ "section](Config_Reference.md#angle) is enabled."
#~ msgstr ""

#~ msgid ""
#~ "`ANGLE_CALIBRATE CHIP=<chip_name>`: Perform angle calibration on the given "
#~ "sensor (there must be an `[angle chip_name]` config section that has "
#~ "specified a `stepper` parameter). IMPORTANT - this tool will command the "
#~ "stepper motor to move without checking the normal kinematic boundary limits."
#~ " Ideally the motor should be disconnected from any printer carriage before "
#~ "performing calibration. If the stepper can not be disconnected from the "
#~ "printer, make sure the carriage is near the center of its rail before "
#~ "starting calibration. (The stepper motor may move forwards or backwards two "
#~ "full rotations during this test.) After completing this test use the "
#~ "`SAVE_CONFIG` command to save the calibration data to the config file. In "
#~ "order to use this tool the Python \"numpy\" package must be installed (see "
#~ "the [measuring resonance document](Measuring_Resonances.md#software-"
#~ "installation) for more information)."
#~ msgstr ""

#~ msgid ""
#~ "`ANGLE_DEBUG_READ CHIP=<config_name> REG=<register>`: Queries sensor "
#~ "register \"register\" (e.g. 44 or 0x2C). Can be useful for debugging "
#~ "purposes. This is only available for tle5012b chips."
#~ msgstr ""

#~ msgid ""
#~ "`ANGLE_DEBUG_WRITE CHIP=<config_name> REG=<register> VAL=<value>`: Writes "
#~ "raw \"value\" into register \"register\". Both \"value\" and \"register\" "
#~ "can be a decimal or a hexadecimal integer. Use with care, and refer to "
#~ "sensor data sheet for the reference. This is only available for tle5012b "
#~ "chips."
#~ msgstr ""

#~ msgid "BED_MESH_CALIBRATE"
#~ msgstr ""

#~ msgid "BED_MESH_OUTPUT"
#~ msgstr ""

#~ msgid "BED_MESH_MAP"
#~ msgstr ""

#~ msgid "BED_MESH_CLEAR"
#~ msgstr ""

#~ msgid "BED_MESH_PROFILE"
#~ msgstr ""

#~ msgid "BED_MESH_OFFSET"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [bed_screws config "
#~ "section](Config_Reference.md#bed_screws) is enabled (also see the [manual "
#~ "level guide](Manual_Level.md#adjusting-bed-leveling-screws))."
#~ msgstr ""

#~ msgid ""
#~ "`BED_SCREWS_ADJUST`: This command will invoke the bed screws adjustment "
#~ "tool. It will command the nozzle to different locations (as defined in the "
#~ "config file) and allow one to make adjustments to the bed screws so that the"
#~ " bed is a constant distance from the nozzle."
#~ msgstr ""

#~ msgid "BED_TILT_CALIBRATE"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a [bltouch config "
#~ "section](Config_Reference.md#bltouch) is enabled (also see the [BL-Touch "
#~ "guide](BLTouch.md))."
#~ msgstr ""

#~ msgid ""
#~ "`BLTOUCH_DEBUG COMMAND=<command>`: This sends a command to the BLTouch. It "
#~ "may be useful for debugging. Available commands are: `pin_down`, "
#~ "`touch_mode`, `pin_up`, `self_test`, `reset`. A BL-Touch V3.0 or V3.1 may "
#~ "also support `set_5V_output_mode`, `set_OD_output_mode`, `output_mode_store`"
#~ " commands."
#~ msgstr ""

#~ msgid ""
#~ "`BLTOUCH_STORE MODE=<output_mode>`: This stores an output mode in the EEPROM"
#~ " of a BLTouch V3.1 Available output_modes are: `5V`, `OD`"
#~ msgstr ""

#~ msgid "The configfile module is automatically loaded."
#~ msgstr ""

#~ msgid ""
#~ "`SAVE_CONFIG`: This command will overwrite the main printer config file and "
#~ "restart the host software. This command is used in conjunction with other "
#~ "calibration commands to store the results of calibration tests."
#~ msgstr ""

#~ msgid "UPDATE_DELAYED_GCODE"
#~ msgstr ""

#~ msgid "[delta_calibrate]"
#~ msgstr ""

#~ msgid "DELTA_CALIBRATE"
#~ msgstr ""

#~ msgid "DELTA_ANALYZE"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a [display config "
#~ "section](Config_Reference.md#gcode_macro) is enabled."
#~ msgstr ""

#~ msgid ""
#~ "`SET_DISPLAY_GROUP [DISPLAY=<display>] GROUP=<group>`: Set the active "
#~ "display group of an lcd display. This allows to define multiple display data"
#~ " groups in the config, e.g. `[display_data <group> <elementname>]` and "
#~ "switch between them using this extended gcode command. If DISPLAY is not "
#~ "specified it defaults to \"display\" (the primary display)."
#~ msgstr ""

#~ msgid ""
#~ "The display_status module is automatically loaded if a [display config "
#~ "section](Config_Reference.md#display) is enabled. It provides the following "
#~ "standard G-Code commands:"
#~ msgstr ""

#~ msgid "Set build percentage: `M73 P<percent>`"
#~ msgstr ""

#~ msgid ""
#~ "`SET_DISPLAY_TEXT MSG=<message>`: Performs the equivalent of M117, setting "
#~ "the supplied `MSG` as the current display message. If `MSG` is omitted the "
#~ "display will be cleared."
#~ msgstr ""

#~ msgid "SET_DUAL_CARRIAGE"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when an [endstop_phase config "
#~ "section](Config_Reference.md#endstop_phase) is enabled (also see the "
#~ "[endstop phase guide](Endstop_Phase.md))."
#~ msgstr ""

#~ msgid ""
#~ "`ENDSTOP_PHASE_CALIBRATE [STEPPER=<config_name>]`: If no STEPPER parameter "
#~ "is provided then this command will reports statistics on endstop stepper "
#~ "phases during past homing operations. When a STEPPER parameter is provided "
#~ "it arranges for the given endstop phase setting to be written to the config "
#~ "file (in conjunction with the SAVE_CONFIG command)."
#~ msgstr ""

#~ msgid "`EXCLUDE_OBJECT`"
#~ msgstr ""

#~ msgid ""
#~ "When the `NAME` parameter is given, the named object will be excluded from "
#~ "printing."
#~ msgstr ""

#~ msgid ""
#~ "When the `RESET` parameter is given, the list of excluded objects will be "
#~ "cleared. Additionally including `NAME` will only reset the named object. "
#~ "This **can** cause print failures, if layers were already skipped."
#~ msgstr ""

#~ msgid ""
#~ "`EXCLUDE_OBJECT_DEFINE [NAME=object_name [CENTER=X,Y] [POLYGON=[[x,y],...]] "
#~ "[RESET=1] [JSON=1]`: Provides a summary of an object in the file."
#~ msgstr ""

#~ msgid ""
#~ "When the `NAME` parameter is included, this defines an object to be "
#~ "excluded."
#~ msgstr ""

#~ msgid "`CENTER`: An X,Y coordinate for the object."
#~ msgstr ""

#~ msgid ""
#~ "When the `RESET` parameter is provided, all defined objects will be cleared,"
#~ " and the `[exclude_object]` module will be reset."
#~ msgstr ""

#~ msgid ""
#~ "`EXCLUDE_OBJECT_START NAME=object_name`: This command takes a `NAME` "
#~ "parameter and denotes the start of the gcode for an object on the current "
#~ "layer."
#~ msgstr ""

#~ msgid ""
#~ "`EXCLUDE_OBJECT_END [NAME=object_name]`: Denotes the end of the object's "
#~ "gcode for the layer. It is paired with `EXCLUDE_OBJECT_START`. A `NAME` "
#~ "parameter is optional, and will only warn when the provided name does not "
#~ "match the current object."
#~ msgstr ""

#~ msgid "ACTIVATE_EXTRUDER"
#~ msgstr ""

#~ msgid "SET_PRESSURE_ADVANCE"
#~ msgstr ""

#~ msgid "SET_EXTRUDER_ROTATION_DISTANCE"
#~ msgstr ""

#~ msgid "SYNC_EXTRUDER_MOTION"
#~ msgstr ""

#~ msgid "SET_EXTRUDER_STEP_DISTANCE"
#~ msgstr ""

#~ msgid "SYNC_STEPPER_TO_EXTRUDER"
#~ msgstr ""

#~ msgid "SET_FAN_SPEED"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a "
#~ "[filament_switch_sensor](Config_Reference.md#filament_switch_sensor) or "
#~ "[filament_motion_sensor](Config_Reference.md#filament_motion_sensor) config "
#~ "section is enabled."
#~ msgstr ""

#~ msgid ""
#~ "`QUERY_FILAMENT_SENSOR SENSOR=<sensor_name>`: Queries the current status of "
#~ "the filament sensor. The data displayed on the terminal will depend on the "
#~ "sensor type defined in the configuration."
#~ msgstr ""

#~ msgid ""
#~ "`SET_FILAMENT_SENSOR SENSOR=<sensor_name> ENABLE=[0|1]`: Sets the filament "
#~ "sensor on/off. If ENABLE is set to 0, the filament sensor will be disabled, "
#~ "if set to 1 it is enabled."
#~ msgstr ""

#~ msgid ""
#~ "`G10`: Retracts the extruder using the currently configured parameters."
#~ msgstr ""

#~ msgid "The following additional commands are also available."
#~ msgstr ""

#~ msgid ""
#~ "`SET_RETRACTION [RETRACT_LENGTH=<mm>] [RETRACT_SPEED=<mm/s>] "
#~ "[UNRETRACT_EXTRA_LENGTH=<mm>] [UNRETRACT_SPEED=<mm/s>]`: Adjust the "
#~ "parameters used by firmware retraction. RETRACT_LENGTH determines the length"
#~ " of filament to retract and unretract. The speed of retraction is adjusted "
#~ "via RETRACT_SPEED, and is typically set relatively high. The speed of "
#~ "unretraction is adjusted via UNRETRACT_SPEED, and is not particularly "
#~ "critical, although often lower than RETRACT_SPEED. In some cases it is "
#~ "useful to add a small amount of additional length on unretraction, and this "
#~ "is set via UNRETRACT_EXTRA_LENGTH. SET_RETRACTION is commonly set as part of"
#~ " slicer per-filament configuration, as different filaments require different"
#~ " parameter settings."
#~ msgstr ""

#~ msgid ""
#~ "`GET_RETRACTION`: Queries the current parameters used by firmware retraction"
#~ " and displays them on the terminal."
#~ msgstr ""

#~ msgid "STEPPER_BUZZ"
#~ msgstr ""

#~ msgid "FORCE_MOVE"
#~ msgstr ""

#~ msgid "SET_KINEMATIC_POSITION"
#~ msgstr ""

#~ msgid "[gcode]"
#~ msgstr ""

#~ msgid "RESTART"
#~ msgstr ""

#~ msgid "FIRMWARE_RESTART"
#~ msgstr ""

#~ msgid "STATUS"
#~ msgstr ""

#~ msgid "HELP"
#~ msgstr ""

#~ msgid ""
#~ "The following standard G-Code commands are available if a [gcode_arcs config"
#~ " section](Config_Reference.md#gcode_arcs) is enabled:"
#~ msgstr ""

#~ msgid "Arc Plane Select: G17 (XY plane), G18 (XZ plane), G19 (YZ plane)"
#~ msgstr ""

#~ msgid "SET_GCODE_VARIABLE"
#~ msgstr ""

#~ msgid "[gcode_move]"
#~ msgstr ""

#~ msgid "GET_POSITION"
#~ msgstr ""

#~ msgid "SET_GCODE_OFFSET"
#~ msgstr ""

#~ msgid "SAVE_GCODE_STATE"
#~ msgstr ""

#~ msgid "RESTORE_GCODE_STATE"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [tsl1401cl filament width "
#~ "sensor config section](Config_Reference.md#tsl1401cl_filament_width_sensor) "
#~ "or [hall filament width sensor config "
#~ "section](Config_Reference.md#hall_filament_width_sensor) is enabled (also "
#~ "see [TSLl401CL Filament Width Sensor](TSL1401CL_Filament_Width_Sensor.md) "
#~ "and [Hall Filament Width Sensor](Hall_Filament_Width_Sensor.md)):"
#~ msgstr ""

#~ msgid "`QUERY_FILAMENT_WIDTH`: Return the current measured filament width."
#~ msgstr ""

#~ msgid ""
#~ "`RESET_FILAMENT_WIDTH_SENSOR`: Clear all sensor readings. Helpful after "
#~ "filament change."
#~ msgstr ""

#~ msgid ""
#~ "`DISABLE_FILAMENT_WIDTH_SENSOR`: Turn off the filament width sensor and stop"
#~ " using it for flow control."
#~ msgstr ""

#~ msgid ""
#~ "`ENABLE_FILAMENT_WIDTH_SENSOR`: Turn on the filament width sensor and start "
#~ "using it for flow control."
#~ msgstr ""

#~ msgid ""
#~ "`QUERY_RAW_FILAMENT_WIDTH`: Return the current ADC channel readings and RAW "
#~ "sensor value for calibration points."
#~ msgstr ""

#~ msgid "`ENABLE_FILAMENT_WIDTH_LOG`: Turn on diameter logging."
#~ msgstr ""

#~ msgid "`DISABLE_FILAMENT_WIDTH_LOG`: Turn off diameter logging."
#~ msgstr ""

#~ msgid ""
#~ "The heaters module is automatically loaded if a heater is defined in the "
#~ "config file."
#~ msgstr ""

#~ msgid "`TURN_OFF_HEATERS`: Turn off all heaters."
#~ msgstr ""

#~ msgid ""
#~ "`TEMPERATURE_WAIT SENSOR=<config_name> [MINIMUM=<target>] "
#~ "[MAXIMUM=<target>]`: Wait until the given temperature sensor is at or above "
#~ "the supplied MINIMUM and/or at or below the supplied MAXIMUM."
#~ msgstr ""

#~ msgid ""
#~ "`SET_HEATER_TEMPERATURE HEATER=<heater_name> [TARGET=<target_temperature>]`:"
#~ " Sets the target temperature for a heater. If a target temperature is not "
#~ "supplied, the target is 0."
#~ msgstr ""

#~ msgid "SET_IDLE_TIMEOUT"
#~ msgstr ""

#~ msgid ""
#~ "The following command is enabled if an [input_shaper config "
#~ "section](Config_Reference.md#input_shaper) has been enabled (also see the "
#~ "[resonance compensation guide](Resonance_Compensation.md))."
#~ msgstr ""

#~ msgid ""
#~ "`SET_INPUT_SHAPER [SHAPER_FREQ_X=<shaper_freq_x>] "
#~ "[SHAPER_FREQ_Y=<shaper_freq_y>] [DAMPING_RATIO_X=<damping_ratio_x>] "
#~ "[DAMPING_RATIO_Y=<damping_ratio_y>] [SHAPER_TYPE=<shaper>] "
#~ "[SHAPER_TYPE_X=<shaper_type_x>] [SHAPER_TYPE_Y=<shaper_type_y>]`: Modify "
#~ "input shaper parameters. Note that SHAPER_TYPE parameter resets input shaper"
#~ " for both X and Y axes even if different shaper types have been configured "
#~ "in [input_shaper] section. SHAPER_TYPE cannot be used together with either "
#~ "of SHAPER_TYPE_X and SHAPER_TYPE_Y parameters. See [config "
#~ "reference](Config_Reference.md#input_shaper) for more details on each of "
#~ "these parameters."
#~ msgstr ""

#~ msgid "The manual_probe module is automatically loaded."
#~ msgstr ""

#~ msgid ""
#~ "`MANUAL_PROBE [SPEED=<speed>]`: Run a helper script useful for measuring the"
#~ " height of the nozzle at a given location. If SPEED is specified, it sets "
#~ "the speed of TESTZ commands (the default is 5mm/s). During a manual probe, "
#~ "the following additional commands are available:"
#~ msgstr ""

#~ msgid "`ABORT`: This command terminates the manual probing tool."
#~ msgstr ""

#~ msgid "Z_ENDSTOP_CALIBRATE"
#~ msgstr ""

#~ msgid "Z_OFFSET_APPLY_ENDSTOP"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a [manual_stepper config "
#~ "section](Config_Reference.md#manual_stepper) is enabled."
#~ msgstr ""

#~ msgid ""
#~ "`MANUAL_STEPPER STEPPER=config_name [ENABLE=[0|1]] [SET_POSITION=<pos>] "
#~ "[SPEED=<speed>] [ACCEL=<accel>] [MOVE=<pos> [STOP_ON_ENDSTOP=[1|2|-1|-2]] "
#~ "[SYNC=0]]`: This command will alter the state of the stepper. Use the ENABLE"
#~ " parameter to enable/disable the stepper. Use the SET_POSITION parameter to "
#~ "force the stepper to think it is at the given position. Use the MOVE "
#~ "parameter to request a movement to the given position. If SPEED and/or ACCEL"
#~ " is specified then the given values will be used instead of the defaults "
#~ "specified in the config file. If an ACCEL of zero is specified then no "
#~ "acceleration will be performed. If STOP_ON_ENDSTOP=1 is specified then the "
#~ "move will end early should the endstop report as triggered (use "
#~ "STOP_ON_ENDSTOP=2 to complete the move without error even if the endstop "
#~ "does not trigger, use -1 or -2 to stop when the endstop reports not "
#~ "triggered). Normally future G-Code commands will be scheduled to run after "
#~ "the stepper move completes, however if a manual stepper move uses SYNC=0 "
#~ "then future G-Code movement commands may run in parallel with the stepper "
#~ "movement."
#~ msgstr ""

#~ msgid "SET_DIGIPOT"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when any of the [led config "
#~ "sections](Config_Reference.md#leds) are enabled."
#~ msgstr ""

#~ msgid ""
#~ "`SET_LED LED=<config_name> RED=<value> GREEN=<value> BLUE=<value> "
#~ "WHITE=<value> [INDEX=<index>] [TRANSMIT=0] [SYNC=1]`: This sets the LED "
#~ "output. Each color `<value>` must be between 0.0 and 1.0. The WHITE option "
#~ "is only valid on RGBW LEDs. If the LED supports multiple chips in a daisy-"
#~ "chain then one may specify INDEX to alter the color of just the given chip "
#~ "(1 for the first chip, 2 for the second, etc.). If INDEX is not provided "
#~ "then all LEDs in the daisy-chain will be set to the provided color. If "
#~ "TRANSMIT=0 is specified then the color change will only be made on the next "
#~ "SET_LED command that does not specify TRANSMIT=0; this may be useful in "
#~ "combination with the INDEX parameter to batch multiple updates in a daisy-"
#~ "chain. By default, the SET_LED command will sync it's changes with other "
#~ "ongoing gcode commands. This can lead to undesirable behavior if LEDs are "
#~ "being set while the printer is not printing as it will reset the idle "
#~ "timeout. If careful timing is not needed, the optional SYNC=0 parameter can "
#~ "be specified to apply the changes without resetting the idle timeout."
#~ msgstr ""

#~ msgid ""
#~ "`SET_LED_TEMPLATE LED=<led_name> TEMPLATE=<template_name> "
#~ "[<param_x>=<literal>] [INDEX=<index>]`: Assign a "
#~ "[display_template](Config_Reference.md#display_template) to a given "
#~ "[LED](Config_Reference.md#leds). For example, if one defined a "
#~ "`[display_template my_led_template]` config section then one could assign "
#~ "`TEMPLATE=my_led_template` here. The display_template should produce a comma"
#~ " separated string containing four floating point numbers corresponding to "
#~ "red, green, blue, and white color settings. The template will be "
#~ "continuously evaluated and the LED will be automatically set to the "
#~ "resulting colors. One may set display_template parameters to use during "
#~ "template evaluation (parameters will be parsed as Python literals). If INDEX"
#~ " is not specified then all chips in the LED's daisy-chain will be set to the"
#~ " template, otherwise only the chip with the given index will be updated. If "
#~ "TEMPLATE is an empty string then this command will clear any previous "
#~ "template assigned to the LED (one can then use `SET_LED` commands to manage "
#~ "the LED's color settings)."
#~ msgstr ""

#~ msgid "SET_PIN"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [palette2 config "
#~ "section](Config_Reference.md#palette2) is enabled."
#~ msgstr ""

#~ msgid ""
#~ "`O1`...`O32`: These codes are read from the GCode stream and processed by "
#~ "this module and passed to the Palette 2 device."
#~ msgstr ""

#~ msgid ""
#~ "`PALETTE_CONNECT`: This command initializes the connection with the Palette "
#~ "2."
#~ msgstr ""

#~ msgid "`PALETTE_DISCONNECT`: This command disconnects from the Palette 2."
#~ msgstr ""

#~ msgid ""
#~ "`PALETTE_CLEAR`: This command instructs the Palette 2 to clear all of the "
#~ "input and output paths of filament."
#~ msgstr ""

#~ msgid ""
#~ "`PALETTE_CUT`: This command instructs the Palette 2 to cut the filament "
#~ "currently loaded in the splice core."
#~ msgstr ""

#~ msgid ""
#~ "`PALETTE_SMART_LOAD`: This command start the smart load sequence on the "
#~ "Palette 2. Filament is loaded automatically by extruding it the distance "
#~ "calibrated on the device for the printer, and instructs the Palette 2 once "
#~ "the loading has been completed. This command is the same as pressing **Smart"
#~ " Load** directly on the Palette 2 screen after the filament load is "
#~ "complete."
#~ msgstr ""

#~ msgid ""
#~ "The pid_calibrate module is automatically loaded if a heater is defined in "
#~ "the config file."
#~ msgstr ""

#~ msgid ""
#~ "`PID_CALIBRATE HEATER=<config_name> TARGET=<temperature> [WRITE_FILE=1]`: "
#~ "Perform a PID calibration test. The specified heater will be enabled until "
#~ "the specified target temperature is reached, and then the heater will be "
#~ "turned off and on for several cycles. If the WRITE_FILE parameter is "
#~ "enabled, then the file /tmp/heattest.txt will be created with a log of all "
#~ "temperature samples taken during the test."
#~ msgstr ""

#~ msgid "PAUSE"
#~ msgstr ""

#~ msgid "RESUME"
#~ msgstr ""

#~ msgid "CLEAR_PAUSE"
#~ msgstr ""

#~ msgid "CANCEL_PRINT"
#~ msgstr ""

#~ msgid "[print_stats]"
#~ msgstr ""

#~ msgid "SET_PRINT_STATS_INFO"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when a [probe config "
#~ "section](Config_Reference.md#probe) or [bltouch config "
#~ "section](Config_Reference.md#bltouch) is enabled (also see the [probe "
#~ "calibrate guide](Probe_Calibrate.md))."
#~ msgstr ""

#~ msgid ""
#~ "`PROBE [PROBE_SPEED=<mm/s>] [LIFT_SPEED=<mm/s>] [SAMPLES=<count>] "
#~ "[SAMPLE_RETRACT_DIST=<mm>] [SAMPLES_TOLERANCE=<mm>] "
#~ "[SAMPLES_TOLERANCE_RETRIES=<count>] [SAMPLES_RESULT=median|average]`: Move "
#~ "the nozzle downwards until the probe triggers. If any of the optional "
#~ "parameters are provided they override their equivalent setting in the [probe"
#~ " config section](Config_Reference.md#probe)."
#~ msgstr ""

#~ msgid ""
#~ "`QUERY_PROBE`: Report the current status of the probe (\"triggered\" or "
#~ "\"open\")."
#~ msgstr ""

#~ msgid ""
#~ "`PROBE_ACCURACY [PROBE_SPEED=<mm/s>] [SAMPLES=<count>] "
#~ "[SAMPLE_RETRACT_DIST=<mm>]`: Calculate the maximum, minimum, average, "
#~ "median, and standard deviation of multiple probe samples. By default, 10 "
#~ "SAMPLES are taken. Otherwise the optional parameters default to their "
#~ "equivalent setting in the probe config section."
#~ msgstr ""

#~ msgid ""
#~ "`PROBE_CALIBRATE [SPEED=<speed>] [<probe_parameter>=<value>]`: Run a helper "
#~ "script useful for calibrating the probe's z_offset. See the PROBE command "
#~ "for details on the optional probe parameters. See the MANUAL_PROBE command "
#~ "for details on the SPEED parameter and the additional commands available "
#~ "while the tool is active. Please note, the PROBE_CALIBRATE command uses the "
#~ "speed variable to move in XY direction as well as Z."
#~ msgstr ""

#~ msgid ""
#~ "`Z_OFFSET_APPLY_PROBE`: Take the current Z Gcode offset (aka, babystepping),"
#~ " and subtract if from the probe's z_offset. This acts to take a frequently "
#~ "used babystepping value, and \"make it permanent\". Requires a `SAVE_CONFIG`"
#~ " to take effect."
#~ msgstr ""

#~ msgid "The query_adc module is automatically loaded."
#~ msgstr ""

#~ msgid ""
#~ "`QUERY_ADC [NAME=<config_name>] [PULLUP=<value>]`: Report the last analog "
#~ "value received for a configured analog pin. If NAME is not provided, the "
#~ "list of available adc names are reported. If PULLUP is provided (as a value "
#~ "in Ohms), the raw analog value along with the equivalent resistance given "
#~ "that pullup is reported."
#~ msgstr ""

#~ msgid ""
#~ "The query_endstops module is automatically loaded. The following standard "
#~ "G-Code commands are currently available, but using them is not recommended:"
#~ msgstr ""

#~ msgid "QUERY_ENDSTOPS"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when a [resonance_tester config "
#~ "section](Config_Reference.md#resonance_tester) is enabled (also see the "
#~ "[measuring resonances guide](Measuring_Resonances.md))."
#~ msgstr ""

#~ msgid ""
#~ "`MEASURE_AXES_NOISE`: Measures and outputs the noise for all axes of all "
#~ "enabled accelerometer chips."
#~ msgstr ""

#~ msgid ""
#~ "`TEST_RESONANCES AXIS=<axis> OUTPUT=<resonances,raw_data> [NAME=<name>] "
#~ "[FREQ_START=<min_freq>] [FREQ_END=<max_freq>] [HZ_PER_SEC=<hz_per_sec>] "
#~ "[CHIPS=<adxl345_chip_name>] [POINT=x,y,z] [INPUT_SHAPING=[<0:1>]]`: Runs the"
#~ " resonance test in all configured probe points for the requested \"axis\" "
#~ "and measures the acceleration using the accelerometer chips configured for "
#~ "the respective axis. \"axis\" can either be X or Y, or specify an arbitrary "
#~ "direction as `AXIS=dx,dy`, where dx and dy are floating point numbers "
#~ "defining a direction vector (e.g. `AXIS=X`, `AXIS=Y`, or `AXIS=1,-1` to "
#~ "define a diagonal direction). Note that `AXIS=dx,dy` and `AXIS=-dx,-dy` is "
#~ "equivalent. `adxl345_chip_name` can be one or more configured adxl345 "
#~ "chip,delimited with comma, for example `CHIPS=\"adxl345, adxl345 rpi\"`. "
#~ "Note that `adxl345` can be omitted from named adxl345 chips. If POINT is "
#~ "specified it will override the point(s) configured in `[resonance_tester]`. "
#~ "If `INPUT_SHAPING=0` or not set(default), disables input shaping for the "
#~ "resonance testing, because it is not valid to run the resonance testing with"
#~ " the input shaper enabled. `OUTPUT` parameter is a comma-separated list of "
#~ "which outputs will be written. If `raw_data` is requested, then the raw "
#~ "accelerometer data is written into a file or a series of files "
#~ "`/tmp/raw_data_<axis>_[<chip_name>_][<point>_]<name>.csv` with (`<point>_` "
#~ "part of the name generated only if more than 1 probe point is configured or "
#~ "POINT is specified). If `resonances` is specified, the frequency response is"
#~ " calculated (across all probe points) and written into "
#~ "`/tmp/resonances_<axis>_<name>.csv` file. If unset, OUTPUT defaults to "
#~ "`resonances`, and NAME defaults to the current time in \"YYYYMMDD_HHMMSS\" "
#~ "format."
#~ msgstr ""

#~ msgid ""
#~ "`SHAPER_CALIBRATE [AXIS=<axis>] [NAME=<name>] [FREQ_START=<min_freq>] "
#~ "[FREQ_END=<max_freq>] [HZ_PER_SEC=<hz_per_sec>] "
#~ "[MAX_SMOOTHING=<max_smoothing>]`: Similarly to `TEST_RESONANCES`, runs the "
#~ "resonance test as configured, and tries to find the optimal parameters for "
#~ "the input shaper for the requested axis (or both X and Y axes if `AXIS` "
#~ "parameter is unset). If `MAX_SMOOTHING` is unset, its value is taken from "
#~ "`[resonance_tester]` section, with the default being unset. See the [Max "
#~ "smoothing](Measuring_Resonances.md#max-smoothing) of the measuring "
#~ "resonances guide for more information on the use of this feature. The "
#~ "results of the tuning are printed to the console, and the frequency "
#~ "responses and the different input shapers values are written to a CSV "
#~ "file(s) `/tmp/calibration_data_<axis>_<name>.csv`. Unless specified, NAME "
#~ "defaults to the current time in \"YYYYMMDD_HHMMSS\" format. Note that the "
#~ "suggested input shaper parameters can be persisted in the config by issuing "
#~ "`SAVE_CONFIG` command."
#~ msgstr ""

#~ msgid ""
#~ "`M118 <message>`: echo the message prepended with the configured default "
#~ "prefix (or `echo: ` if no prefix is configured)."
#~ msgstr ""

#~ msgid ""
#~ "`RESPOND MSG=\"<message>\"`: echo the message prepended with the configured "
#~ "default prefix (or `echo: ` if no prefix is configured)."
#~ msgstr ""

#~ msgid ""
#~ "`RESPOND TYPE=echo_no_space MSG=\"<message>\"`: echo the message prepended "
#~ "with `echo:` without a space between prefix and message, helpful for "
#~ "compatibility with some octoprint plugins that expect very specific "
#~ "formatting."
#~ msgstr ""

#~ msgid ""
#~ "`RESPOND TYPE=error MSG=\"<message>\"`: echo the message prepended with `!! "
#~ "`."
#~ msgstr ""

#~ msgid ""
#~ "The following command is enabled if a [save_variables config "
#~ "section](Config_Reference.md#save_variables) has been enabled."
#~ msgstr ""

#~ msgid ""
#~ "`SAVE_VARIABLE VARIABLE=<name> VALUE=<value>`: Saves the variable to disk so"
#~ " that it can be used across restarts. All stored variables are loaded into "
#~ "the `printer.save_variables.variables` dict at startup and can be used in "
#~ "gcode macros. The provided VALUE is parsed as a Python literal."
#~ msgstr ""

#~ msgid "SCREWS_TILT_CALCULATE"
#~ msgstr ""

#~ msgid ""
#~ "When the [sdcard_loop config section](Config_Reference.md#sdcard_loop) is "
#~ "enabled, the following extended commands are available."
#~ msgstr ""

#~ msgid ""
#~ "`SDCARD_LOOP_BEGIN COUNT=<count>`: Begin a looped section in the SD print. A"
#~ " count of 0 indicates that the section should be looped indefinitely."
#~ msgstr ""

#~ msgid "`SDCARD_LOOP_END`: End a looped section in the SD print."
#~ msgstr ""

#~ msgid ""
#~ "`SDCARD_LOOP_DESIST`: Complete existing loops without further iterations."
#~ msgstr ""

#~ msgid "SET_SERVO"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [skew_correction config "
#~ "section](Config_Reference.md#skew_correction) is enabled (also see the [Skew"
#~ " Correction](Skew_Correction.md) guide)."
#~ msgstr ""

#~ msgid ""
#~ "`SET_SKEW [XY=<ac_length,bd_length,ad_length>] [XZ=<ac,bd,ad>] "
#~ "[YZ=<ac,bd,ad>] [CLEAR=<0|1>]`: Configures the [skew_correction] module with"
#~ " measurements (in mm) taken from a calibration print. One may enter "
#~ "measurements for any combination of planes, planes not entered will retain "
#~ "their current value. If `CLEAR=1` is entered then all skew correction will "
#~ "be disabled."
#~ msgstr ""

#~ msgid ""
#~ "`GET_CURRENT_SKEW`: Reports the current printer skew for each plane in both "
#~ "radians and degrees. The skew is calculated based on parameters provided via"
#~ " the `SET_SKEW` gcode."
#~ msgstr ""

#~ msgid ""
#~ "`CALC_MEASURED_SKEW [AC=<ac_length>] [BD=<bd_length>] [AD=<ad_length>]`: "
#~ "Calculates and reports the skew (in radians and degrees) based on a measured"
#~ " print. This can be useful for determining the printer's current skew after "
#~ "correction has been applied. It may also be useful before correction is "
#~ "applied to determine if skew correction is necessary. See [Skew "
#~ "Correction](Skew_Correction.md) for details on skew calibration objects and "
#~ "measurements."
#~ msgstr ""

#~ msgid ""
#~ "`SKEW_PROFILE [LOAD=<name>] [SAVE=<name>] [REMOVE=<name>]`: Profile "
#~ "management for skew_correction. LOAD will restore skew state from the "
#~ "profile matching the supplied name. SAVE will save the current skew state to"
#~ " a profile matching the supplied name. Remove will delete the profile "
#~ "matching the supplied name from persistent memory. Note that after SAVE or "
#~ "REMOVE operations have been run the SAVE_CONFIG gcode must be run to make "
#~ "the changes to persistent memory permanent."
#~ msgstr ""

#~ msgid "SET_SMART_EFFECTOR"
#~ msgstr ""

#~ msgid "RESET_SMART_EFFECTOR"
#~ msgstr ""

#~ msgid "[stepper_enable]"
#~ msgstr ""

#~ msgid "SET_STEPPER_ENABLE"
#~ msgstr ""

#~ msgid ""
#~ "The following command is available when a [temperature_fan config "
#~ "section](Config_Reference.md#temperature_fan) is enabled."
#~ msgstr ""

#~ msgid ""
#~ "`SET_TEMPERATURE_FAN_TARGET temperature_fan=<temperature_fan_name> "
#~ "[target=<target_temperature>] [min_speed=<min_speed>] "
#~ "[max_speed=<max_speed>]`: Sets the target temperature for a temperature_fan."
#~ " If a target is not supplied, it is set to the specified temperature in the "
#~ "config file. If speeds are not supplied, no change is applied."
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when any of the [tmcXXXX config "
#~ "sections](Config_Reference.md#tmc-stepper-driver-configuration) are enabled."
#~ msgstr ""

#~ msgid ""
#~ "`DUMP_TMC STEPPER=<name>`: This command will read the TMC driver registers "
#~ "and report their values."
#~ msgstr ""

#~ msgid ""
#~ "`INIT_TMC STEPPER=<name>`: This command will initialize the TMC registers. "
#~ "Needed to re-enable the driver if power to the chip is turned off then back "
#~ "on."
#~ msgstr ""

#~ msgid ""
#~ "`SET_TMC_CURRENT STEPPER=<name> CURRENT=<amps> HOLDCURRENT=<amps>`: This "
#~ "will adjust the run and hold currents of the TMC driver. (HOLDCURRENT is not"
#~ " applicable to tmc2660 drivers.)"
#~ msgstr ""

#~ msgid ""
#~ "`SET_TMC_FIELD STEPPER=<name> FIELD=<field> VALUE=<value>`: This will alter "
#~ "the value of the specified register field of the TMC driver. This command is"
#~ " intended for low-level diagnostics and debugging only because changing the "
#~ "fields during run-time can lead to undesired and potentially dangerous "
#~ "behavior of your printer. Permanent changes should be made using the printer"
#~ " configuration file instead. No sanity checks are performed for the given "
#~ "values."
#~ msgstr ""

#~ msgid "The toolhead module is automatically loaded."
#~ msgstr ""

#~ msgid ""
#~ "`SET_VELOCITY_LIMIT [VELOCITY=<value>] [ACCEL=<value>] "
#~ "[ACCEL_TO_DECEL=<value>] [SQUARE_CORNER_VELOCITY=<value>]`: Modify the "
#~ "printer's velocity limits."
#~ msgstr ""

#~ msgid "The tuning_tower module is automatically loaded."
#~ msgstr ""

#~ msgid ""
#~ "`TUNING_TOWER COMMAND=<command> PARAMETER=<name> START=<value> "
#~ "[SKIP=<value>] [FACTOR=<value> [BAND=<value>]] | [STEP_DELTA=<value> "
#~ "STEP_HEIGHT=<value>]`: A tool for tuning a parameter on each Z height during"
#~ " a print. The tool will run the given `COMMAND` with the given `PARAMETER` "
#~ "assigned to a value that varies with `Z` according to a formula. Use "
#~ "`FACTOR` if you will use a ruler or calipers to measure the Z height of the "
#~ "optimum value, or `STEP_DELTA` and `STEP_HEIGHT` if the tuning tower model "
#~ "has bands of discrete values as is common with temperature towers. If "
#~ "`SKIP=<value>` is specified, the tuning process doesn't begin until Z height"
#~ " `<value>` is reached, and below that the value will be set to `START`; in "
#~ "this case, the `z_height` used in the formulas below is actually `max(z - "
#~ "skip, 0)`. There are three possible combinations of options:"
#~ msgstr ""

#~ msgid ""
#~ "`FACTOR` and `BAND`: The value changes at an average rate of `factor` per "
#~ "millimeter, but in discrete bands where the adjustment will only be made "
#~ "every `BAND` millimeters of Z height. The formula used is: `value = start + "
#~ "factor * ((floor(z_height / band) + .5) * band)`."
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports the following standard G-Code commands if the "
#~ "[virtual_sdcard config section](Config_Reference.md#virtual_sdcard) is "
#~ "enabled:"
#~ msgstr ""

#~ msgid "Initialize SD card: `M21`"
#~ msgstr ""

#~ msgid "Start/resume SD print: `M24`"
#~ msgstr ""

#~ msgid "Set SD position: `M26 S<offset>`"
#~ msgstr ""

#~ msgid ""
#~ "In addition, the following extended commands are available when the "
#~ "\"virtual_sdcard\" config section is enabled."
#~ msgstr ""

#~ msgid ""
#~ "`SDCARD_PRINT_FILE FILENAME=<filename>`: Load a file and start SD print."
#~ msgstr ""

#~ msgid "`SDCARD_RESET_FILE`: Unload file and clear SD state."
#~ msgstr ""

#~ msgid "SET_Z_THERMAL_ADJUST"
#~ msgstr ""

#~ msgid ""
#~ "The following commands are available when the [z_tilt config "
#~ "section](Config_Reference.md#z_tilt) is enabled."
#~ msgstr ""

#~ msgid ""
#~ "`Z_TILT_ADJUST [<probe_parameter>=<value>]`: This command will probe the "
#~ "points specified in the config and then make independent adjustments to each"
#~ " Z stepper to compensate for tilt. See the PROBE command for details on the "
#~ "optional probe parameters."
#~ msgstr ""

#~ msgid "Klipper has several compelling features:"
#~ msgstr ""

#~ msgid ""
#~ "Best in class performance. Klipper is able to achieve high stepping rates on"
#~ " both new and old micro-controllers. Even old 8bit micro-controllers can "
#~ "obtain rates over 175K steps per second. On more recent micro-controllers, "
#~ "several million steps per second are possible. Higher stepper rates enable "
#~ "higher print velocities. The stepper event timing remains precise even at "
#~ "high speeds which improves overall stability."
#~ msgstr ""

#~ msgid ""
#~ "Configuration via simple config file. There's no need to reflash the micro-"
#~ "controller to change a setting. All of Klipper's configuration is stored in "
#~ "a standard config file which can be easily edited. This makes it easier to "
#~ "setup and maintain the hardware."
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports \"Input Shaping\" to reduce the impact of vibrations on "
#~ "print quality. This can reduce or eliminate \"ringing\" (also known as "
#~ "\"ghosting\", \"echoing\", or \"rippling\") in prints. It may also allow one"
#~ " to obtain faster printing speeds while still maintaining high print "
#~ "quality."
#~ msgstr ""

#~ msgid ""
#~ "Klipper is hardware agnostic. One should get the same precise timing "
#~ "independent of the low-level electronics hardware. The Klipper micro-"
#~ "controller code is designed to faithfully follow the schedule provided by "
#~ "the Klipper host software (or prominently alert the user if it is unable "
#~ "to). This makes it easier to use available hardware, to upgrade to new "
#~ "hardware, and to have confidence in the hardware."
#~ msgstr ""

#~ msgid ""
#~ "Simpler code. Klipper uses a very high level language (Python) for most "
#~ "code. The kinematics algorithms, the G-code parsing, the heating and "
#~ "thermistor algorithms, etc. are all written in Python. This makes it easier "
#~ "to develop new functionality."
#~ msgstr ""

#~ msgid ""
#~ "Builtin API server. In addition to the standard G-Code interface, Klipper "
#~ "supports a rich JSON based application interface. This enables programmers "
#~ "to build external applications with detailed control of the printer."
#~ msgstr ""

#~ msgid "Klipper supports many standard 3d printer features:"
#~ msgstr ""

#~ msgid ""
#~ "Standard G-Code support. Common g-code commands that are produced by typical"
#~ " \"slicers\" (SuperSlicer, Cura, PrusaSlicer, etc.) are supported."
#~ msgstr ""

#~ msgid ""
#~ "Support for cartesian, delta, corexy, corexz, hybrid-corexy, hybrid-corexz, "
#~ "deltesian, rotary delta, polar, and cable winch style printers."
#~ msgstr ""

#~ msgid ""
#~ "Automatic delta calibration support. The calibration tool can perform basic "
#~ "height calibration as well as an enhanced X and Y dimension calibration. The"
#~ " calibration can be done with a Z height probe or via manual probing."
#~ msgstr ""

#~ msgid ""
#~ "Support for common temperature sensors (eg, common thermistors, AD595, "
#~ "AD597, AD849x, PT100, PT1000, MAX6675, MAX31855, MAX31856, MAX31865, BME280,"
#~ " HTU21D, DS18B20, and LM75). Custom thermistors and custom analog "
#~ "temperature sensors can also be configured. One can monitor the internal "
#~ "micro-controller temperature sensor and the internal temperature sensor of a"
#~ " Raspberry Pi."
#~ msgstr ""

#~ msgid ""
#~ "Support for standard fans, nozzle fans, and temperature controlled fans. No "
#~ "need to keep fans running when the printer is idle. Fan speed can be "
#~ "monitored on fans that have a tachometer."
#~ msgstr ""

#~ msgid ""
#~ "Support for common LCD displays attached directly to the printer. A default "
#~ "menu is also available. The contents of the display and menu can be fully "
#~ "customized via the config file."
#~ msgstr ""

#~ msgid ""
#~ "Klipper implements a \"stepper phase endstop\" algorithm that can improve "
#~ "the accuracy of typical endstop switches. When properly tuned it can improve"
#~ " a print's first layer bed adhesion."
#~ msgstr ""

#~ msgid ""
#~ "Support for measuring and recording acceleration using an adxl345, mpu9250, "
#~ "and mpu6050 accelerometers."
#~ msgstr ""

#~ msgid ""
#~ "Sample configuration files are available for many common printers. Check the"
#~ " [config directory](../config/) for a list."
#~ msgstr ""

#~ msgid "Step Benchmarks"
#~ msgstr ""

#~ msgid "Micro-controller"
#~ msgstr ""

#~ msgid "3 steppers active"
#~ msgstr ""

#~ msgid "157K"
#~ msgstr ""

#~ msgid "20Mhz AVR"
#~ msgstr ""

#~ msgid "123K"
#~ msgstr ""

#~ msgid "686K"
#~ msgstr ""

#~ msgid "STM32F042"
#~ msgstr ""

#~ msgid "578K"
#~ msgstr ""

#~ msgid "866K"
#~ msgstr ""

#~ msgid "STM32G0B1"
#~ msgstr ""

#~ msgid "790K"
#~ msgstr ""

#~ msgid "1180K"
#~ msgstr ""

#~ msgid "SAM3X8E"
#~ msgstr ""

#~ msgid "981K"
#~ msgstr ""

#~ msgid "1690K"
#~ msgstr ""

#~ msgid "LPC1768"
#~ msgstr ""

#~ msgid "1351K"
#~ msgstr ""

#~ msgid "2353K"
#~ msgstr ""

#~ msgid "RP2040"
#~ msgstr ""

#~ msgid "1636K"
#~ msgstr ""

#~ msgid "2500K"
#~ msgstr ""

#~ msgid "SAMD51"
#~ msgstr ""

#~ msgid "1885K"
#~ msgstr ""

#~ msgid "3652K"
#~ msgstr ""

#~ msgid "STM32F446"
#~ msgstr ""

#~ msgid "2634K"
#~ msgstr ""

#~ msgid "9091K"
#~ msgstr ""

#~ msgid ""
#~ "If unsure of the micro-controller on a particular board, find the "
#~ "appropriate [config file](../config/), and look for the micro-controller "
#~ "name in the comments at the top of that file."
#~ msgstr ""

#~ msgid "How can I donate to the project?"
#~ msgstr ""

#~ msgid "How do I calculate the rotation_distance config parameter?"
#~ msgstr ""

#~ msgid "Where's my serial port?"
#~ msgstr ""

#~ msgid ""
#~ "The name found in the above command is stable and it is possible to use it "
#~ "in the config file and while flashing the micro-controller code. For "
#~ "example, a flash command might look similar to:"
#~ msgstr ""

#~ msgid ""
#~ "Be sure to copy-and-paste the name from the \"ls\" command that you ran "
#~ "above as the name will be different for each printer."
#~ msgstr ""

#~ msgid "When the micro-controller restarts the device changes to /dev/ttyUSB1"
#~ msgstr ""

#~ msgid "The \"make flash\" command doesn't work"
#~ msgstr ""

#~ msgid ""
#~ "If you're having an intermittent failure or you do have a standard setup, "
#~ "then double check that Klipper isn't running when flashing (sudo service "
#~ "klipper stop), make sure OctoPrint isn't trying to connect directly to the "
#~ "device (open the Connection tab in the web page and click Disconnect if the "
#~ "Serial Port is set to the device), and make sure FLASH_DEVICE is set "
#~ "correctly for your board (see the [question above](#wheres-my-serial-port))."
#~ msgstr ""

#~ msgid "How do I change the serial baud rate?"
#~ msgstr ""

#~ msgid ""
#~ "If you want to change the baud rate anyway, then the new rate will need to "
#~ "be configured in the micro-controller (during **make menuconfig**) and that "
#~ "updated code will need to be compiled and flashed to the micro-controller. "
#~ "The Klipper printer.cfg file will also need to be updated to match that baud"
#~ " rate (see the [config reference](Config_Reference.md#mcu) for details). For"
#~ " example:"
#~ msgstr ""

#~ msgid ""
#~ "The baud rate shown on the OctoPrint web page has no impact on the internal "
#~ "Klipper micro-controller baud rate. Always set the OctoPrint baud rate to "
#~ "250000 when using Klipper."
#~ msgstr ""

#~ msgid "Can I run Klipper on something other than a Raspberry Pi 3?"
#~ msgstr ""

#~ msgid ""
#~ "Klipper will run on a Raspberry Pi 1 and on the Raspberry Pi Zero, but these"
#~ " boards don't have enough processing power to run OctoPrint well. It is "
#~ "common for print stalls to occur on these slower machines when printing "
#~ "directly from OctoPrint. (The printer may move faster than OctoPrint can "
#~ "send movement commands.) If you wish to run on one one of these slower "
#~ "boards anyway, consider using the \"virtual_sdcard\" feature when printing "
#~ "(see [config reference](Config_Reference.md#virtual_sdcard) for details)."
#~ msgstr ""

#~ msgid ""
#~ "Klipper has been run on other machines. The Klipper host software only "
#~ "requires Python running on a Linux (or similar) computer. However, if you "
#~ "wish to run it on a different machine you will need Linux admin knowledge to"
#~ " install the system prerequisites for that particular machine. See the "
#~ "[install-octopi.sh](../scripts/install-octopi.sh) script for further "
#~ "information on the necessary Linux admin steps."
#~ msgstr ""

#~ msgid ""
#~ "If you are looking to run the Klipper host software on a shared general-"
#~ "purpose desktop or server class machine, then note that Klipper has some "
#~ "real-time scheduling requirements. If, during a print, the host computer "
#~ "also performs an intensive general-purpose computing task (such as "
#~ "defragmenting a hard drive, 3d rendering, heavy swapping, etc.), then it may"
#~ " cause Klipper to report print errors."
#~ msgstr ""

#~ msgid "Can I run multiple instances of Klipper on the same host machine?"
#~ msgstr ""

#~ msgid ""
#~ "~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer.cfg -l "
#~ "/tmp/klippy.log\n"
#~ msgstr ""

#~ msgid ""
#~ "~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer2.cfg -l "
#~ "/tmp/klippy2.log -I /tmp/printer2\n"
#~ msgstr ""

#~ msgid "Do I have to use OctoPrint?"
#~ msgstr ""

#~ msgid ""
#~ "Klipper creates a \"virtual serial port\" via the \"/tmp/printer\" file, and"
#~ " it emulates a classic 3d-printer serial interface via that file. In "
#~ "general, alternative software may work with Klipper as long as it can be "
#~ "configured to use \"/tmp/printer\" for the printer serial port."
#~ msgstr ""

#~ msgid ""
#~ "The code does this to reduce the chance of accidentally commanding the head "
#~ "into the bed or a wall. Once the printer is homed the software attempts to "
#~ "verify each move is within the position_min/max defined in the config file. "
#~ "If the motors are disabled (via an M84 or M18 command) then the motors will "
#~ "need to be homed again prior to movement."
#~ msgstr ""

#~ msgid ""
#~ "If you want to move the head after a print finishes, consider adding the "
#~ "desired movement to the \"custom g-code\" section of your slicer."
#~ msgstr ""

#~ msgid "Why is the Z position_endstop set to 0.5 in the default configs?"
#~ msgstr ""

#~ msgid ""
#~ "I converted my config from Marlin and the X/Y axes work fine, but I just get"
#~ " a screeching noise when homing the Z axis"
#~ msgstr ""

#~ msgid ""
#~ "Long answer: In practice Marlin can typically only step at a rate of around "
#~ "10000 steps per second. If it is requested to move at a speed that would "
#~ "require a higher step rate then Marlin will generally just step as fast as "
#~ "it can. Klipper is able to achieve much higher step rates, but the stepper "
#~ "motor may not have sufficient torque to move at a higher speed. So, for a Z "
#~ "axis with a high gearing ratio or high microsteps setting the actual "
#~ "obtainable max_z_velocity may be smaller than what is configured in Marlin."
#~ msgstr ""

#~ msgid ""
#~ "If using the TMC2208 (or TMC2224) driver in \"standalone mode\" then make "
#~ "sure to use the [latest version of Klipper](#how-do-i-upgrade-to-the-latest-"
#~ "software). A workaround for a TMC2208 \"stealthchop\" driver problem was "
#~ "added to Klipper in mid-March of 2020."
#~ msgstr ""

#~ msgid ""
#~ "This is commonly caused by hardware errors on the USB connection between the"
#~ " host machine and the micro-controller. Things to look for:"
#~ msgstr ""

#~ msgid ""
#~ "If using a Raspberry Pi, use a [good quality power "
#~ "supply](https://www.raspberrypi.com/documentation/computers/raspberry-"
#~ "pi.html#power-supply) for the Raspberry Pi and use a [good quality USB "
#~ "cable](https://forums.raspberrypi.com/viewtopic.php?p=589877#p589877) to "
#~ "connect that power supply to the Pi. If you get \"under voltage\" warnings "
#~ "from OctoPrint, this is related to the power supply and it must be fixed."
#~ msgstr ""

#~ msgid ""
#~ "Verify stepper, heater, and other printer wires are not crimped or frayed. "
#~ "(Printer movement may place stress on a faulty wire causing it to lose "
#~ "contact, briefly short, or generate excessive noise.)"
#~ msgstr ""

#~ msgid "My Raspberry Pi keeps rebooting during prints"
#~ msgstr ""

#~ msgid ""
#~ "When I set `restart_method=command` my AVR device just hangs on a restart"
#~ msgstr ""

#~ msgid ""
#~ "The workaround is to use a restart_method other than \"command\" or to flash"
#~ " an updated bootloader to the AVR device. Flashing a new bootloader is a one"
#~ " time step that typically requires an external programmer - see "
#~ "[Bootloaders](Bootloaders.md) for further details."
#~ msgstr ""

#~ msgid ""
#~ "The software has been designed to prevent that. Once the host enables a "
#~ "heater, the host software needs to confirm that enablement every 5 seconds. "
#~ "If the micro-controller does not receive a confirmation every 5 seconds it "
#~ "goes into a \"shutdown\" state which is designed to turn off all heaters and"
#~ " stepper motors."
#~ msgstr ""

#~ msgid ""
#~ "In addition, the micro-controller software is configured with a minimum and "
#~ "maximum temperature range for each heater at startup (see the min_temp and "
#~ "max_temp parameters in the [config reference](Config_Reference.md#extruder) "
#~ "for details). If the micro-controller detects that the temperature is "
#~ "outside of that range then it will also enter a \"shutdown\" state."
#~ msgstr ""

#~ msgid "How do I convert a Marlin pin number to a Klipper pin name?"
#~ msgstr ""

#~ msgid ""
#~ "Long answer: Klipper uses the standard pin names defined by the micro-"
#~ "controller. On the Atmega chips these hardware pins have names like `PA4`, "
#~ "`PC7`, or `PD2`."
#~ msgstr ""

#~ msgid ""
#~ "To avoid this confusion, the core Klipper code uses the standard pin names "
#~ "defined by the micro-controller."
#~ msgstr ""

#~ msgid "It depends on the type of device and type of pin:"
#~ msgstr ""

#~ msgid ""
#~ "PWM pins (or Timer pins): Klipper does not use hardware PWM by default for "
#~ "any device. So, in general, one may wire heaters, fans, and similar devices "
#~ "to any general purpose IO pin. However, fans and output_pin devices may be "
#~ "optionally configured to use `hardware_pwm: True`, in which case the micro-"
#~ "controller must support hardware PWM on the pin (otherwise, Klipper will "
#~ "report a \"Not a valid PWM pin\" error)."
#~ msgstr ""

#~ msgid ""
#~ "SPI pins: When using hardware SPI it is necessary to wire the pins to the "
#~ "micro-controller's SPI capable pins. However, most devices can be configured"
#~ " to use \"software SPI\", in which case any general purpose IO pins may be "
#~ "used."
#~ msgstr ""

#~ msgid ""
#~ "Other devices may be wired to any general purpose IO pin. For example, "
#~ "steppers, heaters, fans, Z probes, servos, LEDs, common hd44780/st7920 LCD "
#~ "displays, the Trinamic UART control line may be wired to any general purpose"
#~ " IO pin."
#~ msgstr ""

#~ msgid ""
#~ "Navigate to the OctoPrint terminal tab and issue an M112 command in the "
#~ "terminal box. The M112 command will cause Klipper to enter into a "
#~ "\"shutdown\" state, and it will cause OctoPrint to disconnect from Klipper. "
#~ "Navigate to the OctoPrint connection area and click on \"Connect\" to cause "
#~ "OctoPrint to reconnect. Navigate back to the terminal tab and issue a "
#~ "FIRMWARE_RESTART command to clear the Klipper error state. After completing "
#~ "this sequence, the previous heating request will be canceled and a new print"
#~ " may be started."
#~ msgstr ""

#~ msgid ""
#~ "In a way, yes. Home the printer, issue a `GET_POSITION` command, run your "
#~ "print, home again and issue another `GET_POSITION`. Then compare the values "
#~ "in the `mcu:` line."
#~ msgstr ""

#~ msgid ""
#~ "Note that endstop switches themselves tend to trigger at slightly different "
#~ "positions, so a difference of a couple of microsteps is likely the result of"
#~ " endstop inaccuracies. A stepper motor itself can only lose steps in "
#~ "increments of 4 full steps. (So, if one is using 16 microsteps, then a lost "
#~ "step on the stepper would result in the \"mcu:\" step counter being off by a"
#~ " multiple of 64 microsteps.)"
#~ msgstr ""

#~ msgid ""
#~ "Short answer: We want to know if our printers detect a problem so that the "
#~ "underlying issue can be fixed and we can obtain great quality prints. We "
#~ "definitely do not want our printers to silently produce low quality prints."
#~ msgstr ""

#~ msgid ""
#~ "There are some related questions: Why doesn't Klipper pause the print "
#~ "instead? Report a warning instead? Check for errors before the print? Ignore"
#~ " errors in user typed commands? etc? Currently Klipper reads commands using "
#~ "the G-Code protocol, and unfortunately the G-Code command protocol is not "
#~ "flexible enough to make these alternatives practical today. There is "
#~ "developer interest in improving the user experience during abnormal events, "
#~ "but it is expected that will require notable infrastructure work (including "
#~ "a shift away from G-Code)."
#~ msgstr ""

#~ msgid ""
#~ "The first step to upgrading the software is to review the latest [config "
#~ "changes](Config_Changes.md) document. On occasion, changes are made to the "
#~ "software that require users to update their settings as part of a software "
#~ "upgrade. It is a good idea to review this document prior to upgrading."
#~ msgstr ""

#~ msgid ""
#~ "cd ~/klipper\n"
#~ "git pull\n"
#~ "~/klipper/scripts/install-octopi.sh\n"
#~ msgstr ""

#~ msgid ""
#~ "make menuconfig\n"
#~ "make clean\n"
#~ "make\n"
#~ "\n"
#~ "sudo service klipper stop\n"
#~ "make flash FLASH_DEVICE=/dev/ttyACM0\n"
#~ "sudo service klipper start\n"
#~ msgstr ""

#~ msgid ""
#~ "cd ~/klipper\n"
#~ "git pull\n"
#~ "sudo service klipper restart\n"
#~ msgstr ""

#~ msgid ""
#~ "If any errors persist then double check the [config "
#~ "changes](Config_Changes.md) document, as you may need to modify the printer "
#~ "configuration."
#~ msgstr ""

#~ msgid "How do I uninstall Klipper?"
#~ msgstr ""

#~ msgid ""
#~ "On the raspberry pi end, an uninstall script is available in "
#~ "[scripts/klipper-uninstall.sh](../scripts/klipper-uninstall.sh). For "
#~ "example:"
#~ msgstr ""

#~ msgid ""
#~ "The `[exclude_object]` module allows Klipper to exclude objects while a "
#~ "print is in progress. To enable this feature include an [exclude_object "
#~ "config section](Config_Reference.md#exclude_object) (also see the [command "
#~ "reference](G-Codes.md#exclude-object) and [sample-"
#~ "macros.cfg](../config/sample-macros.cfg) file for a Marlin/RepRapFirmware "
#~ "compatible M486 G-Code macro.)"
#~ msgstr ""

#~ msgid "Workflow Overview"
#~ msgstr ""

#~ msgid ""
#~ "Slicing is completed and the file is uploaded for printing. During the "
#~ "upload, the file is processed and `[exclude_object]` markers are added to "
#~ "the file. Alternately, slicers may be configured to prepare object exclusion"
#~ " markers natively, or in it's own pre-processing step."
#~ msgstr ""

#~ msgid ""
#~ "When Klipper processes the `EXCLUDE_OBJECT_DEFINE` block, it will update the"
#~ " status with the known objects and pass it on to clients."
#~ msgstr ""

#~ msgid ""
#~ "If the user requests that an object be cancelled, the client will issue an "
#~ "`EXCLUDE_OBJECT NAME=<name>` command to Klipper."
#~ msgstr ""

#~ msgid ""
#~ "The client will receive the updated status from Klipper and can use that "
#~ "information to reflect the object's status in the UI."
#~ msgstr ""

#~ msgid "The GCode File"
#~ msgstr ""

#~ msgid "Object Definitions"
#~ msgstr ""

#~ msgid ""
#~ "Object definitions are named, to allow users to easily select an object to "
#~ "be excluded, and additional metadata may be provided to allow for graphical "
#~ "cancellation displays. Currently defined metadata includes a `CENTER` X,Y "
#~ "coordinate, and a `POLYGON` list of X,Y points representing a minimal "
#~ "outline of the object. This could be a simple bounding box, or a complicated"
#~ " hull for showing more detailed visualizations of the printed objects. "
#~ "Especially when gcode files include multiple parts with overlapping bounding"
#~ " regions, center points become hard to visually distinguish. `POLYGONS` must"
#~ " be a json-compatible array of point `[X,Y]` tuples without whitespace. "
#~ "Additional parameters will be saved as strings in the object definition and "
#~ "provided in status updates."
#~ msgstr ""

#~ msgid ""
#~ "All available G-Code commands are documented in the [G-Code "
#~ "Reference](./G-Codes.md#excludeobject)"
#~ msgstr ""

#~ msgid ""
#~ "The state of this module is provided to clients by the [exclude_object "
#~ "status](Status_Reference.md#exclude_object)."
#~ msgstr ""

#~ msgid "The Klipper firmware is restarted."
#~ msgstr ""

#~ msgid "When an `EXCLUDE_OBJECT_DEFINE RESET=1` command is issued."
#~ msgstr ""

#~ msgid ""
#~ "As the print progresses, the `exclude_object.current_object` status field "
#~ "will be updated as Klipper processes `EXCLUDE_OBJECT_START` and "
#~ "`EXCLUDE_OBJECT_END` commands. The `current_object` field will be set even "
#~ "if the object has been excluded. Undefined objects marked with a "
#~ "`EXCLUDE_OBJECT_START` will be added to the known objects to assist in UI "
#~ "hinting, without any additional metadata."
#~ msgstr ""

#~ msgid ""
#~ "This document contains guidelines for contributing an example Klipper "
#~ "configuration to the Klipper github repository (located in the [config "
#~ "directory](../config/))."
#~ msgstr ""

#~ msgid "Guidelines"
#~ msgstr ""

#~ msgid ""
#~ "The `printer` prefix is used for stock printers sold by a mainstream "
#~ "manufacturer."
#~ msgstr ""

#~ msgid ""
#~ "The `kit` prefix is for 3d printers that are assembled according to a widely"
#~ " used specification. These \"kit\" printers are generally distinct from "
#~ "normal \"printers\" in that they are not sold by a manufacturer."
#~ msgstr ""

#~ msgid ""
#~ "The `example` prefix is used to describe printer kinematics. This type of "
#~ "config is typically only added along with code for a new type of printer "
#~ "kinematics."
#~ msgstr ""

#~ msgid ""
#~ "Do not use spaces or special characters in the config filename. The filename"
#~ " should contain only characters `A-Z`, `a-z`, `0-9`, `-`, and `.`."
#~ msgstr ""

#~ msgid ""
#~ "The example configuration should be for the \"stock\" configuration of the "
#~ "printer. (There are too many \"customized\" configurations to track in the "
#~ "main Klipper repository.) Similarly, we only add example config files for "
#~ "printers, kits, and boards that have mainstream popularity (eg, there should"
#~ " be at least a 100 of them in active use). Consider using the [Klipper "
#~ "Community Discourse server](https://community.klipper3d.org) for other "
#~ "configs."
#~ msgstr ""

#~ msgid ""
#~ "Do not specify `pressure_advance` in an example config, as that value is "
#~ "specific to the filament, not the printer hardware. Similarly, do not "
#~ "specify `max_extrude_only_velocity` nor `max_extrude_only_accel` settings."
#~ msgstr ""

#~ msgid ""
#~ "Only define macros that utilize functionality specific to the given printer "
#~ "or to define g-codes that are commonly emitted by slicers configured for the"
#~ " given printer."
#~ msgstr ""

#~ msgid ""
#~ "Do not copy the field documentation into the example config files. (Doing so"
#~ " creates a maintenance burden as an update to the documentation would then "
#~ "require changing it in many places.)"
#~ msgstr ""

#~ msgid "Use `field: value` syntax instead of `field=value`."
#~ msgstr ""

#~ msgid ""
#~ "Avoid defining field values that are set to their default value. For "
#~ "example, one should not specify `min_extrude_temp: 170` as that is already "
#~ "the default value."
#~ msgstr ""

#~ msgid ""
#~ "Avoid adding attribution or revision messages to the config files. (For "
#~ "example, avoid adding lines like \"this file was created by ...\".) Place "
#~ "attribution and change history in the git commit message."
#~ msgstr ""

#~ msgid ""
#~ "Do not disable a default safety system in an example config file. For "
#~ "example, a config should not specify a custom `max_extrude_cross_section`. "
#~ "Do not enable debugging features. For example there should not be a "
#~ "`force_move` config section."
#~ msgstr ""

#~ msgid ""
#~ "Example config files are submitted by creating a github \"pull request\". "
#~ "Please also follow the directions in the [contributing "
#~ "document](CONTRIBUTING.md)."
#~ msgstr ""

#~ msgid ""
#~ "This document describes Klipper's stepper phase adjusted endstop system. "
#~ "This functionality can improve the accuracy of traditional endstop switches."
#~ " It is most useful when using a Trinamic stepper motor driver that has run-"
#~ "time configuration."
#~ msgstr ""

#~ msgid ""
#~ "The stepper phase adjusted endstop mechanism can use the precision of the "
#~ "stepper motors to improve the precision of the endstop switches. A stepper "
#~ "motor moves by cycling through a series of phases until in completes four "
#~ "\"full steps\". So, a stepper motor using 16 micro-steps would have 64 "
#~ "phases and when moving in a positive direction it would cycle through "
#~ "phases: 0, 1, 2, ... 61, 62, 63, 0, 1, 2, etc. Crucially, when the stepper "
#~ "motor is at a particular position on a linear rail it should always be at "
#~ "the same stepper phase. Thus, when a carriage triggers the endstop switch "
#~ "the stepper controlling that carriage should always be at the same stepper "
#~ "motor phase. Klipper's endstop phase system combines the stepper phase with "
#~ "the endstop trigger to improve the accuracy of the endstop."
#~ msgstr ""

#~ msgid "Calibrating endstop phases"
#~ msgstr ""

#~ msgid "[endstop_phase]\n"
#~ msgstr ""

#~ msgid ""
#~ "After performing the above, the `ENDSTOP_PHASE_CALIBRATE` command will often"
#~ " report the same (or nearly the same) phase for the stepper. This phase can "
#~ "be saved in the config file so that all future G28 commands use that phase. "
#~ "(So, in future homing operations, Klipper will obtain the same position even"
#~ " if the endstop triggers a little earlier or a little later.)"
#~ msgstr ""

#~ msgid "ENDSTOP_PHASE_CALIBRATE STEPPER=stepper_z\n"
#~ msgstr ""

#~ msgid ""
#~ "This feature is most useful on delta printers and on the Z endstop of "
#~ "cartesian/corexy printers. It is possible to use this feature on the XY "
#~ "endstops of cartesian printers, but that isn't particularly useful as a "
#~ "minor error in X/Y endstop position is unlikely to impact print quality. It "
#~ "is not valid to use this feature on the XY endstops of corexy printers (as "
#~ "the XY position is not determined by a single stepper on corexy kinematics)."
#~ " It is not valid to use this feature on a printer using a "
#~ "\"probe:z_virtual_endstop\" Z endstop (as the stepper phase is only stable "
#~ "if the endstop is at a static location on a rail)."
#~ msgstr ""

#~ msgid ""
#~ "In order to use this system the endstop must be accurate enough to identify "
#~ "the stepper position within two \"full steps\". So, for example, if a "
#~ "stepper is using 16 micro-steps with a step distance of 0.005mm then the "
#~ "endstop must have an accuracy of at least 0.160mm. If one gets \"Endstop "
#~ "stepper_z incorrect phase\" type error messages than in may be due to an "
#~ "endstop that is not sufficiently accurate. If recalibration does not help "
#~ "then disable endstop phase adjustments by removing them from the config "
#~ "file."
#~ msgstr ""

#~ msgid ""
#~ "It is possible to use this system with traditional (non-Trinamic) stepper "
#~ "motor drivers. However, doing this requires making sure that the stepper "
#~ "motor drivers are reset every time the micro-controller is reset. (If the "
#~ "two are always reset together then Klipper can determine the stepper phase "
#~ "by tracking the total number of steps it has commanded the stepper to move.)"
#~ " Currently, the only way to do this reliably is if both the micro-controller"
#~ " and stepper motor drivers are powered solely from USB and that USB power is"
#~ " provided from a host running on a Raspberry Pi. In this situation one can "
#~ "specify an mcu config with \"restart_method: rpi_usb\" - that option will "
#~ "arrange for the micro-controller to always be reset via a USB power reset, "
#~ "which would arrange for both the micro-controller and stepper motor drivers "
#~ "to be reset together. If using this mechanism, one would then need to "
#~ "manually configure the \"trigger_phase\" config sections (see [config "
#~ "reference](Config_Reference.md#endstop_phase) for the details)."
#~ msgstr ""

#~ msgid ""
#~ "This document describes Klipper's automatic calibration system for \"delta\""
#~ " style printers."
#~ msgstr ""

#~ msgid ""
#~ "Ultimately, the delta calibration is dependent on the precision of the tower"
#~ " endstop switches. If one is using Trinamic stepper motor drivers then "
#~ "consider enabling [endstop phase](Endstop_Phase.md) detection to improve the"
#~ " accuracy of those switches."
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports calibrating the delta parameters via a manual probing "
#~ "method or via an automatic Z probe."
#~ msgstr ""

#~ msgid ""
#~ "If using a probe that is mounted on the side of the hotend (that is, it has "
#~ "an X or Y offset) then note that performing delta calibration will "
#~ "invalidate the results of probe calibration. These types of probes are "
#~ "rarely suitable for use on a delta (because minor effector tilt will result "
#~ "in a probe location bias). If using the probe anyway, then be sure to rerun "
#~ "probe calibration after any delta calibration."
#~ msgstr ""

#~ msgid ""
#~ "Klipper has a DELTA_CALIBRATE command that can perform basic delta "
#~ "calibration. This command probes seven different points on the bed and "
#~ "calculates new values for the tower angles, tower endstops, and delta "
#~ "radius."
#~ msgstr ""

#~ msgid ""
#~ "During the delta calibration process it may be necessary for the printer to "
#~ "probe below what would otherwise be considered the plane of the bed. It is "
#~ "typical to permit this during calibration by updating the config so that the"
#~ " printer's `minimum_z_position=-5`. (Once calibration completes, one can "
#~ "remove this setting from the config.)"
#~ msgstr ""

#~ msgid ""
#~ "To perform the basic probe, make sure the config has a [delta_calibrate] "
#~ "section defined and then run the tool:"
#~ msgstr ""

#~ msgid ""
#~ "After probing the seven points new delta parameters will be calculated. Save"
#~ " and apply these parameters by running:"
#~ msgstr ""

#~ msgid "Enhanced delta calibration"
#~ msgstr ""

#~ msgid ""
#~ "This calibration procedure requires printing a test object and measuring "
#~ "parts of that test object with digital calipers."
#~ msgstr ""

#~ msgid ""
#~ "Use a slicer to generate G-Code from the "
#~ "[docs/prints/calibrate_size.stl](prints/calibrate_size.stl) file. Slice the "
#~ "object using a slow speed (eg, 40mm/s). If possible, use a stiff plastic "
#~ "(such as PLA) for the object. The object has a diameter of 140mm. If this is"
#~ " too large for the printer then one can scale it down (but be sure to "
#~ "uniformly scale both the X and Y axes). If the printer supports "
#~ "significantly larger prints then this object can also be increased in size. "
#~ "A larger size can improve the measurement accuracy, but good print adhesion "
#~ "is more important than a larger print size."
#~ msgstr ""

#~ msgid ""
#~ "If possible, perform the measurements described below while the object is "
#~ "still attached to the print bed, but don't worry if the part detaches from "
#~ "the bed - just try to avoid bending the object when performing the "
#~ "measurements."
#~ msgstr ""

#~ msgid "![delta-a-distance](img/delta-a-distance.jpg)"
#~ msgstr ""

#~ msgid "![delta_cal_e_step1](img/delta_cal_e_step1.png)"
#~ msgstr ""

#~ msgid ""
#~ "DELTA_ANALYZE "
#~ "CENTER_DISTS=<a_dist>,<far_c_dist>,<b_dist>,<far_a_dist>,<c_dist>,<far_b_dist>\n"
#~ msgstr ""

#~ msgid ""
#~ "Then measure the distance between the A pillar and the pillar across from "
#~ "the C label."
#~ msgstr ""

#~ msgid ""
#~ "Then go counterclockwise and measure the distance between the pillar across "
#~ "from C to the B pillar, the distance between the B pillar and the pillar "
#~ "across from A, and so on."
#~ msgstr ""

#~ msgid "Enter these parameters into Klipper:"
#~ msgstr ""

#~ msgid ""
#~ "At this point it is okay to remove the object from the bed. The final "
#~ "measurements are of the pillars themselves. Measure the size of the center "
#~ "pillar along the A spoke, then the B spoke, and then the C spoke."
#~ msgstr ""

#~ msgid "![delta_cal_e_step3](img/delta_cal_e_step3.png)"
#~ msgstr ""

#~ msgid "DELTA_ANALYZE CENTER_PILLAR_WIDTHS=<a>,<b>,<c>\n"
#~ msgstr ""

#~ msgid "![delta-ab-pillar](img/delta-outer-pillar.jpg)"
#~ msgstr ""

#~ msgid "![delta_cal_e_step4](img/delta_cal_e_step4.png)"
#~ msgstr ""

#~ msgid "DELTA_ANALYZE OUTER_PILLAR_WIDTHS=<a>,<far_c>,<b>,<far_a>,<c>,<far_b>\n"
#~ msgstr ""

#~ msgid "DELTA_ANALYZE SCALE=1.0\n"
#~ msgstr ""

#~ msgid "Finally, perform the enhanced delta calibration by running:"
#~ msgstr ""

#~ msgid ""
#~ "This command can take several minutes to complete. After completion it will "
#~ "calculate updated delta parameters (delta radius, tower angles, endstop "
#~ "positions, and arm lengths). Use the SAVE_CONFIG command to save and apply "
#~ "the settings:"
#~ msgstr ""

#~ msgid ""
#~ "If the delta printer has good dimensional accuracy then the distance between"
#~ " any two pillars should be around 74mm and the width of every pillar should "
#~ "be around 9mm. (Specifically, the goal is for the distance between any two "
#~ "pillars minus the width of one of the pillars to be exactly 65mm.) Should "
#~ "there be a dimensional inaccuracy in the part then the DELTA_ANALYZE routine"
#~ " will calculate new delta parameters using both the distance measurements "
#~ "and the previous height measurements from the last DELTA_CALIBRATE command."
#~ msgstr ""

#~ msgid "Using Bed Mesh on a Delta"
#~ msgstr ""

#~ msgid ""
#~ "Note that performing delta calibration will invalidate any previously "
#~ "obtained bed mesh. After performing a new delta calibration be sure to rerun"
#~ " BED_MESH_CALIBRATE."
#~ msgstr ""

#~ msgid "This document describes some of the Klipper debugging tools."
#~ msgstr ""

#~ msgid ""
#~ "The main Klipper GitHub repository uses \"github actions\" to run a series "
#~ "of regression tests. It can be useful to run some of these tests locally."
#~ msgstr ""

#~ msgid "./scripts/check_whitespace.sh\n"
#~ msgstr ""

#~ msgid ""
#~ "tar xfz klipper-dict-20??????.tar.gz\n"
#~ "~/klippy-env/bin/python ~/klipper/scripts/test_klippy.py -d dict/ ~/klipper/test/klippy/*.test\n"
#~ msgstr ""

#~ msgid ""
#~ "Normally, the host klippy.py process would be used to translate gcode "
#~ "commands to Klipper micro-controller commands. However, it's also possible "
#~ "to manually send these MCU commands (functions marked with the "
#~ "DECL_COMMAND() macro in the Klipper source code). To do so, run:"
#~ msgstr ""

#~ msgid ""
#~ "See the \"HELP\" command within the tool for more information on its "
#~ "functionality."
#~ msgstr ""

#~ msgid "Translating gcode files to micro-controller commands"
#~ msgstr ""

#~ msgid ""
#~ "To run Klippy in this batch mode, there is a one time step necessary to "
#~ "generate the micro-controller \"data dictionary\". This is done by compiling"
#~ " the micro-controller code to obtain the **out/klipper.dict** file:"
#~ msgstr ""

#~ msgid ""
#~ "Once the above is done it is possible to run Klipper in batch mode (see "
#~ "[installation](Installation.md) for the steps necessary to build the python "
#~ "virtual environment and a printer.cfg file):"
#~ msgstr ""

#~ msgid ""
#~ "The above will produce a file **test.serial** with the binary serial output."
#~ " This output can be translated to readable text with:"
#~ msgstr ""

#~ msgid ""
#~ "The resulting file **test.txt** contains a human readable list of micro-"
#~ "controller commands."
#~ msgstr ""

#~ msgid "Motion analysis and data logging"
#~ msgstr ""

#~ msgid "Data logging is enabled with the `data_logger.py` tool. For example:"
#~ msgstr ""

#~ msgid ""
#~ "This command will connect to the Klipper API Server, subscribe to status and"
#~ " motion information, and log the results. Two files are generated - a "
#~ "compressed data file and an index file (eg, `mylog.json.gz` and "
#~ "`mylog.index.gz`). After starting the logging, it is possible to complete "
#~ "prints and other actions - the logging will continue in the background. When"
#~ " done logging, hit `ctrl-c` to exit from the `data_logger.py` tool."
#~ msgstr ""

#~ msgid ""
#~ "sudo apt-get update\n"
#~ "sudo apt-get install python-matplotlib\n"
#~ msgstr ""

#~ msgid "Graphs can be generated with a command like the following:"
#~ msgstr ""

#~ msgid ""
#~ "One can use the `-g` option to specify the datasets to graph (it takes a "
#~ "Python literal containing a list of lists). For example:"
#~ msgstr ""

#~ msgid ""
#~ "The list of available datasets can be found using the `-l` option - for "
#~ "example:"
#~ msgstr ""

#~ msgid ""
#~ "It is also possible to specify matplotlib plot options for each dataset:"
#~ msgstr ""

#~ msgid ""
#~ "Many matplotlib options are available; some examples are \"color\", "
#~ "\"label\", \"alpha\", and \"linestyle\"."
#~ msgstr ""

#~ msgid ""
#~ "The raw data logs produced by the `data_logger.py` tool follow the format "
#~ "described in the [API Server](API_Server.md). It may be useful to inspect "
#~ "the data with a Unix command like the following: `gunzip < mylog.json.gz | "
#~ "tr '\\03' '\\n' | less`"
#~ msgstr ""

#~ msgid ""
#~ "The Klippy log file (/tmp/klippy.log) stores statistics on bandwidth, micro-"
#~ "controller load, and host buffer load. It can be useful to graph these "
#~ "statistics after a print."
#~ msgstr ""

#~ msgid "Then graphs can be produced with:"
#~ msgstr ""

#~ msgid "One can then view the resulting **loadgraph.png** file."
#~ msgstr ""

#~ msgid "Extracting information from the klippy.log file"
#~ msgstr ""

#~ msgid ""
#~ "mkdir work_directory\n"
#~ "cd work_directory\n"
#~ "cp /tmp/klippy.log .\n"
#~ "~/klipper/scripts/logextract.py ./klippy.log\n"
#~ msgstr ""

#~ msgid "Testing with simulavr"
#~ msgstr ""

#~ msgid ""
#~ "To use simulavr, download the simulavr package and compile with python "
#~ "support. Note that the build system may need to have some packages (such as "
#~ "swig) installed in order to build the python module."
#~ msgstr ""

#~ msgid ""
#~ "Make sure a file like **./build/pysimulavr/_pysimulavr.*.so** is present "
#~ "after the above compilation:"
#~ msgstr ""

#~ msgid ""
#~ "This commmand should report a specific file (e.g. "
#~ "**./build/pysimulavr/_pysimulavr.cpython-39-x86_64-linux-gnu.so**) and not "
#~ "an error."
#~ msgstr ""

#~ msgid ""
#~ "sudo apt update\n"
#~ "sudo apt install g++ make cmake swig rst2pdf help2man texinfo\n"
#~ "make cfgclean python debian\n"
#~ "sudo dpkg -i build/debian/python3-simulavr*.deb\n"
#~ msgstr ""

#~ msgid ""
#~ "cd /path/to/klipper\n"
#~ "make menuconfig\n"
#~ msgstr ""

#~ msgid ""
#~ "PYTHONPATH=/path/to/simulavr/build/pysimulavr/ ./scripts/avrsim.py "
#~ "out/klipper.elf\n"
#~ msgstr ""

#~ msgid "./scripts/avrsim.py out/klipper.elf\n"
#~ msgstr ""

#~ msgid ""
#~ "~/klippy-env/bin/python ./klippy/klippy.py config/generic-simulavr.cfg -i "
#~ "test.gcode -v\n"
#~ msgstr ""

#~ msgid ""
#~ "One useful feature of simulavr is its ability to create signal wave "
#~ "generation files with the exact timing of events. To do this, follow the "
#~ "directions above, but run avrsim.py with a command-line like the following:"
#~ msgstr ""

#~ msgid ""
#~ "The above would create a file **avrsim.vcd** with information on each change"
#~ " to the GPIOs on PORTA and PORTB. This could then be viewed using gtkwave "
#~ "with:"
#~ msgstr ""

#~ msgid "This document provides contact information for Klipper."
#~ msgstr ""

#~ msgid "[Discord Chat](#discord-chat)"
#~ msgstr ""

#~ msgid "[I have a feature request](#i-have-a-feature-request)"
#~ msgstr ""

#~ msgid ""
#~ "[I found a bug in the Klipper software](#i-found-a-bug-in-the-klipper-"
#~ "software)"
#~ msgstr ""

#~ msgid "[Klipper github](#klipper-github)"
#~ msgstr ""

#~ msgid ""
#~ "There is a [Klipper Community Discourse "
#~ "server](https://community.klipper3d.org) for discussions on Klipper."
#~ msgstr ""

#~ msgid ""
#~ "There is a Discord server dedicated to Klipper at: "
#~ "<https://discord.klipper3d.org>."
#~ msgstr ""

#~ msgid "I have a question about Klipper"
#~ msgstr ""

#~ msgid ""
#~ "It is also possible to search for similar questions in the [Klipper "
#~ "Community Forum](#community-forum)."
#~ msgstr ""

#~ msgid ""
#~ "Many questions we receive are general 3d-printing questions that are not "
#~ "specific to Klipper. If you have a general question or are experiencing "
#~ "general printing problems, then you will likely get a better response by "
#~ "asking in a general 3d-printing forum or a forum dedicated to your printer "
#~ "hardware."
#~ msgstr ""

#~ msgid ""
#~ "All new features require someone interested and able to implement that "
#~ "feature. If you are interested in helping to implement or test a new "
#~ "feature, you can search for ongoing developments in the [Klipper Community "
#~ "Forum](#community-forum). There is also [Klipper Discord Chat](#discord-"
#~ "chat) for discussions between collaborators."
#~ msgstr ""

#~ msgid ""
#~ "Unfortunately, we receive many more requests for help than we could possibly"
#~ " answer. Most problem reports we see are eventually tracked down to:"
#~ msgstr ""

#~ msgid "Not following all the steps described in the Klipper documentation."
#~ msgstr ""

#~ msgid ""
#~ "If you are experiencing a printing problem, then we recommend carefully "
#~ "inspecting the printer hardware (all joints, wires, screws, etc.) and verify"
#~ " nothing is abnormal. We find most printing problems are not related to the "
#~ "Klipper software. If you do find a problem with the printer hardware then "
#~ "you will likely get a better response by searching in a general 3d-printing "
#~ "forum or in a forum dedicated to your printer hardware."
#~ msgstr ""

#~ msgid "I found a bug in the Klipper software"
#~ msgstr ""

#~ msgid ""
#~ "Problems should be reported in the [Klipper Community Forum](#community-"
#~ "forum)."
#~ msgstr ""

#~ msgid ""
#~ "Make sure you are running unmodified code from "
#~ "<https://github.com/Klipper3d/klipper>. If the code has been modified or is "
#~ "obtained from another source, then you should reproduce the problem on the "
#~ "unmodified code from <https://github.com/Klipper3d/klipper> prior to "
#~ "reporting."
#~ msgstr ""

#~ msgid ""
#~ "Obtain the Klipper log file from the event. The log file has been engineered"
#~ " to answer common questions the Klipper developers have about the software "
#~ "and its environment (software version, hardware type, configuration, event "
#~ "timing, and hundreds of other questions)."
#~ msgstr ""

#~ msgid ""
#~ "An \"scp\" or \"sftp\" utility is needed to copy this log file to your "
#~ "desktop computer. The \"scp\" utility comes standard with Linux and MacOS "
#~ "desktops. There are freely available scp utilities for other desktops (eg, "
#~ "WinSCP). If using a graphical scp utility that can not directly copy "
#~ "`/tmp/klippy.log` then repeatedly click on `..` or `parent folder` until you"
#~ " get to the root directory, click on the `tmp` folder, and then select the "
#~ "`klippy.log` file."
#~ msgstr ""

#~ msgid ""
#~ "Do not modify the log file in any way; do not provide a snippet of the log. "
#~ "Only the full unmodified log file provides the necessary information."
#~ msgstr ""

#~ msgid ""
#~ "Open a new topic on the [Klipper Community Forum](#community-forum) and "
#~ "provide a clear description of the problem. Other Klipper contributors will "
#~ "need to understand what steps were taken, what the desired outcome was, and "
#~ "what outcome actually occurred. The compressed Klipper log file should be "
#~ "attached to that topic."
#~ msgstr ""

#~ msgid "Klipper is open-source software and we appreciate new contributions."
#~ msgstr ""

#~ msgid ""
#~ "There are several [documents for developers](Overview.md#developer-"
#~ "documentation). If you have questions on the code then you can also ask in "
#~ "the [Klipper Community Forum](#community-forum) or on the [Klipper Community"
#~ " Discord](#discord-chat)."
#~ msgstr ""

#~ msgid ""
#~ "Klipper github may be used by contributors to share the status of their work"
#~ " to improve Klipper. It is expected that the person opening a github ticket "
#~ "is actively working on the given task and will be the one performing all the"
#~ " work necessary to accomplish it. The Klipper github is not used for "
#~ "requests, nor to report bugs, nor to ask questions. Use the [Klipper "
#~ "Community Forum](#community-forum) or the [Klipper Community "
#~ "Discord](#discord-chat) instead."
#~ msgstr ""

#~ msgid ""
#~ "This document provides a list of steps to help confirm the pin settings in "
#~ "the Klipper printer.cfg file. It is a good idea to run through these steps "
#~ "after following the steps in the [installation document](Installation.md)."
#~ msgstr ""

#~ msgid "Verify temperature"
#~ msgstr ""

#~ msgid "![octoprint-temperature](img/octoprint-temperature.png)"
#~ msgstr ""

#~ msgid "Verify M112"
#~ msgstr ""

#~ msgid ""
#~ "The M112 command causes Klipper to go into a \"shutdown\" state. To clear "
#~ "this state, issue a FIRMWARE_RESTART command in the Octoprint terminal tab."
#~ msgstr ""

#~ msgid ""
#~ "Navigate to the Octoprint temperature tab and type in 50 followed by enter "
#~ "in the \"Tool\" temperature box. The extruder temperature in the graph "
#~ "should start to increase (within about 30 seconds or so). Then go to the "
#~ "\"Tool\" temperature drop-down box and select \"Off\". After several minutes"
#~ " the temperature should start to return to its initial room temperature "
#~ "value. If the temperature does not increase then verify the \"heater_pin\" "
#~ "setting in the config."
#~ msgstr ""

#~ msgid "Verify stepper motor enable pin"
#~ msgstr ""

#~ msgid "Verify endstops"
#~ msgstr ""

#~ msgid ""
#~ "If the endstop appears inverted (it reports \"open\" when triggered and "
#~ "vice-versa) then add a \"!\" to the pin definition (for example, "
#~ "\"endstop_pin: ^!ar3\"), or remove the \"!\" if there is already one "
#~ "present."
#~ msgstr ""

#~ msgid "Verify stepper motors"
#~ msgstr ""

#~ msgid ""
#~ "If the stepper does not move at all, then verify the \"enable_pin\" and "
#~ "\"step_pin\" settings for the stepper. If the stepper motor moves but does "
#~ "not return to its original position then verify the \"dir_pin\" setting. If "
#~ "the stepper motor oscillates in an incorrect direction, then it generally "
#~ "indicates that the \"dir_pin\" for the axis needs to be inverted. This is "
#~ "done by adding a '!' to the \"dir_pin\" in the printer config file (or "
#~ "removing it if one is already there). If the motor moves significantly more "
#~ "or significantly less than one millimeter then verify the "
#~ "\"rotation_distance\" setting."
#~ msgstr ""

#~ msgid ""
#~ "After verifying all endstops and verifying all stepper motors the homing "
#~ "mechanism should be tested. Issue a G28 command to home all axes. Remove "
#~ "power from the printer if it does not home properly. Rerun the endstop and "
#~ "stepper motor verification steps if necessary."
#~ msgstr ""

#~ msgid ""
#~ "To test the extruder motor it will be necessary to heat the extruder to a "
#~ "printing temperature. Navigate to the Octoprint temperature tab and select a"
#~ " target temperature from the temperature drop-down box (or manually enter an"
#~ " appropriate temperature). Wait for the printer to reach the desired "
#~ "temperature. Then navigate to the Octoprint control tab and click the "
#~ "\"Extrude\" button. Verify that the extruder motor turns in the correct "
#~ "direction. If it does not, see the troubleshooting tips in the previous "
#~ "section to confirm the \"enable_pin\", \"step_pin\", and \"dir_pin\" "
#~ "settings for the extruder."
#~ msgstr ""

#~ msgid ""
#~ "Klipper supports [PID control](https://en.wikipedia.org/wiki/PID_controller)"
#~ " for the extruder and bed heaters. In order to use this control mechanism, "
#~ "it is necessary to calibrate the PID settings on each printer (PID settings "
#~ "found in other firmwares or in the example configuration files often work "
#~ "poorly)."
#~ msgstr ""

#~ msgid ""
#~ "At the completion of the tuning test run `SAVE_CONFIG` to update the "
#~ "printer.cfg file the new PID settings."
#~ msgstr ""

#~ msgid "Next steps"
#~ msgstr ""

#~ msgid ""
#~ "After one has verified that basic printing works, it is a good idea to "
#~ "consider calibrating [pressure advance](Pressure_Advance.md)."
#~ msgstr ""

#~ msgid ""
#~ "This document is a reference for options available in the Klipper config "
#~ "file."
#~ msgstr ""

#~ msgid "Micro-controller configuration"
#~ msgstr ""

#~ msgid ""
#~ "Many config options require the name of a micro-controller pin. Klipper uses"
#~ " the hardware names for these pins - for example `PA4`."
#~ msgstr ""

#~ msgid ""
#~ "Input pins may be preceded by `^` to indicate that a hardware pull-up "
#~ "resistor should be enabled for the pin. If the micro-controller supports "
#~ "pull-down resistors then an input pin may alternatively be preceded by `~`."
#~ msgstr ""

#~ msgid "[mcu]"
#~ msgstr ""

#~ msgid ""
#~ "[mcu]\n"
#~ "serial:\n"
#~ "#   The serial port to connect to the MCU. If unsure (or if it\n"
#~ "#   changes) see the \"Where's my serial port?\" section of the FAQ.\n"
#~ "#   This parameter must be provided when using a serial port.\n"
#~ "#baud: 250000\n"
#~ "#   The baud rate to use. The default is 250000.\n"
#~ "#canbus_uuid:\n"
#~ "#   If using a device connected to a CAN bus then this sets the unique\n"
#~ "#   chip identifier to connect to. This value must be provided when using\n"
#~ "#   CAN bus for communication.\n"
#~ "#canbus_interface:\n"
#~ "#   If using a device connected to a CAN bus then this sets the CAN\n"
#~ "#   network interface to use. The default is 'can0'.\n"
#~ "#restart_method:\n"
#~ "#   This controls the mechanism the host will use to reset the\n"
#~ "#   micro-controller. The choices are 'arduino', 'cheetah', 'rpi_usb',\n"
#~ "#   and 'command'. The 'arduino' method (toggle DTR) is common on\n"
#~ "#   Arduino boards and clones. The 'cheetah' method is a special\n"
#~ "#   method needed for some Fysetc Cheetah boards. The 'rpi_usb' method\n"
#~ "#   is useful on Raspberry Pi boards with micro-controllers powered\n"
#~ "#   over USB - it briefly disables power to all USB ports to\n"
#~ "#   accomplish a micro-controller reset. The 'command' method involves\n"
#~ "#   sending a Klipper command to the micro-controller so that it can\n"
#~ "#   reset itself. The default is 'arduino' if the micro-controller\n"
#~ "#   communicates over a serial port, 'command' otherwise.\n"
#~ msgstr ""

#~ msgid ""
#~ "Additional micro-controllers (one may define any number of sections with an "
#~ "\"mcu\" prefix). Additional micro-controllers introduce additional pins that"
#~ " may be configured as heaters, steppers, fans, etc.. For example, if an "
#~ "\"[mcu extra_mcu]\" section is introduced, then pins such as "
#~ "\"extra_mcu:ar9\" may then be used elsewhere in the config (where \"ar9\" is"
#~ " a hardware pin name or alias name on the given mcu)."
#~ msgstr ""

#~ msgid "Common kinematic settings"
#~ msgstr ""

#~ msgid "The printer section controls high level printer settings."
#~ msgstr ""

#~ msgid "[stepper]"
#~ msgstr ""

#~ msgid ""
#~ "See the [rotation distance document](Rotation_Distance.md) for information "
#~ "on calculating the `rotation_distance` parameter. See the [Multi-MCU "
#~ "homing](Multi_MCU_Homing.md) document for information on homing using "
#~ "multiple micro-controllers."
#~ msgstr ""

#~ msgid "Cartesian Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to cartesian printers are described here - see "
#~ "[common kinematic settings](#common-kinematic-settings) for available "
#~ "parameters."
#~ msgstr ""

#~ msgid "Linear Delta Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to linear delta printers are described here - see "
#~ "[common kinematic settings](#common-kinematic-settings) for available "
#~ "parameters."
#~ msgstr ""

#~ msgid "Deltesian Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to deltesian printers are described here - see "
#~ "[common kinematic settings](#common-kinematic-settings) for available "
#~ "parameters."
#~ msgstr ""

#~ msgid "CoreXY Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to corexy printers are described here - see [common"
#~ " kinematic settings](#common-kinematic-settings) for available parameters."
#~ msgstr ""

#~ msgid "CoreXZ Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to corexz printers are described here - see [common"
#~ " kinematic settings](#common-kinematic-settings) for available parameters."
#~ msgstr ""

#~ msgid "Hybrid-CoreXY Kinematics"
#~ msgstr ""

#~ msgid "This kinematic is also known as Markforged kinematic."
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: hybrid_corexy\n"
#~ "max_z_velocity:\n"
#~ "#   This sets the maximum velocity (in mm/s) of movement along the z\n"
#~ "#   axis. The default is to use max_velocity for max_z_velocity.\n"
#~ "max_z_accel:\n"
#~ "#   This sets the maximum acceleration (in mm/s^2) of movement along\n"
#~ "#   the z axis. The default is to use max_accel for max_z_accel.\n"
#~ "\n"
#~ "# The stepper_x section is used to describe the X axis as well as the\n"
#~ "# stepper controlling the X-Y movement.\n"
#~ "[stepper_x]\n"
#~ "\n"
#~ "# The stepper_y section is used to describe the stepper controlling\n"
#~ "# the Y axis.\n"
#~ "[stepper_y]\n"
#~ "\n"
#~ "# The stepper_z section is used to describe the stepper controlling\n"
#~ "# the Z axis.\n"
#~ "[stepper_z]\n"
#~ msgstr ""

#~ msgid ""
#~ "See [example-hybrid-corexz.cfg](../config/example-hybrid-corexz.cfg) for an "
#~ "example hybrid corexz kinematics config file."
#~ msgstr ""

#~ msgid "Polar Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to polar printers are described here - see [common "
#~ "kinematic settings](#common-kinematic-settings) for available parameters."
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: polar\n"
#~ "max_z_velocity:\n"
#~ "#   This sets the maximum velocity (in mm/s) of movement along the z\n"
#~ "#   axis. This setting can be used to restrict the maximum speed of\n"
#~ "#   the z stepper motor. The default is to use max_velocity for\n"
#~ "#   max_z_velocity.\n"
#~ "max_z_accel:\n"
#~ "#   This sets the maximum acceleration (in mm/s^2) of movement along\n"
#~ "#   the z axis. It limits the acceleration of the z stepper motor. The\n"
#~ "#   default is to use max_accel for max_z_accel.\n"
#~ "\n"
#~ "# The stepper_bed section is used to describe the stepper controlling\n"
#~ "# the bed.\n"
#~ "[stepper_bed]\n"
#~ "gear_ratio:\n"
#~ "#   A gear_ratio must be specified and rotation_distance may not be\n"
#~ "#   specified. For example, if the bed has an 80 toothed pulley driven\n"
#~ "#   by a stepper with a 16 toothed pulley then one would specify a\n"
#~ "#   gear ratio of \"80:16\". This parameter must be provided.\n"
#~ "\n"
#~ "# The stepper_arm section is used to describe the stepper controlling\n"
#~ "# the carriage on the arm.\n"
#~ "[stepper_arm]\n"
#~ "\n"
#~ "# The stepper_z section is used to describe the stepper controlling\n"
#~ "# the Z axis.\n"
#~ "[stepper_z]\n"
#~ msgstr ""

#~ msgid ""
#~ "See [example-rotary-delta.cfg](../config/example-rotary-delta.cfg) for an "
#~ "example rotary delta kinematics config file."
#~ msgstr ""

#~ msgid ""
#~ "ROTARY DELTA KINEMATICS ARE A WORK IN PROGRESS. Homing moves may timeout and"
#~ " some boundary checks are not implemented."
#~ msgstr ""

#~ msgid "Cable winch Kinematics"
#~ msgstr ""

#~ msgid ""
#~ "Only parameters specific to cable winch printers are described here - see "
#~ "[common kinematic settings](#common-kinematic-settings) for available "
#~ "parameters."
#~ msgstr ""

#~ msgid ""
#~ "[printer]\n"
#~ "kinematics: winch\n"
#~ "\n"
#~ "# The stepper_a section describes the stepper connected to the first\n"
#~ "# cable winch. A minimum of 3 and a maximum of 26 cable winches may be\n"
#~ "# defined (stepper_a to stepper_z) though it is common to define 4.\n"
#~ "[stepper_a]\n"
#~ "rotation_distance:\n"
#~ "#   The rotation_distance is the nominal distance (in mm) the toolhead\n"
#~ "#   moves towards the cable winch for each full rotation of the\n"
#~ "#   stepper motor. This parameter must be provided.\n"
#~ "anchor_x:\n"
#~ "anchor_y:\n"
#~ "anchor_z:\n"
#~ "#   The X, Y, and Z position of the cable winch in cartesian space.\n"
#~ "#   These parameters must be provided.\n"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to define a special \"none\" kinematics to disable kinematic "
#~ "support in Klipper. This may be useful for controlling devices that are not "
#~ "typical 3d-printers or for debugging purposes."
#~ msgstr ""

#~ msgid "Common extruder and heated bed support"
#~ msgstr ""

#~ msgid ""
#~ "[extruder]\n"
#~ "step_pin:\n"
#~ "dir_pin:\n"
#~ "enable_pin:\n"
#~ "microsteps:\n"
#~ "rotation_distance:\n"
#~ "#full_steps_per_rotation:\n"
#~ "#gear_ratio:\n"
#~ "#   See the \"stepper\" section for a description of the above\n"
#~ "#   parameters. If none of the above parameters are specified then no\n"
#~ "#   stepper will be associated with the nozzle hotend (though a\n"
#~ "#   SYNC_EXTRUDER_MOTION command may associate one at run-time).\n"
#~ "nozzle_diameter:\n"
#~ "#   Diameter of the nozzle orifice (in mm). This parameter must be\n"
#~ "#   provided.\n"
#~ "filament_diameter:\n"
#~ "#   The nominal diameter of the raw filament (in mm) as it enters the\n"
#~ "#   extruder. This parameter must be provided.\n"
#~ "#max_extrude_cross_section:\n"
#~ "#   Maximum area (in mm^2) of an extrusion cross section (eg,\n"
#~ "#   extrusion width multiplied by layer height). This setting prevents\n"
#~ "#   excessive amounts of extrusion during relatively small XY moves.\n"
#~ "#   If a move requests an extrusion rate that would exceed this value\n"
#~ "#   it will cause an error to be returned. The default is: 4.0 *\n"
#~ "#   nozzle_diameter^2\n"
#~ "#instantaneous_corner_velocity: 1.000\n"
#~ "#   The maximum instantaneous velocity change (in mm/s) of the\n"
#~ "#   extruder during the junction of two moves. The default is 1mm/s.\n"
#~ "#max_extrude_only_distance: 50.0\n"
#~ "#   Maximum length (in mm of raw filament) that a retraction or\n"
#~ "#   extrude-only move may have. If a retraction or extrude-only move\n"
#~ "#   requests a distance greater than this value it will cause an error\n"
#~ "#   to be returned. The default is 50mm.\n"
#~ "#max_extrude_only_velocity:\n"
#~ "#max_extrude_only_accel:\n"
#~ "#   Maximum velocity (in mm/s) and acceleration (in mm/s^2) of the\n"
#~ "#   extruder motor for retractions and extrude-only moves. These\n"
#~ "#   settings do not have any impact on normal printing moves. If not\n"
#~ "#   specified then they are calculated to match the limit an XY\n"
#~ "#   printing move with a cross section of 4.0*nozzle_diameter^2 would\n"
#~ "#   have.\n"
#~ "#pressure_advance: 0.0\n"
#~ "#   The amount of raw filament to push into the extruder during\n"
#~ "#   extruder acceleration. An equal amount of filament is retracted\n"
#~ "#   during deceleration. It is measured in millimeters per\n"
#~ "#   millimeter/second. The default is 0, which disables pressure\n"
#~ "#   advance.\n"
#~ "#pressure_advance_smooth_time: 0.040\n"
#~ "#   A time range (in seconds) to use when calculating the average\n"
#~ "#   extruder velocity for pressure advance. A larger value results in\n"
#~ "#   smoother extruder movements. This parameter may not exceed 200ms.\n"
#~ "#   This setting only applies if pressure_advance is non-zero. The\n"
#~ "#   default is 0.040 (40 milliseconds).\n"
#~ "#\n"
#~ "# The remaining variables describe the extruder heater.\n"
#~ "heater_pin:\n"
#~ "#   PWM output pin controlling the heater. This parameter must be\n"
#~ "#   provided.\n"
#~ "#max_power: 1.0\n"
#~ "#   The maximum power (expressed as a value from 0.0 to 1.0) that the\n"
#~ "#   heater_pin may be set to. The value 1.0 allows the pin to be set\n"
#~ "#   fully enabled for extended periods, while a value of 0.5 would\n"
#~ "#   allow the pin to be enabled for no more than half the time. This\n"
#~ "#   setting may be used to limit the total power output (over extended\n"
#~ "#   periods) to the heater. The default is 1.0.\n"
#~ "sensor_type:\n"
#~ "#   Type of sensor - common thermistors are \"EPCOS 100K B57560G104F\",\n"
#~ "#   \"ATC Semitec 104GT-2\", \"ATC Semitec 104NT-4-R025H42G\", \"Generic\n"
#~ "#   3950\",\"Honeywell 100K 135-104LAG-J01\", \"NTC 100K MGB18-104F39050L32\",\n"
#~ "#   \"SliceEngineering 450\", and \"TDK NTCG104LH104JT1\". See the\n"
#~ "#   \"Temperature sensors\" section for other sensors. This parameter\n"
#~ "#   must be provided.\n"
#~ "sensor_pin:\n"
#~ "#   Analog input pin connected to the sensor. This parameter must be\n"
#~ "#   provided.\n"
#~ "#pullup_resistor: 4700\n"
#~ "#   The resistance (in ohms) of the pullup attached to the thermistor.\n"
#~ "#   This parameter is only valid when the sensor is a thermistor. The\n"
#~ "#   default is 4700 ohms.\n"
#~ "#smooth_time: 1.0\n"
#~ "#   A time value (in seconds) over which temperature measurements will\n"
#~ "#   be smoothed to reduce the impact of measurement noise. The default\n"
#~ "#   is 1 seconds.\n"
#~ "control:\n"
#~ "#   Control algorithm (either pid or watermark). This parameter must\n"
#~ "#   be provided.\n"
#~ "pid_Kp:\n"
#~ "pid_Ki:\n"
#~ "pid_Kd:\n"
#~ "#   The proportional (pid_Kp), integral (pid_Ki), and derivative\n"
#~ "#   (pid_Kd) settings for the PID feedback control system. Klipper\n"
#~ "#   evaluates the PID settings with the following general formula:\n"
#~ "#     heater_pwm = (Kp*error + Ki*integral(error) - Kd*derivative(error)) / 255\n"
#~ "#   Where \"error\" is \"requested_temperature - measured_temperature\"\n"
#~ "#   and \"heater_pwm\" is the requested heating rate with 0.0 being full\n"
#~ "#   off and 1.0 being full on. Consider using the PID_CALIBRATE\n"
#~ "#   command to obtain these parameters. The pid_Kp, pid_Ki, and pid_Kd\n"
#~ "#   parameters must be provided for PID heaters.\n"
#~ "#max_delta: 2.0\n"
#~ "#   On 'watermark' controlled heaters this is the number of degrees in\n"
#~ "#   Celsius above the target temperature before disabling the heater\n"
#~ "#   as well as the number of degrees below the target before\n"
#~ "#   re-enabling the heater. The default is 2 degrees Celsius.\n"
#~ "#pwm_cycle_time: 0.100\n"
#~ "#   Time in seconds for each software PWM cycle of the heater. It is\n"
#~ "#   not recommended to set this unless there is an electrical\n"
#~ "#   requirement to switch the heater faster than 10 times a second.\n"
#~ "#   The default is 0.100 seconds.\n"
#~ "#min_extrude_temp: 170\n"
#~ "#   The minimum temperature (in Celsius) at which extruder move\n"
#~ "#   commands may be issued. The default is 170 Celsius.\n"
#~ "min_temp:\n"
#~ "max_temp:\n"
#~ "#   The maximum range of valid temperatures (in Celsius) that the\n"
#~ "#   heater must remain within. This controls a safety feature\n"
#~ "#   implemented in the micro-controller code - should the measured\n"
#~ "#   temperature ever fall outside this range then the micro-controller\n"
#~ "#   will go into a shutdown state. This check can help detect some\n"
#~ "#   heater and sensor hardware failures. Set this range just wide\n"
#~ "#   enough so that reasonable temperatures do not result in an error.\n"
#~ "#   These parameters must be provided.\n"
#~ msgstr ""

#~ msgid ""
#~ "The heater_bed section describes a heated bed. It uses the same heater "
#~ "settings described in the \"extruder\" section."
#~ msgstr ""

#~ msgid "Bed level support"
#~ msgstr ""

#~ msgid ""
#~ "See the [bed mesh guide](Bed_Mesh.md) and [command "
#~ "reference](G-Codes.md#bed_mesh) for additional information."
#~ msgstr ""

#~ msgid ""
#~ " rectangular bed, probe_count = 3, 3:\n"
#~ "             x---x---x (max_point)\n"
#~ "             |\n"
#~ "             x---x---x\n"
#~ "                     |\n"
#~ " (min_point) x---x---x\n"
#~ "\n"
#~ " round bed, round_probe_count = 5, bed_radius = r:\n"
#~ "                 x (0, r) end\n"
#~ "               /\n"
#~ "             x---x---x\n"
#~ "                       \\\n"
#~ " (-r, 0) x---x---x---x---x (r, 0)\n"
#~ "           \\\n"
#~ "             x---x---x\n"
#~ "                   /\n"
#~ "                 x  (0, -r) start\n"
#~ msgstr ""

#~ msgid ""
#~ "Bed tilt compensation. One may define a bed_tilt config section to enable "
#~ "move transformations that account for a tilted bed. Note that bed_mesh and "
#~ "bed_tilt are incompatible; both cannot be defined."
#~ msgstr ""

#~ msgid ""
#~ "[bed_tilt]\n"
#~ "#x_adjust: 0\n"
#~ "#   The amount to add to each move's Z height for each mm on the X\n"
#~ "#   axis. The default is 0.\n"
#~ "#y_adjust: 0\n"
#~ "#   The amount to add to each move's Z height for each mm on the Y\n"
#~ "#   axis. The default is 0.\n"
#~ "#z_adjust: 0\n"
#~ "#   The amount to add to the Z height when the nozzle is nominally at\n"
#~ "#   0, 0. The default is 0.\n"
#~ "# The remaining parameters control a BED_TILT_CALIBRATE extended\n"
#~ "# g-code command that may be used to calibrate appropriate x and y\n"
#~ "# adjustment parameters.\n"
#~ "#points:\n"
#~ "#   A list of X, Y coordinates (one per line; subsequent lines\n"
#~ "#   indented) that should be probed during a BED_TILT_CALIBRATE\n"
#~ "#   command. Specify coordinates of the nozzle and be sure the probe\n"
#~ "#   is above the bed at the given nozzle coordinates. The default is\n"
#~ "#   to not enable the command.\n"
#~ "#speed: 50\n"
#~ "#   The speed (in mm/s) of non-probing moves during the calibration.\n"
#~ "#   The default is 50.\n"
#~ "#horizontal_move_z: 5\n"
#~ "#   The height (in mm) that the head should be commanded to move to\n"
#~ "#   just prior to starting a probe operation. The default is 5.\n"
#~ msgstr ""

#~ msgid ""
#~ "See the [leveling guide](Manual_Level.md#adjusting-bed-leveling-screws) and "
#~ "[command reference](G-Codes.md#bed_screws) for additional information."
#~ msgstr ""

#~ msgid ""
#~ "Tool to help adjust bed screws tilt using Z probe. One may define a "
#~ "screws_tilt_adjust config section to enable a SCREWS_TILT_CALCULATE g-code "
#~ "command."
#~ msgstr ""

#~ msgid ""
#~ "[screws_tilt_adjust]\n"
#~ "#screw1:\n"
#~ "#   The (X, Y) coordinate of the first bed leveling screw. This is a\n"
#~ "#   position to command the nozzle to so that the probe is directly\n"
#~ "#   above the bed screw (or as close as possible while still being\n"
#~ "#   above the bed). This is the base screw used in calculations. This\n"
#~ "#   parameter must be provided.\n"
#~ "#screw1_name:\n"
#~ "#   An arbitrary name for the given screw. This name is displayed when\n"
#~ "#   the helper script runs. The default is to use a name based upon\n"
#~ "#   the screw XY location.\n"
#~ "#screw2:\n"
#~ "#screw2_name:\n"
#~ "#...\n"
#~ "#   Additional bed leveling screws. At least two screws must be\n"
#~ "#   defined.\n"
#~ "#speed: 50\n"
#~ "#   The speed (in mm/s) of non-probing moves during the calibration.\n"
#~ "#   The default is 50.\n"
#~ "#horizontal_move_z: 5\n"
#~ "#   The height (in mm) that the head should be commanded to move to\n"
#~ "#   just prior to starting a probe operation. The default is 5.\n"
#~ "#screw_thread: CW-M3\n"
#~ "#   The type of screw used for bed level, M3, M4 or M5 and the\n"
#~ "#   direction of the knob used to level the bed, clockwise decrease\n"
#~ "#   counter-clockwise decrease.\n"
#~ "#   Accepted values: CW-M3, CCW-M3, CW-M4, CCW-M4, CW-M5, CCW-M5.\n"
#~ "#   Default value is CW-M3, most printers use an M3 screw and\n"
#~ "#   turning the knob clockwise decrease distance.\n"
#~ msgstr ""

#~ msgid ""
#~ "[z_tilt]\n"
#~ "#z_positions:\n"
#~ "#   A list of X, Y coordinates (one per line; subsequent lines\n"
#~ "#   indented) describing the location of each bed \"pivot point\". The\n"
#~ "#   \"pivot point\" is the point where the bed attaches to the given Z\n"
#~ "#   stepper. It is described using nozzle coordinates (the X, Y position\n"
#~ "#   of the nozzle if it could move directly above the point). The\n"
#~ "#   first entry corresponds to stepper_z, the second to stepper_z1,\n"
#~ "#   the third to stepper_z2, etc. This parameter must be provided.\n"
#~ "#points:\n"
#~ "#   A list of X, Y coordinates (one per line; subsequent lines\n"
#~ "#   indented) that should be probed during a Z_TILT_ADJUST command.\n"
#~ "#   Specify coordinates of the nozzle and be sure the probe is above\n"
#~ "#   the bed at the given nozzle coordinates. This parameter must be\n"
#~ "#   provided.\n"
#~ "#speed: 50\n"
#~ "#   The speed (in mm/s) of non-probing moves during the calibration.\n"
#~ "#   The default is 50.\n"
#~ "#horizontal_move_z: 5\n"
#~ "#   The height (in mm) that the head should be commanded to move to\n"
#~ "#   just prior to starting a probe operation. The default is 5.\n"
#~ "#retries: 0\n"
#~ "#   Number of times to retry if the probed points aren't within\n"
#~ "#   tolerance.\n"
#~ "#retry_tolerance: 0\n"
#~ "#   If retries are enabled then retry if largest and smallest probed\n"
#~ "#   points differ more than retry_tolerance. Note the smallest unit of\n"
#~ "#   change here would be a single step. However if you are probing\n"
#~ "#   more points than steppers then you will likely have a fixed\n"
#~ "#   minimum value for the range of probed points which you can learn\n"
#~ "#   by observing command output.\n"
#~ msgstr ""

#~ msgid ""
#~ "Moving gantry leveling using 4 independently controlled Z motors. Corrects "
#~ "hyperbolic parabola effects (potato chip) on moving gantry which is more "
#~ "flexible. WARNING: Using this on a moving bed may lead to undesirable "
#~ "results. If this section is present then a QUAD_GANTRY_LEVEL extended G-Code"
#~ " command becomes available. This routine assumes the following Z motor "
#~ "configuration:"
#~ msgstr ""

#~ msgid "Where x is the 0, 0 point on the bed"
#~ msgstr ""

#~ msgid ""
#~ "Printer Skew Correction. It is possible to use software to correct printer "
#~ "skew across 3 planes, xy, xz, yz. This is done by printing a calibration "
#~ "model along a plane and measuring three lengths. Due to the nature of skew "
#~ "correction these lengths are set via gcode. See [Skew "
#~ "Correction](Skew_Correction.md) and [Command "
#~ "Reference](G-Codes.md#skew_correction) for details."
#~ msgstr ""

#~ msgid ""
#~ "Temperature-dependant toolhead Z position adjustment. Compensate for "
#~ "vertical toolhead movement caused by thermal expansion of the printer's "
#~ "frame in real-time using a temperature sensor (typically coupled to a "
#~ "vertical section of frame)."
#~ msgstr ""

#~ msgid ""
#~ "[z_thermal_adjust]\n"
#~ "#temp_coeff:\n"
#~ "#   The temperature coefficient of expansion, in mm/degC. For example, a\n"
#~ "#   temp_coeff of 0.01 mm/degC will move the Z axis downwards by 0.01 mm for\n"
#~ "#   every degree Celsius that the temperature sensor increases. Defaults to\n"
#~ "#   0.0 mm/degC, which applies no adjustment.\n"
#~ "#smooth_time:\n"
#~ "#   Smoothing window applied to the temperature sensor, in seconds. Can reduce\n"
#~ "#   motor noise from excessive small corrections in response to sensor noise.\n"
#~ "#   The default is 2.0 seconds.\n"
#~ "#z_adjust_off_above:\n"
#~ "#   Disables adjustments above this Z height [mm]. The last computed correction\n"
#~ "#   will remain applied until the toolhead moves below the specified Z height\n"
#~ "#   again. The default is 99999999.0 mm (always on).\n"
#~ "#max_z_adjustment:\n"
#~ "#   Maximum absolute adjustment that can be applied to the Z axis [mm]. The\n"
#~ "#   default is 99999999.0 mm (unlimited).\n"
#~ "#sensor_type:\n"
#~ "#sensor_pin:\n"
#~ "#min_temp:\n"
#~ "#max_temp:\n"
#~ "#   Temperature sensor configuration.\n"
#~ "#   See the \"extruder\" section for the definition of the above\n"
#~ "#   parameters.\n"
#~ "#gcode_id:\n"
#~ "#   See the \"heater_generic\" section for the definition of this\n"
#~ "#   parameter.\n"
#~ msgstr ""

#~ msgid "[safe_z_home]"
#~ msgstr ""

#~ msgid ""
#~ "[safe_z_home]\n"
#~ "home_xy_position:\n"
#~ "#   A X, Y coordinate (e.g. 100, 100) where the Z homing should be\n"
#~ "#   performed. This parameter must be provided.\n"
#~ "#speed: 50.0\n"
#~ "#   Speed at which the toolhead is moved to the safe Z home\n"
#~ "#   coordinate. The default is 50 mm/s\n"
#~ "#z_hop:\n"
#~ "#   Distance (in mm) to lift the Z axis prior to homing. This is\n"
#~ "#   applied to any homing command, even if it doesn't home the Z axis.\n"
#~ "#   If the Z axis is already homed and the current Z position is less\n"
#~ "#   than z_hop, then this will lift the head to a height of z_hop. If\n"
#~ "#   the Z axis is not already homed the head is lifted by z_hop.\n"
#~ "#   The default is to not implement Z hop.\n"
#~ "#z_hop_speed: 15.0\n"
#~ "#   Speed (in mm/s) at which the Z axis is lifted prior to homing. The\n"
#~ "#   default is 15 mm/s.\n"
#~ "#move_to_previous: False\n"
#~ "#   When set to True, the X and Y axes are reset to their previous\n"
#~ "#   positions after Z axis homing. The default is False.\n"
#~ msgstr ""

#~ msgid ""
#~ "Homing override. One may use this mechanism to run a series of g-code "
#~ "commands in place of a G28 found in the normal g-code input. This may be "
#~ "useful on printers that require a specific procedure to home the machine."
#~ msgstr ""

#~ msgid ""
#~ "Stepper phase adjusted endstops. To use this feature, define a config "
#~ "section with an \"endstop_phase\" prefix followed by the name of the "
#~ "corresponding stepper config section (for example, \"[endstop_phase "
#~ "stepper_z]\"). This feature can improve the accuracy of endstop switches. "
#~ "Add a bare \"[endstop_phase]\" declaration to enable the "
#~ "ENDSTOP_PHASE_CALIBRATE command."
#~ msgstr ""

#~ msgid ""
#~ "[endstop_phase stepper_z]\n"
#~ "#endstop_accuracy:\n"
#~ "#   Sets the expected accuracy (in mm) of the endstop. This represents\n"
#~ "#   the maximum error distance the endstop may trigger (eg, if an\n"
#~ "#   endstop may occasionally trigger 100um early or up to 100um late\n"
#~ "#   then set this to 0.200 for 200um). The default is\n"
#~ "#   4*rotation_distance/full_steps_per_rotation.\n"
#~ "#trigger_phase:\n"
#~ "#   This specifies the phase of the stepper motor driver to expect\n"
#~ "#   when hitting the endstop. It is composed of two numbers separated\n"
#~ "#   by a forward slash character - the phase and the total number of\n"
#~ "#   phases (eg, \"7/64\"). Only set this value if one is sure the\n"
#~ "#   stepper motor driver is reset every time the mcu is reset. If this\n"
#~ "#   is not set, then the stepper phase will be detected on the first\n"
#~ "#   home and that phase will be used on all subsequent homes.\n"
#~ "#endstop_align_zero: False\n"
#~ "#   If true then the position_endstop of the axis will effectively be\n"
#~ "#   modified so that the zero position for the axis occurs at a full\n"
#~ "#   step on the stepper motor. (If used on the Z axis and the print\n"
#~ "#   layer height is a multiple of a full step distance then every\n"
#~ "#   layer will occur on a full step.) The default is False.\n"
#~ msgstr ""

#~ msgid ""
#~ "G-Code macros (one may define any number of sections with a \"gcode_macro\" "
#~ "prefix). See the [command template guide](Command_Templates.md) for more "
#~ "information."
#~ msgstr ""

#~ msgid ""
#~ "Execute a gcode on a set delay. See the [command template "
#~ "guide](Command_Templates.md#delayed-gcodes) and [command "
#~ "reference](G-Codes.md#delayed_gcode) for more information."
#~ msgstr ""

#~ msgid ""
#~ "Support saving variables to disk so that they are retained across restarts. "
#~ "See [command templates](Command_Templates.md#save-variables-to-disk) and "
#~ "[G-Code reference](G-Codes.md#save_variables) for further information."
#~ msgstr ""

#~ msgid ""
#~ "Idle timeout. An idle timeout is automatically enabled - add an explicit "
#~ "idle_timeout config section to change the default settings."
#~ msgstr ""

#~ msgid "Optional G-Code features"
#~ msgstr ""

#~ msgid ""
#~ "[virtual_sdcard]\n"
#~ "path:\n"
#~ "#   The path of the local directory on the host machine to look for\n"
#~ "#   g-code files. This is a read-only directory (sdcard file writes\n"
#~ "#   are not supported). One may point this to OctoPrint's upload\n"
#~ "#   directory (generally ~/.octoprint/uploads/ ). This parameter must\n"
#~ "#   be provided.\n"
#~ "#on_error_gcode:\n"
#~ "#   A list of G-Code commands to execute when an error is reported.\n"
#~ "\n"
#~ msgstr ""

#~ msgid ""
#~ "See the [command reference](G-Codes.md#sdcard_loop) for supported commands. "
#~ "See the [sample-macros.cfg](../config/sample-macros.cfg) file for a Marlin "
#~ "compatible M808 G-Code macro."
#~ msgstr ""

#~ msgid ""
#~ "Support manually moving stepper motors for diagnostic purposes. Note, using "
#~ "this feature may place the printer in an invalid state - see the [command "
#~ "reference](G-Codes.md#force_move) for important details."
#~ msgstr ""

#~ msgid ""
#~ "Pause/Resume functionality with support of position capture and restore. See"
#~ " the [command reference](G-Codes.md#pause_resume) for more information."
#~ msgstr ""

#~ msgid ""
#~ "Firmware filament retraction. This enables G10 (retract) and G11 (unretract)"
#~ " GCODE commands issued by many slicers. The parameters below provide startup"
#~ " defaults, although the values can be adjusted via the SET_RETRACTION "
#~ "[command](G-Codes.md#firmware_retraction)), allowing per-filament settings "
#~ "and runtime tuning."
#~ msgstr ""

#~ msgid "Support for gcode arc (G2/G3) commands."
#~ msgstr ""

#~ msgid "Enable the \"M118\" and \"RESPOND\" extended [commands](G-Codes.md#respond)."
#~ msgstr ""

#~ msgid ""
#~ "Enables support to exclude or cancel individual objects during the printing "
#~ "process."
#~ msgstr ""

#~ msgid "[exclude_object]\n"
#~ msgstr ""

#~ msgid ""
#~ "Enables [resonance compensation](Resonance_Compensation.md). Also see the "
#~ "[command reference](G-Codes.md#input_shaper)."
#~ msgstr ""

#~ msgid ""
#~ "Support for ADXL345 accelerometers. This support allows one to query "
#~ "accelerometer measurements from the sensor. This enables an "
#~ "ACCELEROMETER_MEASURE command (see [G-Codes](G-Codes.md#adxl345) for more "
#~ "information). The default chip name is \"default\", but one may specify an "
#~ "explicit name (eg, [adxl345 my_chip_name])."
#~ msgstr ""

#~ msgid "[mpu9250]"
#~ msgstr ""

#~ msgid ""
#~ "[mpu9250 my_accelerometer]\n"
#~ "#i2c_address:\n"
#~ "#   Default is 104 (0x68). If AD0 is high, it would be 0x69 instead.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed: 400000\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters. The default \"i2c_speed\" is 400000.\n"
#~ "#axes_map: x, y, z\n"
#~ "#   See the \"adxl345\" section for information on this parameter.\n"
#~ msgstr ""

#~ msgid ""
#~ "[resonance_tester]\n"
#~ "#probe_points:\n"
#~ "#   A list of X, Y, Z coordinates of points (one point per line) to test\n"
#~ "#   resonances at. At least one point is required. Make sure that all\n"
#~ "#   points with some safety margin in XY plane (~a few centimeters)\n"
#~ "#   are reachable by the toolhead.\n"
#~ "#accel_chip:\n"
#~ "#   A name of the accelerometer chip to use for measurements. If\n"
#~ "#   adxl345 chip was defined without an explicit name, this parameter\n"
#~ "#   can simply reference it as \"accel_chip: adxl345\", otherwise an\n"
#~ "#   explicit name must be supplied as well, e.g. \"accel_chip: adxl345\n"
#~ "#   my_chip_name\". Either this, or the next two parameters must be\n"
#~ "#   set.\n"
#~ "#accel_chip_x:\n"
#~ "#accel_chip_y:\n"
#~ "#   Names of the accelerometer chips to use for measurements for each\n"
#~ "#   of the axis. Can be useful, for instance, on bed slinger printer,\n"
#~ "#   if two separate accelerometers are mounted on the bed (for Y axis)\n"
#~ "#   and on the toolhead (for X axis). These parameters have the same\n"
#~ "#   format as 'accel_chip' parameter. Only 'accel_chip' or these two\n"
#~ "#   parameters must be provided.\n"
#~ "#max_smoothing:\n"
#~ "#   Maximum input shaper smoothing to allow for each axis during shaper\n"
#~ "#   auto-calibration (with 'SHAPER_CALIBRATE' command). By default no\n"
#~ "#   maximum smoothing is specified. Refer to Measuring_Resonances guide\n"
#~ "#   for more details on using this feature.\n"
#~ "#min_freq: 5\n"
#~ "#   Minimum frequency to test for resonances. The default is 5 Hz.\n"
#~ "#max_freq: 133.33\n"
#~ "#   Maximum frequency to test for resonances. The default is 133.33 Hz.\n"
#~ "#accel_per_hz: 75\n"
#~ "#   This parameter is used to determine which acceleration to use to\n"
#~ "#   test a specific frequency: accel = accel_per_hz * freq. Higher the\n"
#~ "#   value, the higher is the energy of the oscillations. Can be set to\n"
#~ "#   a lower than the default value if the resonances get too strong on\n"
#~ "#   the printer. However, lower values make measurements of\n"
#~ "#   high-frequency resonances less precise. The default value is 75\n"
#~ "#   (mm/sec).\n"
#~ "#hz_per_sec: 1\n"
#~ "#   Determines the speed of the test. When testing all frequencies in\n"
#~ "#   range [min_freq, max_freq], each second the frequency increases by\n"
#~ "#   hz_per_sec. Small values make the test slow, and the large values\n"
#~ "#   will decrease the precision of the test. The default value is 1.0\n"
#~ "#   (Hz/sec == sec^-2).\n"
#~ msgstr ""

#~ msgid "[board_pins]"
#~ msgstr ""

#~ msgid ""
#~ "[board_pins my_aliases]\n"
#~ "mcu: mcu\n"
#~ "#   A comma separated list of micro-controllers that may use the\n"
#~ "#   aliases. The default is to apply the aliases to the main \"mcu\".\n"
#~ "aliases:\n"
#~ "aliases_<name>:\n"
#~ "#   A comma separated list of \"name=value\" aliases to create for the\n"
#~ "#   given micro-controller. For example, \"EXP1_1=PE6\" would create an\n"
#~ "#   \"EXP1_1\" alias for the \"PE6\" pin. However, if \"value\" is enclosed\n"
#~ "#   in \"<>\" then \"name\" is created as a reserved pin (for example,\n"
#~ "#   \"EXP1_9=<GND>\" would reserve \"EXP1_9\"). Any number of options\n"
#~ "#   starting with \"aliases_\" may be specified.\n"
#~ msgstr ""

#~ msgid ""
#~ "Include file support. One may include additional config file from the main "
#~ "printer config file. Wildcards may also be used (eg, \"configs/*.cfg\")."
#~ msgstr ""

#~ msgid "[duplicate_pin_override]"
#~ msgstr ""

#~ msgid ""
#~ "[duplicate_pin_override]\n"
#~ "pins:\n"
#~ "#   A comma separated list of pins that may be used multiple times in\n"
#~ "#   a config file without normal error checks. This parameter must be\n"
#~ "#   provided.\n"
#~ msgstr ""

#~ msgid ""
#~ "Z height probe. One may define this section to enable Z height probing "
#~ "hardware. When this section is enabled, PROBE and QUERY_PROBE extended "
#~ "[g-code commands](G-Codes.md#probe) become available. Also, see the [probe "
#~ "calibrate guide](Probe_Calibrate.md). The probe section also creates a "
#~ "virtual \"probe:z_virtual_endstop\" pin. One may set the stepper_z "
#~ "endstop_pin to this virtual pin on cartesian style printers that use the "
#~ "probe in place of a z endstop. If using \"probe:z_virtual_endstop\" then do "
#~ "not define a position_endstop in the stepper_z config section."
#~ msgstr ""

#~ msgid ""
#~ "BLTouch probe. One may define this section (instead of a probe section) to "
#~ "enable a BLTouch probe. See [BL-Touch guide](BLTouch.md) and [command "
#~ "reference](G-Codes.md#bltouch) for further information. A virtual "
#~ "\"probe:z_virtual_endstop\" pin is also created (see the \"probe\" section "
#~ "for the details)."
#~ msgstr ""

#~ msgid ""
#~ "The \"Smart Effector\" from Duet3d implements a Z probe using a force "
#~ "sensor. One may define this section instead of `[probe]` to enable the Smart"
#~ " Effector specific features. This also enables [runtime "
#~ "commands](G-Codes.md#smart_effector) to adjust the parameters of the Smart "
#~ "Effector at run time."
#~ msgstr ""

#~ msgid "Additional stepper motors and extruders"
#~ msgstr ""

#~ msgid ""
#~ "Multi-stepper axes. On a cartesian style printer, the stepper controlling a "
#~ "given axis may have additional config blocks defining steppers that should "
#~ "be stepped in concert with the primary stepper. One may define any number of"
#~ " sections with a numeric suffix starting at 1 (for example, \"stepper_z1\", "
#~ "\"stepper_z2\", etc.)."
#~ msgstr ""

#~ msgid "[extruder1]"
#~ msgstr ""

#~ msgid ""
#~ "See [sample-multi-extruder.cfg](../config/sample-multi-extruder.cfg) for an "
#~ "example configuration."
#~ msgstr ""

#~ msgid ""
#~ "Support for cartesian printers with dual carriages on a single axis. The "
#~ "active carriage is set via the SET_DUAL_CARRIAGE extended g-code command. "
#~ "The \"SET_DUAL_CARRIAGE CARRIAGE=1\" command will activate the carriage "
#~ "defined in this section (CARRIAGE=0 will return activation to the primary "
#~ "carriage). Dual carriage support is typically combined with extra extruders "
#~ "- the SET_DUAL_CARRIAGE command is often called at the same time as the "
#~ "ACTIVATE_EXTRUDER command. Be sure to park the carriages during "
#~ "deactivation."
#~ msgstr ""

#~ msgid ""
#~ "[dual_carriage]\n"
#~ "axis:\n"
#~ "#   The axis this extra carriage is on (either x or y). This parameter\n"
#~ "#   must be provided.\n"
#~ "#step_pin:\n"
#~ "#dir_pin:\n"
#~ "#enable_pin:\n"
#~ "#microsteps:\n"
#~ "#rotation_distance:\n"
#~ "#endstop_pin:\n"
#~ "#position_endstop:\n"
#~ "#position_min:\n"
#~ "#position_max:\n"
#~ "#   See the \"stepper\" section for the definition of the above parameters.\n"
#~ msgstr ""

#~ msgid ""
#~ "Support for additional steppers synchronized to the movement of an extruder "
#~ "(one may define any number of sections with an \"extruder_stepper\" prefix)."
#~ msgstr ""

#~ msgid ""
#~ "[extruder_stepper my_extra_stepper]\n"
#~ "extruder:\n"
#~ "#   The extruder this stepper is synchronized to. If this is set to an\n"
#~ "#   empty string then the stepper will not be synchronized to an\n"
#~ "#   extruder. This parameter must be provided.\n"
#~ "#step_pin:\n"
#~ "#dir_pin:\n"
#~ "#enable_pin:\n"
#~ "#microsteps:\n"
#~ "#rotation_distance:\n"
#~ "#   See the \"stepper\" section for the definition of the above\n"
#~ "#   parameters.\n"
#~ msgstr ""

#~ msgid ""
#~ "[manual_stepper my_stepper]\n"
#~ "#step_pin:\n"
#~ "#dir_pin:\n"
#~ "#enable_pin:\n"
#~ "#microsteps:\n"
#~ "#rotation_distance:\n"
#~ "#   See the \"stepper\" section for a description of these parameters.\n"
#~ "#velocity:\n"
#~ "#   Set the default velocity (in mm/s) for the stepper. This value\n"
#~ "#   will be used if a MANUAL_STEPPER command does not specify a SPEED\n"
#~ "#   parameter. The default is 5mm/s.\n"
#~ "#accel:\n"
#~ "#   Set the default acceleration (in mm/s^2) for the stepper. An\n"
#~ "#   acceleration of zero will result in no acceleration. This value\n"
#~ "#   will be used if a MANUAL_STEPPER command does not specify an ACCEL\n"
#~ "#   parameter. The default is zero.\n"
#~ "#endstop_pin:\n"
#~ "#   Endstop switch detection pin. If specified, then one may perform\n"
#~ "#   \"homing moves\" by adding a STOP_ON_ENDSTOP parameter to\n"
#~ "#   MANUAL_STEPPER movement commands.\n"
#~ msgstr ""

#~ msgid "[verify_heater]"
#~ msgstr ""

#~ msgid ""
#~ "[verify_heater heater_config_name]\n"
#~ "#max_error: 120\n"
#~ "#   The maximum \"cumulative temperature error\" before raising an\n"
#~ "#   error. Smaller values result in stricter checking and larger\n"
#~ "#   values allow for more time before an error is reported.\n"
#~ "#   Specifically, the temperature is inspected once a second and if it\n"
#~ "#   is close to the target temperature then an internal \"error\n"
#~ "#   counter\" is reset; otherwise, if the temperature is below the\n"
#~ "#   target range then the counter is increased by the amount the\n"
#~ "#   reported temperature differs from that range. Should the counter\n"
#~ "#   exceed this \"max_error\" then an error is raised. The default is\n"
#~ "#   120.\n"
#~ "#check_gain_time:\n"
#~ "#   This controls heater verification during initial heating. Smaller\n"
#~ "#   values result in stricter checking and larger values allow for\n"
#~ "#   more time before an error is reported. Specifically, during\n"
#~ "#   initial heating, as long as the heater increases in temperature\n"
#~ "#   within this time frame (specified in seconds) then the internal\n"
#~ "#   \"error counter\" is reset. The default is 20 seconds for extruders\n"
#~ "#   and 60 seconds for heater_bed.\n"
#~ "#hysteresis: 5\n"
#~ "#   The maximum temperature difference (in Celsius) to a target\n"
#~ "#   temperature that is considered in range of the target. This\n"
#~ "#   controls the max_error range check. It is rare to customize this\n"
#~ "#   value. The default is 5.\n"
#~ "#heating_gain: 2\n"
#~ "#   The minimum temperature (in Celsius) that the heater must increase\n"
#~ "#   by during the check_gain_time check. It is rare to customize this\n"
#~ "#   value. The default is 2.\n"
#~ msgstr ""

#~ msgid "Tool to disable heaters when homing or probing an axis."
#~ msgstr ""

#~ msgid "[thermistor]"
#~ msgstr ""

#~ msgid ""
#~ "[thermistor my_thermistor]\n"
#~ "#temperature1:\n"
#~ "#resistance1:\n"
#~ "#temperature2:\n"
#~ "#resistance2:\n"
#~ "#temperature3:\n"
#~ "#resistance3:\n"
#~ "#   Three resistance measurements (in Ohms) at the given temperatures\n"
#~ "#   (in Celsius). The three measurements will be used to calculate the\n"
#~ "#   Steinhart-Hart coefficients for the thermistor. These parameters\n"
#~ "#   must be provided when using Steinhart-Hart to define the\n"
#~ "#   thermistor.\n"
#~ "#beta:\n"
#~ "#   Alternatively, one may define temperature1, resistance1, and beta\n"
#~ "#   to define the thermistor parameters. This parameter must be\n"
#~ "#   provided when using \"beta\" to define the thermistor.\n"
#~ msgstr ""

#~ msgid ""
#~ "Custom ADC temperature sensors (one may define any number of sections with "
#~ "an \"adc_temperature\" prefix). This allows one to define a custom "
#~ "temperature sensor that measures a voltage on an Analog to Digital Converter"
#~ " (ADC) pin and uses linear interpolation between a set of configured "
#~ "temperature/voltage (or temperature/resistance) measurements to determine "
#~ "the temperature. The resulting sensor can be used as a sensor_type in a "
#~ "heater section. (For example, if one defines a \"[adc_temperature "
#~ "my_sensor]\" section then one may use a \"sensor_type: my_sensor\" when "
#~ "defining a heater.) Be sure to place the sensor section in the config file "
#~ "above its first use in a heater section."
#~ msgstr ""

#~ msgid "[heater_generic]"
#~ msgstr ""

#~ msgid ""
#~ "[heater_generic my_generic_heater]\n"
#~ "#gcode_id:\n"
#~ "#   The id to use when reporting the temperature in the M105 command.\n"
#~ "#   This parameter must be provided.\n"
#~ "#heater_pin:\n"
#~ "#max_power:\n"
#~ "#sensor_type:\n"
#~ "#sensor_pin:\n"
#~ "#smooth_time:\n"
#~ "#control:\n"
#~ "#pid_Kp:\n"
#~ "#pid_Ki:\n"
#~ "#pid_Kd:\n"
#~ "#pwm_cycle_time:\n"
#~ "#min_temp:\n"
#~ "#max_temp:\n"
#~ "#   See the \"extruder\" section for the definition of the above\n"
#~ "#   parameters.\n"
#~ msgstr ""

#~ msgid ""
#~ "Generic temperature sensors. One can define any number of additional "
#~ "temperature sensors that are reported via the M105 command."
#~ msgstr ""

#~ msgid "Temperature sensors"
#~ msgstr ""

#~ msgid "Common thermistors"
#~ msgstr ""

#~ msgid ""
#~ "sensor_type:\n"
#~ "#   One of \"EPCOS 100K B57560G104F\", \"ATC Semitec 104GT-2\",\n"
#~ "#   \"ATC Semitec 104NT-4-R025H42G\", \"Generic 3950\",\n"
#~ "#   \"Honeywell 100K 135-104LAG-J01\", \"NTC 100K MGB18-104F39050L32\",\n"
#~ "#   \"SliceEngineering 450\", or \"TDK NTCG104LH104JT1\"\n"
#~ "sensor_pin:\n"
#~ "#   Analog input pin connected to the thermistor. This parameter must\n"
#~ "#   be provided.\n"
#~ "#pullup_resistor: 4700\n"
#~ "#   The resistance (in ohms) of the pullup attached to the thermistor.\n"
#~ "#   The default is 4700 ohms.\n"
#~ "#inline_resistor: 0\n"
#~ "#   The resistance (in ohms) of an extra (not heat varying) resistor\n"
#~ "#   that is placed inline with the thermistor. It is rare to set this.\n"
#~ "#   The default is 0 ohms.\n"
#~ msgstr ""

#~ msgid ""
#~ "Common temperature amplifiers. The following parameters are available in "
#~ "heater sections that use one of these sensors."
#~ msgstr ""

#~ msgid "Directly connected PT1000 sensor"
#~ msgstr ""

#~ msgid ""
#~ "sensor_type: PT1000\n"
#~ "sensor_pin:\n"
#~ "#   Analog input pin connected to the sensor. This parameter must be\n"
#~ "#   provided.\n"
#~ "#pullup_resistor: 4700\n"
#~ "#   The resistance (in ohms) of the pullup attached to the sensor. The\n"
#~ "#   default is 4700 ohms.\n"
#~ msgstr ""

#~ msgid ""
#~ "MAXxxxxx serial peripheral interface (SPI) temperature based sensors. The "
#~ "following parameters are available in heater sections that use one of these "
#~ "sensor types."
#~ msgstr ""

#~ msgid "BMP280/BME280/BME680 temperature sensor"
#~ msgstr ""

#~ msgid ""
#~ "sensor_type: BME280\n"
#~ "#i2c_address:\n"
#~ "#   Default is 118 (0x76). Some BME280 sensors have an address of 119\n"
#~ "#   (0x77).\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ msgstr ""

#~ msgid ""
#~ "HTU21D family two wire interface (I2C) environmental sensor. Note that this "
#~ "sensor is not intended for use with extruders and heater beds, but rather "
#~ "for monitoring ambient temperature (C) and relative humidity. See [sample-"
#~ "macros.cfg](../config/sample-macros.cfg) for a gcode_macro that may be used "
#~ "to report humidity in addition to temperature."
#~ msgstr ""

#~ msgid "LM75 temperature sensor"
#~ msgstr ""

#~ msgid ""
#~ "sensor_type: LM75\n"
#~ "#i2c_address:\n"
#~ "#   Default is 72 (0x48). Normal range is 72-79 (0x48-0x4F) and the 3\n"
#~ "#   low bits of the address are configured via pins on the chip\n"
#~ "#   (usually with jumpers or hard wired).\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#lm75_report_time:\n"
#~ "#   Interval in seconds between readings. Default is 0.8, with minimum\n"
#~ "#   0.5.\n"
#~ msgstr ""

#~ msgid ""
#~ "The atsam, atsamd, and stm32 micro-controllers contain an internal "
#~ "temperature sensor. One can use the \"temperature_mcu\" sensor to monitor "
#~ "these temperatures."
#~ msgstr ""

#~ msgid "Host temperature sensor"
#~ msgstr ""

#~ msgid ""
#~ "sensor_type: temperature_host\n"
#~ "#sensor_path:\n"
#~ "#   The path to temperature system file. The default is\n"
#~ "#   \"/sys/class/thermal/thermal_zone0/temp\" which is the temperature\n"
#~ "#   system file on a Raspberry Pi computer.\n"
#~ msgstr ""

#~ msgid ""
#~ "DS18B20 is a 1-wire (w1) digital temperature sensor. Note that this sensor "
#~ "is not intended for use with extruders and heater beds, but rather for "
#~ "monitoring ambient temperature (C). These sensors have range up to 125 C, so"
#~ " are usable for e.g. chamber temperature monitoring. They can also function "
#~ "as simple fan/heater controllers. DS18B20 sensors are only supported on the "
#~ "\"host mcu\", e.g. the Raspberry Pi. The w1-gpio Linux kernel module must be"
#~ " installed."
#~ msgstr ""

#~ msgid "Fans"
#~ msgstr ""

#~ msgid "Print cooling fan."
#~ msgstr ""

#~ msgid "[heater_fan]"
#~ msgstr ""

#~ msgid ""
#~ "[heater_fan my_nozzle_fan]\n"
#~ "#pin:\n"
#~ "#max_power:\n"
#~ "#shutdown_speed:\n"
#~ "#cycle_time:\n"
#~ "#hardware_pwm:\n"
#~ "#kick_start_time:\n"
#~ "#off_below:\n"
#~ "#tachometer_pin:\n"
#~ "#tachometer_ppr:\n"
#~ "#tachometer_poll_interval:\n"
#~ "#enable_pin:\n"
#~ "#   See the \"fan\" section for a description of the above parameters.\n"
#~ "#heater: extruder\n"
#~ "#   Name of the config section defining the heater that this fan is\n"
#~ "#   associated with. If a comma separated list of heater names is\n"
#~ "#   provided here, then the fan will be enabled when any of the given\n"
#~ "#   heaters are enabled. The default is \"extruder\".\n"
#~ "#heater_temp: 50.0\n"
#~ "#   A temperature (in Celsius) that the heater must drop below before\n"
#~ "#   the fan is disabled. The default is 50 Celsius.\n"
#~ "#fan_speed: 1.0\n"
#~ "#   The fan speed (expressed as a value from 0.0 to 1.0) that the fan\n"
#~ "#   will be set to when its associated heater is enabled. The default\n"
#~ "#   is 1.0\n"
#~ msgstr ""

#~ msgid ""
#~ "Controller cooling fan (one may define any number of sections with a "
#~ "\"controller_fan\" prefix). A \"controller fan\" is a fan that will be "
#~ "enabled whenever its associated heater or its associated stepper driver is "
#~ "active. The fan will stop whenever an idle_timeout is reached to ensure no "
#~ "overheating will occur after deactivating a watched component."
#~ msgstr ""

#~ msgid ""
#~ "Temperature-triggered cooling fans (one may define any number of sections "
#~ "with a \"temperature_fan\" prefix). A \"temperature fan\" is a fan that will"
#~ " be enabled whenever its associated sensor is above a set temperature. By "
#~ "default, a temperature_fan has a shutdown_speed equal to max_power."
#~ msgstr ""

#~ msgid ""
#~ "[temperature_fan my_temp_fan]\n"
#~ "#pin:\n"
#~ "#max_power:\n"
#~ "#shutdown_speed:\n"
#~ "#cycle_time:\n"
#~ "#hardware_pwm:\n"
#~ "#kick_start_time:\n"
#~ "#off_below:\n"
#~ "#tachometer_pin:\n"
#~ "#tachometer_ppr:\n"
#~ "#tachometer_poll_interval:\n"
#~ "#enable_pin:\n"
#~ "#   See the \"fan\" section for a description of the above parameters.\n"
#~ "#sensor_type:\n"
#~ "#sensor_pin:\n"
#~ "#control:\n"
#~ "#max_delta:\n"
#~ "#min_temp:\n"
#~ "#max_temp:\n"
#~ "#   See the \"extruder\" section for a description of the above parameters.\n"
#~ "#pid_Kp:\n"
#~ "#pid_Ki:\n"
#~ "#pid_Kd:\n"
#~ "#   The proportional (pid_Kp), integral (pid_Ki), and derivative\n"
#~ "#   (pid_Kd) settings for the PID feedback control system. Klipper\n"
#~ "#   evaluates the PID settings with the following general formula:\n"
#~ "#     fan_pwm = max_power - (Kp*e + Ki*integral(e) - Kd*derivative(e)) / 255\n"
#~ "#   Where \"e\" is \"target_temperature - measured_temperature\" and\n"
#~ "#   \"fan_pwm\" is the requested fan rate with 0.0 being full off and\n"
#~ "#   1.0 being full on. The pid_Kp, pid_Ki, and pid_Kd parameters must\n"
#~ "#   be provided when the PID control algorithm is enabled.\n"
#~ "#pid_deriv_time: 2.0\n"
#~ "#   A time value (in seconds) over which temperature measurements will\n"
#~ "#   be smoothed when using the PID control algorithm. This may reduce\n"
#~ "#   the impact of measurement noise. The default is 2 seconds.\n"
#~ "#target_temp: 40.0\n"
#~ "#   A temperature (in Celsius) that will be the target temperature.\n"
#~ "#   The default is 40 degrees.\n"
#~ "#max_speed: 1.0\n"
#~ "#   The fan speed (expressed as a value from 0.0 to 1.0) that the fan\n"
#~ "#   will be set to when the sensor temperature exceeds the set value.\n"
#~ "#   The default is 1.0.\n"
#~ "#min_speed: 0.3\n"
#~ "#   The minimum fan speed (expressed as a value from 0.0 to 1.0) that\n"
#~ "#   the fan will be set to for PID temperature fans.\n"
#~ "#   The default is 0.3.\n"
#~ "#gcode_id:\n"
#~ "#   If set, the temperature will be reported in M105 queries using the\n"
#~ "#   given id. The default is to not report the temperature via M105.\n"
#~ msgstr ""

#~ msgid ""
#~ "[fan_generic extruder_partfan]\n"
#~ "#pin:\n"
#~ "#max_power:\n"
#~ "#shutdown_speed:\n"
#~ "#cycle_time:\n"
#~ "#hardware_pwm:\n"
#~ "#kick_start_time:\n"
#~ "#off_below:\n"
#~ "#tachometer_pin:\n"
#~ "#tachometer_ppr:\n"
#~ "#tachometer_poll_interval:\n"
#~ "#enable_pin:\n"
#~ "#   See the \"fan\" section for a description of the above parameters.\n"
#~ msgstr ""

#~ msgid ""
#~ "Support for LEDs (and LED strips) controlled via micro-controller PWM pins "
#~ "(one may define any number of sections with an \"led\" prefix). See the "
#~ "[command reference](G-Codes.md#led) for more information."
#~ msgstr ""

#~ msgid "[neopixel]"
#~ msgstr ""

#~ msgid ""
#~ "Note that the [linux mcu](RPi_microcontroller.md) implementation does not "
#~ "currently support directly connected neopixels. The current design using the"
#~ " Linux kernel interface does not allow this scenario because the kernel GPIO"
#~ " interface is not fast enough to provide the required pulse rates."
#~ msgstr ""

#~ msgid "[dotstar]"
#~ msgstr ""

#~ msgid ""
#~ "[dotstar my_dotstar]\n"
#~ "data_pin:\n"
#~ "#   The pin connected to the data line of the dotstar. This parameter\n"
#~ "#   must be provided.\n"
#~ "clock_pin:\n"
#~ "#   The pin connected to the clock line of the dotstar. This parameter\n"
#~ "#   must be provided.\n"
#~ "#chain_count:\n"
#~ "#   See the \"neopixel\" section for information on this parameter.\n"
#~ "#initial_RED: 0.0\n"
#~ "#initial_GREEN: 0.0\n"
#~ "#initial_BLUE: 0.0\n"
#~ "#   See the \"led\" section for information on these parameters.\n"
#~ msgstr ""

#~ msgid "PCA9533 LED support. The PCA9533 is used on the mightyboard."
#~ msgstr ""

#~ msgid "[pca9632]"
#~ msgstr ""

#~ msgid ""
#~ "[pca9632 my_pca9632]\n"
#~ "#i2c_address: 98\n"
#~ "#   The i2c address that the chip is using on the i2c bus. This may be\n"
#~ "#   96, 97, 98, or 99.  The default is 98.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#scl_pin:\n"
#~ "#sda_pin:\n"
#~ "#   Alternatively, if the pca9632 is not connected to a hardware I2C\n"
#~ "#   bus, then one may specify the \"clock\" (scl_pin) and \"data\"\n"
#~ "#   (sda_pin) pins. The default is to use hardware I2C.\n"
#~ "#color_order: RGBW\n"
#~ "#   Set the pixel order of the LED (using a string containing the\n"
#~ "#   letters R, G, B, W). The default is RGBW.\n"
#~ "#initial_RED: 0.0\n"
#~ "#initial_GREEN: 0.0\n"
#~ "#initial_BLUE: 0.0\n"
#~ "#initial_WHITE: 0.0\n"
#~ "#   See the \"led\" section for information on these parameters.\n"
#~ msgstr ""

#~ msgid ""
#~ "Servos (one may define any number of sections with a \"servo\" prefix). The "
#~ "servos may be controlled using the SET_SERVO [g-code "
#~ "command](G-Codes.md#servo). For example: SET_SERVO SERVO=my_servo ANGLE=180"
#~ msgstr ""

#~ msgid "[gcode_button]"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_button my_gcode_button]\n"
#~ "pin:\n"
#~ "#   The pin on which the button is connected. This parameter must be\n"
#~ "#   provided.\n"
#~ "#analog_range:\n"
#~ "#   Two comma separated resistances (in Ohms) specifying the minimum\n"
#~ "#   and maximum resistance range for the button. If analog_range is\n"
#~ "#   provided then the pin must be an analog capable pin. The default\n"
#~ "#   is to use digital gpio for the button.\n"
#~ "#analog_pullup_resistor:\n"
#~ "#   The pullup resistance (in Ohms) when analog_range is specified.\n"
#~ "#   The default is 4700 ohms.\n"
#~ "#press_gcode:\n"
#~ "#   A list of G-Code commands to execute when the button is pressed.\n"
#~ "#   G-Code templates are supported. This parameter must be provided.\n"
#~ "#release_gcode:\n"
#~ "#   A list of G-Code commands to execute when the button is released.\n"
#~ "#   G-Code templates are supported. The default is to not run any\n"
#~ "#   commands on a button release.\n"
#~ msgstr ""

#~ msgid ""
#~ "[output_pin my_pin]\n"
#~ "pin:\n"
#~ "#   The pin to configure as an output. This parameter must be\n"
#~ "#   provided.\n"
#~ "#pwm: False\n"
#~ "#   Set if the output pin should be capable of pulse-width-modulation.\n"
#~ "#   If this is true, the value fields should be between 0 and 1; if it\n"
#~ "#   is false the value fields should be either 0 or 1. The default is\n"
#~ "#   False.\n"
#~ "#static_value:\n"
#~ "#   If this is set, then the pin is assigned to this value at startup\n"
#~ "#   and the pin can not be changed during runtime. A static pin uses\n"
#~ "#   slightly less ram in the micro-controller. The default is to use\n"
#~ "#   runtime configuration of pins.\n"
#~ "#value:\n"
#~ "#   The value to initially set the pin to during MCU configuration.\n"
#~ "#   The default is 0 (for low voltage).\n"
#~ "#shutdown_value:\n"
#~ "#   The value to set the pin to on an MCU shutdown event. The default\n"
#~ "#   is 0 (for low voltage).\n"
#~ "#maximum_mcu_duration:\n"
#~ "#   The maximum duration a non-shutdown value may be driven by the MCU\n"
#~ "#   without an acknowledge from the host.\n"
#~ "#   If host can not keep up with an update, the MCU will shutdown\n"
#~ "#   and set all pins to their respective shutdown values.\n"
#~ "#   Default: 0 (disabled)\n"
#~ "#   Usual values are around 5 seconds.\n"
#~ "#cycle_time: 0.100\n"
#~ "#   The amount of time (in seconds) per PWM cycle. It is recommended\n"
#~ "#   this be 10 milliseconds or greater when using software based PWM.\n"
#~ "#   The default is 0.100 seconds for pwm pins.\n"
#~ "#hardware_pwm: False\n"
#~ "#   Enable this to use hardware PWM instead of software PWM. When\n"
#~ "#   using hardware PWM the actual cycle time is constrained by the\n"
#~ "#   implementation and may be significantly different than the\n"
#~ "#   requested cycle_time. The default is False.\n"
#~ "#scale:\n"
#~ "#   This parameter can be used to alter how the 'value' and\n"
#~ "#   'shutdown_value' parameters are interpreted for pwm pins. If\n"
#~ "#   provided, then the 'value' parameter should be between 0.0 and\n"
#~ "#   'scale'. This may be useful when configuring a PWM pin that\n"
#~ "#   controls a stepper voltage reference. The 'scale' can be set to\n"
#~ "#   the equivalent stepper amperage if the PWM were fully enabled, and\n"
#~ "#   then the 'value' parameter can be specified using the desired\n"
#~ "#   amperage for the stepper. The default is to not scale the 'value'\n"
#~ "#   parameter.\n"
#~ msgstr ""

#~ msgid ""
#~ "Statically configured digital output pins (one may define any number of "
#~ "sections with a \"static_digital_output\" prefix). Pins configured here will"
#~ " be setup as a GPIO output during MCU configuration. They can not be changed"
#~ " at run-time."
#~ msgstr ""

#~ msgid "[multi_pin]"
#~ msgstr ""

#~ msgid ""
#~ "[multi_pin my_multi_pin]\n"
#~ "pins:\n"
#~ "#   A comma separated list of pins associated with this alias. This\n"
#~ "#   parameter must be provided.\n"
#~ msgstr ""

#~ msgid ""
#~ "Configuration of Trinamic stepper motor drivers in UART/SPI mode. Additional"
#~ " information is in the [TMC Drivers guide](TMC_Drivers.md) and in the "
#~ "[command reference](G-Codes.md#tmcxxxx)."
#~ msgstr ""

#~ msgid ""
#~ "Configure a TMC2130 stepper motor driver via SPI bus. To use this feature, "
#~ "define a config section with a \"tmc2130\" prefix followed by the name of "
#~ "the corresponding stepper config section (for example, \"[tmc2130 "
#~ "stepper_x]\")."
#~ msgstr ""

#~ msgid "[tmc2208]"
#~ msgstr ""

#~ msgid ""
#~ "[tmc2208 stepper_x]\n"
#~ "uart_pin:\n"
#~ "#   The pin connected to the TMC2208 PDN_UART line. This parameter\n"
#~ "#   must be provided.\n"
#~ "#tx_pin:\n"
#~ "#   If using separate receive and transmit lines to communicate with\n"
#~ "#   the driver then set uart_pin to the receive pin and tx_pin to the\n"
#~ "#   transmit pin. The default is to use uart_pin for both reading and\n"
#~ "#   writing.\n"
#~ "#select_pins:\n"
#~ "#   A comma separated list of pins to set prior to accessing the\n"
#~ "#   tmc2208 UART. This may be useful for configuring an analog mux for\n"
#~ "#   UART communication. The default is to not configure any pins.\n"
#~ "#interpolate: True\n"
#~ "#   If true, enable step interpolation (the driver will internally\n"
#~ "#   step at a rate of 256 micro-steps). This interpolation does\n"
#~ "#   introduce a small systemic positional deviation - see\n"
#~ "#   TMC_Drivers.md for details. The default is True.\n"
#~ "run_current:\n"
#~ "#   The amount of current (in amps RMS) to configure the driver to use\n"
#~ "#   during stepper movement. This parameter must be provided.\n"
#~ "#hold_current:\n"
#~ "#   The amount of current (in amps RMS) to configure the driver to use\n"
#~ "#   when the stepper is not moving. Setting a hold_current is not\n"
#~ "#   recommended (see TMC_Drivers.md for details). The default is to\n"
#~ "#   not reduce the current.\n"
#~ "#sense_resistor: 0.110\n"
#~ "#   The resistance (in ohms) of the motor sense resistor. The default\n"
#~ "#   is 0.110 ohms.\n"
#~ "#stealthchop_threshold: 0\n"
#~ "#   The velocity (in mm/s) to set the \"stealthChop\" threshold to. When\n"
#~ "#   set, \"stealthChop\" mode will be enabled if the stepper motor\n"
#~ "#   velocity is below this value. The default is 0, which disables\n"
#~ "#   \"stealthChop\" mode.\n"
#~ "#driver_IHOLDDELAY: 8\n"
#~ "#driver_TPOWERDOWN: 20\n"
#~ "#driver_TBL: 2\n"
#~ "#driver_TOFF: 3\n"
#~ "#driver_HEND: 0\n"
#~ "#driver_HSTRT: 5\n"
#~ "#driver_PWM_AUTOGRAD: True\n"
#~ "#driver_PWM_AUTOSCALE: True\n"
#~ "#driver_PWM_LIM: 12\n"
#~ "#driver_PWM_REG: 8\n"
#~ "#driver_PWM_FREQ: 1\n"
#~ "#driver_PWM_GRAD: 14\n"
#~ "#driver_PWM_OFS: 36\n"
#~ "#   Set the given register during the configuration of the TMC2208\n"
#~ "#   chip. This may be used to set custom motor parameters. The\n"
#~ "#   defaults for each parameter are next to the parameter name in the\n"
#~ "#   above list.\n"
#~ msgstr ""

#~ msgid ""
#~ "Configure a TMC2209 stepper motor driver via single wire UART. To use this "
#~ "feature, define a config section with a \"tmc2209\" prefix followed by the "
#~ "name of the corresponding stepper config section (for example, \"[tmc2209 "
#~ "stepper_x]\")."
#~ msgstr ""

#~ msgid "[tmc2660]"
#~ msgstr ""

#~ msgid ""
#~ "[tmc2660 stepper_x]\n"
#~ "cs_pin:\n"
#~ "#   The pin corresponding to the TMC2660 chip select line. This pin\n"
#~ "#   will be set to low at the start of SPI messages and set to high\n"
#~ "#   after the message transfer completes. This parameter must be\n"
#~ "#   provided.\n"
#~ "#spi_speed: 4000000\n"
#~ "#   SPI bus frequency used to communicate with the TMC2660 stepper\n"
#~ "#   driver. The default is 4000000.\n"
#~ "#spi_bus:\n"
#~ "#spi_software_sclk_pin:\n"
#~ "#spi_software_mosi_pin:\n"
#~ "#spi_software_miso_pin:\n"
#~ "#   See the \"common SPI settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#interpolate: True\n"
#~ "#   If true, enable step interpolation (the driver will internally\n"
#~ "#   step at a rate of 256 micro-steps). This only works if microsteps\n"
#~ "#   is set to 16. Interpolation does introduce a small systemic\n"
#~ "#   positional deviation - see TMC_Drivers.md for details. The default\n"
#~ "#   is True.\n"
#~ "run_current:\n"
#~ "#   The amount of current (in amps RMS) used by the driver during\n"
#~ "#   stepper movement. This parameter must be provided.\n"
#~ "#sense_resistor:\n"
#~ "#   The resistance (in ohms) of the motor sense resistor. This\n"
#~ "#   parameter must be provided.\n"
#~ "#idle_current_percent: 100\n"
#~ "#   The percentage of the run_current the stepper driver will be\n"
#~ "#   lowered to when the idle timeout expires (you need to set up the\n"
#~ "#   timeout using a [idle_timeout] config section). The current will\n"
#~ "#   be raised again once the stepper has to move again. Make sure to\n"
#~ "#   set this to a high enough value such that the steppers do not lose\n"
#~ "#   their position. There is also small delay until the current is\n"
#~ "#   raised again, so take this into account when commanding fast moves\n"
#~ "#   while the stepper is idling. The default is 100 (no reduction).\n"
#~ "#driver_TBL: 2\n"
#~ "#driver_RNDTF: 0\n"
#~ "#driver_HDEC: 0\n"
#~ "#driver_CHM: 0\n"
#~ "#driver_HEND: 3\n"
#~ "#driver_HSTRT: 3\n"
#~ "#driver_TOFF: 4\n"
#~ "#driver_SEIMIN: 0\n"
#~ "#driver_SEDN: 0\n"
#~ "#driver_SEMAX: 0\n"
#~ "#driver_SEUP: 0\n"
#~ "#driver_SEMIN: 0\n"
#~ "#driver_SFILT: 0\n"
#~ "#driver_SGT: 0\n"
#~ "#driver_SLPH: 0\n"
#~ "#driver_SLPL: 0\n"
#~ "#driver_DISS2G: 0\n"
#~ "#driver_TS2G: 3\n"
#~ "#   Set the given parameter during the configuration of the TMC2660\n"
#~ "#   chip. This may be used to set custom driver parameters. The\n"
#~ "#   defaults for each parameter are next to the parameter name in the\n"
#~ "#   list above. See the TMC2660 datasheet about what each parameter\n"
#~ "#   does and what the restrictions on parameter combinations are. Be\n"
#~ "#   especially aware of the CHOPCONF register, where setting CHM to\n"
#~ "#   either zero or one will lead to layout changes (the first bit of\n"
#~ "#   HDEC) is interpreted as the MSB of HSTRT in this case).\n"
#~ msgstr ""

#~ msgid ""
#~ "Configure a TMC5160 stepper motor driver via SPI bus. To use this feature, "
#~ "define a config section with a \"tmc5160\" prefix followed by the name of "
#~ "the corresponding stepper config section (for example, \"[tmc5160 "
#~ "stepper_x]\")."
#~ msgstr ""

#~ msgid "Run-time stepper motor current configuration"
#~ msgstr ""

#~ msgid ""
#~ "Statically configured AD5206 digipots connected via SPI bus (one may define "
#~ "any number of sections with an \"ad5206\" prefix)."
#~ msgstr ""

#~ msgid "[mcp4451]"
#~ msgstr ""

#~ msgid ""
#~ "[mcp4451 my_digipot]\n"
#~ "i2c_address:\n"
#~ "#   The i2c address that the chip is using on the i2c bus. This\n"
#~ "#   parameter must be provided.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#wiper_0:\n"
#~ "#wiper_1:\n"
#~ "#wiper_2:\n"
#~ "#wiper_3:\n"
#~ "#   The value to statically set the given MCP4451 \"wiper\" to. This is\n"
#~ "#   typically set to a number between 0.0 and 1.0 with 1.0 being the\n"
#~ "#   highest resistance and 0.0 being the lowest resistance. However,\n"
#~ "#   the range may be changed with the 'scale' parameter (see below).\n"
#~ "#   If a wiper is not specified then it is left unconfigured.\n"
#~ "#scale:\n"
#~ "#   This parameter can be used to alter how the 'wiper_x' parameters\n"
#~ "#   are interpreted. If provided, then the 'wiper_x' parameters should\n"
#~ "#   be between 0.0 and 'scale'. This may be useful when the MCP4451 is\n"
#~ "#   used to set stepper voltage references. The 'scale' can be set to\n"
#~ "#   the equivalent stepper amperage if the MCP4451 were at its highest\n"
#~ "#   resistance, and then the 'wiper_x' parameters can be specified\n"
#~ "#   using the desired amperage value for the stepper. The default is\n"
#~ "#   to not scale the 'wiper_x' parameters.\n"
#~ msgstr ""

#~ msgid ""
#~ "Statically configured MCP4728 digital-to-analog converter connected via I2C "
#~ "bus (one may define any number of sections with an \"mcp4728\" prefix)."
#~ msgstr ""

#~ msgid ""
#~ "Statically configured MCP4018 digipot connected via two gpio \"bit banging\""
#~ " pins (one may define any number of sections with an \"mcp4018\" prefix)."
#~ msgstr ""

#~ msgid "Display support"
#~ msgstr ""

#~ msgid ""
#~ "[display]\n"
#~ "lcd_type:\n"
#~ "#   The type of LCD chip in use. This may be \"hd44780\", \"hd44780_spi\",\n"
#~ "#   \"st7920\", \"emulated_st7920\", \"uc1701\", \"ssd1306\", or \"sh1106\".\n"
#~ "#   See the display sections below for information on each type and\n"
#~ "#   additional parameters they provide. This parameter must be\n"
#~ "#   provided.\n"
#~ "#display_group:\n"
#~ "#   The name of the display_data group to show on the display. This\n"
#~ "#   controls the content of the screen (see the \"display_data\" section\n"
#~ "#   for more information). The default is _default_20x4 for hd44780\n"
#~ "#   displays and _default_16x4 for other displays.\n"
#~ "#menu_timeout:\n"
#~ "#   Timeout for menu. Being inactive this amount of seconds will\n"
#~ "#   trigger menu exit or return to root menu when having autorun\n"
#~ "#   enabled. The default is 0 seconds (disabled)\n"
#~ "#menu_root:\n"
#~ "#   Name of the main menu section to show when clicking the encoder\n"
#~ "#   on the home screen. The defaults is __main, and this shows the\n"
#~ "#   the default menus as defined in klippy/extras/display/menu.cfg\n"
#~ "#menu_reverse_navigation:\n"
#~ "#   When enabled it will reverse up and down directions for list\n"
#~ "#   navigation. The default is False. This parameter is optional.\n"
#~ "#encoder_pins:\n"
#~ "#   The pins connected to encoder. 2 pins must be provided when using\n"
#~ "#   encoder. This parameter must be provided when using menu.\n"
#~ "#encoder_steps_per_detent:\n"
#~ "#   How many steps the encoder emits per detent (\"click\"). If the\n"
#~ "#   encoder takes two detents to move between entries or moves two\n"
#~ "#   entries from one detent, try changing this. Allowed values are 2\n"
#~ "#   (half-stepping) or 4 (full-stepping). The default is 4.\n"
#~ "#click_pin:\n"
#~ "#   The pin connected to 'enter' button or encoder 'click'. This\n"
#~ "#   parameter must be provided when using menu. The presence of an\n"
#~ "#   'analog_range_click_pin' config parameter turns this parameter\n"
#~ "#   from digital to analog.\n"
#~ "#back_pin:\n"
#~ "#   The pin connected to 'back' button. This parameter is optional,\n"
#~ "#   menu can be used without it. The presence of an\n"
#~ "#   'analog_range_back_pin' config parameter turns this parameter from\n"
#~ "#   digital to analog.\n"
#~ "#up_pin:\n"
#~ "#   The pin connected to 'up' button. This parameter must be provided\n"
#~ "#   when using menu without encoder. The presence of an\n"
#~ "#   'analog_range_up_pin' config parameter turns this parameter from\n"
#~ "#   digital to analog.\n"
#~ "#down_pin:\n"
#~ "#   The pin connected to 'down' button. This parameter must be\n"
#~ "#   provided when using menu without encoder. The presence of an\n"
#~ "#   'analog_range_down_pin' config parameter turns this parameter from\n"
#~ "#   digital to analog.\n"
#~ "#kill_pin:\n"
#~ "#   The pin connected to 'kill' button. This button will call\n"
#~ "#   emergency stop. The presence of an 'analog_range_kill_pin' config\n"
#~ "#   parameter turns this parameter from digital to analog.\n"
#~ "#analog_pullup_resistor: 4700\n"
#~ "#   The resistance (in ohms) of the pullup attached to the analog\n"
#~ "#   button. The default is 4700 ohms.\n"
#~ "#analog_range_click_pin:\n"
#~ "#   The resistance range for a 'enter' button. Range minimum and\n"
#~ "#   maximum comma-separated values must be provided when using analog\n"
#~ "#   button.\n"
#~ "#analog_range_back_pin:\n"
#~ "#   The resistance range for a 'back' button. Range minimum and\n"
#~ "#   maximum comma-separated values must be provided when using analog\n"
#~ "#   button.\n"
#~ "#analog_range_up_pin:\n"
#~ "#   The resistance range for a 'up' button. Range minimum and maximum\n"
#~ "#   comma-separated values must be provided when using analog button.\n"
#~ "#analog_range_down_pin:\n"
#~ "#   The resistance range for a 'down' button. Range minimum and\n"
#~ "#   maximum comma-separated values must be provided when using analog\n"
#~ "#   button.\n"
#~ "#analog_range_kill_pin:\n"
#~ "#   The resistance range for a 'kill' button. Range minimum and\n"
#~ "#   maximum comma-separated values must be provided when using analog\n"
#~ "#   button.\n"
#~ msgstr ""

#~ msgid ""
#~ "Information on configuring hd44780 displays (which is used in "
#~ "\"RepRapDiscount 2004 Smart Controller\" type displays)."
#~ msgstr ""

#~ msgid "hd44780_spi display"
#~ msgstr ""

#~ msgid ""
#~ "[display]\n"
#~ "lcd_type: hd44780_spi\n"
#~ "#   Set to \"hd44780_spi\" for hd44780_spi displays.\n"
#~ "latch_pin:\n"
#~ "spi_software_sclk_pin:\n"
#~ "spi_software_mosi_pin:\n"
#~ "spi_software_miso_pin:\n"
#~ "#   The pins connected to the shift register controlling the display.\n"
#~ "#   The spi_software_miso_pin needs to be set to an unused pin of the\n"
#~ "#   printer mainboard as the shift register does not have a MISO pin,\n"
#~ "#   but the software spi implementation requires this pin to be\n"
#~ "#   configured.\n"
#~ "#hd44780_protocol_init: True\n"
#~ "#   Perform 8-bit/4-bit protocol initialization on an hd44780 display.\n"
#~ "#   This is necessary on real hd44780 devices. However, one may need\n"
#~ "#   to disable this on some \"clone\" devices. The default is True.\n"
#~ "#line_length:\n"
#~ "#   Set the number of characters per line for an hd44780 type lcd.\n"
#~ "#   Possible values are 20 (default) and 16. The number of lines is\n"
#~ "#   fixed to 4.\n"
#~ "...\n"
#~ msgstr ""

#~ msgid ""
#~ "Information on configuring st7920 displays (which is used in "
#~ "\"RepRapDiscount 12864 Full Graphic Smart Controller\" type displays)."
#~ msgstr ""

#~ msgid "emulated_st7920 display"
#~ msgstr ""

#~ msgid ""
#~ "[display]\n"
#~ "lcd_type: emulated_st7920\n"
#~ "#   Set to \"emulated_st7920\" for emulated_st7920 displays.\n"
#~ "en_pin:\n"
#~ "spi_software_sclk_pin:\n"
#~ "spi_software_mosi_pin:\n"
#~ "spi_software_miso_pin:\n"
#~ "#   The pins connected to an emulated_st7920 type lcd. The en_pin\n"
#~ "#   corresponds to the cs_pin of the st7920 type lcd,\n"
#~ "#   spi_software_sclk_pin corresponds to sclk_pin and\n"
#~ "#   spi_software_mosi_pin corresponds to sid_pin. The\n"
#~ "#   spi_software_miso_pin needs to be set to an unused pin of the\n"
#~ "#   printer mainboard as the st7920 as no MISO pin but the software\n"
#~ "#   spi implementation requires this pin to be configured.\n"
#~ "...\n"
#~ msgstr ""

#~ msgid ""
#~ "Information on configuring uc1701 displays (which is used in \"MKS Mini "
#~ "12864\" type displays)."
#~ msgstr ""

#~ msgid "ssd1306 and sh1106 displays"
#~ msgstr ""

#~ msgid ""
#~ "[display]\n"
#~ "lcd_type:\n"
#~ "#   Set to either \"ssd1306\" or \"sh1106\" for the given display type.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   Optional parameters available for displays connected via an i2c\n"
#~ "#   bus. See the \"common I2C settings\" section for a description of\n"
#~ "#   the above parameters.\n"
#~ "#cs_pin:\n"
#~ "#dc_pin:\n"
#~ "#spi_speed:\n"
#~ "#spi_bus:\n"
#~ "#spi_software_sclk_pin:\n"
#~ "#spi_software_mosi_pin:\n"
#~ "#spi_software_miso_pin:\n"
#~ "#   The pins connected to the lcd when in \"4-wire\" spi mode. See the\n"
#~ "#   \"common SPI settings\" section for a description of the parameters\n"
#~ "#   that start with \"spi_\". The default is to use i2c mode for the\n"
#~ "#   display.\n"
#~ "#reset_pin:\n"
#~ "#   A reset pin may be specified on the display. If it is not\n"
#~ "#   specified then the hardware must have a pull-up on the\n"
#~ "#   corresponding lcd line.\n"
#~ "#contrast:\n"
#~ "#   The contrast to set. The value may range from 0 to 256 and the\n"
#~ "#   default is 239.\n"
#~ "#vcomh: 0\n"
#~ "#   Set the Vcomh value on the display. This value is associated with\n"
#~ "#   a \"smearing\" effect on some OLED displays. The value may range\n"
#~ "#   from 0 to 63. Default is 0.\n"
#~ "#invert: False\n"
#~ "#   TRUE inverts the pixels on certain OLED displays.  The default is\n"
#~ "#   False.\n"
#~ "#x_offset: 0\n"
#~ "#   Set the horizontal offset value on SH1106 displays. The default is\n"
#~ "#   0.\n"
#~ "...\n"
#~ msgstr ""

#~ msgid ""
#~ "Support for displaying custom data on an lcd screen. One may create any "
#~ "number of display groups and any number of data items under those groups. "
#~ "The display will show all the data items for a given group if the "
#~ "display_group option in the [display] section is set to the given group "
#~ "name."
#~ msgstr ""

#~ msgid ""
#~ "[display_data my_group_name my_data_name]\n"
#~ "position:\n"
#~ "#   Comma separated row and column of the display position that should\n"
#~ "#   be used to display the information. This parameter must be\n"
#~ "#   provided.\n"
#~ "text:\n"
#~ "#   The text to show at the given position. This field is evaluated\n"
#~ "#   using command templates (see docs/Command_Templates.md). This\n"
#~ "#   parameter must be provided.\n"
#~ msgstr ""

#~ msgid ""
#~ "Display data text \"macros\" (one may define any number of sections with a "
#~ "display_template prefix). See the [command templates](Command_Templates.md) "
#~ "document for information on template evaluation."
#~ msgstr ""

#~ msgid ""
#~ "This feature can also be used for continuous LED updates using the "
#~ "[SET_LED_TEMPLATE](G-Codes.md#set_led_template) command."
#~ msgstr ""

#~ msgid "[display_glyph]"
#~ msgstr ""

#~ msgid ""
#~ "See [sample-glyphs.cfg](../config/sample-glyphs.cfg) for some examples."
#~ msgstr ""

#~ msgid "[display my_extra_display]"
#~ msgstr ""

#~ msgid ""
#~ "[display my_extra_display]\n"
#~ "# See the \"display\" section for available parameters.\n"
#~ msgstr ""

#~ msgid "Customizable lcd display menus."
#~ msgstr ""

#~ msgid ""
#~ "See the [command template document](Command_Templates.md#menu-templates) for"
#~ " information on menu attributes available during template rendering."
#~ msgstr ""

#~ msgid "Filament sensors"
#~ msgstr ""

#~ msgid ""
#~ "See the [command reference](G-Codes.md#filament_switch_sensor) for more "
#~ "information."
#~ msgstr ""

#~ msgid "[filament_motion_sensor]"
#~ msgstr ""

#~ msgid ""
#~ "[filament_motion_sensor my_sensor]\n"
#~ "detection_length: 7.0\n"
#~ "#   The minimum length of filament pulled through the sensor to trigger\n"
#~ "#   a state change on the switch_pin\n"
#~ "#   Default is 7 mm.\n"
#~ "extruder:\n"
#~ "#   The name of the extruder section this sensor is associated with.\n"
#~ "#   This parameter must be provided.\n"
#~ "switch_pin:\n"
#~ "#pause_on_runout:\n"
#~ "#runout_gcode:\n"
#~ "#insert_gcode:\n"
#~ "#event_delay:\n"
#~ "#pause_delay:\n"
#~ "#   See the \"filament_switch_sensor\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ msgstr ""

#~ msgid ""
#~ "TSLl401CL Based Filament Width Sensor. See the "
#~ "[guide](TSL1401CL_Filament_Width_Sensor.md) for more information."
#~ msgstr ""

#~ msgid ""
#~ "Hall filament width sensor (see [Hall Filament Width "
#~ "Sensor](Hall_Filament_Width_Sensor.md))."
#~ msgstr ""

#~ msgid "Board specific hardware support"
#~ msgstr ""

#~ msgid ""
#~ "Configure an SX1509 I2C to GPIO expander. Due to the delay incurred by I2C "
#~ "communication you should NOT use SX1509 pins as stepper enable, step or dir "
#~ "pins or any other pin that requires fast bit-banging. They are best used as "
#~ "static or gcode controlled digital outputs or hardware-pwm pins for e.g. "
#~ "fans. One may define any number of sections with an \"sx1509\" prefix. Each "
#~ "expander provides a set of 16 pins (sx1509_my_sx1509:PIN_0 to "
#~ "sx1509_my_sx1509:PIN_15) which can be used in the printer configuration."
#~ msgstr ""

#~ msgid ""
#~ "[sx1509 my_sx1509]\n"
#~ "i2c_address:\n"
#~ "#   I2C address used by this expander. Depending on the hardware\n"
#~ "#   jumpers this is one out of the following addresses: 62 63 112\n"
#~ "#   113. This parameter must be provided.\n"
#~ "#i2c_mcu:\n"
#~ "#i2c_bus:\n"
#~ "#i2c_speed:\n"
#~ "#   See the \"common I2C settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ "#i2c_bus:\n"
#~ "#   If the I2C implementation of your micro-controller supports\n"
#~ "#   multiple I2C busses, you may specify the bus name here. The\n"
#~ "#   default is to use the default micro-controller i2c bus.\n"
#~ msgstr ""

#~ msgid ""
#~ "SAMD SERCOM configuration to specify which pins to use on a given SERCOM. "
#~ "One may define any number of sections with a \"samd_sercom\" prefix. Each "
#~ "SERCOM must be configured prior to using it as SPI or I2C peripheral. Place "
#~ "this config section above any other section that makes use of SPI or I2C "
#~ "buses."
#~ msgstr ""

#~ msgid "[adc_scaled]"
#~ msgstr ""

#~ msgid ""
#~ "See the [generic-duet2-maestro.cfg](../config/generic-duet2-maestro.cfg) "
#~ "file for an example."
#~ msgstr ""

#~ msgid "[replicape]"
#~ msgstr ""

#~ msgid ""
#~ "# The \"replicape\" config section adds \"replicape:stepper_x_enable\"\n"
#~ "# virtual stepper enable pins (for steppers X, Y, Z, E, and H) and\n"
#~ "# \"replicape:power_x\" PWM output pins (for hotbed, e, h, fan0, fan1,\n"
#~ "# fan2, and fan3) that may then be used elsewhere in the config file.\n"
#~ "[replicape]\n"
#~ "revision:\n"
#~ "#   The replicape hardware revision. Currently only revision \"B3\" is\n"
#~ "#   supported. This parameter must be provided.\n"
#~ "#enable_pin: !gpio0_20\n"
#~ "#   The replicape global enable pin. The default is !gpio0_20 (aka\n"
#~ "#   P9_41).\n"
#~ "host_mcu:\n"
#~ "#   The name of the mcu config section that communicates with the\n"
#~ "#   Klipper \"linux process\" mcu instance. This parameter must be\n"
#~ "#   provided.\n"
#~ "#standstill_power_down: False\n"
#~ "#   This parameter controls the CFG6_ENN line on all stepper\n"
#~ "#   motors. True sets the enable lines to \"open\". The default is\n"
#~ "#   False.\n"
#~ "#stepper_x_microstep_mode:\n"
#~ "#stepper_y_microstep_mode:\n"
#~ "#stepper_z_microstep_mode:\n"
#~ "#stepper_e_microstep_mode:\n"
#~ "#stepper_h_microstep_mode:\n"
#~ "#   This parameter controls the CFG1 and CFG2 pins of the given\n"
#~ "#   stepper motor driver. Available options are: disable, 1, 2,\n"
#~ "#   spread2, 4, 16, spread4, spread16, stealth4, and stealth16. The\n"
#~ "#   default is disable.\n"
#~ "#stepper_x_current:\n"
#~ "#stepper_y_current:\n"
#~ "#stepper_z_current:\n"
#~ "#stepper_e_current:\n"
#~ "#stepper_h_current:\n"
#~ "#   The configured maximum current (in Amps) of the stepper motor\n"
#~ "#   driver. This parameter must be provided if the stepper is not in a\n"
#~ "#   disable mode.\n"
#~ "#stepper_x_chopper_off_time_high:\n"
#~ "#stepper_y_chopper_off_time_high:\n"
#~ "#stepper_z_chopper_off_time_high:\n"
#~ "#stepper_e_chopper_off_time_high:\n"
#~ "#stepper_h_chopper_off_time_high:\n"
#~ "#   This parameter controls the CFG0 pin of the stepper motor driver\n"
#~ "#   (True sets CFG0 high, False sets it low). The default is False.\n"
#~ "#stepper_x_chopper_hysteresis_high:\n"
#~ "#stepper_y_chopper_hysteresis_high:\n"
#~ "#stepper_z_chopper_hysteresis_high:\n"
#~ "#stepper_e_chopper_hysteresis_high:\n"
#~ "#stepper_h_chopper_hysteresis_high:\n"
#~ "#   This parameter controls the CFG4 pin of the stepper motor driver\n"
#~ "#   (True sets CFG4 high, False sets it low). The default is False.\n"
#~ "#stepper_x_chopper_blank_time_high:\n"
#~ "#stepper_y_chopper_blank_time_high:\n"
#~ "#stepper_z_chopper_blank_time_high:\n"
#~ "#stepper_e_chopper_blank_time_high:\n"
#~ "#stepper_h_chopper_blank_time_high:\n"
#~ "#   This parameter controls the CFG5 pin of the stepper motor driver\n"
#~ "#   (True sets CFG5 high, False sets it low). The default is True.\n"
#~ msgstr ""

#~ msgid ""
#~ "Palette 2 multimaterial support - provides a tighter integration supporting "
#~ "Palette 2 devices in connected mode."
#~ msgstr ""

#~ msgid ""
#~ "If you use this module, do not use the Palette 2 plugin for Octoprint as "
#~ "they will conflict, and 1 will fail to initialize properly likely aborting "
#~ "your print."
#~ msgstr ""

#~ msgid ""
#~ "[palette2]\n"
#~ "serial:\n"
#~ "#   The serial port to connect to the Palette 2.\n"
#~ "#baud: 115200\n"
#~ "#   The baud rate to use. The default is 115200.\n"
#~ "#feedrate_splice: 0.8\n"
#~ "#   The feedrate to use when splicing, default is 0.8\n"
#~ "#feedrate_normal: 1.0\n"
#~ "#   The feedrate to use after splicing, default is 1.0\n"
#~ "#auto_load_speed: 2\n"
#~ "#   Extrude feedrate when autoloading, default is 2 (mm/s)\n"
#~ "#auto_cancel_variation: 0.1\n"
#~ "#   Auto cancel print when ping varation is above this threshold\n"
#~ msgstr ""

#~ msgid ""
#~ "[angle my_angle_sensor]\n"
#~ "sensor_type:\n"
#~ "#   The type of the magnetic hall sensor chip. Available choices are\n"
#~ "#   \"a1333\", \"as5047d\", and \"tle5012b\". This parameter must be\n"
#~ "#   specified.\n"
#~ "#sample_period: 0.000400\n"
#~ "#   The query period (in seconds) to use during measurements. The\n"
#~ "#   default is 0.000400 (which is 2500 samples per second).\n"
#~ "#stepper:\n"
#~ "#   The name of the stepper that the angle sensor is attached to (eg,\n"
#~ "#   \"stepper_x\"). Setting this value enables an angle calibration\n"
#~ "#   tool. To use this feature, the Python \"numpy\" package must be\n"
#~ "#   installed. The default is to not enable angle calibration for the\n"
#~ "#   angle sensor.\n"
#~ "cs_pin:\n"
#~ "#   The SPI enable pin for the sensor. This parameter must be provided.\n"
#~ "#spi_speed:\n"
#~ "#spi_bus:\n"
#~ "#spi_software_sclk_pin:\n"
#~ "#spi_software_mosi_pin:\n"
#~ "#spi_software_miso_pin:\n"
#~ "#   See the \"common SPI settings\" section for a description of the\n"
#~ "#   above parameters.\n"
#~ msgstr ""

#~ msgid "Common SPI settings"
#~ msgstr ""

#~ msgid ""
#~ "#spi_speed:\n"
#~ "#   The SPI speed (in hz) to use when communicating with the device.\n"
#~ "#   The default depends on the type of device.\n"
#~ "#spi_bus:\n"
#~ "#   If the micro-controller supports multiple SPI busses then one may\n"
#~ "#   specify the micro-controller bus name here. The default depends on\n"
#~ "#   the type of micro-controller.\n"
#~ "#spi_software_sclk_pin:\n"
#~ "#spi_software_mosi_pin:\n"
#~ "#spi_software_miso_pin:\n"
#~ "#   Specify the above parameters to use \"software based SPI\". This\n"
#~ "#   mode does not require micro-controller hardware support (typically\n"
#~ "#   any general purpose pins may be used). The default is to not use\n"
#~ "#   \"software spi\".\n"
#~ msgstr ""

#~ msgid ""
#~ "The following parameters are generally available for devices using an I2C "
#~ "bus."
#~ msgstr ""

#~ msgid ""
#~ "Most Klipper micro-controller implementations only support an `i2c_speed` of"
#~ " 100000. The Klipper \"linux\" micro-controller supports a 400000 speed, but"
#~ " it must be [set in the operating system](RPi_microcontroller.md#optional-"
#~ "enabling-i2c) and the `i2c_speed` parameter is otherwise ignored. The "
#~ "Klipper \"rp2040\" micro-controller supports a rate of 400000 via the "
#~ "`i2c_speed` parameter. All other Klipper micro-controllers use a 100000 rate"
#~ " and ignore the `i2c_speed` parameter."
#~ msgstr ""

#~ msgid ""
#~ "This document covers recent software changes to the config file that are not"
#~ " backwards compatible. It is a good idea to review this document when "
#~ "upgrading the Klipper software."
#~ msgstr ""

#~ msgid "Changes"
#~ msgstr ""

#~ msgid ""
#~ "20220616: It was previously possible to flash an rp2040 in bootloader mode "
#~ "by running `make flash FLASH_DEVICE=first`. The equivalent command is now "
#~ "`make flash FLASH_DEVICE=2e8a:0003`."
#~ msgstr ""

#~ msgid ""
#~ "20220407: The temperature_fan `pid_integral_max` config option has been "
#~ "removed (it was deprecated on 20210612)."
#~ msgstr ""

#~ msgid ""
#~ "20220330: The format of the `printer.neopixel.color_data` status information"
#~ " for neopixel and dotstar modules has changed. The information is now stored"
#~ " as a list of color lists (instead of a list of dictionaries). See the "
#~ "[status reference](Status_Reference.md#led) for details."
#~ msgstr ""

#~ msgid ""
#~ "20220304: There is no longer a default for the `extruder` parameter of "
#~ "[extruder_stepper](Config_Reference.md#extruder_stepper) config sections. If"
#~ " desired, specify `extruder: extruder` explicitly to associate the stepper "
#~ "motor with the \"extruder\" motion queue at startup."
#~ msgstr ""

#~ msgid ""
#~ "20220116: The tmc2130, tmc2208, tmc2209, and tmc2660 `run_current` "
#~ "calculation code has changed. For some `run_current` settings the drivers "
#~ "may now be configured differently. This new configuration should be more "
#~ "accurate, but it may invalidate previous tmc driver tuning."
#~ msgstr ""

#~ msgid ""
#~ "20211110: The \"NTC 100K beta 3950\" temperature sensor is deprecated. This "
#~ "sensor will be removed in the near future. Most users will find the "
#~ "\"Generic 3950\" temperature sensor more accurate. To continue to use the "
#~ "older (typically less accurate) definition, define a custom "
#~ "[thermistor](Config_Reference.md#thermistor) with `temperature1: 25`, "
#~ "`resistance1: 100000`, and `beta: 3950`."
#~ msgstr ""

#~ msgid ""
#~ "20211102: Several deprecated features have been removed. The stepper "
#~ "`step_distance` option has been removed (deprecated on 20201222). The "
#~ "`rpi_temperature` sensor alias has been removed (deprecated on 20210219). "
#~ "The mcu `pin_map` option has been removed (deprecated on 20210325). The "
#~ "gcode_macro `default_parameter_<name>` and macro access to command "
#~ "parameters other than via the `params` pseudo-variable has been removed "
#~ "(deprecated on 20210503). The heater `pid_integral_max` option has been "
#~ "removed (deprecated on 20210612)."
#~ msgstr ""

#~ msgid ""
#~ "20210903: The default [`smooth_time`](Config_Reference.md#extruder) for "
#~ "heaters has changed to 1 second (from 2 seconds). For most printers this "
#~ "will result in more stable temperature control."
#~ msgstr ""

#~ msgid ""
#~ "20210830: The adxl345 ACCELEROMETER_MEASURE command no longer supports a "
#~ "RATE parameter. To alter the query rate, update the printer.cfg file and "
#~ "issue a RESTART command."
#~ msgstr ""

#~ msgid ""
#~ "20210819: In some cases, a `G28` homing move may end in a position that is "
#~ "nominally outside the valid movement range. In rare situations this may "
#~ "result in confusing \"Move out of range\" errors after homing. If this "
#~ "occurs, change your start scripts to move the toolhead to a valid position "
#~ "immediately after homing."
#~ msgstr ""

#~ msgid ""
#~ "20210720: A controller_fan section now monitors all stepper motors by "
#~ "default (not just the kinematic stepper motors). If the previous behavior is"
#~ " desired, see the `stepper` config option in the [config "
#~ "reference](Config_Reference.md#controller_fan)."
#~ msgstr ""

#~ msgid ""
#~ "20210612: The `pid_integral_max` config option in heater and temperature_fan"
#~ " sections is deprecated. The option will be removed in the near future."
#~ msgstr ""

#~ msgid ""
#~ "20210430: The SET_VELOCITY_LIMIT (and M204) command may now set a velocity, "
#~ "acceleration, and square_corner_velocity larger than the specified values in"
#~ " the config file."
#~ msgstr ""

#~ msgid ""
#~ "20210313: Klipper's support for micro-controllers that communicate with CAN "
#~ "bus has changed. If using CAN bus then all micro-controllers must be "
#~ "reflashed and the [Klipper configuration must be updated](CANBUS.md)."
#~ msgstr ""

#~ msgid ""
#~ "20210227: TMC stepper motor drivers in UART or SPI mode are now queried once"
#~ " per second whenever they are enabled - if the driver can not be contacted "
#~ "or if the driver reports an error, then Klipper will transition to a "
#~ "shutdown state."
#~ msgstr ""

#~ msgid ""
#~ "20210201: The `TEST_RESONANCES` command will now disable input shaping if it"
#~ " was previously enabled (and re-enable it after the test). In order to "
#~ "override this behavior and keep the input shaping enabled, one can pass an "
#~ "additional parameter `INPUT_SHAPING=1` to the command."
#~ msgstr ""

#~ msgid ""
#~ "20201222: The `step_distance` setting in the stepper config sections is "
#~ "deprecated. It is advised to update the config to use the "
#~ "[`rotation_distance`](Rotation_Distance.md) setting. Support for "
#~ "`step_distance` will be removed in the near future."
#~ msgstr ""

#~ msgid ""
#~ "20201218: Rotary delta and polar printers must now specify a `gear_ratio` "
#~ "for their rotary steppers, and they may no longer specify a `step_distance` "
#~ "parameter. See the [config reference](Config_Reference.md#stepper) for the "
#~ "format of the new gear_ratio paramter."
#~ msgstr ""

#~ msgid ""
#~ "20201120: The `[board_pins]` config section now specifies the mcu name in an"
#~ " explicit `mcu:` parameter. If using board_pins for a secondary mcu, then "
#~ "the config must be updated to specify that name. See the [config "
#~ "reference](Config_Reference.md#board_pins) for further details."
#~ msgstr ""

#~ msgid ""
#~ "20201029: The neopixel `color_order_GRB` config option has been removed. If "
#~ "necessary, update the config to set the new `color_order` option to RGB, "
#~ "GRB, RGBW, or GRBW."
#~ msgstr ""

#~ msgid "20201020: Klipper v0.9.0 released."
#~ msgstr ""

#~ msgid ""
#~ "20200816: The gcode macro `printer.gcode` object has been renamed to "
#~ "`printer.gcode_move`. Several undocumented variables in `printer.toolhead` "
#~ "and `printer.gcode` have been removed. See docs/Command_Templates.md for a "
#~ "list of available template variables."
#~ msgstr ""

#~ msgid ""
#~ "20200809: The menu system has been rewritten. If the menu has been "
#~ "customized then it will be necessary to update to the new configuration. See"
#~ " config/example-menu.cfg for configuration details and see "
#~ "klippy/extras/display/menu.cfg for examples."
#~ msgstr ""

#~ msgid ""
#~ "20200725: The servo `enable` config parameter and the SET_SERVO `ENABLE` "
#~ "parameter have been removed. Update any macros to use `SET_SERVO "
#~ "SERVO=my_servo WIDTH=0` to disable a servo."
#~ msgstr ""

#~ msgid ""
#~ "20200606: The pin names on linux mcu have changed. Pins now have names of "
#~ "the form `gpiochip<chipid>/gpio<gpio>`. For gpiochip0 you can also use a "
#~ "short `gpio<gpio>`. For example, what was previously referred to as `P20` "
#~ "now becomes `gpio20` or `gpiochip0/gpio20`."
#~ msgstr ""

#~ msgid ""
#~ "20200531: The default USB vendor/product id is now 0x1d50/0x614e. These new "
#~ "ids are reserved for Klipper (thanks to the openmoko project). This change "
#~ "should not require any config changes, but the new ids may appear in system "
#~ "logs."
#~ msgstr ""

#~ msgid ""
#~ "20200425: The gcode_macro command template variable `printer.heater` was "
#~ "renamed to `printer.heaters`."
#~ msgstr ""

#~ msgid ""
#~ "20200308: The default `__test` menu item was removed. If the config file has"
#~ " a custom menu then be sure to remove all references to this `__test` menu "
#~ "item."
#~ msgstr ""

#~ msgid ""
#~ "20200109: The bed_mesh module now references the probe's location in for the"
#~ " mesh configuration. As such, some configuration options have been renamed "
#~ "to more accurately reflect their intended functionality. For rectangular "
#~ "beds, `min_point` and `max_point` have been renamed to `mesh_min` and "
#~ "`mesh_max` respectively. For round beds, `bed_radius` has been renamed to "
#~ "`mesh_radius`. A new `mesh_origin` option has also been added for round "
#~ "beds. Note that these changes are also incompatible with previously saved "
#~ "mesh profiles. If an incompatible profile is detected it will be ignored and"
#~ " scheduled for removal. The removal process can be completed by issuing the "
#~ "SAVE_CONFIG command. The user will need to re-calibrate each profile."
#~ msgstr ""

#~ msgid ""
#~ "20191210: The builtin T0, T1, T2, ... commands have been removed. The "
#~ "extruder activate_gcode and deactivate_gcode config options have been "
#~ "removed. If these commands (and scripts) are needed then define individual "
#~ "[gcode_macro T0] style macros that call the ACTIVATE_EXTRUDER command. See "
#~ "the config/sample-idex.cfg and sample-multi-extruder.cfg files for examples."
#~ msgstr ""

#~ msgid ""
#~ "20191202: Support for the undocumented \"S\" parameter of the \"G4\" command"
#~ " has been removed. Replace any occurrences of S with the standard \"P\" "
#~ "parameter (the delay specified in milliseconds)."
#~ msgstr ""

#~ msgid ""
#~ "20191121: The pressure_advance_lookahead_time parameter has been removed. "
#~ "See example.cfg for alternate configuration settings."
#~ msgstr ""

#~ msgid ""
#~ "20191107: The primary extruder config section must be specified as "
#~ "\"extruder\" and may no longer be specified as \"extruder0\". Gcode command "
#~ "templates that query the extruder status are now accessed via "
#~ "\"{printer.extruder}\"."
#~ msgstr ""

#~ msgid ""
#~ "20191003: The move_to_previous option in [safe_z_homing] now defaults to "
#~ "False. (It was effectively False prior to 20190918.)"
#~ msgstr ""

#~ msgid "20190806: The SET_NEOPIXEL command has been renamed to SET_LED."
#~ msgstr ""

#~ msgid ""
#~ "20190710: The z_hop option was removed from the [firmware_retract] config "
#~ "section. The z_hop support was incomplete and could cause incorrect behavior"
#~ " with several common slicers."
#~ msgstr ""

#~ msgid ""
#~ "20190628: All configuration options have been removed from the "
#~ "[skew_correction] section. Configuration for skew_correction is now done via"
#~ " the SET_SKEW gcode. See [Skew Correction](Skew_Correction.md) for "
#~ "recommended usage."
#~ msgstr ""

#~ msgid ""
#~ "20190606: The \"samples\", \"samples_result\", and \"sample_retract_dist\" "
#~ "config options have been moved to the \"probe\" config section. These "
#~ "options are no longer supported in the \"delta_calibrate\", \"bed_tilt\", "
#~ "\"bed_mesh\", \"screws_tilt_adjust\", \"z_tilt\", or \"quad_gantry_level\" "
#~ "config sections."
#~ msgstr ""

#~ msgid ""
#~ "20190520: The SET_GCODE_OFFSET command has changed; update any g-code macros"
#~ " accordingly. The command will no longer apply the requested offset to the "
#~ "next G1 command. The old behavior may be approximated by using the new "
#~ "\"MOVE=1\" parameter."
#~ msgstr ""

#~ msgid ""
#~ "20190404: The i2c_bus and spi_bus parameters (in various config sections) "
#~ "now take a bus name instead of a number."
#~ msgstr ""

#~ msgid ""
#~ "20190328: The min_speed value in [temperature_fan] config will now be "
#~ "respected and the fan will always run at this speed or higher in PID mode."
#~ msgstr ""

#~ msgid ""
#~ "20190310: The [controller_fan] config section now always takes a name (such "
#~ "as [controller_fan my_controller_fan])."
#~ msgstr ""

#~ msgid ""
#~ "20190308: The [tmc2660] config section has changed. A new sense_resistor "
#~ "config parameter must now be provided. The meaning of several of the "
#~ "driver_XXX parameters has changed."
#~ msgstr ""

#~ msgid ""
#~ "20190224: The bed_shape option has been removed from bed_mesh. The radius "
#~ "option has been renamed to bed_radius. Users with round beds should supply "
#~ "the bed_radius and round_probe_count options."
#~ msgstr ""

#~ msgid "20181220: Klipper v0.7.0 released"
#~ msgstr ""

#~ msgid ""
#~ "This document provides information on implementing G-Code command sequences "
#~ "in gcode_macro (and similar) config sections."
#~ msgstr ""

#~ msgid ""
#~ "Case is not important for the G-Code macro name - MY_MACRO and my_macro will"
#~ " evaluate the same and may be called in either upper or lower case. If any "
#~ "numbers are used in the macro name then they must all be at the end of the "
#~ "name (eg, TEST_MACRO25 is valid, but MACRO25_TEST3 is not)."
#~ msgstr ""

#~ msgid ""
#~ "Indentation is important when defining a macro in the config file. To "
#~ "specify a multi-line G-Code sequence it is important for each line to have "
#~ "proper indentation. For example:"
#~ msgstr ""

#~ msgid ""
#~ "Note how the `gcode:` config option always starts at the beginning of the "
#~ "line and subsequent lines in the G-Code macro never start at the beginning."
#~ msgstr ""

#~ msgid ""
#~ "To help identify the functionality a short description can be added. Add "
#~ "`description:` with a short text to describe the functionality. Default is "
#~ "\"G-Code macro\" if not specified. For example:"
#~ msgstr ""

#~ msgid ""
#~ "The terminal will display the description when you use the `HELP` command or"
#~ " the autocomplete function."
#~ msgstr ""

#~ msgid ""
#~ "Unfortunately, the G-Code command language can be challenging to use. The "
#~ "standard mechanism to move the toolhead is via the `G1` command (the `G0` "
#~ "command is an alias for `G1` and it can be used interchangeably with it). "
#~ "However, this command relies on the \"G-Code parsing state\" setup by `M82`,"
#~ " `M83`, `G90`, `G91`, `G92`, and previous `G1` commands. When creating a "
#~ "G-Code macro it is a good idea to always explicitly set the G-Code parsing "
#~ "state prior to issuing a `G1` command. (Otherwise, there is a risk the `G1` "
#~ "command will make an undesirable request.)"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro MOVE_UP]\n"
#~ "gcode:\n"
#~ "  SAVE_GCODE_STATE NAME=my_move_up_state\n"
#~ "  G91\n"
#~ "  G1 Z10 F300\n"
#~ "  RESTORE_GCODE_STATE NAME=my_move_up_state\n"
#~ msgstr ""

#~ msgid "Template expansion"
#~ msgstr ""

#~ msgid "An example of a complex macro:"
#~ msgstr ""

#~ msgid "Macro parameters"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro SET_PERCENT]\n"
#~ "gcode:\n"
#~ "  M117 Now at { params.VALUE|float * 100 }%\n"
#~ msgstr ""

#~ msgid ""
#~ "It's common to use the Jinja2 `set` directive to use a default parameter and"
#~ " assign the result to a local name. For example:"
#~ msgstr ""

#~ msgid "The \"rawparams\" variable"
#~ msgstr ""

#~ msgid ""
#~ "Note that this will include any comments that were part of the original "
#~ "command."
#~ msgstr ""

#~ msgid "The \"printer\" Variable"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro slow_fan]\n"
#~ "gcode:\n"
#~ "  M106 S{ printer.fan.speed * 0.9 * 255}\n"
#~ msgstr ""

#~ msgid ""
#~ "Important! Macros are first evaluated in entirety and only then are the "
#~ "resulting commands executed. If a macro issues a command that alters the "
#~ "state of the printer, the results of that state change will not be visible "
#~ "during the evaluation of the macro. This can also result in subtle behavior "
#~ "when a macro generates commands that call other macros, as the called macro "
#~ "is evaluated when it is invoked (which is after the entire evaluation of the"
#~ " calling macro)."
#~ msgstr ""

#~ msgid ""
#~ "Note that the Jinja2 `set` directive can assign a local name to an object in"
#~ " the `printer` hierarchy. This can make macros more readable and reduce "
#~ "typing. For example:"
#~ msgstr ""

#~ msgid "Actions"
#~ msgstr ""

#~ msgid "Available \"action\" commands:"
#~ msgstr ""

#~ msgid ""
#~ "`action_raise_error(msg)`: Abort the current macro (and any calling macros) "
#~ "and write the given `msg` to the /tmp/printer pseudo-terminal. The first "
#~ "line of `msg` will be sent with a \"!! \" prefix and subsequent lines will "
#~ "have a \"// \" prefix."
#~ msgstr ""

#~ msgid ""
#~ "`action_call_remote_method(method_name)`: Calls a method registered by a "
#~ "remote client. If the method takes parameters they should be provided via "
#~ "keyword arguments, ie: `action_call_remote_method(\"print_stuff\", "
#~ "my_arg=\"hello_world\")`"
#~ msgstr ""

#~ msgid ""
#~ "The SET_GCODE_VARIABLE command may be useful for saving state between macro "
#~ "calls. Variable names may not contain any upper case characters. For "
#~ "example:"
#~ msgstr ""

#~ msgid ""
#~ "Be sure to take the timing of macro evaluation and command execution into "
#~ "account when using SET_GCODE_VARIABLE."
#~ msgstr ""

#~ msgid ""
#~ "The [delayed_gcode] configuration option can be used to execute a delayed "
#~ "gcode sequence:"
#~ msgstr ""

#~ msgid ""
#~ "When the `load_filament` macro above executes, it will display a \"Load "
#~ "Complete!\" message after the extrusion is finished. The last line of gcode "
#~ "enables the \"clear_display\" delayed_gcode, set to execute in 10 seconds."
#~ msgstr ""

#~ msgid ""
#~ "[delayed_gcode welcome]\n"
#~ "initial_duration: 5.\n"
#~ "gcode:\n"
#~ "  M117 Welcome!\n"
#~ msgstr ""

#~ msgid ""
#~ "[delayed_gcode report_temp]\n"
#~ "initial_duration: 2.\n"
#~ "gcode:\n"
#~ "  {action_respond_info(\"Extruder Temp: %.1f\" % (printer.extruder0.temperature))}\n"
#~ "  UPDATE_DELAYED_GCODE ID=report_temp DURATION=2\n"
#~ msgstr ""

#~ msgid "UPDATE_DELAYED_GCODE ID=report_temp DURATION=0\n"
#~ msgstr ""

#~ msgid ""
#~ "If a [display config section](Config_Reference.md#display) is enabled, then "
#~ "it is possible to customize the menu with [menu](Config_Reference.md#menu) "
#~ "config sections."
#~ msgstr ""

#~ msgid "`menu.width` - element width (number of display columns)"
#~ msgstr ""

#~ msgid "`menu.event` - name of the event that triggered the script"
#~ msgstr ""

#~ msgid "The following actions are available in menu templates:"
#~ msgstr ""

#~ msgid ""
#~ "When `<force>` is set True then it will also stop editing. Default value is "
#~ "False."
#~ msgstr ""

#~ msgid ""
#~ "`menu.exit(force)` - will execute menu exit command, optional boolean "
#~ "parameter `<force>` default value False."
#~ msgstr ""

#~ msgid ""
#~ "If a [save_variables config section](Config_Reference.md#save_variables) has"
#~ " been enabled, `SAVE_VARIABLE VARIABLE=<name> VALUE=<value>` can be used to "
#~ "save the variable to disk so that it can be used across restarts. All stored"
#~ " variables are loaded into the `printer.save_variables.variables` dict at "
#~ "startup and can be used in gcode macros. to avoid overly long lines you can "
#~ "add the following at the top of the macro:"
#~ msgstr ""

#~ msgid ""
#~ "As an example, it could be used to save the state of 2-in-1-out hotend and "
#~ "when starting a print ensure that the active extruder is used, instead of "
#~ "T0:"
#~ msgstr ""

#~ msgid ""
#~ "This document describes the overall code layout and major code flow of "
#~ "Klipper."
#~ msgstr ""

#~ msgid ""
#~ "The **src/** directory contains the C source for the micro-controller code. "
#~ "The **src/atsam/**, **src/atsamd/**, **src/avr/**, **src/linux/**, "
#~ "**src/lpc176x/**, **src/pru/**, and **src/stm32/** directories contain "
#~ "architecture specific micro-controller code. The **src/simulator/** contains"
#~ " code stubs that allow the micro-controller to be test compiled on other "
#~ "architectures. The **src/generic/** directory contains helper code that may "
#~ "be useful across different architectures. The build arranges for includes of"
#~ " \"board/somefile.h\" to first look in the current architecture directory "
#~ "(eg, src/avr/somefile.h) and then in the generic directory (eg, "
#~ "src/generic/somefile.h)."
#~ msgstr ""

#~ msgid ""
#~ "The **lib/** directory contains external 3rd-party library code that is "
#~ "necessary to build some targets."
#~ msgstr ""

#~ msgid ""
#~ "The **scripts/** directory contains build-time scripts useful for compiling "
#~ "the micro-controller code."
#~ msgstr ""

#~ msgid ""
#~ "During compilation, the build may create an **out/** directory. This "
#~ "contains temporary build time objects. The final micro-controller object "
#~ "that is built is **out/klipper.elf.hex** on AVR and **out/klipper.bin** on "
#~ "ARM."
#~ msgstr ""

#~ msgid ""
#~ "Execution of the micro-controller code starts in architecture specific code "
#~ "(eg, **src/avr/main.c**) which ultimately calls sched_main() located in "
#~ "**src/sched.c**. The sched_main() code starts by running all functions that "
#~ "have been tagged with the DECL_INIT() macro. It then goes on to repeatedly "
#~ "run all functions tagged with the DECL_TASK() macro."
#~ msgstr ""

#~ msgid ""
#~ "Task, init, and command functions always run with interrupts enabled "
#~ "(however, they can temporarily disable interrupts if needed). These "
#~ "functions should avoid long pauses, delays, or do work that lasts a "
#~ "significant time. (Long delays in these \"task\" functions result in "
#~ "scheduling jitter for other \"tasks\" - delays over 100us may become "
#~ "noticeable, delays over 500us may result in command retransmissions, delays "
#~ "over 100ms may result in watchdog reboots.) These functions schedule work at"
#~ " specific times by scheduling timers."
#~ msgstr ""

#~ msgid ""
#~ "In the event an error is detected the code can invoke shutdown() (a macro "
#~ "which calls sched_shutdown() located in **src/sched.c**). Invoking "
#~ "shutdown() causes all functions tagged with the DECL_SHUTDOWN() macro to be "
#~ "run. Shutdown functions always run with interrupts disabled."
#~ msgstr ""

#~ msgid "Klippy code overview"
#~ msgstr ""

#~ msgid ""
#~ "Initial execution starts in **klippy/klippy.py**. This reads the command-"
#~ "line arguments, opens the printer config file, instantiates the main printer"
#~ " objects, and starts the serial connection. The main execution of G-code "
#~ "commands is in the process_commands() method in **klippy/gcode.py**. This "
#~ "code translates the G-code commands into printer object calls, which "
#~ "frequently translate the actions to commands to be executed on the micro-"
#~ "controller (as declared via the DECL_COMMAND macro in the micro-controller "
#~ "code)."
#~ msgstr ""

#~ msgid "Code flow of a move command"
#~ msgstr ""

#~ msgid ""
#~ "Processing for a move command starts in gcode.py. The goal of gcode.py is to"
#~ " translate G-code into internal calls. A G1 command will invoke cmd_G1() in "
#~ "klippy/extras/gcode_move.py. The gcode_move.py code handles changes in "
#~ "origin (eg, G92), changes in relative vs absolute positions (eg, G90), and "
#~ "unit changes (eg, F6000=100mm/s). The code path for a move is: "
#~ "`_process_data() -> _process_commands() -> cmd_G1()`. Ultimately the "
#~ "ToolHead class is invoked to execute the actual request: `cmd_G1() -> "
#~ "ToolHead.move()`"
#~ msgstr ""

#~ msgid ""
#~ "ToolHead.move() creates a Move() object with the parameters of the move (in "
#~ "cartesian space and in units of seconds and millimeters)."
#~ msgstr ""

#~ msgid "MoveQueue.add_move() places the move object on the \"look-ahead\" queue."
#~ msgstr ""

#~ msgid ""
#~ "Move.set_junction() implements the \"trapezoid generator\" on a move. The "
#~ "\"trapezoid generator\" breaks every move into three parts: a constant "
#~ "acceleration phase, followed by a constant velocity phase, followed by a "
#~ "constant deceleration phase. Every move contains these three phases in this "
#~ "order, but some phases may be of zero duration."
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
#~ "finding_algorithm) to generate the step times for each stepper. For "
#~ "efficiency reasons, the stepper pulse times are generated in C code. The "
#~ "moves are first placed on a \"trapezoid motion queue\": "
#~ "`ToolHead._process_moves() -> trapq_append()` (in klippy/chelper/trapq.c). "
#~ "The step times are then generated: `ToolHead._process_moves() -> "
#~ "ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> "
#~ "itersolve_generate_steps() -> itersolve_gen_steps_range()` (in "
#~ "klippy/chelper/itersolve.c). The goal of the iterative solver is to find "
#~ "step times given a function that calculates a stepper position from a time. "
#~ "This is done by repeatedly \"guessing\" various times until the stepper "
#~ "position formula returns the desired position of the next step on the "
#~ "stepper. The feedback produced from each guess is used to improve future "
#~ "guesses so that the process rapidly converges to the desired time. The "
#~ "kinematic stepper position formulas are located in the klippy/chelper/ "
#~ "directory (eg, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c)."
#~ msgstr ""

#~ msgid ""
#~ "After the iterative solver calculates the step times they are added to an "
#~ "array: `itersolve_gen_steps_range() -> stepcompress_append()` (in "
#~ "klippy/chelper/stepcompress.c). The array (struct stepcompress.queue) stores"
#~ " the corresponding micro-controller clock counter times for every step. Here"
#~ " the \"micro-controller clock counter\" value directly corresponds to the "
#~ "micro-controller's hardware counter - it is relative to when the micro-"
#~ "controller was last powered up."
#~ msgstr ""

#~ msgid ""
#~ "Processing of the queue_step commands on the micro-controller starts in "
#~ "src/command.c which parses the command and calls `command_queue_step()`. The"
#~ " command_queue_step() code (in src/stepper.c) just appends the parameters of"
#~ " each queue_step command to a per stepper queue. Under normal operation the "
#~ "queue_step command is parsed and queued at least 100ms before the time of "
#~ "its first step. Finally, the generation of stepper events is done in "
#~ "`stepper_event()`. It's called from the hardware timer interrupt at the "
#~ "scheduled time of the first step. The stepper_event() code generates a step "
#~ "pulse and then reschedules itself to run at the time of the next step pulse "
#~ "for the given queue_step parameters. The parameters for each queue_step "
#~ "command are \"interval\", \"count\", and \"add\". At a high-level, "
#~ "stepper_event() runs the following, 'count' times: `do_step(); "
#~ "next_wake_time = last_wake_time + interval; interval += add;`"
#~ msgstr ""

#~ msgid "Adding a host module"
#~ msgstr ""

#~ msgid ""
#~ "The easiest way to add a new module is to use an existing module as a "
#~ "reference - see **klippy/extras/servo.py** as an example."
#~ msgstr ""

#~ msgid ""
#~ "Execution of the module starts in the module level `load_config()` function "
#~ "(for config sections of the form [my_module]) or in `load_config_prefix()` "
#~ "(for config sections of the form [my_module my_name]). This function is "
#~ "passed a \"config\" object and it must return a new \"printer object\" "
#~ "associated with the given config section."
#~ msgstr ""

#~ msgid ""
#~ "Use the `config.get_printer()` method to obtain a reference to the main "
#~ "\"printer\" class. This \"printer\" class stores references to all the "
#~ "\"printer objects\" that have been instantiated. Use the "
#~ "`printer.lookup_object()` method to find references to other printer "
#~ "objects. Almost all functionality (even core kinematic modules) are "
#~ "encapsulated in one of these printer objects. Note, though, that when a new "
#~ "module is instantiated, not all other printer objects will have been "
#~ "instantiated. The \"gcode\" and \"pins\" modules will always be available, "
#~ "but for other modules it is a good idea to defer the lookup."
#~ msgstr ""

#~ msgid ""
#~ "klippy:connect - This event is generated after all printer objects are "
#~ "instantiated. It is commonly used to lookup other printer objects, to verify"
#~ " config settings, and to perform an initial \"handshake\" with printer "
#~ "hardware."
#~ msgstr ""

#~ msgid ""
#~ "If there is an error in the user's config, be sure to raise it during the "
#~ "`load_config()` or \"connect event\" phases. Use either `raise "
#~ "config.error(\"my error\")` or `raise printer.config_error(\"my error\")` to"
#~ " report the error."
#~ msgstr ""

#~ msgid ""
#~ "If the printer object defines a `get_status()` method then the module can "
#~ "export [status information](Status_Reference.md) via "
#~ "[macros](Command_Templates.md) and via the [API Server](API_Server.md). The "
#~ "`get_status()` method must return a Python dictionary with keys that are "
#~ "strings and values that are integers, floats, strings, lists, dictionaries, "
#~ "True, False, or None. Tuples (and named tuples) may also be used (these "
#~ "appear as lists when accessed via the API Server). Lists and dictionaries "
#~ "that are exported must be treated as \"immutable\" - if their contents "
#~ "change then a new object must be returned from `get_status()`, otherwise the"
#~ " API Server will not detect those changes."
#~ msgstr ""

#~ msgid ""
#~ "Do not use global variables. All state should be stored in the printer "
#~ "object returned from the `load_config()` function. This is important as "
#~ "otherwise the RESTART command may not perform as expected. Also, for similar"
#~ " reasons, if any external files (or sockets) are opened then be sure to "
#~ "register a \"klippy:disconnect\" event handler and close them from that "
#~ "callback."
#~ msgstr ""

#~ msgid ""
#~ "It is recommended to assign a value to all member variables in the Python "
#~ "constructor of Python classes. (And therefore avoid utilizing Python's "
#~ "ability to dynamically create new member variables.)"
#~ msgstr ""

#~ msgid ""
#~ "If submitting the module for inclusion in the main Klipper code, be sure to "
#~ "place a copyright notice at the top of the module. See the existing modules "
#~ "for the preferred format."
#~ msgstr ""

#~ msgid ""
#~ "This section provides some tips on adding support to Klipper for additional "
#~ "types of printer kinematics. This type of activity requires excellent "
#~ "understanding of the math formulas for the target kinematics. It also "
#~ "requires software development skills - though one should only need to update"
#~ " the host software."
#~ msgstr ""

#~ msgid ""
#~ "Start by studying the \"[code flow of a move](#code-flow-of-a-move-"
#~ "command)\" section and the [Kinematics document](Kinematics.md)."
#~ msgstr ""

#~ msgid ""
#~ "Implement the C stepper kinematic position functions for each stepper if "
#~ "they are not already available (see kin_cart.c, kin_corexy.c, and "
#~ "kin_delta.c in klippy/chelper/). The function should call `move_get_coord()`"
#~ " to convert a given move time (in seconds) to a cartesian coordinate (in "
#~ "millimeters), and then calculate the desired stepper position (in "
#~ "millimeters) from that cartesian coordinate."
#~ msgstr ""

#~ msgid ""
#~ "Other methods. Implement the `check_move()`, `get_status()`, "
#~ "`get_steppers()`, `home()`, and `set_position()` methods. These functions "
#~ "are typically used to provide kinematic specific checks. However, at the "
#~ "start of development one can use boiler-plate code here."
#~ msgstr ""

#~ msgid "Porting to a new micro-controller"
#~ msgstr ""

#~ msgid ""
#~ "Start by identifying any 3rd party libraries that will be used during the "
#~ "port. Common examples include \"CMSIS\" wrappers and manufacturer \"HAL\" "
#~ "libraries. All 3rd party code needs to be GNU GPLv3 compatible. The 3rd "
#~ "party code should be committed to the Klipper lib/ directory. Update the "
#~ "lib/README file with information on where and when the library was obtained."
#~ " It is preferable to copy the code into the Klipper repository unchanged, "
#~ "but if any changes are required then those changes should be listed "
#~ "explicitly in the lib/README file."
#~ msgstr ""

#~ msgid ""
#~ "The first main coding task is to bring up communication support to the "
#~ "target board. This is the most difficult step in a new port. Once basic "
#~ "communication is working, the remaining steps tend to be much easier. It is "
#~ "typical to use a UART type serial device during initial development as these"
#~ " types of hardware devices are generally easier to enable and control. "
#~ "During this phase, make liberal use of helper code from the src/generic/ "
#~ "directory (check how src/simulator/Makefile includes the generic C code into"
#~ " the build). It is also necessary to define timer_read_time() (which returns"
#~ " the current system clock) in this phase, but it is not necessary to fully "
#~ "support timer irq handling."
#~ msgstr ""

#~ msgid ""
#~ "Add support for timer dispatch from hardware interrupts. See Klipper [commit"
#~ " "
#~ "970831ee](https://github.com/Klipper3d/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)"
#~ " as an example of steps 1-5 done for the LPC176x architecture."
#~ msgstr ""

#~ msgid ""
#~ "Bring up additional peripherals - for example see Klipper commit "
#~ "[65613aed](https://github.com/Klipper3d/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27),"
#~ " "
#~ "[c812a40a](https://github.com/Klipper3d/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5),"
#~ " and "
#~ "[c381d03a](https://github.com/Klipper3d/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)."
#~ msgstr ""

#~ msgid "Consider adding build test cases in the test/ directory."
#~ msgstr ""

#~ msgid ""
#~ "Avoid using \"C bitfields\" to access IO registers; prefer direct read and "
#~ "write operations of 32bit, 16bit, or 8bit integers. The C language "
#~ "specifications don't clearly specify how the compiler must implement C "
#~ "bitfields (eg, endianness, and bit layout), and it's difficult to determine "
#~ "what IO operations will occur on a C bitfield read or write."
#~ msgstr ""

#~ msgid "Coordinate Systems"
#~ msgstr ""

#~ msgid ""
#~ "However, in some cases it is useful to obtain the toolhead position in some "
#~ "other coordinate system and Klipper has several tools to facilitate that. "
#~ "This can be seen by running the GET_POSITION command. For example:"
#~ msgstr ""

#~ msgid ""
#~ "The \"mcu\" position (`stepper.get_mcu_position()` in the code) is the total"
#~ " number of steps the micro-controller has issued in a positive direction "
#~ "minus the number of steps issued in a negative direction since the micro-"
#~ "controller was last reset. If the robot is in motion when the query is "
#~ "issued then the reported value includes moves buffered on the micro-"
#~ "controller, but does not include moves on the look-ahead queue."
#~ msgstr ""

#~ msgid ""
#~ "The \"kinematic\" position (`kin.calc_position()`) is the cartesian position"
#~ " of the toolhead as derived from \"stepper\" positions and is relative to "
#~ "the coordinate system specified in the config file. This may differ from the"
#~ " requested cartesian position due to the granularity of the stepper motors. "
#~ "If the robot is in motion when the \"stepper\" positions are taken then the "
#~ "reported value includes moves buffered on the micro-controller, but does not"
#~ " include moves on the look-ahead queue. One may use the "
#~ "`toolhead.flush_step_generation()` or `toolhead.wait_moves()` calls to fully"
#~ " flush the look-ahead and step generation code."
#~ msgstr ""

#~ msgid ""
#~ "The \"gcode\" position is the last requested position from a `G1` (or `G0`) "
#~ "command in cartesian coordinates relative to the coordinate system specified"
#~ " in the config file. This may differ from the \"toolhead\" position if a "
#~ "g-code transformation (eg, bed_mesh, bed_tilt, skew_correction) is in "
#~ "effect. This may differ from the actual coordinates specified in the last "
#~ "`G1` command if the g-code origin has been changed (eg, `G92`, "
#~ "`SET_GCODE_OFFSET`, `M221`). The `M114` command "
#~ "(`gcode_move.get_status()['gcode_position']`) will report the last g-code "
#~ "position relative to the current g-code coordinate system."
#~ msgstr ""

#~ msgid ""
#~ "The \"gcode homing\" is the location to use for the g-code origin (in "
#~ "cartesian coordinates relative to the coordinate system specified in the "
#~ "config file) after a `G28` home command. The `SET_GCODE_OFFSET` command can "
#~ "alter this value."
#~ msgstr ""

#~ msgid ""
#~ "Fundamental to the operation of Klipper is the handling of clocks, times, "
#~ "and timestamps. Klipper executes actions on the printer by scheduling events"
#~ " to occur in the near future. For example, to turn on a fan, the code might "
#~ "schedule a change to a GPIO pin in a 100ms. It is rare for the code to "
#~ "attempt to take an instantaneous action. Thus, the handling of time within "
#~ "Klipper is critical to correct operation."
#~ msgstr ""

#~ msgid ""
#~ "System time. The system time uses the system's monotonic clock - it is a "
#~ "floating point number stored as seconds and it is (generally) relative to "
#~ "when the host computer was last started. System times have limited use in "
#~ "the software - they are primarily used when interacting with the operating "
#~ "system. Within the host code, system times are frequently stored in "
#~ "variables named *eventtime* or *curtime*."
#~ msgstr ""

#~ msgid ""
#~ "MCU clock. This is the hardware clock counter on each micro-controller. It "
#~ "is stored as an integer and its update rate is relative to the frequency of "
#~ "the given micro-controller. The host software translates its internal times "
#~ "to clocks before transmission to the mcu. The mcu code only ever tracks time"
#~ " in clock ticks. Within the host code, clock values are tracked as 64bit "
#~ "integers, while the mcu code uses 32bit integers. Within the host code, "
#~ "clocks are generally stored in variables with names containing *clock* or "
#~ "*ticks*."
#~ msgstr ""

#~ msgid "Some things to be aware of when reviewing the code:"
#~ msgstr ""

#~ msgid ""
#~ "Multiple micro-controllers: The host software supports using multiple micro-"
#~ "controllers on a single printer. In this case, the \"MCU clock\" of each "
#~ "micro-controller is tracked separately. The clocksync.py code handles clock "
#~ "drift between micro-controllers by modifying the way it converts from "
#~ "\"print time\" to \"MCU clock\". On secondary mcus, the mcu frequency that "
#~ "is used in this conversion is regularly updated to account for measured "
#~ "drift."
#~ msgstr ""

#~ msgid ""
#~ "Thank you for contributing to Klipper! This document describes the process "
#~ "for contributing changes to Klipper."
#~ msgstr ""

#~ msgid "Overview of Contribution Process"
#~ msgstr ""

#~ msgid ""
#~ "A submitter starts by creating a [GitHub Pull "
#~ "Request](https://github.com/Klipper3d/klipper/pulls) when a submission is "
#~ "ready for widespread deployment."
#~ msgstr ""

#~ msgid ""
#~ "After a successful review, the reviewer will \"approve the review\" on "
#~ "GitHub and a [maintainer](#reviewers) will commit the change to the Klipper "
#~ "master branch."
#~ msgstr ""

#~ msgid "What to expect in a review"
#~ msgstr ""

#~ msgid ""
#~ "It is understood that there are many ways to accomplish a task; it is not "
#~ "the intent of the review to discuss the \"best\" implementation. Where "
#~ "possible, review discussions focused on facts and measurements are "
#~ "preferable."
#~ msgstr ""

#~ msgid "Common things a reviewer will look for:"
#~ msgstr ""

#~ msgid ""
#~ "Submitters are expected to test their changes prior to submission. The "
#~ "reviewers look for errors, but they don't, in general, test submissions. An "
#~ "accepted submission is often deployed to thousands of printers within a few "
#~ "weeks of acceptance. Quality of submissions is therefore considered a "
#~ "priority."
#~ msgstr ""

#~ msgid "Submissions must pass all [regression test cases](Debugging.md)."
#~ msgstr ""

#~ msgid ""
#~ "Code submissions should not contain excessive debugging code, debugging "
#~ "options, nor run-time debug logging."
#~ msgstr ""

#~ msgid ""
#~ "Updates to documentation should not declare that they are a \"work in "
#~ "progress\"."
#~ msgstr ""

#~ msgid ""
#~ "Reviewers need to identify, at least in their own minds, roughly \"who the "
#~ "target audience is\", a rough scale of \"the size of that audience\", the "
#~ "\"benefit\" they will obtain, how the \"benefit is measured\", and the "
#~ "\"results of those measurement tests\". In most cases this will be obvious "
#~ "to both the submitter and the reviewer, and it is not explicitly stated "
#~ "during a review."
#~ msgstr ""

#~ msgid ""
#~ "If a reviewer asks for details on the \"benefit\" of a submission, please "
#~ "don't consider it criticism. Being able to understand the real-world "
#~ "benefits of a change is a natural part of a review."
#~ msgstr ""

#~ msgid ""
#~ "All new modules, config options, commands, command parameters, and documents"
#~ " should have \"high impact\". We do not want to burden users with options "
#~ "that they can not reasonably configure nor do we want to burden them with "
#~ "options that don't provide a notable benefit."
#~ msgstr ""

#~ msgid ""
#~ "If the goal of an option is to make the code more modular then prefer using "
#~ "code constants instead of user facing config options."
#~ msgstr ""

#~ msgid ""
#~ "Is the copyright of the submission clear, non-gratuitous, and compatible?"
#~ msgstr ""

#~ msgid ""
#~ "Code taken from 3rd party sources must be compatible with the Klipper "
#~ "license (GNU GPLv3). Large 3rd party code additions should be added to the "
#~ "`lib/` directory (and follow the format described in "
#~ "[lib/README](../lib/README))."
#~ msgstr ""

#~ msgid ""
#~ "Does the submission follow guidelines specified in the Klipper "
#~ "documentation?"
#~ msgstr ""

#~ msgid "Is the Klipper documentation updated to reflect new changes?"
#~ msgstr ""

#~ msgid ""
#~ "All commands and command parameters must be documented in <G-Codes.md>."
#~ msgstr ""

#~ msgid ""
#~ "All exported \"status variables\" must be documented in "
#~ "<Status_Reference.md>."
#~ msgstr ""

#~ msgid ""
#~ "Any change that makes a non-backwards compatible change to a command or "
#~ "config file setting must be documented in <Config_Changes.md>."
#~ msgstr ""

#~ msgid ""
#~ "Are commits well formed, address a single topic per commit, and independent?"
#~ msgstr ""

#~ msgid ""
#~ "Commits must not have a merge conflict. New additions to the Klipper master "
#~ "branch are always done via a \"rebase\" or \"squash and rebase\". It is "
#~ "generally not necessary for submitters to re-merge their submission on every"
#~ " update to the Klipper master repository. However, if there is a merge "
#~ "conflict, then submitters are recommended to use `git rebase` to address the"
#~ " conflict."
#~ msgstr ""

#~ msgid ""
#~ "Whitespace changes should not be mixed with functional changes. In general, "
#~ "gratuitous whitespace changes are not accepted unless they are from the "
#~ "established \"owner\" of the code being modified."
#~ msgstr ""

#~ msgid ""
#~ "It is not a goal of a review to discuss \"better implementations\". However,"
#~ " if a reviewer struggles to understand the implementation of a submission, "
#~ "then they may ask for changes to make the implementation more transparent. "
#~ "In particular, if reviewers can not convince themselves that a submission is"
#~ " free of defects then changes may be necessary."
#~ msgstr ""

#~ msgid "Helping with reviews"
#~ msgstr ""

#~ msgid ""
#~ "To help with a review, follow the steps outlined in [what to expect in a "
#~ "review](#what-to-expect-in-a-review) to verify the submission. After "
#~ "completing the review, add a comment to the GitHub Pull Request with your "
#~ "findings. If the submission passes the review then please state that "
#~ "explicitly in the comment - for example something like \"I reviewed this "
#~ "change according to the steps in the CONTRIBUTING document and everything "
#~ "looks good to me\". If unable to complete some steps in the review then "
#~ "please explicitly state which steps were reviewed and which steps were not "
#~ "reviewed - for example something like \"I didn't check the code for defects,"
#~ " but I reviewed everything else in the CONTRIBUTING document and it looks "
#~ "good\"."
#~ msgstr ""

#~ msgid "Reviewers"
#~ msgstr ""

#~ msgid "Name"
#~ msgstr ""

#~ msgid "Areas of interest"
#~ msgstr ""

#~ msgid "@dmbutyugin"
#~ msgstr ""

#~ msgid "@Arksine"
#~ msgstr ""

#~ msgid "@KevinOConnor"
#~ msgstr ""

#~ msgid "Paul McGowan"
#~ msgstr ""

#~ msgid "Configuration files, documentation"
#~ msgstr ""

#~ msgid "The Klipper \"maintainers\" are:"
#~ msgstr ""

#~ msgid "Format of commit messages"
#~ msgstr ""

#~ msgid ""
#~ "module: Capitalized, short (50 chars or less) summary\n"
#~ "\n"
#~ "More detailed explanatory text, if necessary.  Wrap it to about 75\n"
#~ "characters or so.  In some contexts, the first line is treated as the\n"
#~ "subject of an email and the rest of the text as the body.  The blank\n"
#~ "line separating the summary from the body is critical (unless you omit\n"
#~ "the body entirely); tools like rebase can get confused if you run the\n"
#~ "two together.\n"
#~ "\n"
#~ "Further paragraphs come after blank lines..\n"
#~ "\n"
#~ "Signed-off-by: My Name <myemail@example.org>\n"
#~ msgstr ""

#~ msgid ""
#~ "It is important to have a \"Signed-off-by\" line on each commit - it "
#~ "certifies that you agree to the [developer certificate of origin](developer-"
#~ "certificate-of-origin). It must contain your real name (sorry, no pseudonyms"
#~ " or anonymous contributions) and contain a current email address."
#~ msgstr ""

#~ msgid ""
#~ "[Klipper-translations Project](https://github.com/Klipper3d/klipper-"
#~ "translations) is a project dedicated to translating Klipper to different "
#~ "languages. [Weblate](https://hosted.weblate.org/projects/klipper/) hosts all"
#~ " the Gettext strings for translating and reviewing. Locales can be displayed"
#~ " on [klipper3d.org](https://www.klipper3d.org) once they satisfy the "
#~ "following requirements:"
#~ msgstr ""

#~ msgid "All titles (H1) are translated"
#~ msgstr ""

#~ msgid ""
#~ "To reduce the frustration of translating domain-specific terms and gain "
#~ "awareness of the ongoing translations, you can submit a PR modifying the "
#~ "[Klipper-translations Project](https://github.com/Klipper3d/klipper-"
#~ "translations) `readme.md`. Once a translation is ready, the corresponding "
#~ "modification to the Klipper project can be made."
#~ msgstr ""

#~ msgid "Once the requirements are met, you need to:"
#~ msgstr ""

#~ msgid ""
#~ "Optional: add a manual-index.md file in klipper-translations repository's "
#~ "`docs\\locals\\<lang>` folder to replace the language specific index.md "
#~ "(generated index.md does not render correctly)."
#~ msgstr ""

#~ msgid ""
#~ "Currently, there isn't a method for correctly translating pictures in the "
#~ "documentation"
#~ msgstr ""

#~ msgid ""
#~ "This document describes the protocol Klipper uses to communicate over [CAN "
#~ "bus](https://en.wikipedia.org/wiki/CAN_bus). See <CANBUS.md> for information"
#~ " on configuring Klipper with CAN bus."
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses only CAN 2.0A standard size CAN bus packets, which are limited "
#~ "to 8 data bytes and an 11-bit CAN bus identifier. In order to support "
#~ "efficient communication, each micro-controller is assigned at run-time a "
#~ "unique 1-byte CAN bus nodeid (`canbus_nodeid`) for general Klipper command "
#~ "and response traffic. Klipper command messages going from host to micro-"
#~ "controller use the CAN bus id of `canbus_nodeid * 2 + 256`, while Klipper "
#~ "response messages from micro-controller to host use `canbus_nodeid * 2 + 256"
#~ " + 1`."
#~ msgstr ""

#~ msgid "Admin messages"
#~ msgstr ""

#~ msgid "CMD_QUERY_UNASSIGNED message"
#~ msgstr ""

#~ msgid ""
#~ "The CMD_QUERY_UNASSIGNED message format is: `<1-byte message_id = 0x00>`"
#~ msgstr ""

#~ msgid ""
#~ "This command assigns a `canbus_nodeid` to the micro-controller with a given "
#~ "`canbus_uuid`."
#~ msgstr ""

#~ msgid "RESP_NEED_NODEID message"
#~ msgstr ""

#~ msgid "Data Packets"
#~ msgstr ""

#~ msgid ""
#~ "The packet data in messages using the node's receive CAN bus id "
#~ "(`canbus_nodeid * 2 + 256`) are simply appended to a buffer, and when a "
#~ "complete [mcu protocol message](Protocol.md) is found its contents are "
#~ "parsed and processed. The data is treated as a byte stream - there is no "
#~ "requirement for the start of a Klipper message block to align with the start"
#~ " of a CAN bus packet."
#~ msgstr ""

#~ msgid "This document describes Klipper's CAN bus support."
#~ msgstr ""

#~ msgid ""
#~ "Klipper currently supports CAN on stm32, same5x, and rp2040 chips. In "
#~ "addition, the micro-controller chip must be on a board that has a CAN "
#~ "transceiver."
#~ msgstr ""

#~ msgid "Host Hardware"
#~ msgstr ""

#~ msgid ""
#~ "Use a [Waveshare Raspberry Pi CAN hat](https://www.waveshare.com/rs485-can-"
#~ "hat.htm) or one of its many clones."
#~ msgstr ""

#~ msgid ""
#~ "It is also necessary to configure the host operating system to use the "
#~ "adapter. This is typically done by creating a new file named "
#~ "`/etc/network/interfaces.d/can0` with the following contents:"
#~ msgstr ""

#~ msgid ""
#~ "Note that the \"Raspberry Pi CAN hat\" also requires [changes to "
#~ "config.txt](https://www.waveshare.com/wiki/RS485_CAN_HAT)."
#~ msgstr ""

#~ msgid ""
#~ "A CAN bus should have two 120 ohm resistors between the CANH and CANL wires."
#~ " Ideally, one resistor located at each the end of the bus."
#~ msgstr ""

#~ msgid ""
#~ "To test that the resistors are correct, one can remove power to the printer "
#~ "and use a multi-meter to check the resistance between the CANH and CANL "
#~ "wires - it should report ~60 ohms on a correctly wired CAN bus."
#~ msgstr ""

#~ msgid ""
#~ "Each micro-controller on the CAN bus is assigned a unique id based on the "
#~ "factory chip identifier encoded into each micro-controller. To find each "
#~ "micro-controller device id, make sure the hardware is powered and wired "
#~ "correctly, and then run:"
#~ msgstr ""

#~ msgid ""
#~ "If uninitialized CAN devices are detected the above command will report "
#~ "lines like the following:"
#~ msgstr ""

#~ msgid ""
#~ "Each device will have a unique identifier. In the above example, "
#~ "`11aa22bb33cc` is the micro-controller's \"canbus_uuid\"."
#~ msgstr ""

#~ msgid ""
#~ "Update the Klipper [mcu configuration](Config_Reference.md#mcu) to use the "
#~ "CAN bus to communicate with the device - for example:"
#~ msgstr ""

#~ msgid "USB to CAN bus bridge mode"
#~ msgstr ""

#~ msgid ""
#~ "When Klipper uses this mode the micro-controller appears as a \"USB CAN bus "
#~ "adapter\" under Linux. The \"Klipper bridge mcu\" itself will appear as if "
#~ "was on this CAN bus - it can be identified via `canbus_query.py` and "
#~ "configured like other CAN bus Klipper nodes. It will appear alongside other "
#~ "devices that are actually on the CAN bus."
#~ msgstr ""

#~ msgid ""
#~ "The \"bridge mcu\" is not actually on the CAN bus. Messages to and from it "
#~ "do not consume bandwidth on the CAN bus. The mcu can not be seen by other "
#~ "adapters that may be on the CAN bus."
#~ msgstr ""

#~ msgid ""
#~ "Whenever the \"bridge mcu\" is reset, Linux will disable the corresponding "
#~ "`can0` interface. To ensure proper handling of FIRMWARE_RESTART and RESTART "
#~ "commands, it is recommended to replace `auto` with `allow-hotplug` in the "
#~ "`/etc/network/interfaces.d/can0` file. For example:"
#~ msgstr ""

#~ msgid ""
#~ "This document provides information on common bootloaders found on micro-"
#~ "controllers that Klipper supports."
#~ msgstr ""

#~ msgid ""
#~ "If one can flash a bootloader to a micro-controller then one can generally "
#~ "also use that mechanism to flash an application, but care should be taken "
#~ "when doing this as one may inadvertently remove the bootloader. In contrast,"
#~ " a bootloader will generally only permit a user to flash an application. It "
#~ "is therefore recommended to use a bootloader to flash an application where "
#~ "possible."
#~ msgstr ""

#~ msgid "AVR micro-controllers"
#~ msgstr ""

#~ msgid ""
#~ "To flash a bootloader itself, the AVR chips require an external hardware "
#~ "flashing tool (which communicates with the chip using SPI). This tool can be"
#~ " purchased (for example, do a web search for \"avr isp\", \"arduino isp\", "
#~ "or \"usb tiny isp\"). It is also possible to use another Arduino or "
#~ "Raspberry Pi to flash an AVR bootloader (for example, do a web search for "
#~ "\"program an avr using raspberry pi\"). The examples below are written "
#~ "assuming an \"AVR ISP Mk2\" type device is in use."
#~ msgstr ""

#~ msgid "Atmega2560"
#~ msgstr ""

#~ msgid "To flash the bootloader itself use something like:"
#~ msgstr ""

#~ msgid "To flash an application use something like:"
#~ msgstr ""

#~ msgid "Atmega1280"
#~ msgstr ""

#~ msgid ""
#~ "wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/atmega/ATmegaBOOT_168_atmega1280.hex'\n"
#~ "\n"
#~ "avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xF5:m -U hfuse:w:0xDA:m -U lfuse:w:0xFF:m\n"
#~ "avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U flash:w:ATmegaBOOT_168_atmega1280.hex\n"
#~ "avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
#~ msgstr ""

#~ msgid "Atmega1284p"
#~ msgstr ""

#~ msgid ""
#~ "wget 'https://github.com/Lauszus/Sanguino/raw/1.0.2/bootloaders/optiboot/optiboot_atmega1284p.hex'\n"
#~ "\n"
#~ "avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xDE:m -U lfuse:w:0xFF:m\n"
#~ "avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega1284p.hex\n"
#~ "avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
#~ msgstr ""

#~ msgid ""
#~ "Note that a number of \"Melzi\" style boards come preloaded with a "
#~ "bootloader that uses a baud rate of 57600. In this case, to flash an "
#~ "application use something like this instead:"
#~ msgstr ""

#~ msgid "At90usb1286"
#~ msgstr ""

#~ msgid ""
#~ "The Teensy++ device from pjrc.com comes with a proprietary bootloader. It "
#~ "requires a custom flashing tool from "
#~ "<https://github.com/PaulStoffregen/teensy_loader_cli>. One can flash an "
#~ "application with it using something like:"
#~ msgstr ""

#~ msgid "Atmega168"
#~ msgstr ""

#~ msgid ""
#~ "wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/optiboot/optiboot_atmega168.hex'\n"
#~ "\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0x04:m -U hfuse:w:0xDD:m -U lfuse:w:0xFF:m\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega168.hex\n"
#~ "avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
#~ msgstr ""

#~ msgid ""
#~ "avrdude -carduino -patmega168 -P/dev/ttyACM0 -b115200 -D "
#~ "-Uflash:w:out/klipper.elf.hex:i\n"
#~ msgstr ""

#~ msgid ""
#~ "It is not common to use a bootloader with the SAM3 mcu. The chip itself has "
#~ "a ROM that allows the flash to be programmed from 3.3V serial port or from "
#~ "USB."
#~ msgstr ""

#~ msgid ""
#~ "The code at <https://github.com/shumatech/BOSSA> can be used to program the "
#~ "SAM3. It is recommended to use version 1.9 or later."
#~ msgstr ""

#~ msgid "SAM4 micro-controllers (Duet Wifi)"
#~ msgstr ""

#~ msgid ""
#~ "To enable the ROM, the \"erase\" pin is held high during a reset, which "
#~ "erases the flash contents, and causes the ROM to run."
#~ msgstr ""

#~ msgid "bossac --port=/dev/ttyACM0 -b -U -e -w -v -R out/klipper.bin\n"
#~ msgstr ""

#~ msgid ""
#~ "The SAMD21 bootloader is flashed via the ARM Serial Wire Debug (SWD) "
#~ "interface. This is commonly done with a dedicated SWD hardware dongle. "
#~ "Alternatively, one can use a [Raspberry Pi with OpenOCD](#running-openocd-"
#~ "on-the-raspberry-pi)."
#~ msgstr ""

#~ msgid "source [find target/at91samdXX.cfg]\n"
#~ msgstr ""

#~ msgid ""
#~ "wget 'https://github.com/arduino/ArduinoCore-"
#~ "samd/raw/1.8.3/bootloaders/zero/samd21_sam_ba.bin'\n"
#~ msgstr ""

#~ msgid ""
#~ "at91samd bootloader 0\n"
#~ "program samd21_sam_ba.bin verify\n"
#~ msgstr ""

#~ msgid "bossac -U -p /dev/ttyACM0 --offset=0x2000 -w out/klipper.bin -v -b -R\n"
#~ msgstr ""

#~ msgid ""
#~ "avrdude -c stk500v2 -p atmega2560 -P /dev/ttyACM0 -u "
#~ "-Uflash:w:out/klipper.elf.hex:i\n"
#~ msgstr ""

#~ msgid ""
#~ "Like the SAMD21, the SAMD51 bootloader is flashed via the ARM Serial Wire "
#~ "Debug (SWD) interface. To flash a bootloader with [OpenOCD on a Raspberry "
#~ "Pi](#running-openocd-on-the-raspberry-pi) use the following chip config:"
#~ msgstr ""

#~ msgid ""
#~ "Obtain a bootloader - several bootloaders are available from "
#~ "<https://github.com/adafruit/uf2-samdx1/releases/latest>. For example:"
#~ msgstr ""

#~ msgid ""
#~ "at91samd bootloader 0\n"
#~ "program bootloader-itsybitsy_m4-v3.7.0.bin verify\n"
#~ "at91samd bootloader 16384\n"
#~ msgstr ""

#~ msgid "bossac -U -p /dev/ttyACM0 --offset=0x4000 -w out/klipper.bin -v -b -R\n"
#~ msgstr ""

#~ msgid ""
#~ "The STM32F103 devices have a ROM that can flash a bootloader or application "
#~ "via 3.3V serial. Typically one would wire the PA10 (MCU Rx) and PA9 (MCU Tx)"
#~ " pins to a 3.3V UART adapter. To access the ROM, one should connect the "
#~ "\"boot 0\" pin to high and \"boot 1\" pin to low, and then reset the device."
#~ " The \"stm32flash\" package can then be used to flash the device using "
#~ "something like:"
#~ msgstr ""

#~ msgid ""
#~ "Note that if one is using a Raspberry Pi for the 3.3V serial, the stm32flash"
#~ " protocol uses a serial parity mode which the Raspberry Pi's \"mini UART\" "
#~ "does not support. See "
#~ "<https://www.raspberrypi.com/documentation/computers/configuration.html#configuring-"
#~ "uarts> for details on enabling the full uart on the Raspberry Pi GPIO pins."
#~ msgstr ""

#~ msgid "STM32F103 with stm32duino bootloader"
#~ msgstr ""

#~ msgid "This bootloader can be flashed via 3.3V serial with something like:"
#~ msgstr ""

#~ msgid ""
#~ "This bootloader uses 8KiB of flash space (the application must be compiled "
#~ "with a start address of 8KiB). Flash an application with something like:"
#~ msgstr ""

#~ msgid ""
#~ "The bootloader typically runs for only a short period after boot. It may be "
#~ "necessary to time the above command so that it runs while the bootloader is "
#~ "still active (the bootloader will flash a board led while it is running). "
#~ "Alternatively, set the \"boot 0\" pin to low and \"boot 1\" pin to high to "
#~ "stay in the bootloader after a reset."
#~ msgstr ""

#~ msgid ""
#~ "The [HID bootloader](https://github.com/Serasidis/STM32_HID_Bootloader) is a"
#~ " compact, driverless bootloader capable of flashing over USB. Also available"
#~ " is a [fork with builds specific to the SKR Mini E3 "
#~ "1.2](https://github.com/Arksine/STM32_HID_Bootloader/releases/latest)."
#~ msgstr ""

#~ msgid ""
#~ "It is not possible to use stm32flash for the SKR Mini E3 as the boot0 pin is"
#~ " tied directly to ground and not broken out via header pins. It is "
#~ "recommended to use a STLink V2 with STM32Cubeprogrammer to flash the "
#~ "bootloader. If you don't have access to a STLink it is also possible to use "
#~ "a [Raspberry Pi and OpenOCD](#running-openocd-on-the-raspberry-pi) with the "
#~ "following chip config:"
#~ msgstr ""

#~ msgid ""
#~ "If you wish you can make a backup of the current flash with the following "
#~ "command. Note that it may take some time to complete:"
#~ msgstr ""

#~ msgid "finally, you can flash with commands similar to:"
#~ msgstr ""

#~ msgid "NOTES:"
#~ msgstr ""

#~ msgid ""
#~ "Prior flashing the SKR Mini E3 with this bootloader you should be aware that"
#~ " you will no longer be able to update firmware via the sdcard."
#~ msgstr ""

#~ msgid "After which you can release the reset button."
#~ msgstr ""

#~ msgid ""
#~ "The hid-flash program is used to upload a binary to the bootloader. You can "
#~ "install this software with the following commands:"
#~ msgstr ""

#~ msgid "If the bootloader is running you can flash with something like:"
#~ msgstr ""

#~ msgid "alternatively, you can use `make flash` to flash klipper directly:"
#~ msgstr ""

#~ msgid "OR if klipper has been previously flashed:"
#~ msgstr ""

#~ msgid ""
#~ "It may be necessary to manually enter the bootloader, this can be done by "
#~ "setting \"boot 0\" low and \"boot 1\" high. On the SKR Mini E3 \"Boot 1\" is"
#~ " not available, so it may be done by setting pin PA2 low if you flashed "
#~ "\"hid_btt_skr_mini_e3.bin\". This pin is labeld \"TX0\" on the TFT header in"
#~ " the SKR Mini E3's \"PIN\" document. There is a ground pin next to PA2 which"
#~ " you can use to pull PA2 low."
#~ msgstr ""

#~ msgid ""
#~ "The [MSC bootloader](https://github.com/Telekatz/MSC-stm32f103-bootloader) "
#~ "is a driverless bootloader capable of flashing over USB."
#~ msgstr ""

#~ msgid ""
#~ "For STM32F072 boards it is also possible to flash the bootloader over USB "
#~ "(via DFU) with something like:"
#~ msgstr ""

#~ msgid ""
#~ "This bootloader uses 8KiB or 16KiB of flash space, see description of the "
#~ "bootloader (the application must be compiled with with the corresponding "
#~ "starting address)."
#~ msgstr ""

#~ msgid "STM32F103/STM32F0x2 with CanBoot bootloader"
#~ msgstr ""

#~ msgid ""
#~ "It is recommended to use a ST-Link Programmer to flash CanBoot, however it "
#~ "should be possible to flash using `stm32flash` on STM32F103 devices, and "
#~ "`dfu-util` on STM32F042/STM32F072 devices. See the previous sections in this"
#~ " document for instructions on these flashing methods, substituting "
#~ "`canboot.bin` for the file name where appropriate. The CanBoot repo linked "
#~ "above provides instructions for building the bootloader."
#~ msgstr ""

#~ msgid ""
#~ "The `flash_can.py` utility supplied in the `lib/canboot` folder may be used "
#~ "to upload Klipper firmware. The device UUID is necessary to flash. If you do"
#~ " not have a UUID it is possible to query nodes currently running the "
#~ "bootloader:"
#~ msgstr ""

#~ msgid ""
#~ "This will return UUIDs for all connected nodes not currently assigned a "
#~ "UUID. This should include all nodes currently in the bootloader."
#~ msgstr ""

#~ msgid ""
#~ "python3 flash_can.py -i can0 -f ~/klipper/out/klipper.bin -u aabbccddeeff\n"
#~ msgstr ""

#~ msgid ""
#~ "When building Klipper for use with CanBoot, select the 8 KiB Bootloader "
#~ "option."
#~ msgstr ""

#~ msgid ""
#~ "STM32F4 microcontrollers come equipped with a built-in system bootloader "
#~ "capable of flashing over USB (via DFU), 3.3v Serial, and various other "
#~ "methods (see STM Document AN2606 for more information). Some STM32F4 boards,"
#~ " such as the SKR Pro 1.1, are not able to enter the DFU bootloader. The HID "
#~ "bootloader is available for STM32F405/407 based boards should the user "
#~ "prefer flashing over USB over using the sdcard. Note that you may need to "
#~ "configure and build a version specific to your board, a [build for the SKR "
#~ "Pro 1.1 is available "
#~ "here](https://github.com/Arksine/STM32_HID_Bootloader/releases/latest)."
#~ msgstr ""

#~ msgid ""
#~ "wget https://github.com/Arksine/STM32_HID_Bootloader/releases/download/v0.5-beta/hid_bootloader_SKR_PRO.bin\n"
#~ "\n"
#~ "stm32flash -w hid_bootloader_SKR_PRO.bin -v -g 0 /dev/ttyAMA0\n"
#~ msgstr ""

#~ msgid ""
#~ "As with the STM32F1, the STM32F4 uses the hid-flash tool to upload binaries "
#~ "to the MCU. See the instructions above for details on how to build and use "
#~ "hid-flash."
#~ msgstr ""

#~ msgid "LPC176x micro-controllers (Smoothieboards)"
#~ msgstr ""

#~ msgid ""
#~ "It is common for Smoothieboards to come with a bootloader from: "
#~ "<https://github.com/triffid/LPC17xx-DFU-Bootloader>. When using this "
#~ "bootloader the application must be compiled with a start address of 16KiB. "
#~ "The easiest way to flash an application with this bootloader is to copy the "
#~ "application file (eg, `out/klipper.bin`) to a file named `firmware.bin` on "
#~ "an SD card, and then to reboot the micro-controller with that SD card."
#~ msgstr ""

#~ msgid ""
#~ "OpenOCD is a software package that can perform low-level chip flashing and "
#~ "debugging. It can use the GPIO pins on a Raspberry Pi to communicate with a "
#~ "variety of ARM chips."
#~ msgstr ""

#~ msgid ""
#~ "Begin by downloading and compiling the software (each step may take several "
#~ "minutes and the \"make\" step may take 30+ minutes):"
#~ msgstr ""

#~ msgid "Configure OpenOCD"
#~ msgstr ""

#~ msgid "nano ~/openocd/openocd.cfg\n"
#~ msgstr ""

#~ msgid ""
#~ "# Uses RPi pins: GPIO25 for SWDCLK, GPIO24 for SWDIO, GPIO18 for nRST\n"
#~ "source [find interface/raspberrypi2-native.cfg]\n"
#~ "bcm2835gpio_swd_nums 25 24\n"
#~ "bcm2835gpio_srst_num 18\n"
#~ "transport select swd\n"
#~ "\n"
#~ "# Use hardware reset wire for chip resets\n"
#~ "reset_config srst_only\n"
#~ "adapter_nsrst_delay 100\n"
#~ "adapter_nsrst_assert_width 100\n"
#~ "\n"
#~ "# Specify the chip type\n"
#~ "source [find target/atsame5x.cfg]\n"
#~ "\n"
#~ "# Set the adapter speed\n"
#~ "adapter_khz 40\n"
#~ "\n"
#~ "# Connect to chip\n"
#~ "init\n"
#~ "targets\n"
#~ "reset halt\n"
#~ msgstr ""

#~ msgid ""
#~ "Poweroff both the the Raspberry Pi and the target chip before wiring! Verify"
#~ " the target chip uses 3.3V prior to connecting to a Raspberry Pi!"
#~ msgstr ""

#~ msgid "Then power up the Raspberry Pi and provide power to the target chip."
#~ msgstr ""

#~ msgid "Run OpenOCD:"
#~ msgstr ""

#~ msgid ""
#~ "The above should cause OpenOCD to emit some text messages and then wait (it "
#~ "should not immediately return to the Unix shell prompt). If OpenOCD exits on"
#~ " its own or if it continues to emit text messages then double check the "
#~ "wiring."
#~ msgstr ""

#~ msgid "telnet 127.0.0.1 4444\n"
#~ msgstr ""

#~ msgid "OpenOCD and gdb"
#~ msgstr ""

#~ msgid "Add the following to the OpenOCD config file:"
#~ msgstr ""

#~ msgid ""
#~ "Restart OpenOCD on the Raspberry Pi and then run the following Unix command "
#~ "on the desktop machine:"
#~ msgstr ""

#~ msgid "Within gdb run:"
#~ msgstr ""

#~ msgid ""
#~ "(Replace \"octopi\" with the host name of the Raspberry Pi.) Once gdb is "
#~ "running it is possible to set breakpoints and to inspect registers."
#~ msgstr ""

#~ msgid "This document describes Klipper benchmarks."
#~ msgstr ""

#~ msgid ""
#~ "This section describes the mechanism used to generate the Klipper micro-"
#~ "controller step rate benchmarks."
#~ msgstr ""

#~ msgid ""
#~ "The step rate benchmark is designed to find the maximum stepping rate that "
#~ "the hardware and software can reach. This benchmark stepping rate is not "
#~ "achievable in day-to-day use as Klipper needs to perform other tasks (eg, "
#~ "mcu/host communication, temperature reading, endstop checking) in any real-"
#~ "world usage."
#~ msgstr ""

#~ msgid "Step rate benchmark test"
#~ msgstr ""

#~ msgid ""
#~ "SET start_clock {clock+freq}\n"
#~ "SET ticks 1000\n"
#~ "\n"
#~ "reset_step_clock oid=0 clock={start_clock}\n"
#~ "set_next_step_dir oid=0 dir=0\n"
#~ "queue_step oid=0 interval={ticks} count=60000 add=0\n"
#~ "set_next_step_dir oid=0 dir=1\n"
#~ "queue_step oid=0 interval=3000 count=1 add=0\n"
#~ "\n"
#~ "reset_step_clock oid=1 clock={start_clock}\n"
#~ "set_next_step_dir oid=1 dir=0\n"
#~ "queue_step oid=1 interval={ticks} count=60000 add=0\n"
#~ "set_next_step_dir oid=1 dir=1\n"
#~ "queue_step oid=1 interval=3000 count=1 add=0\n"
#~ "\n"
#~ "reset_step_clock oid=2 clock={start_clock}\n"
#~ "set_next_step_dir oid=2 dir=0\n"
#~ "queue_step oid=2 interval={ticks} count=60000 add=0\n"
#~ "set_next_step_dir oid=2 dir=1\n"
#~ "queue_step oid=2 interval=3000 count=1 add=0\n"
#~ msgstr ""

#~ msgid ""
#~ "On a failure, one can copy-and-paste the following to clear the error in "
#~ "preparation for the next test:"
#~ msgstr ""

#~ msgid ""
#~ "To obtain the single stepper benchmarks, the same configuration sequence is "
#~ "used, but only the first block of the above test is cut-and-paste into the "
#~ "console.py window."
#~ msgstr ""

#~ msgid "ECHO Test result is: {\"%.0fK\" % (3. * freq / ticks / 1000.)}\n"
#~ msgstr ""

#~ msgid "AVR step rate benchmark"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PA5 dir_pin=PA4 invert_step=0 step_pulse_ticks=32\n"
#~ "config_stepper oid=1 step_pin=PA3 dir_pin=PA2 invert_step=0 step_pulse_ticks=32\n"
#~ "config_stepper oid=2 step_pin=PC7 dir_pin=PC6 invert_step=0 step_pulse_ticks=32\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid "avr"
#~ msgstr ""

#~ msgid "1 stepper"
#~ msgstr ""

#~ msgid "3 stepper"
#~ msgstr ""

#~ msgid "Arduino Due step rate benchmark"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PB27 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=PB26 dir_pin=PC30 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=PA21 dir_pin=PC30 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid "sam3x8e"
#~ msgstr ""

#~ msgid "257"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the Duet Maestro:"
#~ msgstr ""

#~ msgid "sam4s8c"
#~ msgstr ""

#~ msgid "260"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the Duet Wifi:"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `59314d99` with gcc version `gcc version "
#~ "10.3.1 20210621 (release) (GNU Arm Embedded Toolchain 10.3-2021.07)`."
#~ msgstr ""

#~ msgid "48"
#~ msgstr ""

#~ msgid "Beaglebone PRU step rate benchmark"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=gpio0_23 dir_pin=gpio1_12 invert_step=0 step_pulse_ticks=20\n"
#~ "config_stepper oid=1 step_pin=gpio1_15 dir_pin=gpio0_26 invert_step=0 step_pulse_ticks=20\n"
#~ "config_stepper oid=2 step_pin=gpio0_22 dir_pin=gpio2_1 invert_step=0 step_pulse_ticks=20\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid "pru"
#~ msgstr ""

#~ msgid "847"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the STM32F042:"
#~ msgstr ""

#~ msgid "stm32f042"
#~ msgstr ""

#~ msgid "249"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the STM32F103:"
#~ msgstr ""

#~ msgid "stm32f103"
#~ msgstr ""

#~ msgid "264"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the STM32F4:"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `59314d99` with gcc version `arm-none-eabi-"
#~ "gcc (Fedora 10.2.0-4.fc34) 10.2.0`. The STM32F407 results were obtained by "
#~ "running an STM32F407 binary on an STM32F446 (and thus using a 168Mhz clock)."
#~ msgstr ""

#~ msgid "46"
#~ msgstr ""

#~ msgid "stm32f407"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on a STM32H743VIT6:"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `00191b5c` with gcc version `arm-none-eabi-"
#~ "gcc (15:8-2019-q3-1+b1) 8.3.1 20190703 (release) [gcc-8-branch revision "
#~ "273027]`."
#~ msgstr ""

#~ msgid "44"
#~ msgstr ""

#~ msgid "STM32G0B1 step rate benchmark"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PB13 dir_pin=PB12 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=PB10 dir_pin=PB2 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=PB0 dir_pin=PC5 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid "stm32g0b1"
#~ msgstr ""

#~ msgid "243"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the LPC176x:"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `59314d99` with gcc version `arm-none-eabi-"
#~ "gcc (Fedora 10.2.0-4.fc34) 10.2.0`. The 120Mhz LPC1769 results were obtained"
#~ " by overclocking an LPC1768 to 120Mhz."
#~ msgstr ""

#~ msgid "52"
#~ msgstr ""

#~ msgid "lpc1769"
#~ msgstr ""

#~ msgid "SAMD21 step rate benchmark"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=PA27 dir_pin=PA20 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=PB3 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=PA17 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid "samd21"
#~ msgstr ""

#~ msgid "306"
#~ msgstr ""

#~ msgid "The following configuration sequence is used on the SAMD51:"
#~ msgstr ""

#~ msgid ""
#~ "The test was last run on commit `59314d99` with gcc version `arm-none-eabi-"
#~ "gcc (Fedora 10.2.0-4.fc34) 10.2.0` on a SAMD51J19A micro-controller."
#~ msgstr ""

#~ msgid "191"
#~ msgstr ""

#~ msgid "3 stepper (200Mhz)"
#~ msgstr ""

#~ msgid "RP2040 step rate benchmark"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=gpio25 dir_pin=gpio3 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=1 step_pin=gpio26 dir_pin=gpio4 invert_step=-1 step_pulse_ticks=0\n"
#~ "config_stepper oid=2 step_pin=gpio27 dir_pin=gpio5 invert_step=-1 step_pulse_ticks=0\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid "rp2040"
#~ msgstr ""

#~ msgid "Linux MCU step rate benchmark"
#~ msgstr ""

#~ msgid ""
#~ "allocate_oids count=3\n"
#~ "config_stepper oid=0 step_pin=gpio2 dir_pin=gpio3 invert_step=0 step_pulse_ticks=5\n"
#~ "config_stepper oid=1 step_pin=gpio4 dir_pin=gpio5 invert_step=0 step_pulse_ticks=5\n"
#~ "config_stepper oid=2 step_pin=gpio6 dir_pin=gpio17 invert_step=0 step_pulse_ticks=5\n"
#~ "finalize_config crc=0\n"
#~ msgstr ""

#~ msgid "Linux (RPi3)"
#~ msgstr ""

#~ msgid "380"
#~ msgstr ""

#~ msgid ""
#~ "The command dispatch benchmark tests how many \"dummy\" commands the micro-"
#~ "controller can process. It is primarily a test of the hardware communication"
#~ " mechanism. The test is run using the console.py tool (described in "
#~ "<Debugging.md>). The following is cut-and-paste into the console.py terminal"
#~ " window:"
#~ msgstr ""

#~ msgid ""
#~ "When the test completes, determine the difference between the clocks "
#~ "reported in the two \"uptime\" response messages. The total number of "
#~ "commands per second is then `100000 * mcu_frequency / clock_diff`."
#~ msgstr ""

#~ msgid "MCU"
#~ msgstr ""

#~ msgid "Build"
#~ msgstr ""

#~ msgid "stm32f042 (CAN)"
#~ msgstr ""

#~ msgid "c105adc8"
#~ msgstr ""

#~ msgid "atmega2560 (serial)"
#~ msgstr ""

#~ msgid "b161a69e"
#~ msgstr ""

#~ msgid "sam3x8e (serial)"
#~ msgstr ""

#~ msgid "at90usb1286 (USB)"
#~ msgstr ""

#~ msgid "01d2183f"
#~ msgstr ""

#~ msgid "samd21 (USB)"
#~ msgstr ""

#~ msgid "arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0"
#~ msgstr ""

#~ msgid "260K"
#~ msgstr ""

#~ msgid "pru-gcc (GCC) 8.0.0 20170530 (experimental)"
#~ msgstr ""

#~ msgid "355K"
#~ msgstr ""

#~ msgid "418K"
#~ msgstr ""

#~ msgid "534K"
#~ msgstr ""

#~ msgid "628K"
#~ msgstr ""

#~ msgid "650K"
#~ msgstr ""

#~ msgid "samd51 (USB)"
#~ msgstr ""

#~ msgid "stm32f446 (USB)"
#~ msgstr ""

#~ msgid "rp2040 (USB)"
#~ msgstr ""

#~ msgid "c5667193"
#~ msgstr ""

#~ msgid "Host Benchmarks"
#~ msgstr ""

#~ msgid ""
#~ "time ~/klippy-env/bin/python ./klippy/klippy.py config/example-cartesian.cfg"
#~ " -i something_complex.gcode -o /dev/null -d out/klipper.dict\n"
#~ msgstr ""

#~ msgid ""
#~ "The Bed Mesh module may be used to compensate for bed surface irregularties "
#~ "to achieve a better first layer across the entire bed. It should be noted "
#~ "that software based correction will not achieve perfect results, it can only"
#~ " approximate the shape of the bed. Bed Mesh also cannot compensate for "
#~ "mechanical and electrical issues. If an axis is skewed or a probe is not "
#~ "accurate then the bed_mesh module will not receive accurate results from the"
#~ " probing process."
#~ msgstr ""

#~ msgid "Basic Configuration"
#~ msgstr ""

#~ msgid ""
#~ "This example assumes a printer with a 250 mm x 220 mm rectangular bed and a "
#~ "probe with an x-offset of 24 mm and y-offset of 5 mm."
#~ msgstr ""

#~ msgid ""
#~ "`speed: 120` *Default Value: 50* The speed in which the tool moves between "
#~ "points."
#~ msgstr ""

#~ msgid ""
#~ "`mesh_min: 35, 6` *Required* The first probed coordinate, nearest to the "
#~ "origin. This coordinate is relative to the probe's location."
#~ msgstr ""

#~ msgid ""
#~ "`probe_count: 5, 3` *Default Value: 3, 3* The number of points to probe on "
#~ "each axis, specified as X, Y integer values. In this example 5 points will "
#~ "be probed along the X axis, with 3 points along the Y axis, for a total of "
#~ "15 probed points. Note that if you wanted a square grid, for example 3x3, "
#~ "this could be specified as a single integer value that is used for both "
#~ "axes, ie `probe_count: 3`. Note that a mesh requires a minimum probe_count "
#~ "of 3 along each axis."
#~ msgstr ""

#~ msgid "![bedmesh_rect_basic](img/bedmesh_rect_basic.svg)"
#~ msgstr ""

#~ msgid ""
#~ "This example assumes a printer equipped with a round bed radius of 100mm. We"
#~ " will use the same probe offsets as the rectangular example, 24 mm on X and "
#~ "5 mm on Y."
#~ msgstr ""

#~ msgid ""
#~ "`mesh_radius: 75` *Required* The radius of the probed mesh in mm, relative "
#~ "to the `mesh_origin`. Note that the probe's offsets limit the size of the "
#~ "mesh radius. In this example, a radius larger than 76 would move the tool "
#~ "beyond the range of the printer."
#~ msgstr ""

#~ msgid ""
#~ "`round_probe_count: 5` *Default Value: 5* This is an integer value that "
#~ "defines the maximum number of probed points along the X and Y axes. By "
#~ "\"maximum\", we mean the number of points probed along the mesh origin. This"
#~ " value must be an odd number, as it is required that the center of the mesh "
#~ "is probed."
#~ msgstr ""

#~ msgid "![bedmesh_round_basic](img/bedmesh_round_basic.svg)"
#~ msgstr ""

#~ msgid ""
#~ "Below the more advanced configuration options are explained in detail. Each "
#~ "example will build upon the basic rectangular bed configuration shown above."
#~ " Each of the advanced options apply to round beds in the same manner."
#~ msgstr ""

#~ msgid ""
#~ "While its possible to sample the probed matrix directly using simple "
#~ "bilinear interpolation to determine the Z-Values between probed points, it "
#~ "is often useful to interpolate extra points using more advanced "
#~ "interpolation algorithms to increase mesh density. These algorithms add "
#~ "curvature to the mesh, attempting to simulate the material properties of the"
#~ " bed. Bed Mesh offers lagrange and bicubic interpolation to accomplish this."
#~ msgstr ""

#~ msgid ""
#~ "`mesh_pps: 2, 3` *Default Value: 2, 2* The `mesh_pps` option is shorthand "
#~ "for Mesh Points Per Segment. This option specifies how many points to "
#~ "interpolate for each segment along the X and Y axes. Consider a 'segment' to"
#~ " be the space between each probed point. Like `probe_count`, `mesh_pps` is "
#~ "specified as an X, Y integer pair, and also may be specified a single "
#~ "integer that is applied to both axes. In this example there are 4 segments "
#~ "along the X axis and 2 segments along the Y axis. This evaluates to 8 "
#~ "interpolated points along X, 6 interpolated points along Y, which results in"
#~ " a 13x8 mesh. Note that if mesh_pps is set to 0 then mesh interpolation is "
#~ "disabled and the probed matrix will be sampled directly."
#~ msgstr ""

#~ msgid ""
#~ "`bicubic_tension: 0.2` *Default Value: 0.2* If the `algorithm` option is set"
#~ " to bicubic it is possible to specify the tension value. The higher the "
#~ "tension the more slope is interpolated. Be careful when adjusting this, as "
#~ "higher values also create more overshoot, which will result in interpolated "
#~ "values higher or lower than your probed points."
#~ msgstr ""

#~ msgid "![bedmesh_interpolated](img/bedmesh_interpolated.svg)"
#~ msgstr ""

#~ msgid ""
#~ "Bed Mesh works by intercepting gcode move commands and applying a transform "
#~ "to their Z coordinate. Long moves must be split into smaller moves to "
#~ "correctly follow the shape of the bed. The options below control the "
#~ "splitting behavior."
#~ msgstr ""

#~ msgid ""
#~ "`move_check_distance: 5` *Default Value: 5* The minimum distance to check "
#~ "for the desired change in Z before performing a split. In this example, a "
#~ "move longer than 5mm will be traversed by the algorithm. Each 5mm a mesh Z "
#~ "lookup will occur, comparing it with the Z value of the previous move. If "
#~ "the delta meets the threshold set by `split_delta_z`, the move will be split"
#~ " and traversal will continue. This process repeats until the end of the move"
#~ " is reached, where a final adjustment will be applied. Moves shorter than "
#~ "the `move_check_distance` have the correct Z adjustment applied directly to "
#~ "the move without traversal or splitting."
#~ msgstr ""

#~ msgid ""
#~ "Generally the default values for these options are sufficient, in fact the "
#~ "default value of 5mm for the `move_check_distance` may be overkill. However "
#~ "an advanced user may wish to experiment with these options in an effort to "
#~ "squeeze out the optimial first layer."
#~ msgstr ""

#~ msgid ""
#~ "When \"fade\" is enabled Z adjustment is phased out over a distance defined "
#~ "by the configuration. This is accomplished by applying small adjustments to "
#~ "the layer height, either increasing or decreasing depending on the shape of "
#~ "the bed. When fade has completed, Z adjustment is no longer applied, "
#~ "allowing the top of the print to be flat rather than mirror the shape of the"
#~ " bed. Fade also may have some undesirable traits, if you fade too quickly it"
#~ " can result in visible artifacts on the print. Also, if your bed is "
#~ "significantly warped, fade can shrink or stretch the Z height of the print. "
#~ "As such, fade is disabled by default."
#~ msgstr ""

#~ msgid ""
#~ "`fade_start: 1` *Default Value: 1* The Z height in which to start phasing "
#~ "out adjustment. It is a good idea to get a few layers down before starting "
#~ "the fade process."
#~ msgstr ""

#~ msgid ""
#~ "`fade_target: 0` *Default Value: The average Z value of the mesh* The "
#~ "`fade_target` can be thought of as an additional Z offset applied to the "
#~ "entire bed after fade completes. Generally speaking we would like this value"
#~ " to be 0, however there are circumstances where it should not be. For "
#~ "example, lets assume your homing position on the bed is an outlier, its .2 "
#~ "mm lower than the average probed height of the bed. If the `fade_target` is "
#~ "0, fade will shrink the print by an average of .2 mm across the bed. By "
#~ "setting the `fade_target` to .2, the homed area will expand by .2 mm, "
#~ "however the rest of the bed will have an accurately sized. Generally its a "
#~ "good idea to leave `fade_target` out of the configuration so the average "
#~ "height of the mesh is used, however it may be desirable to manually adjust "
#~ "the fade target if one wants to print on a specific portion of the bed."
#~ msgstr ""

#~ msgid ""
#~ "Most probes are suceptible to drift, ie: inaccuracies in probing introduced "
#~ "by heat or interference. This can make calculating the probe's z-offset "
#~ "challenging, particuarly at different bed temperatures. As such, some "
#~ "printers use an endstop for homing the Z axis, and a probe for calibrating "
#~ "the mesh. These printers can benefit from configuring the relative reference"
#~ " index."
#~ msgstr ""

#~ msgid ""
#~ "`relative_reference_index: 7` *Default Value: None (disabled)* When the "
#~ "probed points are generated they are each assigned an index. You can look up"
#~ " this index in klippy.log or by using BED_MESH_OUTPUT (see the section on "
#~ "Bed Mesh GCodes below for more information). If you assign an index to the "
#~ "`relative_reference_index` option, the value probed at this coordinate will "
#~ "replace the probe's z_offset. This effectively makes this coordinate the "
#~ "\"zero\" reference for the mesh."
#~ msgstr ""

#~ msgid "Faulty Regions"
#~ msgstr ""

#~ msgid ""
#~ "The `faulty_region` options may be configured to compensate for this affect."
#~ " If a generated point lies within a faulty region bed mesh will attempt to "
#~ "probe up to 4 points at the boundaries of this region. These probed values "
#~ "will be averaged and inserted in the mesh as the Z value at the generated "
#~ "(X, Y) coordinate."
#~ msgstr ""

#~ msgid ""
#~ "`faulty_region_{1...99}_min` `faulty_region_{1..99}_max` *Default Value: "
#~ "None (disabled)* Faulty Regions are defined in a way similar to that of mesh"
#~ " itself, where minimum and maximum (X, Y) coordinates must be specified for "
#~ "each region. A faulty region may extend outside of a mesh, however the "
#~ "alternate points generated will always be within the mesh boundary. No two "
#~ "regions may overlap."
#~ msgstr ""

#~ msgid "![bedmesh_interpolated](img/bedmesh_faulty_regions.svg)"
#~ msgstr ""

#~ msgid "Calibration"
#~ msgstr ""

#~ msgid "Initiates the probing procedure for Bed Mesh Calibration."
#~ msgstr ""

#~ msgid ""
#~ "It is possible to specify mesh parameters to modify the probed area. The "
#~ "following parameters are available:"
#~ msgstr ""

#~ msgid "`MESH_MIN`"
#~ msgstr ""

#~ msgid "`PROBE_COUNT`"
#~ msgstr ""

#~ msgid "`MESH_RADIUS`"
#~ msgstr ""

#~ msgid "`ROUND_PROBE_COUNT`"
#~ msgstr ""

#~ msgid "`RELATIVE_REFERNCE_INDEX`"
#~ msgstr ""

#~ msgid ""
#~ "See the configuration documentation above for details on how each parameter "
#~ "applies to the mesh."
#~ msgstr ""

#~ msgid "`BED_MESH_PROFILE SAVE=<name> LOAD=<name> REMOVE=<name>`"
#~ msgstr ""

#~ msgid "Profiles can be loaded by executing `BED_MESH_PROFILE LOAD=<name>`."
#~ msgstr ""

#~ msgid "`BED_MESH_PROFILE REMOVE=default`"
#~ msgstr ""

#~ msgid "Output"
#~ msgstr ""

#~ msgid ""
#~ "Outputs the current mesh state to the terminal. Note that the mesh itself is"
#~ " output"
#~ msgstr ""

#~ msgid ""
#~ "// bed_mesh: generated points\n"
#~ "// Index | Tool Adjusted | Probe\n"
#~ "// 0 | (11.0, 1.0) | (35.0, 6.0)\n"
#~ "// 1 | (62.2, 1.0) | (86.2, 6.0)\n"
#~ "// 2 | (113.5, 1.0) | (137.5, 6.0)\n"
#~ "// 3 | (164.8, 1.0) | (188.8, 6.0)\n"
#~ "// 4 | (216.0, 1.0) | (240.0, 6.0)\n"
#~ "// 5 | (216.0, 97.0) | (240.0, 102.0)\n"
#~ "// 6 | (164.8, 97.0) | (188.8, 102.0)\n"
#~ "// 7 | (113.5, 97.0) | (137.5, 102.0)\n"
#~ "// 8 | (62.2, 97.0) | (86.2, 102.0)\n"
#~ "// 9 | (11.0, 97.0) | (35.0, 102.0)\n"
#~ "// 10 | (11.0, 193.0) | (35.0, 198.0)\n"
#~ "// 11 | (62.2, 193.0) | (86.2, 198.0)\n"
#~ "// 12 | (113.5, 193.0) | (137.5, 198.0)\n"
#~ "// 13 | (164.8, 193.0) | (188.8, 198.0)\n"
#~ "// 14 | (216.0, 193.0) | (240.0, 198.0)\n"
#~ msgstr ""

#~ msgid "Clear Mesh State"
#~ msgstr ""

#~ msgid "This gcode may be used to clear the internal mesh state."
#~ msgstr ""

#~ msgid "`BED_MESH_OFFSET [X=<value>] [Y=<value>]`"
#~ msgstr ""

#~ msgid ""
#~ "Bed leveling (sometimes also referred to as \"bed tramming\") is critical to"
#~ " getting high quality prints. If a bed is not properly \"leveled\" it can "
#~ "lead to poor bed adhesion, \"warping\", and subtle problems throughout the "
#~ "print. This document serves as a guide to performing bed leveling in "
#~ "Klipper."
#~ msgstr ""

#~ msgid ""
#~ "In order to get good quality prints the printer should be calibrated so that"
#~ " Z distances are accurate to within about 25 microns (.025mm). This is a "
#~ "small distance - significantly smaller than the width of a typical human "
#~ "hair. This scale can not be measured \"by eye\". Subtle effects (such as "
#~ "heat expansion) impact measurements at this scale. The secret to getting "
#~ "high accuracy is to use a repeatable process and to use a leveling method "
#~ "that leverages the high accuracy of the printer's own motion system."
#~ msgstr ""

#~ msgid ""
#~ "Different types of printers use different methods for performing bed "
#~ "leveling. All of them ultimately depend on the \"paper test\" (described "
#~ "below). However, the actual process for a particular type of printer is "
#~ "described in other documents."
#~ msgstr ""

#~ msgid ""
#~ "For printers with an \"automatic Z probe\" be sure to calibrate the probe "
#~ "following the directions in the [Probe Calibrate](Probe_Calibrate.md) "
#~ "document. For delta printers, see the [Delta Calibrate](Delta_Calibrate.md) "
#~ "document. For printers with bed screws and traditional Z endstops, see the "
#~ "[Manual Level](Manual_Level.md) document."
#~ msgstr ""

#~ msgid "The \"paper test\""
#~ msgstr ""

#~ msgid ""
#~ "It is important to understand the \"paper test\" even if one has an "
#~ "\"automatic Z probe\". The probe itself often needs to be calibrated to get "
#~ "good results. That probe calibration is done using this \"paper test\"."
#~ msgstr ""

#~ msgid ""
#~ "The first step of the paper test is to inspect the printer's nozzle and bed."
#~ " Make sure there is no plastic (or other debris) on the nozzle or bed."
#~ msgstr ""

#~ msgid ""
#~ "If one always prints on a particular tape or printing surface then one may "
#~ "perform the paper test with that tape/surface in place. However, note that "
#~ "tape itself has a thickness and different tapes (or any other printing "
#~ "surface) will impact Z measurements. Be sure to rerun the paper test to "
#~ "measure each type of surface that is in use."
#~ msgstr ""

#~ msgid ""
#~ "**Always perform the paper test when both nozzle and bed are at room "
#~ "temperature!**"
#~ msgstr ""

#~ msgid ""
#~ "It may seem odd to calibrate the distance at room temperature when the goal "
#~ "is to have a consistent distance when heated. However, if one calibrates "
#~ "when the nozzle is heated, it tends to impart small amounts of molten "
#~ "plastic on to the paper, which changes the amount of friction felt. That "
#~ "makes it harder to get a good calibration. Calibrating while the bed/nozzle "
#~ "is hot also greatly increases the risk of burning oneself. The amount of "
#~ "thermal expansion is stable, so it is easily accounted for later in the "
#~ "calibration process."
#~ msgstr ""

#~ msgid ""
#~ "Klipper has several helper scripts available (eg, MANUAL_PROBE, "
#~ "Z_ENDSTOP_CALIBRATE, PROBE_CALIBRATE, DELTA_CALIBRATE). See the documents "
#~ "[described above](#choose-the-appropriate-calibration-mechanism) to choose "
#~ "one of them."
#~ msgstr ""

#~ msgid ""
#~ "Recv: // Starting manual Z probe. Use TESTZ to adjust position.\n"
#~ "Recv: // Finish with ACCEPT or ABORT command.\n"
#~ "Recv: // Z position: ?????? --> 5.000 <-- ??????\n"
#~ msgstr ""

#~ msgid ""
#~ "Place the paper between the nozzle and bed. It can be useful to fold a "
#~ "corner of the paper so that it is easier to grab. (Try not to push down on "
#~ "the bed when moving the paper back and forth.)"
#~ msgstr ""

#~ msgid ""
#~ "Use the TESTZ command to request the nozzle to move closer to the paper. For"
#~ " example:"
#~ msgstr ""

#~ msgid ""
#~ "The TESTZ command will move the nozzle a relative distance from the nozzle's"
#~ " current position. (So, `Z=-.1` requests the nozzle to move closer to the "
#~ "bed by .1mm.) After the nozzle stops moving, push the paper back and forth "
#~ "to check if the nozzle is in contact with the paper and to feel the amount "
#~ "of friction. Continue issuing TESTZ commands until one feels a small amount "
#~ "of friction when testing with the paper."
#~ msgstr ""

#~ msgid "Recv: // Z position: 0.130 --> 0.230 <-- 0.280\n"
#~ msgstr ""

#~ msgid "After finding a small amount of friction run the ACCEPT command:"
#~ msgstr ""

#~ msgid ""
#~ "This will accept the given Z height and proceed with the given calibration "
#~ "tool."
#~ msgstr ""

#~ msgid ""
#~ "If something goes wrong during the test, one can use the `ABORT` command to "
#~ "exit the calibration tool."
#~ msgstr ""

#~ msgid ""
#~ "After successfully performing bed leveling, one may go on to calculate a "
#~ "more precise value for the combined impact of \"thermal expansion\", "
#~ "\"thickness of the paper\", and \"amount of friction felt during the paper "
#~ "test\"."
#~ msgstr ""

#~ msgid ""
#~ "The easiest way to make this calculation is to print a test object that has "
#~ "straight walls on all sides. The large hollow square found in "
#~ "[docs/prints/square.stl](prints/square.stl) can be used for this. When "
#~ "slicing the object, make sure the slicer uses the same layer height and "
#~ "extrusion widths for the first level that it does for all subsequent layers."
#~ " Use a coarse layer height (the layer height should be around 75% of the "
#~ "nozzle diameter) and do not use a brim or raft."
#~ msgstr ""

#~ msgid ""
#~ "If the bottom layer consistently appears narrower than subsequent layers "
#~ "then one can use the SET_GCODE_OFFSET command to make a negative Z "
#~ "adjustment. If one is unsure, then one can decrease the Z adjustment until "
#~ "the bottom layer of prints exhibit a small bulge, and then back-off until it"
#~ " disappears."
#~ msgstr ""

#~ msgid ""
#~ "This document describes the process of running Klipper on a Beaglebone PRU."
#~ msgstr ""

#~ msgid ""
#~ "Start by installing the [Debian 9.9 2019-08-03 4GB SD "
#~ "IoT](https://beagleboard.org/latest-images) image. One may run the image "
#~ "from either a micro-SD card or from builtin eMMC. If using the eMMC, install"
#~ " it to eMMC now by following the instructions from the above link."
#~ msgstr ""

#~ msgid ""
#~ "git clone https://github.com/Klipper3d/klipper\n"
#~ "./klipper/scripts/install-beaglebone.sh\n"
#~ msgstr ""

#~ msgid "One may then install Octoprint:"
#~ msgstr ""

#~ msgid "And setup OctoPrint to start at bootup:"
#~ msgstr ""

#~ msgid ""
#~ "It is necessary to modify OctoPrint's **/etc/default/octoprint** "
#~ "configuration file. One must change the `OCTOPRINT_USER` user to `debian`, "
#~ "change `NICELEVEL` to `0`, uncomment the `BASEDIR`, `CONFIGFILE`, and "
#~ "`DAEMON` settings and change the references from `/home/pi/` to "
#~ "`/home/debian/`:"
#~ msgstr ""

#~ msgid "Then start the Octoprint service:"
#~ msgstr ""

#~ msgid ""
#~ "Make sure the OctoPrint web server is accessible - it should be at: "
#~ "<http://beaglebone:5000/>"
#~ msgstr ""

#~ msgid ""
#~ "sudo service klipper stop\n"
#~ "make flash\n"
#~ "sudo service klipper start\n"
#~ msgstr ""

#~ msgid "make menuconfig\n"
#~ msgstr ""

#~ msgid "Connecting BL-Touch"
#~ msgstr ""

#~ msgid ""
#~ "Hook up the BL-Touch \"servo\" connector to a `control_pin` according to the"
#~ " BL-Touch documentation or your MCU documentation. Using the original "
#~ "wiring, the yellow wire from the triple is the `control_pin` and the white "
#~ "wire from the pair is the `sensor_pin`. You need to configure these pins "
#~ "according to your wiring. Most BL-Touch devices require a pullup on the "
#~ "sensor pin (prefix the pin name with \"^\"). For example:"
#~ msgstr ""

#~ msgid ""
#~ "If the BL-Touch will be used to home the Z axis then set `endstop_pin: "
#~ "probe:z_virtual_endstop` and remove `position_endstop` in the `[stepper_z]` "
#~ "config section, then add a `[safe_z_home]` config section to raise the z "
#~ "axis, home the xy axes, move to the center of the bed, and home the z axis. "
#~ "For example:"
#~ msgstr ""

#~ msgid ""
#~ "It's important that the z_hop movement in safe_z_home is high enough that "
#~ "the probe doesn't hit anything even if the probe pin happens to be in its "
#~ "lowest state."
#~ msgstr ""

#~ msgid ""
#~ "Before moving on, verify that the BL-Touch is mounted at the correct height,"
#~ " the pin should be roughly 2 mm above the nozzle when retracted"
#~ msgstr ""

#~ msgid ""
#~ "If the above is looking good, it's time to test that the control pin is "
#~ "working correctly. First run `BLTOUCH_DEBUG COMMAND=pin_down` in your "
#~ "printer terminal. Verify that the pin moves down and that the red LED on the"
#~ " probe turns off. If not, check your wiring and configuration again. Next "
#~ "issue a `BLTOUCH_DEBUG COMMAND=pin_up`, verify that the pin moves up, and "
#~ "that the red light turns on again. If it's flashing then there's some "
#~ "problem."
#~ msgstr ""

#~ msgid ""
#~ "After completing the BL-Touch control pin and sensor pin tests, it is now "
#~ "time to test probing, but with a twist. Instead of letting the probe pin "
#~ "touch the print bed, let it touch the nail on your finger. Position the "
#~ "toolhead far from the bed, issue a `G28` (or `PROBE` if not using "
#~ "probe:z_virtual_endstop), wait until the toolhead starts to move down, and "
#~ "stop the movement by very gently touching the pin with your nail. You may "
#~ "have to do it twice, since the default homing configuration probes twice. Be"
#~ " prepared to turn off the printer if it doesn't stop when you touch the pin."
#~ msgstr ""

#~ msgid "BL-Touch gone bad"
#~ msgstr ""

#~ msgid "BLTOUCH_DEBUG COMMAND=reset"
#~ msgstr ""

#~ msgid ""
#~ "However, the BL-Touch may also not be able to calibrate itself anymore. This"
#~ " happens if the screw on its top is in the wrong position or the magnetic "
#~ "core inside the probe pin has moved. If it has moved up so that it sticks to"
#~ " the screw, it may not be able to lower its pin anymore. With this behavior "
#~ "you need to open the screw and use a ball-point pen to push it gently back "
#~ "into place. Re-Insert the pin into the BL-Touch so that it falls into the "
#~ "extracted position. Carefully readjust the headless screw into place. You "
#~ "need to find the right position so it is able to lower and raise the pin and"
#~ " the red light turns on and of. Use the `reset`, `pin_up` and `pin_down` "
#~ "commands to achieve this."
#~ msgstr ""

#~ msgid ""
#~ "Many BL-Touch \"clone\" devices work correctly with Klipper using the "
#~ "default configuration. However, some \"clone\" devices may not support the "
#~ "`QUERY_PROBE` command and some \"clone\" devices may require configuration "
#~ "of `pin_up_reports_not_triggered` or `pin_up_touch_mode_reports_triggered`."
#~ msgstr ""

#~ msgid ""
#~ "Some \"clone\" devices do not support `touch_mode` and as a result the "
#~ "`QUERY_PROBE` command does not work. Despite this, it may still be possible "
#~ "to perform probing and homing with these devices. On these devices the "
#~ "`QUERY_PROBE` command during the [initial tests](#initial-tests) will not "
#~ "succeed, however the subsequent `G28` (or `PROBE`) test does succeed. It may"
#~ " be possible to use these \"clone\" devices with Klipper if one does not "
#~ "utilize the `QUERY_PROBE` command and one does not enable the "
#~ "`probe_with_touch_mode` feature."
#~ msgstr ""

#~ msgid ""
#~ "A rare number of old \"clone\" devices are unable to report when they have "
#~ "successfully raised their probe. On these devices Klipper will report a "
#~ "\"BLTouch failed to raise probe\" error after every home or probe attempt. "
#~ "One can test for these devices - move the head far from the bed, run "
#~ "`BLTOUCH_DEBUG COMMAND=pin_down`, verify the pin has moved down, run "
#~ "`QUERY_PROBE`, verify that command reports \"probe: open\", run "
#~ "`BLTOUCH_DEBUG COMMAND=pin_up`, verify the pin has moved up, and run "
#~ "`QUERY_PROBE`. If the pin remains up, the device does not enter an error "
#~ "state, and the first query reports \"probe: open\" while the second query "
#~ "reports \"probe: TRIGGERED\" then it indicates that "
#~ "`pin_up_reports_not_triggered` should be set to False in the Klipper config "
#~ "file."
#~ msgstr ""

#~ msgid ""
#~ "Some BL-Touch v3.0 and BL-Touch 3.1 devices may require configuring "
#~ "`probe_with_touch_mode` in the printer config file."
#~ msgstr ""

#~ msgid ""
#~ "The BL-Touch v3.1 may incorrectly enter an error state after a successful "
#~ "probe attempt. The symptoms are an occasional flashing light on the BL-Touch"
#~ " v3.1 that lasts for a couple of seconds after it successfully contacts the "
#~ "bed. Klipper should clear this error automatically and it is generally "
#~ "harmless. However, one may set `probe_with_touch_mode` in the config file to"
#~ " avoid this issue."
#~ msgstr ""

#~ msgid "Multi-probing without stowing"
#~ msgstr ""

#~ msgid ""
#~ "Important! Setting `stow_on_each_sample` to False can lead to Klipper making"
#~ " horizontal toolhead movements while the probe is deployed. Be sure to "
#~ "verify all probing operations have sufficient Z clearance prior to setting "
#~ "this value to False. If there is insufficient clearance then a horizontal "
#~ "move may cause the pin to catch on an obstruction and result in damage to "
#~ "the printer."
#~ msgstr ""

#~ msgid ""
#~ "Note, however, that some \"clone\" devices and the BL-Touch v2.0 (and "
#~ "earlier) may have reduced accuracy when `probe_with_touch_mode` is set to "
#~ "True. On these devices it is a good idea to test the probe accuracy before "
#~ "and after setting `probe_with_touch_mode` (use the `PROBE_ACCURACY` command "
#~ "to test)."
#~ msgstr ""

#~ msgid ""
#~ "Follow the directions in the [Probe Calibrate](Probe_Calibrate.md) guide to "
#~ "set the x_offset, y_offset, and z_offset config parameters."
#~ msgstr ""

#~ msgid "BL-Touch output mode"
#~ msgstr ""

#~ msgid ""
#~ "*** Only use the 5V mode if your controller boards input line is 5V "
#~ "tolerant. This is why the default configuration of these BL-Touch versions "
#~ "is OPEN-DRAIN mode. You could potentially damage your controller boards CPU "
#~ "***"
#~ msgstr ""

#~ msgid ""
#~ "you have a BL-Touch Smart V3.0, you need the use 'set_output_mode: 5V' "
#~ "parameter to ensure this setting at each startup, since the probe cannot "
#~ "remember the needed setting."
#~ msgstr ""

#~ msgid ""
#~ "you have some other probe: Some probes have a trace on the circuit board to "
#~ "cut or a jumper to set in order to (permanently) set the output mode. In "
#~ "that case, omit the 'set_output_mode' parameter completely."
#~ msgstr ""

#~ msgid ""
#~ "This document describes Klipper's Application Programmer Interface (API). "
#~ "This interface enables external applications to query and control the "
#~ "Klipper host software."
#~ msgstr ""

#~ msgid ""
#~ "In order to use the API server, the klippy.py host software must be started "
#~ "with the `-a` parameter. For example:"
#~ msgstr ""

#~ msgid ""
#~ "This causes the host software to create a Unix Domain Socket. A client can "
#~ "then open a connection on that socket and send commands to Klipper."
#~ msgstr ""

#~ msgid "Request format"
#~ msgstr ""

#~ msgid "<json_object_1><0x03><json_object_2><0x03>...\n"
#~ msgstr ""

#~ msgid "~/klipper/scripts/whconsole.py /tmp/klippy_uds\n"
#~ msgstr ""

#~ msgid "API Protocol"
#~ msgstr ""

#~ msgid "A request might look like:"
#~ msgstr ""

#~ msgid "and a response might look like:"
#~ msgstr ""

#~ msgid ""
#~ "Each request must be a JSON dictionary. (This document uses the Python term "
#~ "\"dictionary\" to describe a \"JSON object\" - a mapping of key/value pairs "
#~ "contained within `{}`.)"
#~ msgstr ""

#~ msgid ""
#~ "The request dictionary may contain a \"params\" parameter which must be of a"
#~ " dictionary type. The \"params\" provide additional parameter information to"
#~ " the Klipper \"endpoint\" handling the request. Its content is specific to "
#~ "the \"endpoint\"."
#~ msgstr ""

#~ msgid ""
#~ "If the processing of a request results in an error, then the response "
#~ "message will contain an \"error\" field instead of a \"result\" field. For "
#~ "example, the request: `{\"id\": 123, \"method\": \"gcode/script\", "
#~ "\"params\": {\"script\": \"G1 X200\"}}` might result in an error response "
#~ "such as: `{\"id\": 123, \"error\": {\"message\": \"Must home axis first: "
#~ "200.000 0.000 0.000 [0.000]\", \"error\": \"WebRequestError\"}}`"
#~ msgstr ""

#~ msgid "Subscriptions"
#~ msgstr ""

#~ msgid "For example:"
#~ msgstr ""

#~ msgid "may initially respond with:"
#~ msgstr ""

#~ msgid "and cause Klipper to send future messages similar to:"
#~ msgstr ""

#~ msgid ""
#~ "A subscription request accepts a \"response_template\" dictionary in the "
#~ "\"params\" field of the request. That \"response_template\" dictionary is "
#~ "used as a template for future asynchronous messages - it may contain "
#~ "arbitrary key/value pairs. When sending these future asynchronous messages, "
#~ "Klipper will add a \"params\" field containing a dictionary with "
#~ "\"endpoint\" specific contents to the response template and then send that "
#~ "template. If a \"response_template\" field is not provided then it defaults "
#~ "to an empty dictionary (`{}`)."
#~ msgstr ""

#~ msgid ""
#~ "By convention, Klipper \"endpoints\" are of the form "
#~ "`<module_name>/<some_name>`. When making a request to an \"endpoint\", the "
#~ "full name must be set in the \"method\" parameter of the request dictionary "
#~ "(eg, `{\"method\"=\"gcode/restart\"}`)."
#~ msgstr ""

#~ msgid ""
#~ "The \"info\" endpoint is used to obtain system and version information from "
#~ "Klipper. It is also used to provide the client's version information to "
#~ "Klipper. For example: `{\"id\": 123, \"method\": \"info\", \"params\": { "
#~ "\"client_info\": { \"version\": \"v1\"}}}`"
#~ msgstr ""

#~ msgid "emergency_stop"
#~ msgstr ""

#~ msgid "register_remote_method"
#~ msgstr ""

#~ msgid ""
#~ "For example: `{\"id\": 123, \"method\": \"register_remote_method\", "
#~ "\"params\": {\"response_template\": {\"action\": \"run_paneldue_beep\"}, "
#~ "\"remote_method\": \"paneldue_beep\"}}` will return: `{\"id\": 123, "
#~ "\"result\": {}}`"
#~ msgstr ""

#~ msgid ""
#~ "[gcode_macro PANELDUE_BEEP]\n"
#~ "gcode:\n"
#~ "  {action_call_remote_method(\"paneldue_beep\", frequency=300, duration=1.0)}\n"
#~ msgstr ""

#~ msgid "objects/list"
#~ msgstr ""

#~ msgid "objects/query"
#~ msgstr ""

#~ msgid ""
#~ "The \"objects\" parameter in the request must be a dictionary containing the"
#~ " printer objects that are to be queried - the key contains the printer "
#~ "object name and the value is either \"null\" (to query all fields) or a list"
#~ " of field names."
#~ msgstr ""

#~ msgid ""
#~ "Available fields are documented in the [Status "
#~ "Reference](Status_Reference.md) document."
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows one to query and then subscribe to information from "
#~ "printer objects. The endpoint request and response is identical to the "
#~ "\"objects/query\" endpoint. For example: `{\"id\": 123, \"method\": "
#~ "\"objects/subscribe\", \"params\": {\"objects\":{\"toolhead\": "
#~ "[\"position\"], \"webhooks\": [\"state\"]}, \"response_template\":{}}}` "
#~ "might return: `{\"id\": 123, \"result\": {\"status\": {\"webhooks\": "
#~ "{\"state\": \"ready\"}, \"toolhead\": {\"position\": [0.0, 0.0, 0.0, 0.0]}},"
#~ " \"eventtime\": 3052153.382083195}}` and result in subsequent asynchronous "
#~ "messages such as: `{\"params\": {\"status\": {\"webhooks\": {\"state\": "
#~ "\"shutdown\"}}, \"eventtime\": 3052165.418815847}}`"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows one to query available G-Code commands that have a help"
#~ " string defined. For example: `{\"id\": 123, \"method\": \"gcode/help\"}` "
#~ "might return: `{\"id\": 123, \"result\": {\"RESTORE_GCODE_STATE\": \"Restore"
#~ " a previously saved G-Code state\", \"PID_CALIBRATE\": \"Run PID calibration"
#~ " test\", \"QUERY_ADC\": \"Report the last value of an analog pin\", ...}}`"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows one to run a series of G-Code commands. For example: "
#~ "`{\"id\": 123, \"method\": \"gcode/script\", \"params\": {\"script\": "
#~ "\"G90\"}}`"
#~ msgstr ""

#~ msgid ""
#~ "If there is a G-Code command being processed when this request is received, "
#~ "then the provided script will be queued. This delay could be significant "
#~ "(eg, if a G-Code wait for temperature command is running). The JSON response"
#~ " message is sent when the processing of the script fully completes."
#~ msgstr ""

#~ msgid ""
#~ "This endpoint allows one to request a restart - it is similar to running the"
#~ " G-Code \"RESTART\" command. For example: `{\"id\": 123, \"method\": "
#~ "\"gcode/restart\"}`"
#~ msgstr ""

#~ msgid "gcode/firmware_restart"
#~ msgstr ""

#~ msgid "gcode/subscribe_output"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint is intended to support human interaction via a \"terminal "
#~ "window\" interface. Parsing content from the G-Code terminal output is "
#~ "discouraged. Use the \"objects/subscribe\" endpoint to obtain updates on "
#~ "Klipper's state."
#~ msgstr ""

#~ msgid ""
#~ "This endpoint is used to subscribe to Klipper's internal stepper queue_step "
#~ "command stream for a stepper. Obtaining these low-level motion updates may "
#~ "be useful for diagnostic and debugging purposes. Using this endpoint may "
#~ "increase Klipper's system load."
#~ msgstr ""

#~ msgid ""
#~ "The \"header\" field in the initial query response is used to describe the "
#~ "fields found in later \"data\" responses."
#~ msgstr ""

#~ msgid ""
#~ "This endpoint is used to subscribe to Klipper's internal \"trapezoid motion "
#~ "queue\". Obtaining these low-level motion updates may be useful for "
#~ "diagnostic and debugging purposes. Using this endpoint may increase "
#~ "Klipper's system load."
#~ msgstr ""

#~ msgid "adxl345/dump_adxl345"
#~ msgstr ""

#~ msgid ""
#~ "A request may look like: `{\"id\": 123, \"method\":\"adxl345/dump_adxl345\","
#~ " \"params\": {\"sensor\": \"adxl345\", \"response_template\": {}}}` and "
#~ "might return: `{\"id\": "
#~ "123,\"result\":{\"header\":[\"time\",\"x_acceleration\",\"y_acceleration\", "
#~ "\"z_acceleration\"]}}` and might later produce asynchronous messages such "
#~ "as: "
#~ "`{\"params\":{\"overflows\":0,\"data\":[[3292.432935,-535.44309,-1529.8374,9561.4],"
#~ " [3292.433256,-382.45935,-1606.32927,9561.48375]]}}`"
#~ msgstr ""

#~ msgid ""
#~ "This endpoint is used to subscribe to [angle sensor "
#~ "data](Config_Reference.md#angle). Obtaining these low-level motion updates "
#~ "may be useful for diagnostic and debugging purposes. Using this endpoint may"
#~ " increase Klipper's system load."
#~ msgstr ""

#~ msgid "pause_resume/cancel"
#~ msgstr ""

#~ msgid "pause_resume/pause"
#~ msgstr ""

#~ msgid "pause_resume/resume"
#~ msgstr ""

#~ msgid "query_endstops/status"
#~ msgstr ""
