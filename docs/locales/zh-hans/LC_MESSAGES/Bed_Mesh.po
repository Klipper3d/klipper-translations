# badpoi <a1635835119@gmail.com>, 2021.
# Yifei Ding <dingyifeiair@gmail.com>, 2021.
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"POT-Creation-Date: 2021-06-28 08:28+0200\n"
"PO-Revision-Date: 2021-11-06 17:57+0000\n"
"Last-Translator: Yifei Ding <dingyifeiair@gmail.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/"
"klipper/bed_mesh/zh_Hans/>\n"
"Language: zh-hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.9-dev\n"

msgid ""
"The Bed Mesh module may be used to compensate for bed surface irregularties "
"to achieve a better first layer across the entire bed. It should be noted "
"that software based correction will not achieve perfect results, it can only "
"approximate the shape of the bed. Bed Mesh also cannot compensate for "
"mechanical and electrical issues. If an axis is skewed or a probe is not "
"accurate then the bed_mesh module will not receive accurate results from the "
"probing process."
msgstr ""
"网床 插件可用于补偿热床表面的不规则性，以保证在打印过程中获得更好的第一层。 "
"需要注意的是，基于软件的校正还不能达到完美的程度，它只能尽可能达到床的形状。"
"网床 也无法补偿机械和电气导致的问题。 如果机器没装好结构歪了或探针不准确，则 "
"网床 模块将无法从探测过程中获得令人满意的结果。"

msgid ""
"Prior to Mesh Calibration you will need to be sure that your Probe's Z-"
"Offset is calibrated. If using an endstop for Z homing it will need to be "
"calibrated as well. See [Probe_Calibrate](Probe_Calibrate.md) and "
"Z_ENDSTOP_CALIBRATE in [Manual_Level](Manual_Level.md) for more information."
msgstr ""
"在进行网格校准之前，请确保您已经校准了探头的 Z 偏移。 如果使用限位开关进行 Z "
"归位，则还需要对其进行校准。 有关详细信息，请参阅 [手动调平](Manual_Level."
"md) 中的 [探针校准](Probe_Calibrate.md) 和 Z_ENDSTOP_CALIBRATE。"

msgid "Basic Configuration"
msgstr "基本配置"

msgid "Rectangular Beds"
msgstr "矩形床"

msgid ""
"This example assumes a printer with a 250 mm x 220 mm rectangular bed and a "
"probe with an x-offset of 24 mm and y-offset of 5 mm."
msgstr ""
"此示例假定打印机具有 250 mm x 220 mm 矩形床和一个 x 偏移为 24 mm和 y 偏移为 "
"5 mm的探针。"

msgid ""
"`speed: 120` *Default Value: 50* The speed in which the tool moves between "
"points."
msgstr "`speed: 120` *默认值：50* 探针在两个点之间移动的速度。"

msgid ""
"`horizontal_move_z: 5` *Default Value: 5* The Z coordinate the probe rises "
"to prior to traveling between points."
msgstr ""
"`horizontal_move_z: 5` *默认值：5* 探针前往下一个点之前Z需要抬升的高度。"

msgid ""
"`mesh_min: 35,6` *Required* The first probed coordinate, nearest to the "
"origin. This coordinate is relative to the probe's location."
msgstr ""
"`mesh_min: 35,6` *必须配置* 第一个探测的坐标，距离原点最近。该坐标就是探针所"
"在的位置。"

msgid ""
"`mesh_max: 240,198` *Required* The probed coordinate farthest farthest from "
"the origin. This is not necessarily the last point probed, as the probing "
"process occurs in a zig-zag fashion. As with `mesh_min`, this coordiante is "
"relative to the probe's location."
msgstr ""
"`mesh_max: 240,198` *必须配置* 距离原点最远的探测坐标。 这不一定是探测的最后"
"一个点，因为探测过程以锯齿形的方式运动。 与 `mesh_min` 一样，这个坐标是探针的"
"位置。"

msgid ""
"`probe_count: 5,3` *Default Value: 3,3* The number of points to probe on "
"each axis, specified as x,y integer values. In this example 5 points will be "
"probed along the X axis, with 3 points along the Y axis, for a total of 15 "
"probed points. Note that if you wanted a square grid, for example 3x3, this "
"could be specified as a single integer value that is used for both axes, ie "
"`probe_count: 3`. Note that a mesh requires a minimum probe_count of 3 along "
"each axis."
msgstr ""
"`probe_count: 5,3` *默认值：3,3* 每条轴上要探测的点数，指定为 x,y 整数值。 在"
"本示例中，将沿 X 轴探测 5 个点，沿 Y 轴探测 3 个点，总共探测 15 个点。 请注"
"意，如果您想要一个方形网格，例如 3x3，可以将指定其为一个整数值，比如 "
"`probe_count: 3`。 请注意，网格需要沿每个轴的最小probe_count 为3。"

msgid ""
"The illustration below demonstrates how the `mesh_min`, `mesh_max`, and "
"`probe_count` options are used to generate probe points. The arrows indicate "
"the direction of the probing procedure, beginning at `mesh_min`. For "
"reference, when the probe is at `mesh_min` the nozzle will be at (11, 1), "
"and when the probe is at `mesh_max`, the nozzle will be at (206, 193)."
msgstr ""
"下图演示了如何使用 `mesh_min`、`mesh_max` 和 `probe_count` 选项来生成探测"
"点。 箭头表示探测过程的运动方向，从“mesh_min”开始。 图中所示，当探针位"
"于“mesh_min”时，喷嘴将位于 (11, 1)，当探针位于“mesh_max”时，喷嘴将位于 (206, "
"193)。"

msgid "![bedmesh_rect_basic](img/bedmesh_rect_basic.svg)"
msgstr "![矩形网床基本配置](img/bedmesh_rect_basic.svg)"

msgid "Round beds"
msgstr "圆形床"

msgid ""
"This example assumes a printer equipped with a round bed radius of 100mm. We "
"will use the same probe offsets as the rectangular example, 24 mm on X and 5 "
"mm on Y."
msgstr ""
"本示例假设打印机配备的圆床半径为 100 mm。 我们将使用与矩形网床示例相同的探针"
"偏移来演示，X 偏移为 24 mm，Y 偏移为 5 mm。"

msgid ""
"`mesh_radius: 75` *Required* The radius of the probed mesh in mm, relative "
"to the `mesh_origin`. Note that the probe's offsets limit the size of the "
"mesh radius. In this example, a radius larger than 76 would move the tool "
"beyond the range of the printer."
msgstr ""
"`mesh_radius: 75` *必须配置* 探测网格范围的半径（以毫米为单位），相对于 "
"`mesh_origin`。 请注意，探针的偏移会限制网格半径的大小。 在此示例中，大于 76 "
"mm的半径会将打印头移动到打印机的范围之外。"

msgid ""
"`mesh_origin: 0,0` *Default Value: 0,0* The center point of the mesh. This "
"coordinate is relative to the probe's location. While the default is 0,0, it "
"may be useful to adjust the origin in an effort to probe a larger portion of "
"the bed. See the illustration below."
msgstr ""
"`mesh_origin: 0,0` *默认值： 0,0* 探测网格的中心点。 该坐标相对于探针的位"
"置。 虽然默认值为 0,0，但为了探测床更多的部分而调整原点可能很有用。 请参阅下"
"图。"

msgid ""
"`round_probe_count: 5` *Default Value: 5* This is an integer value that "
"defines the maximum number of probed points along the X and Y axes. By "
"\"maximum\", we mean the number of points probed along the mesh origin. This "
"value must be an odd number, as it is required that the center of the mesh "
"is probed."
msgstr ""
"`round_probe_count: 5` *默认值： 5* 这是一个整数值，用于限制沿 X 轴和 Y 轴的"
"最大探测点数。 “最大”是指沿网格原点探测的点数。 该值必须是奇数，因为需要探测"
"网格的中心。"

msgid ""
"The illustration below shows how the probed points are generated. As you can "
"see, setting the `mesh_origin` to (-10, 0) allows us to specifiy a larger "
"mesh radius of 85."
msgstr ""
"下图展示了如何生成探测点。 如您所见，将 `mesh_origin` 设置为 (-10, 0) 允许我"
"们指定更大的网格半径 85mm。"

msgid "![bedmesh_round_basic](img/bedmesh_round_basic.svg)"
msgstr "![圆形网床基本配置](img/bedmesh_round_basic.svg)"

msgid "Advanced Configuration"
msgstr "高级配置"

msgid ""
"Below the more advanced configuration options are explained in detail. Each "
"example will build upon the basic rectangular bed configuration shown above. "
"Each of the advanced options apply to round beds in the same manner."
msgstr ""
"下面详细解释了更高级的配置选项。 每个示例都将建立在上面显示的基本矩形床配置之"
"上。 每个高级选项都以相同的方式应用于圆床。"

msgid "Mesh Interpolation"
msgstr "网格插值"

msgid ""
"While its possible to sample the probed matrix directly using simple "
"bilinear interpolation to determine the Z-Values between probed points, it "
"is often useful to interpolate extra points using more advanced "
"interpolation algorithms to increase mesh density. These algorithms add "
"curvature to the mesh, attempting to simulate the material properties of the "
"bed. Bed Mesh offers lagrange and bicubic interpolation to accomplish this."
msgstr ""
"虽然可以使用简单的双线性插值直接对探测网格的数据进行采样以确定探测点之间的 Z "
"值，但使用更高级的插值算法来插入额外的点以增加网格密度通常很有用。 这些算法向"
"网格添加曲率，试图模拟床的材料属性。 网床提供了拉格朗日和双三次插值来实现这一"
"点。"

msgid ""
"`mesh_pps: 2,3` *Default Value: 2,2* The `mesh_pps` option is shorthand for "
"Mesh Points Per Segment. This option specifies how many points to "
"interpolate for each segment along the x and y axes. Consider a 'segment' to "
"be the space between each probed point. Like `probe_count`, `mesh_pps` is "
"specified as an x,y integer pair, and also may be specified a single integer "
"that is applied to both axes. In this example there are 4 segments along the "
"X axis and 2 segments along the Y axis. This evaluates to 8 interpolated "
"points along X, 6 interpolated points along Y, which results in a 13x8 mesh. "
"Note that if mesh_pps is set to 0 then mesh interpolation is disabled and "
"the probed matrix will be sampled directly."
msgstr ""
"`mesh_pps: 2,3` *默认值：2,2*`mesh_pps` 选项是每段网格点数的简写。 此选项指定"
"沿 x 轴和 y 轴为每个线段插值的点数。 将“段”视为每个探测点之间的间隔。 与 "
"`probe_count` 一样，`mesh_pps` 被指定为 x,y 整数对，也可以指定为应用于两个轴"
"的单个整数。 在此示例中，沿 X 轴有 4 个线段，沿 Y 轴有 2 个线段。 这计算为沿 "
"X 的 8 个插值点，沿 Y 的 6 个插值点，从而产生 13x8 网格。 请注意，如果 "
"mesh_pps 设置为 0，则禁用网格插值，并且将直接对探测网格进行采样。"

msgid ""
"`algorithm: lagrange` *Default Value: lagrange* The algorithm used to "
"interpolate the mesh. May be `lagrange` or `bicubic`. Lagrange interpolation "
"is capped at 6 probed points as oscillation tends to occur with a larger "
"number of samples. Bicubic interpolation requires a minimum of 4 probed "
"points along each axis, if less than 4 points are specified then lagrange "
"sampling is forced. If `mesh_pps` is set to 0 then this value is ignored as "
"no mesh interpolation is done."
msgstr ""
"`algorithm: lagrange` *默认值：lagrange* 用于插入网格的算法。 可能是 "
"`lagrange` or `bicubic`。 拉格朗日插值最多为 6 个探测点，因为大量样本容易发生"
"振荡。 双三次插值要求沿每个轴至少有 4 个探测点，如果指定的点少于 4 个，则强制"
"拉格朗日采样。 如果 `mesh_pps` 设置为 0，则该值将被忽略，因为没有进行网格插"
"值。"

msgid ""
"`bicubic_tension: 0.2` *Default Value: 0.2* If the `algorithm` option is set "
"to bicubic it is possible to specify the tension value. The higher the "
"tension the more slope is interpolated. Be careful when adjusting this, as "
"higher values also create more overshoot, which will result in interpolated "
"values higher or lower than your probed points."
msgstr ""
"`bicubic_tension: 0.2` *默认值：0.2* 双三次插值的张力值。如果`algorithm` 选项"
"设置为双三次，则可以指定张力值。 张力越高，内插的斜率越大。 调整时要小心，因"
"为较高的值也会产生更多的过冲，这将导致插值高于或低于探测点。"

msgid ""
"The illustration below shows how the options above are used to generate an "
"interpolated mesh."
msgstr "下图显示了如何使用上述选项生成网格插值。"

msgid "![bedmesh_interpolated](img/bedmesh_interpolated.svg)"
msgstr "![网床插值](img/bedmesh_interpolated.svg)"

msgid "Move Splitting"
msgstr "移动拆分"

msgid ""
"`move_check_distance: 5` *Default Value: 5* The minimum distance to check "
"for the desired change in Z before performing a split. In this example, a "
"move longer than 5mm will be traversed by the algorithm. Each 5mm a mesh Z "
"lookup will occur, comparing it with the Z value of the previous move. If "
"the delta meets the threshold set by `split_delta_z`, the move will be split "
"and traversal will continue. This process repeats until the end of the move "
"is reached, where a final adjustment will be applied. Moves shorter than the "
"`move_check_distance` have the correct Z adjustment applied directly to the "
"move without traversal or splitting."
msgstr ""
"`move_check_distance: 5` *默认值：5* 在执行拆分之前检查 Z 中需要变化的最小距"
"离。 在此示例中，算法将遍历超过 5 毫米的移动。 每 5mm 将查找一次网格的Z ，并"
"将其与前一次移动的 Z 值进行比较。 如果三角洲满足 `split_delta_z` 设置的阈值，"
"则移动将被拆分并继续遍历。 重复此过程，直到到达移动结束处，在此将应用最终调"
"整。 比 `move_check_distance` 短的移动将正确的 Z 调整直接应用于移动，无需遍历"
"或拆分。"

msgid ""
"`split_delta_z: .025` *Default Value: .025* As mentioned above, this is the "
"minimum deviation required to trigger a move split. In this example, any Z "
"value with a deviation +/- .025mm will trigger a split."
msgstr ""
"`split_delta_z: .025` *默认值：.025* 如上所述，这是触发移动拆分所需的最小偏"
"差。 在上面的示例中，任何偏差为 +/- .025 mm的 Z 值都将触发拆分。"

msgid ""
"Generally the default values for these options are sufficient, in fact the "
"default value of 5mm for the `move_check_distance` may be overkill. However "
"an advanced user may wish to experiment with these options in an effort to "
"squeeze out the optimial first layer."
msgstr ""
"一般来说，这些选项的默认值就足够了，但事实上，`move_check_distance` 的默认值 "
"5mm 可能会有点过度矫正。 所以，高端可能希望尝试使用这个选项来获得挤出最佳的第"
"一层。"

msgid "Mesh Fade"
msgstr "网格淡出"

msgid ""
"When \"fade\" is enabled Z adjustment is phased out over a distance defined "
"by the configuration. This is accomplished by applying small adjustments to "
"the layer height, either increasing or decreasing depending on the shape of "
"the bed. When fade has completed, Z adjustment is no longer applied, "
"allowing the top of the print to be flat rather than mirror the shape of the "
"bed. Fade also may have some undesirable traits, if you fade too quickly it "
"can result in visible artifacts on the print. Also, if your bed is "
"significantly warped, fade can shrink or stretch the Z height of the print. "
"As such, fade is disabled by default."
msgstr ""
"启用“网格淡出”后，Z 轴的调整将在配置中定义的距离范围内逐步消失。 这是通过对层"
"高进行小幅调整来实现的，根据床的形状增加或减少。 网格淡出完成后，不再使用 Z "
"调整，使打印的表面是平坦的而不是床弯曲的形状。 网格淡出也可能会产生一些不良表"
"现，如果网格淡出过快，可能会导致打印件上出现可见的瑕疵（伪影）。 此外，如果您"
"的床明显变形，网格淡出会缩小或拉伸打印件的 Z 高度。 因此，默认情况下禁用网格"
"淡出。"

msgid ""
"`fade_start: 1` *Default Value: 1* The Z height in which to start phasing "
"out adjustment. It is a good idea to get a few layers down before starting "
"the fade process."
msgstr ""
"`fade_start: 1` *默认值：1* 开始网格淡出的值，在设定的fade_start值之后逐步停"
"止调整Z的高度。 建议在打印几层之后再开始淡出层高。"

msgid ""
"`fade_end: 10` *Default Value: 0* The Z height in which fade should "
"complete. If this value is lower than `fade_start` then fade is disabled. "
"This value may be adjusted depending on how warped the print surface is. A "
"significantly warped surface should fade out over a longer distance. A near "
"flat surface may be able to reduce this value to phase out more quickly. "
"10mm is a sane value to begin with if using the default value of 1 for "
"`fade_start`."
msgstr ""
"`fade_end: 10` *默认值：0* 网格淡出完成的 Z 高度。 如果此值低于`fade_start`，"
"则禁用网格淡出。 该值可以根据打印表面的弯曲程度进行调整。 明显弯曲的表面应该"
"在将网格淡出的距离长。 接近平坦的表面可能能够降低该值以更快地逐步淘汰。 如果"
"对 `fade_start` 使用默认值 1，则 10mm 是一个合理的值。"

msgid ""
"`fade_target: 0` *Default Value: The average Z value of the mesh* The "
"`fade_target` can be thought of as an additional Z offset applied to the "
"entire bed after fade completes. Generally speaking we would like this value "
"to be 0, however there are circumstances where it should not be. For "
"example, lets assume your homing position on the bed is an outlier, its .2 "
"mm lower than the average probed height of the bed. If the `fade_target` is "
"0, fade will shrink the print by an average of .2 mm across the bed. By "
"setting the `fade_target` to .2, the homed area will expand by .2 mm, "
"however the rest of the bed will have an accurately sized. Generally its a "
"good idea to leave `fade_target` out of the configuration so the average "
"height of the mesh is used, however it may be desirable to manually adjust "
"the fade target if one wants to print on a specific portion of the bed."
msgstr ""
"`fade_target: 0` *默认值：热床网格的平均Z值* `fade_target` 是在网格淡出完成后"
"应用于整个床的额外 Z 偏移。一 般来说，这个值是 0，但有些情况下它需要改动。 例"
"如，您在热床的归位位置与床的平均探测高度有偏差，它比床的平均探测高度低 0.2 "
"mm。 如果 `fade_target` 为 0，淡出会将整个床的打印平均缩小 0.2 mm。 通过将 "
"`fade_target` 设置为 0.2，归位的位置将扩大 0.2 毫米，但床的其余部分将具有准确"
"的尺寸。 一般来说，最好不要修改 `fade_target` 而修正机器本身导致的误差，以便"
"使用网格的平均高度，但是如果想要在床的特定部分打印，可能需要手动调整网格淡"
"出。"

msgid "The Relative Reference Index"
msgstr "相对参考索引"

msgid ""
"Most probes are suceptible to drift, ie: inaccuracies in probing introduced "
"by heat or interference. This can make calculating the probe's z-offset "
"challenging, particuarly at different bed temperatures. As such, some "
"printers use an endstop for homing the Z axis, and a probe for calibrating "
"the mesh. These printers can benefit from configuring the relative reference "
"index."
msgstr ""
"大部分探针检测到的值容易产生误差，即：由温度或探测介质干扰产生的探测误差。 这"
"加大探针Z偏移的看计算难度，尤其是在不同的热床温度下。 因此，一些打印机使用限"
"位开关来归位 Z 轴，并使用探针来校准网格。 这些打印机可以从配置中的相对参考索"
"引（relative_reference_index）中寻找帮助。"

msgid ""
"`relative_reference_index: 7` *Default Value: None (disabled)* When the "
"probed points are generated they are each assigned an index. You can look up "
"this index in klippy.log or by using BED_MESH_OUTPUT (see the section on Bed "
"Mesh GCodes below for more information). If you assign an index to the "
"`relative_reference_index` option, the value probed at this coordinate will "
"replace the probe's z_offset. This effectively makes this coordinate the "
"\"zero\" reference for the mesh."
msgstr ""
"`relative_reference_index: 7`*默认值：无（禁用）*生成探测点时，为每个点分配一"
"个索引。您可以使用网床输出或在 klippy.log 中查找此索引（有关详细信息，请参阅"
"下面的网床 G代码部分）。如果您为 `relative_reference_index` 选项分配了索引，"
"则在该坐标处探测的值将替换探针的 Z偏移值。 这将把这个坐标作为“零高度”的参考。"

msgid ""
"When using the relative reference index, you should choose the index nearest "
"to the spot on the bed where Z endstop calibration was done. Note that when "
"looking up the index using the log or BED_MESH_OUTPUT, you should use the "
"coordinates listed under the \"Probe\" header to find the correct index."
msgstr ""
"使用相对参考指数时，应选择距离床身 Z 限位器校准点最近的指数。 请注意，在网床"
"输出或在日志中查找索引时，您应该使用“探针”标题下列出的坐标来查找正确的索引。"

msgid "Faulty Regions"
msgstr "故障区域"

msgid ""
"It is possible for some areas of a bed to report inaccurate results when "
"probing due to a \"fault\" at specific locations. The best example of this "
"are beds with series of integrated magnets used to retain removable steel "
"sheets. The magnetic field at and around these magnets may cause an "
"inductive probe to trigger at a distance higher or lower than it would "
"otherwise, resulting in a mesh that does not accurately represent the "
"surface at these locations. **Note: This should not be confused with probe "
"location bias, which produces inaccurate results across the entire bed.**"
msgstr ""
"由于特定位置的“故障”，热床的某些区域在探测时可能会报告不准确的结果。 最好的例"
"子是带有用弹簧钢板的磁铁热床。 这些磁铁处和周围的磁场可能干扰探针触发的高度，"
"从而导致网格无法准确表示这些位置的表面。 **注意：不要与探头位置偏差导致探测结"
"果不准确的结果混淆。**"

msgid ""
"The `faulty_region` options may be configured to compensate for this affect. "
"If a generated point lies within a faulty region bed mesh will attempt to "
"probe up to 4 points at the boundaries of this region. These probed values "
"will be averaged and inserted in the mesh as the Z value at the generated "
"(X, Y) coordinate."
msgstr ""
"可以配置 `faulty_region` 选项来避免这种影响。 如果生成的点位于故障区域内，热"
"床网格将尝试在该区域的边界处探测最多 4 个点。 这些探测的平均值将插入网床中作"
"为生成的 (X, Y) 坐标处的 Z 值。"

msgid ""
"`faulty_region_{1...99}_min` `faulty_region_{1..99}_max` *Default Value: "
"None (disabled)* Faulty Regions are defined in a way similar to that of mesh "
"itself, where minimum and maximum (X, Y) coordinates must be specified for "
"each region. A faulty region may extend outside of a mesh, however the "
"alternate points generated will always be within the mesh boundary. No two "
"regions may overlap."
msgstr ""
"`faulty_region_{1...99}_min` `faulty_region_{1...99}_max` *默认值：None "
"（无）(disabled（禁用）)* 故障区域的定义方式类似床网本身，必须为每个区域指定"
"最小和最大（X, Y）坐标。一个故障区域可以延伸到网格之外，但是产生的替代探测点"
"总是在网格的边界内。两个区域不可以重叠。"

msgid ""
"The image below illustrates how replacement points are generated when a "
"generated point lies within a faulty region. The regions shown match those "
"in the sample config above. The replacement points and their coordinates are "
"identified in green."
msgstr ""
"下面的图片说明了当一个生成的探测点位于一个故障区域内时，如何生成替代探测点。"
"所显示的区域与上述样本配置中的区域一致。替代点和它们的坐标以绿色标识。"

msgid "![bedmesh_interpolated](img/bedmesh_faulty_regions.svg)"
msgstr "![bedmesh_interpolated](img/bedmesh_faulty_regions.svg)"

msgid "Bed Mesh Gcodes"
msgstr "床网 G代码"

msgid "Calibration"
msgstr "校准"

msgid ""
"It is possible to specify mesh parameters to modify the probed area. The "
"following parameters are available:"
msgstr "可以通过指定网格参数来修改探测区域。以下参数可用："

msgid "Rectangular beds (cartesian):"
msgstr "矩形打印床（笛卡尔 Cartesian）："

msgid "`MESH_MIN`"
msgstr "`MESH_MIN`"

msgid "`MESH_MAX`"
msgstr "`MESH_MAX`"

msgid "`PROBE_COUNT`"
msgstr "`PROBE_COUNT`"

msgid "Round beds (delta):"
msgstr "圆形打印床（三角洲 delta）："

msgid "`MESH_RADIUS`"
msgstr "`MESH_RADIUS`"

msgid "`MESH_ORIGIN`"
msgstr "`MESH_ORIGIN`"

msgid "`ROUND_PROBE_COUNT`"
msgstr "`ROUND_PROBE_COUNT`"

msgid "All beds:"
msgstr "全部打印床："

msgid "`RELATIVE_REFERNCE_INDEX`"
msgstr "`RELATIVE_REFERNCE_INDEX`"

msgid ""
"`ALGORITHM` See the configuration documentation above for details on how "
"each parameter applies to the mesh."
msgstr "`ALGORITHM` 关于每个参数对网格的影响，详见上方的配置文档。"

msgid "Profiles"
msgstr "配置"

msgid "`BED_MESH_PROFILE SAVE=name LOAD=name REMOVE=name`"
msgstr "`BED_MESH_PROFILE SAVE=name LOAD=name REMOVE=name`"

msgid ""
"After a BED_MESH_CALIBRATE has been performed, it is possible to save the "
"current mesh state into a named profile. This makes it possible to load a "
"mesh without re-probing the bed. After a profile has been saved using "
"`BED_MESH_PROFILE SAVE=name` the `SAVE_CONFIG` gcode may be executed to "
"write the profile to printer.cfg."
msgstr ""
"在进行 BED_MESH_CALIBRATE 后，可以将当前网格状态保存到一个命名的配置中。这样"
"就可以加载一个网格而不需要重新探测打印床。在使用`BED_MESH_PROFILE SAVE=name`"
"保存了一个配置文件后，可以执行`SAVE_CONFIG`gcode，将配置文件写入print.cfg。"

msgid "Profiles can be loaded by executing `BED_MESH_PROFILE LOAD=name`."
msgstr "可以通过运行 `BED_MESH_PROFILE LOAD=name` 来载入配置。"

msgid ""
"It should be noted that each time a BED_MESH_CALIBRATE occurs, the current "
"state is automatically saved to the *default* profile. If this profile "
"exists it is automatically loaded when Klipper starts. If this behavior is "
"not desirable the *default* profile can be removed as follows:"
msgstr ""
"请注意，每次运行 BED_MESH_CALIBRATE 后，当前状态会被保存到 *default* 配置。如"
"果这个配置在配置文件中存在，它会在 Klipper 启动时自动载入。如果不希望这种行"
"为，可以通过以下命令删除 *default* 配置："

msgid "`BED_MESH_PROFILE REMOVE=default`"
msgstr "`BED_MESH_PROFILE REMOVE=default`"

msgid ""
"Any other saved profile can be removed in the same fashion, replacing "
"*default* with the named profile you wish to remove."
msgstr ""
"任何其他保存的配置也可以用相同的方式删除，用你想删除的配置名称替换*default*。"

msgid "Output"
msgstr "输出"

msgid "`BED_MESH_OUTPUT PGP=[0 | 1]`"
msgstr "`BED_MESH_OUTPUT PGP=[0 | 1]`"

msgid ""
"Outputs the current mesh state to the terminal. Note that the mesh itself is "
"output"
msgstr "将当前网格状态输出到终端。请注意，输出的是网格本身"

msgid ""
"The PGP parameter is shorthand for \"Print Generated Points\". If `PGP=1` is "
"set, the generated probed points will be output to the terminal:"
msgstr ""
"PGP 参数是“打印生成的点”的简写。如果设置了`PGP=1`，生成的探测点将输出到终端："

msgid ""
"The \"Tool Adjusted\" points refer to the nozzle location for each point, "
"and the \"Probe\" points refer to the probe location. Note that when "
"manually probing the \"Probe\" points will refer to both the tool and nozzle "
"locations."
msgstr ""
"\"Tool Adjusted\"（工具调整）点指每个点的喷嘴位置，\"Probe\"（探针）点指探头"
"位置。请注意，手动探测时\"Probe\"（探针）点时将同时指工具和喷嘴位置。"

msgid "Clear Mesh State"
msgstr "清除网格状态"

msgid "`BED_MESH_CLEAR`"
msgstr "`BED_MESH_CLEAR`"

msgid "This gcode may be used to clear the internal mesh state."
msgstr "此 gcode 可用于清除内部网格状态。"

msgid "Apply X/Y offsets"
msgstr "应用X/Y偏移量"

msgid "`BED_MESH_OFFSET [X=<value>] [Y=<value>]`"
msgstr "`BED_MESH_OFFSET [X=<value>] [Y=<value>]`"

msgid ""
"This is useful for printers with multiple independent extruders, as an "
"offset is necessary to produce correct Z adjustment after a tool change. "
"Offsets should be specified relative to the primary extruder. That is, a "
"positive X offset should be specified if the secondary extruder is mounted "
"to the right of the primary extruder, and a positive Y offset should be "
"specified if the secondary extruder is mounted \"behind\" the primary "
"extruder."
msgstr ""
"这对有多个独立挤出头的打印机很有用，因为偏移量是必要的，以便在更换工具后产生"
"正确的Z调整。应指定它们相对于主挤出头的偏移量。也就是说，如果第二个挤出头安装"
"在第一个挤出头的右边，应指定一个正的X偏移量，如果第二个挤出头安装在第一个挤出"
"头的 \"后面\"，应指定一个正的Y偏移量。"

msgid ""
"[bed_mesh]\n"
"speed: 120\n"
"horizontal_move_z: 5\n"
"mesh_min: 35,6\n"
"mesh_max: 240, 198\n"
"probe_count: 5,3\n"
msgstr ""
"[bed_mesh]\n"
"speed: 120\n"
"horizontal_move_z: 5\n"
"mesh_min: 35,6\n"
"mesh_max: 240, 198\n"
"probe_count: 5,3\n"

msgid ""
"[bed_mesh]\n"
"speed: 120\n"
"horizontal_move_z: 5\n"
"mesh_radius: 75\n"
"mesh_origin: 0,0\n"
"round_probe_count: 5\n"
msgstr ""
"[bed_mesh]\n"
"speed: 120\n"
"horizontal_move_z: 5\n"
"mesh_radius: 75\n"
"mesh_origin: 0,0\n"
"round_probe_count: 5\n"

msgid ""
"[bed_mesh]\n"
"speed: 120\n"
"horizontal_move_z: 5\n"
"mesh_min: 35,6\n"
"mesh_max: 240, 198\n"
"probe_count: 5,3\n"
"mesh_pps: 2,3\n"
"algorithm: bicubic\n"
"bicubic_tension: 0.2\n"
msgstr ""
"[bed_mesh]\n"
"speed: 120\n"
"horizontal_move_z: 5\n"
"mesh_min: 35,6\n"
"mesh_max: 240, 198\n"
"probe_count: 5,3\n"
"mesh_pps: 2,3\n"
"algorithm: bicubic\n"
"bicubic_tension: 0.2\n"

msgid ""
"[bed_mesh]\n"
"speed: 120\n"
"horizontal_move_z: 5\n"
"mesh_min: 35,6\n"
"mesh_max: 240, 198\n"
"probe_count: 5,3\n"
"move_check_distance: 5\n"
"split_delta_z: .025\n"
msgstr ""
"[bed_mesh]\n"
"speed: 120\n"
"horizontal_move_z: 5\n"
"mesh_min: 35,6\n"
"mesh_max: 240, 198\n"
"probe_count: 5,3\n"
"move_check_distance: 5\n"
"split_delta_z: .025\n"

msgid ""
"[bed_mesh]\n"
"speed: 120\n"
"horizontal_move_z: 5\n"
"mesh_min: 35,6\n"
"mesh_max: 240, 198\n"
"probe_count: 5,3\n"
"fade_start: 1\n"
"fade_end: 10\n"
"fade_target: 0\n"
msgstr ""
"[bed_mesh]\n"
"speed: 120\n"
"horizontal_move_z: 5\n"
"mesh_min: 35,6\n"
"mesh_max: 240, 198\n"
"probe_count: 5,3\n"
"fade_start: 1\n"
"fade_end: 10\n"
"fade_target: 0\n"

msgid ""
"[bed_mesh]\n"
"speed: 120\n"
"horizontal_move_z: 5\n"
"mesh_min: 35,6\n"
"mesh_max: 240, 198\n"
"probe_count: 5,3\n"
"relative_reference_index: 7\n"
msgstr ""
"[bed_mesh]\n"
"speed: 120\n"
"horizontal_move_z: 5\n"
"mesh_min: 35,6\n"
"mesh_max: 240, 198\n"
"probe_count: 5,3\n"
"relative_reference_index: 7\n"

msgid ""
"[bed_mesh]\n"
"speed: 120\n"
"horizontal_move_z: 5\n"
"mesh_min: 35,6\n"
"mesh_max: 240, 198\n"
"probe_count: 5,3\n"
"faulty_region_1_min: 130.0, 0.0\n"
"faulty_region_1_max: 145.0, 40.0\n"
"faulty_region_2_min: 225.0, 0.0\n"
"faulty_region_2_max: 250.0, 25.0\n"
"faulty_region_3_min: 165.0, 95.0\n"
"faulty_region_3_max: 205.0, 110.0\n"
"faulty_region_4_min: 30.0, 170.0\n"
"faulty_region_4_max: 45.0, 210.0\n"
msgstr ""
"[bed_mesh]\n"
"speed: 120\n"
"horizontal_move_z: 5\n"
"mesh_min: 35,6\n"
"mesh_max: 240, 198\n"
"probe_count: 5,3\n"
"faulty_region_1_min: 130.0, 0.0\n"
"faulty_region_1_max: 145.0, 40.0\n"
"faulty_region_2_min: 225.0, 0.0\n"
"faulty_region_2_max: 250.0, 25.0\n"
"faulty_region_3_min: 165.0, 95.0\n"
"faulty_region_3_max: 205.0, 110.0\n"
"faulty_region_4_min: 30.0, 170.0\n"
"faulty_region_4_max: 45.0, 210.0\n"

msgid ""
"// bed_mesh: generated points\n"
"// Index | Tool Adjusted | Probe\n"
"// 0 | (11.0, 1.0) | (35.0, 6.0)\n"
"// 1 | (62.2, 1.0) | (86.2, 6.0)\n"
"// 2 | (113.5, 1.0) | (137.5, 6.0)\n"
"// 3 | (164.8, 1.0) | (188.8, 6.0)\n"
"// 4 | (216.0, 1.0) | (240.0, 6.0)\n"
"// 5 | (216.0, 97.0) | (240.0, 102.0)\n"
"// 6 | (164.8, 97.0) | (188.8, 102.0)\n"
"// 7 | (113.5, 97.0) | (137.5, 102.0)\n"
"// 8 | (62.2, 97.0) | (86.2, 102.0)\n"
"// 9 | (11.0, 97.0) | (35.0, 102.0)\n"
"// 10 | (11.0, 193.0) | (35.0, 198.0)\n"
"// 11 | (62.2, 193.0) | (86.2, 198.0)\n"
"// 12 | (113.5, 193.0) | (137.5, 198.0)\n"
"// 13 | (164.8, 193.0) | (188.8, 198.0)\n"
"// 14 | (216.0, 193.0) | (240.0, 198.0)\n"
msgstr ""
"// bed_mesh: generated points\n"
"// Index | Tool Adjusted | Probe\n"
"// 0 | (11.0, 1.0) | (35.0, 6.0)\n"
"// 1 | (62.2, 1.0) | (86.2, 6.0)\n"
"// 2 | (113.5, 1.0) | (137.5, 6.0)\n"
"// 3 | (164.8, 1.0) | (188.8, 6.0)\n"
"// 4 | (216.0, 1.0) | (240.0, 6.0)\n"
"// 5 | (216.0, 97.0) | (240.0, 102.0)\n"
"// 6 | (164.8, 97.0) | (188.8, 102.0)\n"
"// 7 | (113.5, 97.0) | (137.5, 102.0)\n"
"// 8 | (62.2, 97.0) | (86.2, 102.0)\n"
"// 9 | (11.0, 97.0) | (35.0, 102.0)\n"
"// 10 | (11.0, 193.0) | (35.0, 198.0)\n"
"// 11 | (62.2, 193.0) | (86.2, 198.0)\n"
"// 12 | (113.5, 193.0) | (137.5, 198.0)\n"
"// 13 | (164.8, 193.0) | (188.8, 198.0)\n"
"// 14 | (216.0, 193.0) | (240.0, 198.0)\n"

#: docs/Bed_Mesh.md:block 1 (header)
msgid "Bed Mesh"
msgstr "床网"

#: docs/Bed_Mesh.md:block 48 (paragraph)
msgid ""
"`BED_MESH_CALIBRATE PROFILE=name METHOD=[manual | automatic] "
"[<probe_parameter>=<value>] [<mesh_parameter>=<value>]` *Default Profile: "
"default* *Default Method: automatic if a probe is detected, otherwise manual*"
msgstr ""
"`BED_MESH_CALIBRATE PROFILE=name METHOD=[manual | automatic] "
"[<probe_parameter>=<value>] [<mesh_parameter>=<value>]` *默认配置文件："
"default* *默认方法：如果检测到探针则自动，否则手动*"

#: docs/Bed_Mesh.md:block 49 (paragraph)
msgid "Initiates the probing procedure for Bed Mesh Calibration."
msgstr "启动床网校准的探测程序。"

#: docs/Bed_Mesh.md:block 50 (paragraph)
msgid ""
"The mesh will be saved into a profile specified by the `PROFILE` parameter, "
"or `default` if unspecified. If `METHOD=manual` is selected then manual "
"probing will occur. When switching between automatic and manual probing the "
"generated mesh points will automatically be adjusted."
msgstr ""
"网格将被保存到由 `PROFILE` 参数指定的配置中，如果没有指定，则使用 `default`。"
"如果选择了 `METHOD=manual` ，那么将进行手动探测。在自动和手动探测之间切换时，"
"生成的网格点会自动调整。"

#: docs/Bed_Mesh.md:block 26 (paragraph)
msgid ""
"Bed Mesh works by intercepting gcode move commands and applying a transform "
"to their Z coordinate. Long moves must be split into smaller moves to "
"correctly follow the shape of the bed. The options below control the "
"splitting behavior."
msgstr ""
"床网的工作原理是拦截 G 代码移动命令并对其 Z 坐标进行变换。长的移动必须被分割"
"成较小的移动以正确地遵循床的形状。下面的选项可以控制分割的行为。"

#~ msgid ""
#~ "Bed Mesh works by intercepting gcode move commands and applying a "
#~ "transform to their Z coordinate. Long moves must be and split into "
#~ "smaller moves to correctly follow the shape of the bed. The options below "
#~ "control the splitting behavior."
#~ msgstr ""
#~ "Bed Mesh 的工作原理是拦截 gcode 移动命令并对它们的 Z 坐标应用变换。 将长距"
#~ "离移动并拆分成更小的移动，让打印出来的效果尽量接近床的形状。 下面的选项控"
#~ "制如何拆分。"

#~ msgid ""
#~ "`BED_MESH_CALIBRATE METHOD=[manual | automatic] "
#~ "[<probe_parameter>=<value>] [<mesh_parameter>=<value>]` *Default Method: "
#~ "automatic if a probe is detected, otherwise manual*"
#~ msgstr ""
#~ "`BED_MESH_CALIBRATE METHOD=[manual | automatic] "
#~ "[<probe_parameter>=<value>] [<mesh_parameter>=<value>]` *默认方法：如果检"
#~ "测到探针，则自动，否则手动*"
