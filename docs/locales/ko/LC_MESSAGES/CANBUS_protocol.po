# system3rdb <system3rd@gmail.com>, 2021.
msgid ""
msgstr ""
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"PO-Revision-Date: 2021-08-22 00:41+0000\n"
"Last-Translator: system3rdb <system3rd@gmail.com>\n"
"Language-Team: Korean <https://hosted.weblate.org/projects/klipper/canbus_protocol/ko/>\n"
"Language: ko\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.8.1-dev\n"

msgid "Micro-controller id assignment"
msgstr "마이크로 컨트롤러 ID 할당"

msgid ""
"Klipper uses only CAN 2.0A standard size CAN bus packets, which are limited "
"to 8 data bytes and an 11-bit CAN bus identifier. In order to support "
"efficient communication, each micro-controller is assigned at run-time a "
"unique 1-byte CAN bus nodeid (`canbus_nodeid`) for general Klipper command "
"and response traffic. Klipper command messages going from host to micro-"
"controller use the CAN bus id of `canbus_nodeid * 2 + 256`, while Klipper "
"response messages from micro-controller to host use `canbus_nodeid * 2 + 256"
" + 1`."
msgstr ""
"Klipper는 8 데이터 바이트와 11비트 CAN bus identifier로 제한되는 CAN 2.0A 표준 크기 CAN bus 패킷만"
" 사용합니다. 효율적인 통신을 지원하기 위해 각 마이크로 컨트롤러에는 일반 Klipper 명령 및 응답 트래픽에 대해 고유한 1바이트 "
"CAN bus 노드 ID(`canbus_nodeid`)가 런타임에 할당됩니다. 호스트에서 마이크로 컨트롤러로 가는 Klipper 명령 "
"메시지는 `canbus_nodeid * 2 + 256`의 CAN bus ID를 사용하는 반면, 마이크로 컨트롤러에서 호스트로 가는 "
"Klipper 응답 메시지는 `canbus_nodeid * 2 + 256 + 1`을 사용합니다."

msgid ""
"Each micro-controller has a factory assigned unique chip identifier that is "
"used during id assignment. This identifier can exceed the length of one CAN "
"packet, so a hash function is used to generate a unique 6-byte id "
"(`canbus_uuid`) from the factory id."
msgstr ""
"각 마이크로 컨트롤러에는 ID 할당 중에 사용되는 공장 할당 고유 칩 식별자가 있습니다. 이 식별자는 하나의 CAN 패킷 길이를 초과할 "
"수 있으므로 해시 함수를 사용하여 공장 ID에서 고유한 6바이트 ID(`canbus_uuid`)를 생성합니다."

msgid "Admin messages"
msgstr "관리자 메시지"

msgid ""
"Admin messages are used for id assignment. Admin messages sent from host to "
"micro-controller use the CAN bus id `0x3f0` and messages sent from micro-"
"controller to host use the CAN bus id `0x3f1`. All micro-controllers listen "
"to messages on id `0x3f0`; that id can be thought of as a \"broadcast "
"address\"."
msgstr ""
"관리자 메시지는 ID 할당에 사용됩니다. 호스트에서 마이크로 컨트롤러로 전송된 관리자 메시지는 CAN bus ID `0x3f0`을 "
"사용하고 마이크로 컨트롤러에서 호스트로 전송되는 메시지는 CAN bus ID`0x3f1`을 사용합니다. 모든 마이크로 컨트롤러는 id "
"`0x3f0`의 메시지를 수신합니다. 이 id는 \"브로드캐스트 주소\"로 생각할 수 있습니다."

msgid "CMD_QUERY_UNASSIGNED message"
msgstr "CMD_QUERY_UNASSIGNED 메시지"

msgid ""
"This command queries all micro-controllers that have not yet been assigned a"
" `canbus_nodeid`. Unassigned micro-controllers will respond with a "
"RESP_NEED_NODEID response message."
msgstr ""
"이 명령은 아직 `canbus_nodeid`가 할당되지 않은 모든 마이크로 컨트롤러를 나타냅니다. 할당되지 않은 마이크로 컨트롤러는 "
"RESP_NEED_NODEID 응답 메시지로 응답합니다."

msgid ""
"The CMD_QUERY_UNASSIGNED message format is: `<1-byte message_id = 0x00>`"
msgstr "CMD_QUERY_UNASSIGNED 메시지 형식은 다음과 같습니다: `<1-byte message_id = 0x00>`"

msgid "CMD_SET_NODEID message"
msgstr "CMD_SET_NODEID 메시지"

msgid ""
"This command assigns a `canbus_nodeid` to the micro-controller with a given "
"`canbus_uuid`."
msgstr "이 명령은`canbus_uuid`가 지정된 마이크로 컨트롤러에 `canbus_nodeid`를 할당합니다."

msgid ""
"The CMD_SET_NODEID message format is: `<1-byte message_id = 0x01><6-byte "
"canbus_uuid><1-byte canbus_nodeid>`"
msgstr ""
"CMD_SET_NODEID 메시지 형식은 다음과 같습니다: `<1-byte message_id = 0x01><6-byte "
"canbus_uuid><1-byte canbus_nodeid>`"

msgid "RESP_NEED_NODEID message"
msgstr "RESP_NEED_NODEID 메시지"

msgid ""
"The RESP_NEED_NODEID message format is: `<1-byte message_id = 0x20><6-byte "
"canbus_uuid>`"
msgstr ""
"RESP_NEED_NODEID 메시지 형식은 다음과 같습니다: `<1-byte message_id = 0x20><6-byte "
"canbus_uuid>`"

msgid "Data Packets"
msgstr "데이터 패킷"

msgid ""
"A micro-controller that has been assigned a nodeid via the CMD_SET_NODEID "
"command can send and receive data packets."
msgstr "CMD_SET_NODEID 명령을 통해 nodeid가 할당된 마이크로 컨트롤러는 데이터 패킷을 보내고 받을 수 있습니다."

msgid ""
"The packet data in messages using the node's receive CAN bus id "
"(`canbus_nodeid * 2 + 256`) are simply appended to a buffer, and when a "
"complete [mcu protocol message](Protocol.md) is found its contents are "
"parsed and processed. The data is treated as a byte stream - there is no "
"requirement for the start of a Klipper message block to align with the start"
" of a CAN bus packet."
msgstr ""
"노드의 수신 CAN bus ID(`canbus_nodeid * 2 + 256`)를 사용하는 메시지의 패킷 데이터는 단순히 버퍼에 추가되고"
" 완전한 [mcu protocol message](Protocol.md) 가 발견되면 해당 내용을 구문 분석하고 처리합니다. 데이터는 "
"바이트 스트림으로 처리됩니다 - CAN bus 패킷의 시작과 정렬하기 위해 Klipper 메시지 블록의 시작에 대한 요구 사항은 "
"없습니다."

msgid ""
"Similarly, mcu protocol message responses are sent from micro-controller to "
"host by copying the message data into one or more packets with the node's "
"transmit CAN bus id (`canbus_nodeid * 2 + 256 + 1`)."
msgstr ""
"유사하게, mcu 프로토콜 메시지 응답은 노드의 전송 CAN bus ID(`canbus_nodeid * 2 + 256 + 1`)와 함께 "
"메시지 데이터를 하나 이상의 패킷으로 복사하여 마이크로 컨트롤러에서 호스트로 전송됩니다."

#: docs/CANBUS_protocol.md:block 1 (header)
msgid "CANBUS protocol"
msgstr "CANBUS 프로토콜"

#: docs/CANBUS_protocol.md:block 2 (paragraph)
msgid ""
"This document describes the protocol Klipper uses to communicate over [CAN "
"bus](https://en.wikipedia.org/wiki/CAN_bus). See <CANBUS.md> for information"
" on configuring Klipper with CAN bus."
msgstr ""

#~ msgid ""
#~ "This document describes the protocol Klipper uses to communicate over [CAN "
#~ "bus](https://en.wikipedia.org/wiki/CAN_bus). See [CANBUS.md](CANBUS.md) for "
#~ "information on configuring Klipper with CAN bus."
#~ msgstr ""
#~ "이 문서는 Klipper가 [CAN bus](https://en.wikipedia.org/wiki/CAN_bus) 를 통해 통신하는데 "
#~ "사용하는 프로토콜을 설명합니다. CAN bus 로 Klipper를 구성하는 방법에 대한 정보는 [CANBUS.md](CANBUS.md)를"
#~ " 참조하십시오."
