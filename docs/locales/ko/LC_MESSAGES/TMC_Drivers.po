# brian park <gouache95@gmail.com>, 2021.
msgid ""
msgstr ""
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"PO-Revision-Date: 2021-08-27 12:35+0000\n"
"Last-Translator: brian park <gouache95@gmail.com>\n"
"Language-Team: Korean <https://hosted.weblate.org/projects/klipper/"
"tmc_drivers/ko/>\n"
"Language: ko\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.8.1-dev\n"

msgid ""
"This document provides information on using Trinamic stepper motor drivers "
"in SPI/UART mode on Klipper."
msgstr ""
"이 문서는 Klipper의 SPI/UART 모드에서 Trinamic 스테퍼 모터 드라이버를 사용하는 방법에 대한 정보를 제공합니다."

msgid ""
"Klipper can also use Trinamic drivers in their \"standalone mode\". However,"
" when the drivers are in this mode, no special Klipper configuration is "
"needed and the advanced Klipper features discussed in this document are not "
"available."
msgstr ""
"Klipper는 \"standalone mode\"에서 Trinamic 드라이버를 사용할 수도 있습니다. 그러나 드라이버가 이 모드에 "
"있으면 특별한 Klipper 구성이 필요하지 않으며 이 문서에서 설명하는 고급 Klipper 기능을 사용할 수 없습니다."

msgid ""
"In addition to this document, be sure to review the [TMC driver config "
"reference](Config_Reference.md#tmc-stepper-driver-configuration)."
msgstr ""
"이 문서 외에 [TMC 드라이버 구성 참조](Config_Reference.md#tmc-stepper-driver-"
"configuration)를 반드시 검토하십시오."

msgid "Enabling \"Stealthchop\" mode"
msgstr "\"Stealthchop\" 모드 활성화"

msgid ""
"By default, Klipper places the TMC drivers in \"spreadcycle\" mode. If the "
"driver supports \"stealthchop\" then it can be enabled by adding "
"`stealthchop_threshold: 999999` to the TMC config section."
msgstr ""
"기본적으로 Klipper는 TMC 드라이버를 \"spreadcycle\" 모드로 설정합니다. 드라이버가 \"stealthchop\"을 "
"지원하는 경우 TMC 구성 섹션에 `stealthchop_threshold: 999999`를 추가하여 활성화할 수 있습니다."

msgid ""
"It is recommended to always use \"spreadcycle\" mode (by not specifying "
"`stealthchop_threshold`) or to always use \"stealthchop\" mode (by setting "
"`stealthchop_threshold` to 999999). Unfortunately, the drivers often produce"
" poor and confusing results if the mode changes while the motor is at a non-"
"zero velocity."
msgstr ""
"항상 \"spreadcycle\" 모드(`stealthchop_threshold`를 지정하지 않음)를 사용하거나 항상 "
"`stealthchop_threshold`를 999999로 설정하여 `stealthchop` 모드를 사용하는 것이 좋습니다. 불행히도, "
"모터가 0이 아닌 속도에 있는 동안 모드가 변경되면 드라이버는 종종 좋지 않고 혼란스러운 결과를 생성합니다."

msgid "Sensorless Homing"
msgstr "센서리스 원점복귀"

msgid ""
"Sensorless homing allows to home an axis without the need for a physical "
"limit switch. Instead, the carriage on the axis is moved into the mechanical"
" limit making the stepper motor lose steps. The stepper driver senses the "
"lost steps and indicates this to the controlling MCU (Klipper) by toggling a"
" pin. This information can be used by Klipper as end stop for the axis."
msgstr ""
"센서리스 원점복귀는 물리적 리미트 스위치 없이도 축을 원점복귀할 수 있습니다. 대신 축의 캐리지가 기계적 한계지점으로 이동되어 스테퍼 "
"모터가 step제어가 풀리게 됩니다. 스테퍼 드라이버는 손실된 단계를 감지하고 핀을 토글하여 제어 MCU(Klipper)에 이를 "
"표시합니다. 이 정보는 Klipper에서 축의 끝점으로 사용할 수 있습니다."

msgid ""
"This guide covers the setup of sensorless homing for the X axis of your "
"(cartesian) printer. However, it works the same with all other axes (that "
"require an end stop). You should configure and tune it for one axis at a "
"time."
msgstr ""
"이 가이드는 (직교) 프린터의 X 축에 대한 센서리스 원점 복귀 설정을 다룹니다. 그러나 다른 모든 축(끝 정지가 필요한 축)과 동일하게 "
"작동합니다. 한 번에 하나의 축에 대해 구성하고 조정해야 합니다."

msgid "Limitations"
msgstr "제한사항"

msgid ""
"Be sure that your mechanical components are able to handle the load of the "
"carriage bumping into the limit of the axis repeatedly. Especially "
"leadscrews might generate a lot of force. Homing a Z axis by bumping the "
"nozzle into the printing surface might not be a good idea. For best results,"
" verify that the axis carriage will make a firm contact with the axis limit."
msgstr ""
"기계 구성 요소가 축의 한계에 반복적으로 부딪치는 캐리지의 하중을 처리할 수 있는지 확인하십시오. 특히 리드스크류는 많은 힘을 발생시킬 "
"수 있습니다. 노즐을 인쇄 표면에 부딪혀 Z축의 원점 복귀는 좋은 생각이 아닐 수 있습니다. 최상의 결과를 얻으려면 축 캐리지가 축 "
"제한에 단단히 닿는지 확인하십시오."

msgid ""
"Further, sensorless homing might not be accurate enough for your printer. "
"While homing X and Y axes on a cartesian machine can work well, homing the Z"
" axis is generally not accurate enough and may result in an inconsistent "
"first layer height. Homing a delta printer sensorless is not advisable due "
"to missing accuracy."
msgstr ""
"또한 센서리스 원점 복귀는 프린터에 대해 충분히 정확하지 않을 수 있습니다. 직교 기계에서 X 및 Y 축의 귀환은 잘 작동할 수 있지만 "
"Z 축의 귀환은 일반적으로 충분히 정확하지 않으며 일관되지 않은 첫 번째 레이어 높이를 초래할 수 있습니다. 센서가 없는 델타 프린터의 "
"원점 복귀는 정확도가 떨어지므로 권장하지 않습니다."

msgid ""
"Further, the stall detection of the stepper driver is dependent on the "
"mechanical load on the motor, the motor current and the motor temperature "
"(coil resistance)."
msgstr "또한 스테퍼 드라이버의 stall 감지는 모터의 기계적 부하, 모터 전류 및 모터 온도(코일 저항)에 따라 달라집니다."

msgid ""
"Sensorless homing works best at medium motor speeds. For very slow speeds "
"(less than 10 RPM) the motor does not generate significant back EMF and the "
"TMC cannot reliably detect motor stalls. Further, at very high speeds, the "
"back EMF of the motor approaches the supply voltage of the motor, so the TMC"
" cannot detect stalls anymore. It is advised to have a look in the datasheet"
" of your specific TMCs. There you can also find more details on limitations "
"of this setup."
msgstr ""
"센서리스 원점 복귀는 모터의 적절한 속도에서 가장 잘 작동합니다. 매우 느린 속도(10RPM 미만)의 경우 모터는 상당한 역기전력을 "
"생성하지 않으며 TMC는 모터 stall을 안정적으로 감지할 수 없습니다. 또한 매우 빠른 속도에서 모터의 역기전력이 모터의 공급 전압에 "
"접근하므로 TMC는 더 이상 stall을 감지할수 없습니다. TMC의 데이터시트를 살펴보는 것이 좋습니다. 여기에서 이 설정의 제한 "
"사항에 대한 자세한 내용도 찾을 수 있습니다."

msgid "Prerequisites"
msgstr "전제조건"

msgid "A few prerequisites are needed to use sensorless homing:"
msgstr "센서리스 원점 복귀를 사용하려면 몇 가지 전제 조건이 필요합니다:"

msgid ""
"A StallGuard capable TMC stepper driver (tmc2130, tmc2209, tmc2660, or "
"tmc5160)."
msgstr "StallGuard 지원 TMC 스테퍼 드라이버(tmc2130, tmc2209, tmc2660 또는 tmc5160)."

msgid ""
"SPI / UART interface of the TMC driver wired to micro-controller (stand-"
"alone mode does not work)."
msgstr "마이크로 컨트롤러에 연결된 TMC 드라이버의 SPI/UART 인터페이스 (stand-alone 모드는 작동하지 않음)."

msgid ""
"The appropriate \"DIAG\" or \"SG_TST\" pin of TMC driver connected to the "
"micro-controller."
msgstr "마이크로 컨트롤러에 연결된 TMC 드라이버의 적절한 \"DIAG\" 또는 \"SG_TST\" 핀."

msgid ""
"The steps in the [config checks](Config_checks.md) document must be run to "
"confirm the stepper motors are configured and working properly."
msgstr "[구성 검사](Config_checks.md) 문서의 단계를 실행하여 스테퍼 모터가 구성되고 제대로 작동하는지 확인해야 합니다."

msgid "Tuning"
msgstr "조정"

msgid "The procedure described here has six major steps:"
msgstr "여기에 설명된 절차에는 6가지 주요 단계가 있습니다:"

msgid "Choose a homing speed."
msgstr "원점 복귀 속도를 선택합니다."

msgid "Configure the `printer.cfg` file to enable sensorless homing."
msgstr "센서리스 원점 복귀를 활성화하도록 `printer.cfg` 파일을 구성합니다."

msgid ""
"Find the stallguard setting with highest sensitivity that successfully "
"homes."
msgstr "성공적으로 홈에 도달하는 가장 높은 민감도의 stallguard 설정을 찾으십시오."

msgid ""
"Find the stallguard setting with lowest sensitivity that successfully homes "
"with a single touch."
msgstr "한번의 터치로 성공적으로 홈으로 돌아가는 최저 민감도의 stallguard 설정을 찾으십시오."

msgid "Update the `printer.cfg` with the desired stallguard setting."
msgstr "원하는 stallguard 설정으로 `printer.cfg`를 업데이트하십시오."

msgid "Create or update `printer.cfg` macros to home consistently."
msgstr "일관되게 홈에 대한 `printer.cfg` 매크로를 생성하거나 업데이트합니다."

msgid "Choose homing speed"
msgstr "원점복귀 속도 선택"

msgid ""
"The homing speed is an important choice when performing sensorless homing. "
"It's desirable to use a slow homing speed so that the carriage does not "
"exert excessive force on the frame when making contact with the end of the "
"rail. However, the TMC drivers can't reliably detect a stall at very slow "
"speeds."
msgstr ""
"원점복귀 속도는 센서리스 원점복귀를 수행할 때 중요한 선택입니다. 레일 끝부분에 닿을 때 캐리지가 프레임에 과도한 힘을 가하지 않도록 "
"느린 원점복귀 속도를 사용하는 것이 바람직합니다. 그러나 TMC 드라이버는 매우 느린 속도에서는 stall을 안정적으로 감지할 수 "
"없습니다."

msgid ""
"A good starting point for the homing speed is for the stepper motor to make "
"a full rotation every two seconds. For many axes this will be the "
"`rotation_distance` divided by two. For example:"
msgstr ""
"원점복귀 속도의 좋은 시작점은 스테퍼 모터가 2초마다 완전히 회전하는 것입니다. 많은 축의 경우 이는 `rotation_distance`"
"를 2로 나눈 값입니다. 예를 들어:"

msgid "Configure printer.cfg for sensorless homing"
msgstr "센서리스 원점복귀를 위해 printer.cfg 구성"

msgid ""
"The `homing_retract_dist` setting must be set to zero in the `stepper_x` "
"config section to disable the second homing move. The second homing attempt "
"does not add value when using sensorless homing, it will not work reliably, "
"and it will confuse the tuning process."
msgstr ""
"두 번째 원점복귀 이동을 비활성화하려면 `stepper_x` 구성 섹션에서 `homing_retract_dist` 설정은 0으로 설정해야 "
"합니다. 두 번째 원점복귀 시도는 센서리스 원점복귀를 사용할 때 설정값을 추가하지 않으며 안정적으로 작동하지 않으며 튜닝 프로세스를 "
"혼란스럽게 합니다."

msgid ""
"Be sure that a `hold_current` setting is not specified in the TMC driver "
"section of the config. (If a hold_current is set then after contact is made,"
" the motor stops while the carriage is pressed against the end of the rail, "
"and reducing the current while in that position may cause the carriage to "
"move - that results in poor performance and will confuse the tuning "
"process.)"
msgstr ""
"config의 TMC 드라이버 섹션에 `hold_current` 설정이 지정되지 않았는지 확인하십시오. (hold_current가 "
"설정되면 접촉 후 캐리지가 레일의 끝 부분에 대해 눌러지는 동안 모터가 정지하고 해당 위치에서 전류를 줄이면 캐리지가 움직일 수 "
"있습니다. 이는 성능이 저하 및 튜닝과정 혼란을 초래할 수 있습니다.)"

msgid ""
"It is necessary to configure the sensorless homing pins and to configure "
"initial \"stallguard\" settings. A tmc2209 example configuration for an X "
"axis might look like:"
msgstr ""
"센서리스 귀환 핀을 구성하고 초기 \"stallguard\" 설정을 구성해야 합니다. X축에 대한 tmc2209 예제 구성은 다음과 "
"같습니다:"

msgid "An example tmc2130 or tmc5160 config might look like:"
msgstr "tmc2130 또는 tmc5160 구성의 예는 다음과 같습니다:"

msgid "An example tmc2660 config might look like:"
msgstr "tmc2660 구성의 예는 다음과 같습니다:"

msgid ""
"The examples above only show settings specific to sensorless homing. See the"
" [config reference](Config_Reference.md#tmc-stepper-driver-configuration) "
"for all the available options."
msgstr ""
"위의 예는 센서리스 원점복귀와 관련된 설정만 보여줍니다. 사용 가능한 모든 옵션은 [구성 참조](Config_Reference.md"
"#tmc-stepper-driver-configuration) 를 참조하세요."

msgid "Find highest sensitivity that successfully homes"
msgstr "원점복귀에 가장 높은 민감도 성공적으로 찾기"

msgid ""
"Place the carriage near the center of the rail. Use the SET_TMC_FIELD "
"command to set the highest sensitivity. For tmc2209:"
msgstr ""
"레일 중앙 근처에 캐리지를 놓습니다. SET_TMC_FIELD 명령을 사용하여 가장 높은 민감도를 설정합니다. tmc2209의 경우:"

msgid "For tmc2130, tmc5160, and tmc2660:"
msgstr "tmc2130, tmc5160 및 tmc2660의 경우:"

msgid ""
"Then issue a `G28 X0` command and verify the axis does not move at all. If "
"the axis does move, then issue an `M112` to halt the printer - something is "
"not correct with the diag/sg_tst pin wiring or configuration and it must be "
"corrected before continuing."
msgstr ""
"그런 다음 `G28 X0` 명령을 실행하고 축이 전혀 움직이지 않는지 확인합니다. 축이 움직이면 `M112`를 실행하여 프린터를 "
"중지합니다. diag/sg_tst 핀 배선 또는 구성이 올바르지 않으므로 계속하기 전에 수정해야 합니다."

msgid ""
"Next, continually decrease the sensitivity of the `VALUE` setting and run "
"the `SET_TMC_FIELD` `G28 X0` commands again to find the highest sensitivity "
"that results in the carriage successfully moving all the way to the endstop "
"and halting. (For tmc2209 drivers this will be decreasing SGTHRS, for other "
"drivers it will be increasing sgt.) Be sure to start each attempt with the "
"carriage near the center of the rail (if needed issue `M84` and then "
"manually move the carriage to the center). It should be possible to find the"
" highest sensitivity that homes reliably (settings with higher sensitivity "
"result in small or no movement). Note the found value as "
"*maximum_sensitivity*. (If the minimum possible sensitivity (SGTHRS=0 or "
"sgt=63) is obtained without any carriage movement then something is not "
"correct with the diag/sg_tst pin wiring or configuration and it must be "
"corrected before continuing.)"
msgstr ""
"다음으로 `VALUE` 설정의 감도를 지속적으로 낮추고 `SET_TMC_FIELD` `G28 X0` 명령을 다시 실행하여 캐리지가 "
"엔드스톱까지 성공적으로 이동하고 정지하게 하는 가장 높은 감도를 찾습니다. (tmc2209 드라이버의 경우 SGTHRS가 감소하고 다른 "
"드라이버의 경우 sgt가 증가합니다.) 각 시도를 레일 중앙 근처에서 시작해야 합니다(필요한 경우 `M84`를 발행한 다음 캐리지를 "
"수동으로 센터). 가장 높은 감도를 안정적으로 찾을 수 있어야 합니다(감도가 높은 설정은 움직임이 적거나 없음). 발견된 값을 "
"*maximum_sensitivity*로 기록합니다. (캐리지 이동 없이 가능한 최소 감도(SGTHRS=0 또는 sgt=63)를 얻은 "
"경우 diag/sg_tst 핀 배선 또는 구성에 문제가 있는 것이므로 계속하기 전에 수정해야 합니다.)"

msgid ""
"When searching for maximum_sensitivity, it may be convenient to jump to "
"different VALUE settings (so as to bisect the VALUE parameter). If doing "
"this then be prepared to issue an `M112` command to halt the printer, as a "
"setting with a very low sensitivity may cause the axis to repeatedly "
"\"bang\" into the end of the rail."
msgstr ""
"maximum_sensitivity를 검색할 때 다른 VALUE 설정으로 이동하는 것이 편리할 수 있습니다(VALUE 매개변수를 "
"이등분하기 위해). 이 작업을 수행하는 경우 `M112` 명령을 실행하여 프린터를 중지할 준비를 하십시오. 매우 낮은 감도로 설정하면 "
"축이 레일 끝에 반복적으로 \"쿵\"할 수 있기 때문입니다."

msgid ""
"Be sure to wait a couple of seconds between each homing attempt. After the "
"TMC driver detects a stall it may take a little time for it to clear its "
"internal indicator and be capable of detecting another stall."
msgstr ""
"각 원점복귀 시도 사이에 몇 초 정도 기다려야 합니다. TMC 드라이버가 stall을 감지한 후 내부 표시기를 지우고 다른 stall을 "
"감지할 수 있을 때까지 약간의 시간이 걸릴 수 있습니다."

msgid ""
"During these tuning tests, if a `G28 X0` command does not move all the way "
"to the axis limit, then be careful with issuing any regular movement "
"commands (eg, `G1`). Klipper will not have a correct understanding of the "
"carriage position and a move command may cause undesirable and confusing "
"results."
msgstr ""
"이러한 튜닝 테스트 중에 `G28 X0` 명령이 축 제한까지 완전히 이동하지 않으면 일반 이동 명령(예: `G1`)을 실행할 때 "
"주의하십시오. Klipper는 캐리지 위치를 올바르게 이해하지 못하며 이동 명령은 바람직하지 않고 혼란스러운 결과를 초래할 수 있습니다."

msgid "Find lowest sensitivity that homes with one touch"
msgstr "원터치로 원점복귀에 가장 낮은 민감도 찾기"

msgid ""
"When homing with the found *maximum_sensitivity* value, the axis should move"
" to the end of the rail and stop with a \"single touch\" - that is, there "
"should not be a \"clicking\" or \"banging\" sound. (If there is a banging or"
" clicking sound at maximum_sensitivity then the homing_speed may be too low,"
" the driver current may be too low, or sensorless homing may not be a good "
"choice for the axis.)"
msgstr ""
"찾은 *maximum_sensitivity* 값으로 원점 복귀할 때 축은 레일 끝으로 이동하고 \"한 번의 터치\"로 정지해야 합니다. "
"즉, \"딸깍\" 또는 \"쿵\" 소리가 없어야 합니다. (max_sensitivity에서 두드리는 소리나 딸깍하는 소리가 나면 "
"homing_speed가 너무 낮거나 드라이버 전류가 너무 낮거나 센서리스 homing이 축에 적합한 선택이 아닐 수 있습니다.)"

msgid ""
"The next step is to again continually move the carriage to a position near "
"the center of the rail, decrease the sensitivity, and run the "
"`SET_TMC_FIELD` `G28 X0` commands - the goal is now to find the lowest "
"sensitivity that still results in the carriage successfully homing with a "
"\"single touch\". That is, it does not \"bang\" or \"click\" when contacting"
" the end of the rail. Note the found value as *minimum_sensitivity*."
msgstr ""
"다음 단계는 캐리지를 계속해서 레일 중앙 근처의 위치로 이동하고 민감도를 낮추고 `SET_TMC_FIELD` `G28 X0` 명령을 "
"실행하는 것입니다. 이제 목표는 여전히 캐리지가 \"한 번의 터치\"로 성공적으로 원점 복귀할 수 있는 가장 낮은 민감도를 찾는 "
"것입니다. 즉, 레일 끝부분에 닿았을 때 \"쾅\"하거나 \"딸깍\"하지 않습니다. 발견된 값을 *minimum_sensitivity*로 "
"기록합니다."

msgid "Update printer.cfg with sensitivity value"
msgstr "민감도 값으로 printer.cfg 업데이트"

msgid ""
"After finding *maximum_sensitivity* and *minimum_sensitivity*, use a "
"calculator to obtain the recommend sensitivity as *minimum_sensitivity + "
"(maximum_sensitivity - minimum_sensitivity)/3*. The recommended sensitivity "
"should be in the range between the minimum and maximum, but slightly closer "
"to the minimum. Round the final value to the nearest integer value."
msgstr ""
"*maximum_sensitivity* 및 *minimum_sensitivity*를 찾은 후 계산기를 사용하여 권장 민감도를 *"
"minimum_sensitivity + (maximum_sensitivity - minimum_sensitivity)/3*로 구합니다. "
"권장 민감도는 최소값과 최대값 사이의 범위에 있어야 하지만 최소값에 약간 더 가깝습니다. 최종 값을 가장 가까운 정수 값으로 반올림합니다."

msgid ""
"For tmc2209 set this in the config as `driver_SGTHRS`, for other TMC drivers"
" set this in the config as `driver_SGT`."
msgstr ""
"tmc2209의 경우 구성에서 `driver_SGTHRS`로 설정하고 다른 TMC 드라이버의 경우 구성에서 `driver_SGT`로 "
"설정합니다."

msgid ""
"If the range between *maximum_sensitivity* and *minimum_sensitivity* is "
"small (eg, less than 5) then it may result in unstable homing. A faster "
"homing speed may increase the range and make the operation more stable."
msgstr ""
"*maximum_sensitivity*와 *minimum_sensitivity* 사이의 범위가 작으면(예: 5 미만) 불안정한 원점 "
"복귀가 발생할 수 있습니다. 원점복귀 속도가 빠를수록 범위가 넓어지고 안정적인 작동이 가능합니다."

msgid ""
"Note that if any change is made to driver current, homing speed, or a "
"notable change is made to the printer hardware, then it will be necessary to"
" run the tuning process again."
msgstr "드라이버 전류, 원점복귀 속도가 변경되거나 프린터 하드웨어가 눈에 띄게 변경되면 조정 프로세스를 다시 실행해야 합니다."

msgid "Using Macros when Homing"
msgstr "원점 복귀 시 매크로 사용"

msgid ""
"After sensorless homing completes the carriage will be pressed against the "
"end of the rail and the stepper will exert a force on the frame until the "
"carriage is moved away. It is a good idea to create a macro to home the axis"
" and immediately move the carriage away from the end of the rail."
msgstr ""
"센서리스 원점복귀가 완료되면 캐리지가 레일의 끝 부분에 대해 눌려지고 스테퍼는 캐리지가 멀리 이동할 때까지 프레임에 힘을 가합니다. 축을 "
"홈으로 이동하고 즉시 캐리지를 레일 끝에서 멀리 이동하는 매크로를 만드는 것이 좋습니다."

msgid ""
"It is a good idea for the macro to pause at least 2 seconds prior to "
"starting sensorless homing (or otherwise ensure that there has been no "
"movement on the stepper for 2 seconds). Without a delay it is possible for "
"the driver's internal stall flag to still be set from a previous move."
msgstr ""
"센서리스 원점복귀를 시작하기 최소 2초 전에 매크로를 일시 중지하는 것이 좋습니다(또는 2초 동안 스테퍼에서 움직임이 없는지 확인). "
"지연 없이 드라이버의 내부 stall flag가 이전 이동에서 계속 설정될 수 있습니다."

msgid ""
"It can also be useful to have that macro set the driver current before "
"homing and set a new current after the carriage has moved away. This also "
"allows a hold_current to be set during prints (a hold_current is not "
"recommended during sensorless homing)."
msgstr ""
"또한 해당 매크로가 원점복귀 전에 드라이버 전류를 설정하고 캐리지가 멀리 이동한 후에 새 전류를 설정하도록 하는 것이 유용할 수 "
"있습니다. 이것은 또한 인쇄 중에 hold_current를 설정할 수 있도록 합니다 (hold_current는 센서리스 원점복귀 중에는 "
"권장되지 않음)."

msgid "An example macro might look something like:"
msgstr "예제 매크로는 다음과 같습니다:"

msgid ""
"The resulting macro can be called from a [homing_override config "
"section](Config_Reference.md#homing_override) or from a [START_PRINT "
"macro](Slicers.md#klipper-gcode_macro)."
msgstr ""
"결과 매크로는 [homing_override 구성 섹션](Config_Reference.md#homing_override) 또는 ["
"START_PRINT 매크로](Slicers.md#klipper-gcode_macro)에서 호출할 수 있습니다."

msgid ""
"Note that if the driver current during homing is changed, then the tuning "
"process should be run again."
msgstr "원점복귀 중 드라이버 전류가 변경되면 튜닝 프로세스를 다시 실행해야 합니다."

msgid "Tips for sensorless homing on CoreXY"
msgstr "CoreXY에서 센서리스 원점복귀를 위한 팁"

msgid ""
"It is possible to use sensorless homing on the X and Y carriages of a CoreXY"
" printer. Klipper uses the `[stepper_x]` stepper to detect stalls when "
"homing the X carriage and uses the `[stepper_y]` stepper to detect stalls "
"when homing the Y carriage."
msgstr ""
"CoreXY 프린터의 X 및 Y 캐리지에서 센서리스 원점복귀를 사용할 수 있습니다. Klipper는 `[stepper_x]` 스테퍼를 "
"사용하여 X 캐리지를 원점복귀할 때 stall을 감지하고 `[stepper_y]` 스테퍼를 사용하여 Y 캐리지를 원점복귀할 때 "
"stall을 감지합니다."

msgid ""
"Use the tuning guide described above to find the appropriate \"stall "
"sensitivity\" for each carriage, but be aware of the following restrictions:"
msgstr ""
"위에서 설명한 조정 가이드를 사용하여 각 캐리지에 적절한 \"stall 민감도\"를 찾으십시오. 단, 다음 제한 사항에 유의하십시오:"

msgid ""
"When using sensorless homing on CoreXY, make sure there is no `hold_current`"
" in effect for either stepper during homing."
msgstr ""
"CoreXY에서 센서리스 원점복귀를 사용할 때 원점복귀 중 두 스테퍼에 대해 `hold_current`가 적용되지 않는지 확인하십시오."

msgid ""
"While tuning, make sure both the X and Y carriages are near the center of "
"their rails before each home attempt."
msgstr "조정하는 동안 각 원점복귀 시도 전에 X 및 Y 캐리지가 레일 중앙 근처에 있는지 확인하십시오."

msgid ""
"After tuning is complete, when homing both X and Y, use macros to ensure "
"that one axis is homed first, then move that carriage away from the axis "
"limit, pause for at least 2 seconds, and then start the homing of the other "
"carriage. The move away from the axis avoids homing one axis while the other"
" is pressed against the axis limit (which may skew the stall detection). The"
" pause is necessary to ensure the driver's stall flag is cleared prior to "
"homing again."
msgstr ""
"조정이 완료된 후 X와 Y를 모두 원점복귀시킬 때 매크로를 사용하여 한 축이 먼저 원점복귀되도록 한 다음 해당 캐리지를 축 제한에서 멀리 "
"이동하고 최소 2초 동안 일시 중지한 다음 다른 캐리지의 원점복귀를 시작합니다. 축에서 멀어지면 다른 축이 축 제한에 대해 눌러지는 동안 "
"한 축의 원점복귀를 방지합니다 (스톨 감지가 왜곡될 수 있음). 다시 원점복귀하기 전에 드라이버의 stall flag가 지워지도록 하려면 "
"일시 중지가 필요합니다."

msgid "Querying and diagnosing driver settings"
msgstr "드라이버 설정 쿼리 및 진단"

msgid ""
"The `[DUMP_TMC command](G-Codes.md#tmc-stepper-drivers) is a useful tool "
"when configuring and diagnosing the drivers. It will report all fields "
"configured by Klipper as well as all fields that can be queried from the "
"driver."
msgstr ""
"`[DUMP_TMC 명령](G-Codes.md#tmc-stepper-drivers)은 드라이버를 구성하고 진단할 때 유용한 도구입니다. "
"Klipper가 구성한 모든 필드와 드라이버에서 쿼리할 수 있는 모든 필드를 보고합니다."

msgid ""
"All of the reported fields are defined in the Trinamic datasheet for each "
"driver. These datasheets can be found on the [Trinamic "
"website](https://www.trinamic.com/). Obtain and review the Trinamic "
"datasheet for the driver to interpret the results of DUMP_TMC."
msgstr ""
"보고된 모든 필드는 각 드라이버에 대한 Trinamic 데이터시트에 정의되어 있습니다. 이 데이터시트는 [Trinamic "
"웹사이트](https://www.trinamic.com/)에서 찾을 수 있습니다. 드라이버가 DUMP_TMC의 결과를 해석할 수 있도록 "
"Trinamic 데이터시트를 구하고 검토하십시오."

msgid "Configuring driver_XXX settings"
msgstr "driver_XXX 설정 구성"

msgid ""
"Klipper supports configuring many low-level driver fields using `driver_XXX`"
" settings. The [TMC driver config reference](Config_Reference.md#tmc-"
"stepper-driver-configuration) has the full list of fields available for each"
" type of driver."
msgstr ""
"Klipper는 `driver_XXX` 설정을 사용하여 많은 하위 수준 드라이버 필드 구성을 지원합니다. [TMC 드라이버 구성 "
"참조](Config_Reference.md#tmc-stepper-driver-configuration)에는 각 드라이버 유형에 사용할 수 "
"있는 전체 필드 목록이 있습니다."

msgid ""
"In addition, almost all fields can be modified at run-time using the "
"[SET_TMC_FIELD command](G-Codes.md#tmc-stepper-drivers)."
msgstr ""
"또한 [SET_TMC_FIELD 명령](G-Codes.md#tmc-stepper-drivers)을 사용하여 런타임 시 거의 모든 필드를 "
"수정할 수 있습니다."

msgid ""
"Each of these fields is defined in the Trinamic datasheet for each driver. "
"These datasheets can be found on the [Trinamic "
"website](https://www.trinamic.com/)."
msgstr ""
"이러한 각 필드는 각 드라이버에 대한 Trinamic 데이터시트에 정의되어 있습니다. 이 데이터시트는 [Trinamic "
"웹사이트](https://www.trinamic.com/)에서 찾을 수 있습니다."

msgid ""
"Note that the Trinamic datasheets sometime use wording that can confuse a "
"high-level setting (such as \"hysteresis end\") with a low-level field value"
" (eg, \"HEND\"). In Klipper, `driver_XXX` and SET_TMC_FIELD always set the "
"low-level field value that is actually written to the driver. So, for "
"example, if the Trinamic datasheet states that a value of 3 must be written "
"to the HEND field to obtain a \"hysteresis end\" of 0, then set "
"`driver_HEND=3` to obtain the high-level value of 0."
msgstr ""
"Trinamic 데이터시트는 때때로 높은 수준의 설정(예: \"hysteresis end\")과 낮은 수준의 필드 값(예: \"HEND\""
")을 혼동할 수 있는 문구를 사용합니다. Klipper에서 `driver_XXX`와 SET_TMC_FIELD는 항상 실제로 드라이버에 "
"기록되는 하위 수준 필드 값을 설정합니다. 따라서 예를 들어 Trinamic 데이터시트에 \"hysteresis end\" 0을 얻기 "
"위해 값 3을 HEND 필드에 기록해야 한다고 명시되어 있으면 `driver_HEND=3`을 설정하여 상위 수준 값 0을 얻습니다."

msgid "Common Questions"
msgstr "일반적인 질문"

msgid "Can I use stealthchop mode on an extruder with pressure advance?"
msgstr "pressure advance 기능이 있는 압출기에서 stealthchop 모드를 사용할 수 있습니까?"

msgid ""
"Many people successfully use \"stealthchop\" mode with Klipper's pressure "
"advance. Klipper implements [smooth pressure "
"advance](Kinematics.md#pressure-advance) which does not introduce any "
"instantaneous velocity changes."
msgstr ""
"많은 사람들이 Klipper의 pressure advance으로 \"stealthchop\" 모드를 성공적으로 사용합니다. "
"Klipper는 즉각적인 속도 변화를 도입하지 않는 [smooth pressure advance](Kinematics.md"
"#pressure-advance)을 구현합니다."

msgid ""
"However, \"stealthchop\" mode may produce lower motor torque and/or produce "
"higher motor heat. It may or may not be an adequate mode for your particular"
" printer."
msgstr ""
"그러나 \"stealthchop\" 모드는 더 낮은 모터 토크를 생성하거나 더 높은 모터 열을 생성할 수 있습니다. 특정 프린터에 적합한 "
"모드일 수도 있고 아닐 수도 있습니다."

msgid ""
"I keep getting \"Unable to read tmc uart 'stepper_x' register IFCNT\" "
"errors?"
msgstr "\"Unable to read tmc uart 'stepper_x' register IFCNT\" 오류가 계속 발생합니까?"

msgid ""
"This occurs when Klipper is unable to communicate with a tmc2208 or tmc2209 "
"driver."
msgstr "이것은 Klipper가 tmc2208 또는 tmc2209 드라이버와 통신할 수 없을 때 발생합니다."

msgid ""
"Make sure that the motor power is enabled, as the stepper motor driver "
"generally needs motor power before it can communicate with the micro-"
"controller."
msgstr ""
"스테퍼 모터 드라이버는 일반적으로 마이크로 컨트롤러와 통신하기 전에 모터 전원이 필요하므로 모터 전원이 활성화되어 있는지 확인하십시오."

msgid ""
"If this error occurs after flashing Klipper for the first time, then the "
"stepper driver may have been previously programmed in a state that is not "
"compatible with Klipper. To reset the state, remove all power from the "
"printer for several seconds (physically unplug both USB and power plugs)."
msgstr ""
"이 오류가 Klipper를 처음 깜박인 후 발생하면 스테퍼 드라이버가 이전에 Klipper와 호환되지 않는 상태로 프로그래밍되었을 수 "
"있습니다. 상태를 재설정하려면 몇 초 동안 프린터에서 모든 전원을 제거하십시오(USB와 전원 플러그를 모두 물리적으로 분리)."

msgid ""
"Otherwise, this error is typically the result of incorrect UART pin wiring "
"or an incorrect Klipper configuration of the UART pin settings."
msgstr "그렇지 않으면 이 오류는 일반적으로 잘못된 UART 핀 배선 또는 UART 핀 설정의 잘못된 Klipper 구성의 결과입니다."

msgid ""
"I keep getting \"Unable to write tmc spi 'stepper_x' register ...\" errors?"
msgstr "\"Unable to write tmc spi 'stepper_x' register ...\" 오류가 계속 발생합니까?"

msgid ""
"This occurs when Klipper is unable to communicate with a tmc2130 or tmc5160 "
"driver."
msgstr "이것은 Klipper가 tmc2130 또는 tmc5160 드라이버와 통신할 수 없을 때 발생합니다."

msgid ""
"Otherwise, this error is typically the result of incorrect SPI wiring, an "
"incorrect Klipper configuration of the SPI settings, or an incomplete "
"configuration of devices on an SPI bus."
msgstr ""
"그렇지 않으면 이 오류는 일반적으로 잘못된 SPI 배선, SPI 설정의 잘못된 Klipper 구성 또는 SPI 버스의 장치 구성이 "
"불완전한 결과입니다."

msgid ""
"Note that if the driver is on a shared SPI bus with multiple devices then be"
" sure to fully configure every device on that shared SPI bus in Klipper. If "
"a device on a shared SPI bus is not configured, then it may incorrectly "
"respond to commands not intended for it and corrupt the communication to the"
" intended device. If there is a device on a shared SPI bus that can not be "
"configured in Klipper, then use a [static_digital_output config "
"section](Config_Reference.md#static_digital_output) to set the CS pin of the"
" unused device high (so that it will not attempt to use the SPI bus). The "
"board's schematic is often a useful reference for finding which devices are "
"on an SPI bus and their associated pins."
msgstr ""
"드라이버가 여러 장치가 있는 공유 SPI 버스에 있는 경우 Klipper에서 해당 공유 SPI 버스의 모든 장치를 완전히 구성해야 "
"합니다. 공유 SPI 버스의 장치가 구성되지 않은 경우 의도하지 않은 명령에 잘못 응답하고 의도한 장치에 대한 통신이 손상될 수 "
"있습니다. Klipper에서 구성할 수 없는 공유 SPI 버스에 장치가 있는 경우 [static_digital_output config "
"섹션](Config_Reference.md#static_digital_output)을 사용하여 사용하지 않는 장치의 CS 핀을 높음으로 "
"설정합니다. SPI 버스를 사용하기 위해 보드의 회로도는 SPI 버스 및 관련 핀에 있는 장치를 찾는 데 유용한 참조가 되는 경우가 "
"많습니다."

msgid "Why did I get a \"TMC reports error: ...\" error?"
msgstr "\"TMC 보고서 오류: ...\" 오류가 발생한 이유는 무엇입니까?"

msgid ""
"This type of error indicates the TMC driver detected a problem and has "
"disabled itself. That is, the driver stopped holding its position and "
"ignored movement commands. If Klipper detects that an active driver has "
"disabled itself, it will transition the printer into a \"shutdown\" state."
msgstr ""
"이 유형의 오류는 TMC 드라이버가 문제를 감지하고 자체적으로 비활성화 되었음을 나타냅니다. 즉, 드라이버가 위치 유지를 중지하고 이동 "
"명령을 무시했습니다. Klipper는 활성 드라이버가 자체적으로 비활성화되었음을 감지하면 프린터를 \"shutdown\" 상태로 "
"전환합니다."

msgid "Some common errors and tips for diagnosing them:"
msgstr "몇 가지 일반적인 오류 및 진단 팁:"

msgid ""
"**TMC reports error: ... ot=1(OvertempError!)\"**: This indicates the motor "
"driver disabled itself because it became too hot. Typical solutions are to "
"decrease the stepper motor current, increase cooling on the stepper motor "
"driver, and/or increase cooling on the stepper motor."
msgstr ""
"**TMC reports error: ... ot=1(OvertempError!)\"**: 이것은 모터 드라이버가 너무 뜨거워져서 스스로 "
"비활성화되었음을 나타냅니다. 일반적인 솔루션은 스테퍼 모터 전류를 낮추고, 스테퍼 모터 드라이버의 냉각을 높이거나, 스테퍼 모터의 냉각을 "
"높이는 것입니다."

msgid ""
"**TMC reports error: ... ShortToGND** OR **LowSideShort**: This indicates "
"the driver has disabled itself because it detected very high current passing"
" through the driver. This may indicate a loose or shorted wire to the "
"stepper motor or within the stepper motor itself."
msgstr ""
"**TMC reports error: ... ShortToGND** OR **LowSideShort**: 이것은 드라이버를 통과하는 매우 "
"높은 전류를 감지했기 때문에 드라이버가 스스로 비활성화되었음을 나타냅니다. 이것은 스테퍼 모터 또는 스테퍼 모터 자체 내부의 느슨하거나 "
"단락된 와이어를 나타낼 수 있습니다."

msgid ""
"This error may also occur if using stealthchop mode and the TMC driver is "
"not able to accurately predict the mechanical load of the motor. (If the "
"driver makes a poor prediction then it may send too much current through the"
" motor and trigger its own over-current detection.) To test this, disable "
"stealthchop mode and check if the errors continue to occur."
msgstr ""
"이 오류는 stealthchop 모드를 사용하고 TMC 드라이버가 모터의 기계적 부하를 정확하게 예측할 수 없는 경우에도 발생할 수 "
"있습니다. (드라이버가 잘못된 예측을 하면 모터를 통해 너무 많은 전류를 보내고 자체 과전류 감지를 트리거할 수 있습니다.) 이를 "
"테스트하려면 stealthchop 모드를 비활성화하고 오류가 계속 발생하는지 확인하십시오."

msgid ""
"**TMC reports error: ... reset=1(Reset)** OR **CS_ACTUAL=0(Reset?)** OR "
"**SE=0(Reset?)**: This indicates that the driver has reset itself mid-print."
" This may be due to voltage or wiring issues."
msgstr ""
"**TMC reports error: ... reset=1(Reset)** OR **CS_ACTUAL=0(Reset?)** OR "
"**SE=0(Reset?)**: 이것은 드라이버가 인쇄 중간에 재설정되었음을 나타냅니다. 이는 전압 또는 배선 문제로 인한 것일 수 "
"있습니다."

msgid ""
"**TMC reports error: ... uv_cp=1(Undervoltage!)**: This indicates the driver"
" has detected a low-voltage event and has disabled itself. This may be due "
"to wiring or power supply issues."
msgstr ""
"**TMC reports error: ... uv_cp=1(Undervoltage!)**: 이는 드라이버가 저전압 이벤트를 감지하고 "
"자체적으로 비활성화되었음을 나타냅니다. 이는 배선 또는 전원 공급 문제로 인한 것일 수 있습니다."

msgid ""
"It's also possible that a **TMC reports error** shutdown occurs due to SPI "
"errors that prevent communication with the driver (on tmc2130, tmc5160, or "
"tmc2660). If this occurs, it's common for the reported driver status to show"
" `00000000` or `ffffffff` - for example: `TMC reports error: DRV_STATUS: "
"ffffffff ...` OR `TMC reports error: READRSP@RDSEL2: 00000000 ...`. Such a "
"failure may be due to an SPI wiring problem or may be due to a self-reset or"
" failure of the TMC driver."
msgstr ""
"드라이버와의 통신을 방해하는 SPI 오류로 인해 **TMC가 오류 보고** 종료가 발생할 수도 있습니다(tmc2130, tmc5160 "
"또는 tmc2660에서). 이 경우 보고된 드라이버 상태가 `00000000` 또는 `ffffffff`로 표시되는 것이 일반적입니다. 예:"
" `TMC 보고 오류: DRV_STATUS: ffffffff ...' 또는 `TMC 보고 오류: READRSP@RDSEL2: "
"00000000 ... `. 이러한 오류는 SPI 배선 문제로 인한 것일 수도 있고 자체 재설정 또는 TMC 드라이버의 오류로 인한 것일 "
"수도 있습니다."

msgid "How do I tune spreadcycle/coolstep/etc. mode on my drivers?"
msgstr "Spreadcycle/coolstep 등을 어떻게 조정합니까? 내 드라이버의 모드?"

msgid ""
"The [Trinamic website](https://www.trinamic.com/) has guides on configuring "
"the drivers. These guides are often technical, low-level, and may require "
"specialized hardware. Regardless, they are the best source of information."
msgstr ""
"[Trinamic 웹사이트](https://www.trinamic.com/)에는 드라이버 구성에 대한 가이드가 있습니다. 이 가이드는 "
"종종 기술적이고 낮은 수준이며 특수 하드웨어가 필요할 수 있습니다. 그럼에도 불구하고 그들은 최고의 정보 소스입니다."

msgid ""
"[stepper_x]\n"
"rotation_distance: 40\n"
"homing_speed: 20\n"
"...\n"
msgstr ""
"[stepper_x]\n"
"rotation_distance: 40\n"
"homing_speed: 20\n"
"...\n"

msgid ""
"[tmc2209 stepper_x]\n"
"diag_pin: ^PA1      # Set to MCU pin connected to TMC DIAG pin\n"
"driver_SGTHRS: 255  # 255 is most sensitive value, 0 is least sensitive\n"
"...\n"
"\n"
"[stepper_x]\n"
"endstop_pin: tmc2209_stepper_x:virtual_endstop\n"
"homing_retract_dist: 0\n"
"...\n"
msgstr ""
"[tmc2209 stepper_x]\n"
"diag_pin: ^PA1      # Set to MCU pin connected to TMC DIAG pin\n"
"driver_SGTHRS: 255  # 255 is most sensitive value, 0 is least sensitive\n"
"...\n"
"\n"
"[stepper_x]\n"
"endstop_pin: tmc2209_stepper_x:virtual_endstop\n"
"homing_retract_dist: 0\n"
"...\n"

msgid ""
"[tmc2130 stepper_x]\n"
"diag1_pin: ^!PA1 # Pin connected to TMC DIAG1 pin (or use diag0_pin / DIAG0 pin)\n"
"driver_SGT: -64  # -64 is most sensitive value, 63 is least sensitive\n"
"...\n"
"\n"
"[stepper_x]\n"
"endstop_pin: tmc2130_stepper_x:virtual_endstop\n"
"homing_retract_dist: 0\n"
"...\n"
msgstr ""
"[tmc2130 stepper_x]\n"
"diag1_pin: ^!PA1 # Pin connected to TMC DIAG1 pin (or use diag0_pin / DIAG0 "
"pin)\n"
"driver_SGT: -64  # -64 is most sensitive value, 63 is least sensitive\n"
"...\n"
"\n"
"[stepper_x]\n"
"endstop_pin: tmc2130_stepper_x:virtual_endstop\n"
"homing_retract_dist: 0\n"
"...\n"

msgid ""
"[tmc2660 stepper_x]\n"
"driver_SGT: -64     # -64 is most sensitive value, 63 is least sensitive\n"
"...\n"
"\n"
"[stepper_x]\n"
"endstop_pin: ^PA1   # Pin connected to TMC SG_TST pin\n"
"homing_retract_dist: 0\n"
"...\n"
msgstr ""
"[tmc2660 stepper_x]\n"
"driver_SGT: -64     # -64 is most sensitive value, 63 is least sensitive\n"
"...\n"
"\n"
"[stepper_x]\n"
"endstop_pin: ^PA1   # Pin connected to TMC SG_TST pin\n"
"homing_retract_dist: 0\n"
"...\n"

msgid "SET_TMC_FIELD STEPPER=stepper_x FIELD=SGTHRS VALUE=255\n"
msgstr "SET_TMC_FIELD STEPPER=stepper_x FIELD=SGTHRS VALUE=255\n"

msgid "SET_TMC_FIELD STEPPER=stepper_x FIELD=sgt VALUE=-64\n"
msgstr "SET_TMC_FIELD STEPPER=stepper_x FIELD=sgt VALUE=-64\n"

msgid ""
"[gcode_macro SENSORLESS_HOME_X]\n"
"gcode:\n"
"    {% set HOME_CUR = 0.700 %}\n"
"    {% set driver_config = printer.configfile.settings['tmc2209 stepper_x'] %}\n"
"    {% set RUN_CUR = driver_config.run_current %}\n"
"    {% set HOLD_CUR = driver_config.hold_current %}\n"
"    # Set current for sensorless homing\n"
"    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={HOME_CUR} HOLDCURRENT={HOME_CUR}\n"
"    # Pause to ensure driver stall flag is clear\n"
"    G4 P2000\n"
"    # Home\n"
"    G28 X0\n"
"    # Move away\n"
"    G90\n"
"    G1 X5 F1200\n"
"    # Set current during print\n"
"    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={RUN_CUR} HOLDCURRENT={HOLD_CUR}\n"
msgstr ""
"[gcode_macro SENSORLESS_HOME_X]\n"
"gcode:\n"
"    {% set HOME_CUR = 0.700 %}\n"
"    {% set driver_config = printer.configfile.settings['tmc2209 stepper_x'] "
"%}\n"
"    {% set RUN_CUR = driver_config.run_current %}\n"
"    {% set HOLD_CUR = driver_config.hold_current %}\n"
"    # Set current for sensorless homing\n"
"    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={HOME_CUR} "
"HOLDCURRENT={HOME_CUR}\n"
"    # Pause to ensure driver stall flag is clear\n"
"    G4 P2000\n"
"    # Home\n"
"    G28 X0\n"
"    # Move away\n"
"    G90\n"
"    G1 X5 F1200\n"
"    # Set current during print\n"
"    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={RUN_CUR} "
"HOLDCURRENT={HOLD_CUR}\n"

#: docs/TMC_Drivers.md:block 1 (header)
msgid "TMC drivers"
msgstr "TMC 드라이버"
