# brian park <gouache95@gmail.com>, 2021.
# bookledge <bookledge@gmail.com>, 2021.
msgid ""
msgstr ""
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"PO-Revision-Date: 2021-08-23 03:57+0000\n"
"Last-Translator: bookledge <bookledge@gmail.com>\n"
"Language-Team: Korean <https://hosted.weblate.org/projects/klipper/benchmarks/ko/>\n"
"Language: ko\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.8.1-dev\n"

msgid "This document describes Klipper benchmarks."
msgstr "이 문서는 클리퍼의 벤치마크에 대한 내용이다."

msgid "Micro-controller Benchmarks"
msgstr "마이크로 컨트롤러 벤치마크"

msgid ""
"This section describes the mechanism used to generate the Klipper micro-"
"controller step rate benchmarks."
msgstr "이 섹션은 클리퍼 마이크로 컨트롤러의 step rate 벤치마크를 생성하는데 사용된 메카니즘에 대해 기술하고 있다."

msgid ""
"The primary goal of the benchmarks is to provide a consistent mechanism for "
"measuring the impact of coding changes within the software. A secondary goal"
" is to provide high-level metrics for comparing the performance between "
"chips and between software platforms."
msgstr ""
"벤치마크의 첫번째 목표는 소프트웨어안의 코딩 변화의 영향을 측정하는 일관된 메카니즘을 제공하는 것이다. 두번째 목표는 칩들 사이, "
"소프트웨어 플랫폼 사이의 성능비교를 위한 높은 레벨의 매트릭스를 제공하는 것이다."

msgid ""
"The step rate benchmark is designed to find the maximum stepping rate that "
"the hardware and software can reach. This benchmark stepping rate is not "
"achievable in day-to-day use as Klipper needs to perform other tasks (eg, "
"mcu/host communication, temperature reading, endstop checking) in any real-"
"world usage."
msgstr ""
"Step rate 벤치마크는 하드웨어와 소프트웨어가 도달할 수 있는 최대 스텝 레이트를 찾도록 설계되어 있다. 이 벤치마크 스텝 레이트는"
" 매일매일의 사용으로는 얻어질 수 없다. 왜냐하면 클리퍼는 mcu/host 커뮤니케이션, 온도 확인, 엔드스탑 체크 등의 실제 "
"사용환경속에서 일어나는 다른 작업들도 행해야 하기 때문이다."

msgid ""
"In general, the pins for the benchmark tests are chosen to flash LEDs or "
"other innocuous pins. **Always verify that it is safe to drive the "
"configured pins prior to running a benchmark.** It is not recommended to "
"drive an actual stepper during a benchmark."
msgstr ""
"일반적으로, 벤치마크 테스트를 위한 핀들은 LED를 밝히거나 다른 무해한 핀들에서 선택되어진다. **벤치마크를 돌리기에 앞서 설정된 핀을"
" 돌리는게 안전한지를 항상 먼저 확인해야 한다.** 벤치마크중에는 실제 스텝모터를 돌리는건 추천되지 않는다."

msgid "Step rate benchmark test"
msgstr "스텝 레이트 벤치마크 테스트"

msgid ""
"The above tests three steppers simultaneously stepping. If running the above"
" results in a \"Rescheduled timer in the past\" or \"Stepper too far in "
"past\" error then it indicates the `ticks` parameter is too low (it results "
"in a stepping rate that is too fast). The goal is to find the lowest setting"
" of the ticks parameter that reliably results in a successful completion of "
"the test. It should be possible to bisect the ticks parameter until a stable"
" value is found."
msgstr ""
"위 코드는 세개의 스텝모터를 동시적으로 스텝핑하는 테스트를 진행한다. 위 코드를 실행시키면 \"Rescheduled timer in "
"the past\" 혹은 \"Stepper too far in past\" 라는 에러가 나는데, 그것은 `ticks` 파라메터가 너무 "
"낮다는 것을 말한다. (스텝핑 레이트가 너무 빠르다는 결과이다). 목표는 테스트를 성공적으로 마치는 안정적인 가장 낮은 ticks "
"파라메터의 셋팅을 찾는 것이다. 안정적인 값을 찾을때 까지 ticks 파라메터를 이등분 할 수 있어야 한다."

msgid ""
"On a failure, one can copy-and-paste the following to clear the error in "
"preparation for the next test:"
msgstr "실패시 다음 테스트를 준비하기 위해 에러를 클리어 해야 하는데 다음에 나오는 명령어를 복붙해 사용하면 된다.:"

msgid ""
"To obtain the single stepper and dual stepper benchmarks, the same "
"configuration sequence is used, but only the first block (for the single "
"stepper case) or first two blocks (for the dual stepper case) of the above "
"test is cut-and-paste into the console.py window."
msgstr ""
"싱글 스텝모터나 듀얼 스텝모터의 벤치마크값을 얻기 위해서도 동일한 설정 시퀀스를 사용하면 된다. 단지, 위 테스트에 나오는 첫번째 "
"블록(싱글 스텝퍼의 경우), 처음나오는 두개의 블록(듀얼 스텝퍼의 경우)을 console.py 창에 복붙 하면 된다."

msgid ""
"To produce the benchmarks found in the Features.md document, the total "
"number of steps per second is calculated by multiplying the number of active"
" steppers with the nominal mcu frequency and dividing by the final ticks "
"parameter. The results are rounded to the nearest K. For example, with three"
" active steppers:"
msgstr ""
"Features.md 문서에 있는 벤치마크들을 생성하기 위해서, 초당 전체 스텝수는 명목상의 mcu 주파수와 활성 스텝모터의 수를 곱하고"
" 최종 tick 파라메터로 나누어 계산되어진다. 결과는 가장 가까운 K 로 반올림된다. 예를 들어 세개의 스텝모터라면 :"

msgid ""
"Benchmarks may be run with the micro-controller code compiled using a \"step"
" pulse duration\" of zero (the tables below report this as \"no delay\"). "
"This configuration is believed to be valid in real-world usage when one is "
"solely using Trinamic stepper drivers. The results of these benchmarks are "
"not reported in the Features.md document."
msgstr ""
"벤치마크는 zero(아래 테이블을 통해 보면 이것은 delay 가 없음을 나타낸다)의 \"step pulse duration\"을 "
"사용하여 컴파일된 마이크로 컨트롤러로 돌려야 한다. 이 설정은 TMC 드라이버를 사용할때에만 실제세상의 사용에 유용하다고 믿어진다. 이 "
"벤치마크 결과들은 Features.md 문서에 기록되지 않는다."

msgid "AVR step rate benchmark"
msgstr "AVR 스텝 레이트 벤치마크"

msgid "The following configuration sequence is used on AVR chips:"
msgstr "다음에 나오는 설정 시퀀스는 AVR 칩에 적용된다.:"

msgid ""
"The test was last run on commit `01d2183f` with gcc version `avr-gcc (GCC) "
"5.4.0`. Both the 16Mhz and 20Mhz tests were run using simulavr configured "
"for an atmega644p (previous tests have confirmed simulavr results match "
"tests on both a 16Mhz at90usb and a 16Mhz atmega2560)."
msgstr ""
"테스트는 gcc의 `avr-gcc(GCC) 5.4.0` 버전을 사용하여 `01d2183f` 커밋상에서 최종적으로 돌려졌다. 16Mhz 와"
" 20Mhz 테스트 모두 atmega644p를 위해 설정된 simulavr을 사용해 돌려졌다. (앞선 테스트들에서 simulavr 결과가"
" 16Mhz at90usb 와 16Mhz atmega2560 에서 테스트한 값과 같음을 확인했습니다)."

msgid "avr"
msgstr "avr"

msgid "ticks"
msgstr "ticks"

msgid "1 stepper"
msgstr "한개의 스텝모터"

msgid "104"
msgstr "104"

msgid "2 stepper"
msgstr "두개의 스텝모터"

msgid "296"
msgstr "296"

msgid "3 stepper"
msgstr "세개의 스텝모터"

msgid "472"
msgstr "472"

msgid "Arduino Due step rate benchmark"
msgstr "Arduino Due 스텝레이트 벤치마크"

msgid "The following configuration sequence is used on the Due:"
msgstr "이어지는 설정 시퀀스는 Due 에서 사용되어진다. :"

msgid ""
"The test was last run on commit `8d4a5c16` with gcc version `arm-none-eabi-"
"gcc (Fedora 7.4.0-1.fc30) 7.4.0`."
msgstr ""
"테스트는 gcc의 `arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0` 버전에서 `8d4a5c16` "
"커밋상에 마지막으로 실행되었다."

msgid "sam3x8e"
msgstr "sam3x8e"

msgid "388"
msgstr "388"

msgid "405"
msgstr "405"

msgid "576"
msgstr "576"

msgid "1 stepper (no delay)"
msgstr "한개의 스텝모터 (delay 없음)"

msgid "77"
msgstr "77"

msgid "3 stepper (no delay)"
msgstr "세개의 스텝모터 (delay 없음)"

msgid "299"
msgstr "299"

msgid "Duet Maestro step rate benchmark"
msgstr "Duet Maestro 스텝 레이트 벤치마크"

msgid "The following configuration sequence is used on the Duet Maestro:"
msgstr "이어지는 설정 시퀀스는 Duet Maestro에서 사용된다.:"

msgid "sam4s8c"
msgstr "sam4s8c"

msgid "527"
msgstr "527"

msgid "535"
msgstr "535"

msgid "638"
msgstr "638"

msgid "70"
msgstr "70"

msgid "254"
msgstr "254"

msgid "Duet Wifi step rate benchmark"
msgstr "Duet Wifi 스텝 레이트 벤치마크"

msgid "The following configuration sequence is used on the Duet Wifi:"
msgstr "이어지는 설정 시퀀스는 Duet Wifi 에서 사용된다:"

msgid ""
"The test was last run on commit `59a60d68` with gcc version `arm-none-eabi-"
"gcc 7.3.1 20180622 (release) [ARM/embedded-7-branch revision 261907]`."
msgstr ""
"테스트는 gcc의 `arm-none-eabi-gcc 7.3.1 20180622 (release) [ARM/embedded-7-branch"
" revision 261907]` 버전에서 `59a60d68` 커밋상에 마지막으로 실행되었다."

msgid "sam4e8e"
msgstr "sam4e8e"

msgid "519"
msgstr "519"

msgid "520"
msgstr "520"

msgid "525"
msgstr "525"

msgid "4 stepper"
msgstr "네개의 스텝모터"

msgid "703"
msgstr "703"

msgid "Beaglebone PRU step rate benchmark"
msgstr "Beaglebone PRU 스텝 레이트 벤치마크"

msgid "The following configuration sequence is used on the PRU:"
msgstr "이어지는 설정 시퀀스는 RPU 에서 사용된다:"

msgid ""
"The test was last run on commit `b161a69e` with gcc version `pru-gcc (GCC) "
"8.0.0 20170530 (experimental)`."
msgstr ""
"테스트는 gcc의 `pru-gcc (GCC) 8.0.0 20170530 (experimental)` 버전에서 `b161a69e` 커밋상에"
" 마지막으로 실행되었다."

msgid "pru"
msgstr "pru"

msgid "861"
msgstr "861"

msgid "853"
msgstr "853"

msgid "883"
msgstr "883"

msgid "STM32F042 step rate benchmark"
msgstr "STM32F042 스텝 레이트 벤치마크"

msgid "The following configuration sequence is used on the STM32F042:"
msgstr "이어지는 설정 시퀀스는 STM32F042 에서 사용된다:"

msgid ""
"The test was last run on commit `0b0c47c5` with gcc version `arm-none-eabi-"
"gcc (Fedora 9.2.0-1.fc30) 9.2.0`."
msgstr ""
"테스트는 gcc의 `arm-none-eabi-gcc (Fedora 9.2.0-1.fc30) 9.2.0` 버전에서 `0b0c47c5` "
"커밋상에 마지막으로 실행되었다."

msgid "stm32f042"
msgstr "stm32f042"

msgid "247"
msgstr "247"

msgid "328"
msgstr "328"

msgid "558"
msgstr "558"

msgid "STM32F103 step rate benchmark"
msgstr "STM32F103 스텝 레이트 벤치마크"

msgid "The following configuration sequence is used on the STM32F103:"
msgstr "이어지는 설정 시퀀스는 STM32F103 에서 사용된다:"

msgid "stm32f103"
msgstr "stm32f103"

msgid "347"
msgstr "347"

msgid "372"
msgstr "372"

msgid "600"
msgstr "600"

msgid "71"
msgstr "71"

msgid "288"
msgstr "288"

msgid "STM32F4 step rate benchmark"
msgstr "STM32F4 스텝 레이트 벤치마크"

msgid "The following configuration sequence is used on the STM32F4:"
msgstr "이어지는 설정 시퀀스는 STM32F4 에서 사용된다:"

msgid ""
"The test was last run on commit `8d4a5c16` with gcc version `arm-none-eabi-"
"gcc (Fedora 7.4.0-1.fc30) 7.4.0`. The STM32F407 results were obtained by "
"running an STM32F407 binary on an STM32F446 (and thus using a 168Mhz clock)."
msgstr ""
"테스트는 gcc의 `arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0` 버전에서 `8d4a5c16` "
"커밋상에 마지막으로 실행되었다. STM32F407 결과는 STM32F446에서 STM32F407 바이너리를 실행하여 얻은 것입니다(따라서"
" 168Mhz 클록 사용)."

msgid "stm32f446"
msgstr "stm32f446"

msgid "757"
msgstr "757"

msgid "761"
msgstr "761"

msgid "767"
msgstr "767"

msgid "51"
msgstr "51"

msgid "226"
msgstr "226"

msgid "stm32f407"
msgstr "stm32f407"

msgid "709"
msgstr "709"

msgid "714"
msgstr "714"

msgid "729"
msgstr "729"

msgid "52"
msgstr "52"

msgid "LPC176x step rate benchmark"
msgstr "LPC176x 스텝 레이트 벤치마크"

msgid "The following configuration sequence is used on the LPC176x:"
msgstr "이어지는 설정 시퀀스는 LPC176x 에서 사용된다:"

msgid ""
"The test was last run on commit `8d4a5c16` with gcc version `arm-none-eabi-"
"gcc (Fedora 7.4.0-1.fc30) 7.4.0`. The 120Mhz LPC1769 results were obtained "
"by overclocking an LPC1768 to 120Mhz."
msgstr ""
"테스트는 gcc의 `arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0` 버전으로 `8d4a5c16` "
"커밋상에 마지막으로 실행되었다. 120Mhz LPC1769 결과는 LPC1768을 120MHz 로 오버클럭킹해서 얻은 것이다."

msgid "lpc1768"
msgstr "lpc1768"

msgid "448"
msgstr "448"

msgid "450"
msgstr "450"

msgid "523"
msgstr "523"

msgid "56"
msgstr "56"

msgid "240"
msgstr "240"

msgid "lpc1769"
msgstr "lpc1769"

msgid "526"
msgstr "526"

msgid "545"
msgstr "545"

msgid "SAMD21 step rate benchmark"
msgstr "SAMD21 스텝 레이트 벤치마크"

msgid "The following configuration sequence is used on the SAMD21:"
msgstr "이어지는 설정 시퀀스는 SAMD21 에서 사용된다:"

msgid ""
"The test was last run on commit `8d4a5c16` with gcc version `arm-none-eabi-"
"gcc (Fedora 7.4.0-1.fc30) 7.4.0` on a SAMD21G18 micro-controller."
msgstr ""
"테스트는 SAMD21G18 마이크로 컨트롤러에서 gcc의 `arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) "
"7.4.0` 버전으로 `8d4a5c16` 커밋상에 마지막으로 실행되었다."

msgid "samd21"
msgstr "samd21"

msgid "277"
msgstr "277"

msgid "410"
msgstr "410"

msgid "664"
msgstr "664"

msgid "83"
msgstr "83"

msgid "321"
msgstr "321"

msgid "SAMD51 step rate benchmark"
msgstr "SAMD51 스텝 레이트 벤치마크"

msgid "The following configuration sequence is used on the SAMD51:"
msgstr "이어지는 설정 시퀀스는 SAMD51 에서 사용된다:"

msgid ""
"The test was last run on commit `524ebbc7` with gcc version `arm-none-eabi-"
"gcc (Fedora 9.2.0-1.fc30) 9.2.0` on a SAMD51J19A micro-controller."
msgstr ""
"테스트는 SAMD51J19A 마이크로 컨트롤러에서 gcc의 `arm-none-eabi-gcc (Fedora 9.2.0-1.fc30) "
"9.2.0` 버전으로 `524ebbc7` 커밋상에 마지막으로 실행되었다."

msgid "samd51"
msgstr "samd51"

msgid "516"
msgstr "516"

msgid "631"
msgstr "631"

msgid "1 stepper (200Mhz)"
msgstr "한개의 스테모터 (200Mhz)"

msgid "839"
msgstr "839"

msgid "2 stepper (200Mhz)"
msgstr "두개의 스테모터 (200Mhz)"

msgid "838"
msgstr "838"

msgid "3 stepper (200Mhz)"
msgstr "세개의 스테모터 (200Mhz)"

msgid "4 stepper (200Mhz)"
msgstr "네개의 스테모터 (200Mhz)"

msgid "5 stepper (200Mhz)"
msgstr "다섯개의 스테모터 (200Mhz)"

msgid "891"
msgstr "891"

msgid "42"
msgstr "42"

msgid "194"
msgstr "194"

msgid "Linux MCU step rate benchmark"
msgstr "Linux MCU 스텝 레이트 벤치마크"

msgid "The following configuration sequence is used on a Raspberry Pi:"
msgstr "이어지는 설정 시퀀스는 라즈베리파이에서 사용된다:"

msgid ""
"The test was last run on commit `db0fb5d5` with gcc version `gcc (Raspbian "
"6.3.0-18+rpi1+deb9u1) 6.3.0 20170516` on a Raspberry Pi 3 (revision a22082)."
msgstr ""
"테스트는 라즈베리파이 3(revision a22082)에서 gcc의 `gcc(Raspbian 6.3.0-18+rpi1+deb9u1) "
"6.3.0 20170516` 버전으로 `db0fb5d5` 커밋상에 마지막으로 실행되었다."

msgid "Linux (RPi3)"
msgstr "Linux (RPi3)"

msgid "349"
msgstr "349"

msgid "350"
msgstr "350"

msgid "400"
msgstr "400"

msgid "Command dispatch benchmark"
msgstr "명령 디스패치 벤치마크"

msgid ""
"When the test completes, determine the difference between the clocks "
"reported in the two \"uptime\" response messages. The total number of "
"commands per second is then `100000 * mcu_frequency / clock_diff`."
msgstr ""
"테스트를 마쳤을때 두개의 \"업타임\" 응답메시지들에 보고된 클락사이의 차이를 결정하라. 초당 전체 명령의 수는 `100000 * "
"mcu_frequency / clock_diff` 이다."

msgid ""
"Note that this test may saturate the USB/CPU capacity of a Raspberry Pi. If "
"running on a Raspberry Pi, Beaglebone, or similar host computer then "
"increase the delay (eg, `DELAY {clock + 20*freq} get_uptime`). Where "
"applicable, the benchmarks below are with console.py running on a desktop "
"class machine with the device connected via a high-speed hub."
msgstr ""
"이 테스트는 라즈베리파이의 USB/CPU 용량을 포화시킬지도 있음을 기억하라. 만약 라즈베리파이, 비글본, 혹은 유사한 호스트 컴퓨터를 "
"사용한다면 딜레이를 높여라 (예, `DELAY {clock + 20*freq} get_uptime`). 해당되는 경우 아래의 벤치마크는 "
"고속 허브를 통해 연결된 장치가 있는 데스크톱 클래스 시스템에서 실행되는 console.py에 대한 것입니다."

msgid "MCU"
msgstr "MCU"

msgid "Rate"
msgstr "Rate"

msgid "Build"
msgstr "Build"

msgid "Build compiler"
msgstr "Build compiler"

msgid "stm32f042 (CAN)"
msgstr "stm32f042 (CAN)"

msgid "18K"
msgstr "18K"

msgid "c105adc8"
msgstr "c105adc8"

msgid "arm-none-eabi-gcc (GNU Tools 7-2018-q3-update) 7.3.1"
msgstr "arm-none-eabi-gcc (GNU Tools 7-2018-q3-update) 7.3.1"

msgid "atmega2560 (serial)"
msgstr "atmega2560 (serial)"

msgid "23K"
msgstr "23K"

msgid "b161a69e"
msgstr "b161a69e"

msgid "avr-gcc (GCC) 4.8.1"
msgstr "avr-gcc (GCC) 4.8.1"

msgid "sam3x8e (serial)"
msgstr "sam3x8e (serial)"

msgid "arm-none-eabi-gcc (Fedora 7.1.0-5.fc27) 7.1.0"
msgstr "arm-none-eabi-gcc (Fedora 7.1.0-5.fc27) 7.1.0"

msgid "at90usb1286 (USB)"
msgstr "at90usb1286 (USB)"

msgid "75K"
msgstr "75K"

msgid "01d2183f"
msgstr "01d2183f"

msgid "avr-gcc (GCC) 5.4.0"
msgstr "avr-gcc (GCC) 5.4.0"

msgid "samd21 (USB)"
msgstr "samd21 (USB)"

msgid "223K"
msgstr "223K"

msgid "arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0"
msgstr "arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0"

msgid "pru (shared memory)"
msgstr "pru (shared memory)"

msgid "260K"
msgstr "260K"

msgid "c5968a08"
msgstr "c5968a08"

msgid "pru-gcc (GCC) 8.0.0 20170530 (experimental)"
msgstr "pru-gcc (GCC) 8.0.0 20170530 (experimental)"

msgid "stm32f103 (USB)"
msgstr "stm32f103 (USB)"

msgid "355K"
msgstr "355K"

msgid "sam3x8e (USB)"
msgstr "sam3x8e (USB)"

msgid "418K"
msgstr "418K"

msgid "lpc1768 (USB)"
msgstr "lpc1768 (USB)"

msgid "534K"
msgstr "534K"

msgid "lpc1769 (USB)"
msgstr "lpc1769 (USB)"

msgid "628K"
msgstr "628K"

msgid "sam4s8c (USB)"
msgstr "sam4s8c (USB)"

msgid "650K"
msgstr "650K"

msgid "8d4a5c16"
msgstr "8d4a5c16"

msgid "samd51 (USB)"
msgstr "samd51 (USB)"

msgid "864K"
msgstr "864K"

msgid "stm32f446 (USB)"
msgstr "stm32f446 (USB)"

msgid "870K"
msgstr "870K"

msgid "Host Benchmarks"
msgstr "호스트 벤치마크"

msgid ""
"SET start_clock {clock+freq}\n"
"SET ticks 1000\n"
"\n"
"reset_step_clock oid=0 clock={start_clock}\n"
"set_next_step_dir oid=0 dir=0\n"
"queue_step oid=0 interval={ticks} count=60000 add=0\n"
"set_next_step_dir oid=0 dir=1\n"
"queue_step oid=0 interval=3000 count=1 add=0\n"
"\n"
"reset_step_clock oid=1 clock={start_clock}\n"
"set_next_step_dir oid=1 dir=0\n"
"queue_step oid=1 interval={ticks} count=60000 add=0\n"
"set_next_step_dir oid=1 dir=1\n"
"queue_step oid=1 interval=3000 count=1 add=0\n"
"\n"
"reset_step_clock oid=2 clock={start_clock}\n"
"set_next_step_dir oid=2 dir=0\n"
"queue_step oid=2 interval={ticks} count=60000 add=0\n"
"set_next_step_dir oid=2 dir=1\n"
"queue_step oid=2 interval=3000 count=1 add=0\n"
msgstr ""
"SET start_clock {clock+freq}\n"
"SET ticks 1000\n"
"\n"
"reset_step_clock oid=0 clock={start_clock}\n"
"set_next_step_dir oid=0 dir=0\n"
"queue_step oid=0 interval={ticks} count=60000 add=0\n"
"set_next_step_dir oid=0 dir=1\n"
"queue_step oid=0 interval=3000 count=1 add=0\n"
"\n"
"reset_step_clock oid=1 clock={start_clock}\n"
"set_next_step_dir oid=1 dir=0\n"
"queue_step oid=1 interval={ticks} count=60000 add=0\n"
"set_next_step_dir oid=1 dir=1\n"
"queue_step oid=1 interval=3000 count=1 add=0\n"
"\n"
"reset_step_clock oid=2 clock={start_clock}\n"
"set_next_step_dir oid=2 dir=0\n"
"queue_step oid=2 interval={ticks} count=60000 add=0\n"
"set_next_step_dir oid=2 dir=1\n"
"queue_step oid=2 interval=3000 count=1 add=0\n"

msgid "clear_shutdown\n"
msgstr "clear_shutdown\n"

msgid "ECHO Test result is: {\"%.0fK\" % (3. * freq / ticks / 1000.)}\n"
msgstr "ECHO Test result is: {\"%.0fK\" % (3. * freq / ticks / 1000.)}\n"

msgid ""
"PINS arduino\n"
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=ar29 dir_pin=ar28 invert_step=0\n"
"config_stepper oid=1 step_pin=ar27 dir_pin=ar26 invert_step=0\n"
"config_stepper oid=2 step_pin=ar23 dir_pin=ar22 invert_step=0\n"
"finalize_config crc=0\n"
msgstr ""
"PINS arduino\n"
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=ar29 dir_pin=ar28 invert_step=0\n"
"config_stepper oid=1 step_pin=ar27 dir_pin=ar26 invert_step=0\n"
"config_stepper oid=2 step_pin=ar23 dir_pin=ar22 invert_step=0\n"
"finalize_config crc=0\n"

msgid ""
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=PB27 dir_pin=PA21 invert_step=0\n"
"config_stepper oid=1 step_pin=PB26 dir_pin=PC30 invert_step=0\n"
"config_stepper oid=2 step_pin=PA21 dir_pin=PC30 invert_step=0\n"
"finalize_config crc=0\n"
msgstr ""
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=PB27 dir_pin=PA21 invert_step=0\n"
"config_stepper oid=1 step_pin=PB26 dir_pin=PC30 invert_step=0\n"
"config_stepper oid=2 step_pin=PA21 dir_pin=PC30 invert_step=0\n"
"finalize_config crc=0\n"

msgid ""
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=PC26 dir_pin=PC18 invert_step=0\n"
"config_stepper oid=1 step_pin=PC26 dir_pin=PA8 invert_step=0\n"
"config_stepper oid=2 step_pin=PC26 dir_pin=PB4 invert_step=0\n"
"finalize_config crc=0\n"
msgstr ""
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=PC26 dir_pin=PC18 invert_step=0\n"
"config_stepper oid=1 step_pin=PC26 dir_pin=PA8 invert_step=0\n"
"config_stepper oid=2 step_pin=PC26 dir_pin=PB4 invert_step=0\n"
"finalize_config crc=0\n"

msgid ""
"allocate_oids count=4\n"
"config_stepper oid=0 step_pin=PD6 dir_pin=PD11 invert_step=0\n"
"config_stepper oid=1 step_pin=PD7 dir_pin=PD12 invert_step=0\n"
"config_stepper oid=2 step_pin=PD8 dir_pin=PD13 invert_step=0\n"
"config_stepper oid=3 step_pin=PD5 dir_pin=PA1 invert_step=0\n"
"finalize_config crc=0\n"
"\n"
msgstr ""
"allocate_oids count=4\n"
"config_stepper oid=0 step_pin=PD6 dir_pin=PD11 invert_step=0\n"
"config_stepper oid=1 step_pin=PD7 dir_pin=PD12 invert_step=0\n"
"config_stepper oid=2 step_pin=PD8 dir_pin=PD13 invert_step=0\n"
"config_stepper oid=3 step_pin=PD5 dir_pin=PA1 invert_step=0\n"
"finalize_config crc=0\n"
"\n"

msgid ""
"PINS beaglebone\n"
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=P8_13 dir_pin=P8_12 invert_step=0\n"
"config_stepper oid=1 step_pin=P8_15 dir_pin=P8_14 invert_step=0\n"
"config_stepper oid=2 step_pin=P8_19 dir_pin=P8_18 invert_step=0\n"
"finalize_config crc=0\n"
msgstr ""
"PINS beaglebone\n"
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=P8_13 dir_pin=P8_12 invert_step=0\n"
"config_stepper oid=1 step_pin=P8_15 dir_pin=P8_14 invert_step=0\n"
"config_stepper oid=2 step_pin=P8_19 dir_pin=P8_18 invert_step=0\n"
"finalize_config crc=0\n"

msgid ""
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=PA1 dir_pin=PA2 invert_step=0\n"
"config_stepper oid=1 step_pin=PA3 dir_pin=PA2 invert_step=0\n"
"config_stepper oid=2 step_pin=PB8 dir_pin=PA2 invert_step=0\n"
"finalize_config crc=0\n"
msgstr ""
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=PA1 dir_pin=PA2 invert_step=0\n"
"config_stepper oid=1 step_pin=PA3 dir_pin=PA2 invert_step=0\n"
"config_stepper oid=2 step_pin=PB8 dir_pin=PA2 invert_step=0\n"
"finalize_config crc=0\n"

msgid ""
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=PC13 dir_pin=PB5 invert_step=0\n"
"config_stepper oid=1 step_pin=PB3 dir_pin=PB6 invert_step=0\n"
"config_stepper oid=2 step_pin=PA4 dir_pin=PB7 invert_step=0\n"
"finalize_config crc=0\n"
msgstr ""
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=PC13 dir_pin=PB5 invert_step=0\n"
"config_stepper oid=1 step_pin=PB3 dir_pin=PB6 invert_step=0\n"
"config_stepper oid=2 step_pin=PA4 dir_pin=PB7 invert_step=0\n"
"finalize_config crc=0\n"

msgid ""
"allocate_oids count=4\n"
"config_stepper oid=0 step_pin=PA5 dir_pin=PB5 invert_step=0\n"
"config_stepper oid=1 step_pin=PB2 dir_pin=PB6 invert_step=0\n"
"config_stepper oid=2 step_pin=PB3 dir_pin=PB7 invert_step=0\n"
"config_stepper oid=3 step_pin=PB3 dir_pin=PB8 invert_step=0\n"
"finalize_config crc=0\n"
msgstr ""
"allocate_oids count=4\n"
"config_stepper oid=0 step_pin=PA5 dir_pin=PB5 invert_step=0\n"
"config_stepper oid=1 step_pin=PB2 dir_pin=PB6 invert_step=0\n"
"config_stepper oid=2 step_pin=PB3 dir_pin=PB7 invert_step=0\n"
"config_stepper oid=3 step_pin=PB3 dir_pin=PB8 invert_step=0\n"
"finalize_config crc=0\n"

msgid ""
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=P1.20 dir_pin=P1.18 invert_step=0\n"
"config_stepper oid=1 step_pin=P1.21 dir_pin=P1.18 invert_step=0\n"
"config_stepper oid=2 step_pin=P1.23 dir_pin=P1.18 invert_step=0\n"
"finalize_config crc=0\n"
msgstr ""
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=P1.20 dir_pin=P1.18 invert_step=0\n"
"config_stepper oid=1 step_pin=P1.21 dir_pin=P1.18 invert_step=0\n"
"config_stepper oid=2 step_pin=P1.23 dir_pin=P1.18 invert_step=0\n"
"finalize_config crc=0\n"

msgid ""
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=PA27 dir_pin=PA20 invert_step=0\n"
"config_stepper oid=1 step_pin=PB3 dir_pin=PA21 invert_step=0\n"
"config_stepper oid=2 step_pin=PA17 dir_pin=PA21 invert_step=0\n"
"finalize_config crc=0\n"
msgstr ""
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=PA27 dir_pin=PA20 invert_step=0\n"
"config_stepper oid=1 step_pin=PB3 dir_pin=PA21 invert_step=0\n"
"config_stepper oid=2 step_pin=PA17 dir_pin=PA21 invert_step=0\n"
"finalize_config crc=0\n"

msgid ""
"allocate_oids count=5\n"
"config_stepper oid=0 step_pin=PA22 dir_pin=PA20 invert_step=0\n"
"config_stepper oid=1 step_pin=PA22 dir_pin=PA21 invert_step=0\n"
"config_stepper oid=2 step_pin=PA22 dir_pin=PA19 invert_step=0\n"
"config_stepper oid=3 step_pin=PA22 dir_pin=PA18 invert_step=0\n"
"config_stepper oid=4 step_pin=PA23 dir_pin=PA17 invert_step=0\n"
"finalize_config crc=0\n"
msgstr ""
"allocate_oids count=5\n"
"config_stepper oid=0 step_pin=PA22 dir_pin=PA20 invert_step=0\n"
"config_stepper oid=1 step_pin=PA22 dir_pin=PA21 invert_step=0\n"
"config_stepper oid=2 step_pin=PA22 dir_pin=PA19 invert_step=0\n"
"config_stepper oid=3 step_pin=PA22 dir_pin=PA18 invert_step=0\n"
"config_stepper oid=4 step_pin=PA23 dir_pin=PA17 invert_step=0\n"
"finalize_config crc=0\n"

msgid ""
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=gpio2 dir_pin=gpio3 invert_step=0\n"
"config_stepper oid=1 step_pin=gpio4 dir_pin=gpio5 invert_step=0\n"
"config_stepper oid=2 step_pin=gpio6 dir_pin=gpio7 invert_step=0\n"
"finalize_config crc=0\n"
msgstr ""
"allocate_oids count=3\n"
"config_stepper oid=0 step_pin=gpio2 dir_pin=gpio3 invert_step=0\n"
"config_stepper oid=1 step_pin=gpio4 dir_pin=gpio5 invert_step=0\n"
"config_stepper oid=2 step_pin=gpio6 dir_pin=gpio7 invert_step=0\n"
"finalize_config crc=0\n"

msgid ""
"DELAY {clock + 2*freq} get_uptime\n"
"FLOOD 100000 0.0 debug_nop\n"
"get_uptime\n"
msgstr ""
"DELAY {clock + 2*freq} get_uptime\n"
"FLOOD 100000 0.0 debug_nop\n"
"get_uptime\n"

msgid ""
"time ~/klippy-env/bin/python ./klippy/klippy.py config/example-cartesian.cfg"
" -i something_complex.gcode -o /dev/null -d out/klipper.dict\n"
msgstr ""
"time ~/klippy-env/bin/python ./klippy/klippy.py config/example-cartesian.cfg"
" -i something_complex.gcode -o /dev/null -d out/klipper.dict\n"

msgid "RP2040 step rate benchmark"
msgstr "RP2040 스텝 레이트 벤치마크"

msgid "The following configuration sequence is used on the RP2040:"
msgstr "이어지는 설정 시퀀스는 RP2040 에서 사용된다:"

msgid ""
"allocate_oids count=4\n"
"config_stepper oid=0 step_pin=gpio25 dir_pin=gpio3 invert_step=0\n"
"config_stepper oid=1 step_pin=gpio26 dir_pin=gpio4 invert_step=0\n"
"config_stepper oid=2 step_pin=gpio27 dir_pin=gpio5 invert_step=0\n"
"config_stepper oid=3 step_pin=gpio28 dir_pin=gpio6 invert_step=0\n"
"finalize_config crc=0\n"
msgstr ""
"allocate_oids count=4\n"
"config_stepper oid=0 step_pin=gpio25 dir_pin=gpio3 invert_step=0\n"
"config_stepper oid=1 step_pin=gpio26 dir_pin=gpio4 invert_step=0\n"
"config_stepper oid=2 step_pin=gpio27 dir_pin=gpio5 invert_step=0\n"
"config_stepper oid=3 step_pin=gpio28 dir_pin=gpio6 invert_step=0\n"
"finalize_config crc=0\n"

msgid ""
"The test was last run on commit `c5667193` with gcc version `arm-none-eabi-"
"gcc (Fedora 10.2.0-4.fc34) 10.2.0` on a Raspberry Pi Pico board."
msgstr ""
"테스트는 라즈베리파이 피코 보드에서 gcc의 `arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) "
"10.2.0`버전으로 `c5667193` 커밋상에 마지막으로 실행되었다."

msgid "rp2040"
msgstr "rp2040"

msgid "66"
msgstr "66"

msgid "5"
msgstr "5"

msgid "22"
msgstr "22"

msgid "rp2040 (USB)"
msgstr "rp2040 (USB)"

msgid "873K"
msgstr "873K"

msgid "c5667193"
msgstr "c5667193"

msgid "arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0"
msgstr "arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0"

#: docs/Benchmarks.md:block 1 (header)
msgid "Benchmarks"
msgstr "벤치마크"

#: docs/Benchmarks.md:block 9 (paragraph)
msgid ""
"The test is performed using the console.py tool (described in "
"<Debugging.md>). The micro-controller is configured for the particular "
"hardware platform (see below) and then the following is cut-and-paste into "
"the console.py terminal window:"
msgstr ""

#: docs/Benchmarks.md:block 86 (paragraph)
msgid ""
"The command dispatch benchmark tests how many \"dummy\" commands the micro-"
"controller can process. It is primarily a test of the hardware communication"
" mechanism. The test is run using the console.py tool (described in "
"<Debugging.md>). The following is cut-and-paste into the console.py terminal"
" window:"
msgstr ""

#: docs/Benchmarks.md:block 92 (paragraph)
msgid ""
"It is possible to run timing tests on the host software using the \"batch "
"mode\" processing mechanism (described in <Debugging.md>). This is typically"
" done by choosing a large and complex G-Code file and timing how long it "
"takes for the host software to process it. For example:"
msgstr ""

#~ msgid ""
#~ "The test is performed using the console.py tool (described in "
#~ "[Debugging.md](Debugging.md)). The micro-controller is configured for the "
#~ "particular hardware platform (see below) and then the following is cut-and-"
#~ "paste into the console.py terminal window:"
#~ msgstr ""
#~ "이 테스트는 console.py 툴을 사용해 진행된다. (이것은 [Debugging.md](Debugging.md)에 기록되어 있다). "
#~ "마이크로 컨트롤러는 특정 하드웨어 플랫폼(하단참고)을 위해 구성되어 있다. 그리고 다음은 console.py 터미널 창에 잘라 붙여넣기 "
#~ "된다.:"

#~ msgid ""
#~ "The command dispatch benchmark tests how many \"dummy\" commands the micro-"
#~ "controller can process. It is primarily a test of the hardware communication"
#~ " mechanism. The test is run using the console.py tool (described in "
#~ "[Debugging.md](Debugging.md)). The following is cut-and-paste into the "
#~ "console.py terminal window:"
#~ msgstr ""
#~ "명령 디스패치 벤치마크는 마이크로 컨트롤러가 얼마나 많은 \"더미\" 명령을 수행할 수 있는지를 테스트 한다. 이것은 본질적으로 하드웨어"
#~ " 통신 메카니즘에 대한 테스트이다. 테스트는 console.py 도구([Debugging.md](Debugging.md)에 설명된)를 "
#~ "사용하여 동작한다. 다음을 console.py 터미널 창으로 잘라붙이기 한다.:"

#~ msgid ""
#~ "It is possible to run timing tests on the host software using the \"batch "
#~ "mode\" processing mechanism (described in [Debugging.md](Debugging.md)). "
#~ "This is typically done by choosing a large and complex G-Code file and "
#~ "timing how long it takes for the host software to process it. For example:"
#~ msgstr ""
#~ "호스트 상에서 \"batch mode\" 프로세싱 메커니즘([Debugging.md](Debugging.md)에 기술된)을 사용하여 "
#~ "타이밍 테스트 하는게 가능하다. 이것은 일반적으로 크고 복잡한 Gcode 파일을 선택하여 호스트 소프트웨어가 그것을 프로세싱하는데 얼마나"
#~ " 오래 시간이 걸리는지 시간을 잰다. 예를 들어:"
